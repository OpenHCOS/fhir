// This file is generated by rust-protobuf 2.1.4. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Base64Binary {
    // message fields
    pub value: ::std::vec::Vec<u8>,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Base64Binary {
    pub fn new() -> Base64Binary {
        ::std::default::Default::default()
    }

    // bytes value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Base64Binary {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Base64Binary {
        Base64Binary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &Base64Binary| { &m.value },
                    |m: &mut Base64Binary| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Base64Binary| { &m.id },
                    |m: &mut Base64Binary| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Base64Binary| { &m.extension },
                    |m: &mut Base64Binary| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Base64Binary>(
                    "Base64Binary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Base64Binary {
        static mut instance: ::protobuf::lazy::Lazy<Base64Binary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Base64Binary,
        };
        unsafe {
            instance.get(Base64Binary::new)
        }
    }
}

impl ::protobuf::Clear for Base64Binary {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Base64Binary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Base64Binary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Boolean {
    // message fields
    pub value: bool,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Boolean {
    pub fn new() -> Boolean {
        ::std::default::Default::default()
    }

    // bool value = 1;

    pub fn clear_value(&mut self) {
        self.value = false;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: bool) {
        self.value = v;
    }

    pub fn get_value(&self) -> bool {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Boolean {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != false {
            my_size += 2;
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != false {
            os.write_bool(1, self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Boolean {
        Boolean::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "value",
                    |m: &Boolean| { &m.value },
                    |m: &mut Boolean| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Boolean| { &m.id },
                    |m: &mut Boolean| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Boolean| { &m.extension },
                    |m: &mut Boolean| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Boolean>(
                    "Boolean",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Boolean {
        static mut instance: ::protobuf::lazy::Lazy<Boolean> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Boolean,
        };
        unsafe {
            instance.get(Boolean::new)
        }
    }
}

impl ::protobuf::Clear for Boolean {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Boolean {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Boolean {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Code {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Code {
    pub fn new() -> Code {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Code {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Code {
        Code::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &Code| { &m.value },
                    |m: &mut Code| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Code| { &m.id },
                    |m: &mut Code| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Code| { &m.extension },
                    |m: &mut Code| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Code>(
                    "Code",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Code {
        static mut instance: ::protobuf::lazy::Lazy<Code> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Code,
        };
        unsafe {
            instance.get(Code::new)
        }
    }
}

impl ::protobuf::Clear for Code {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Code {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Code {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Date {
    // message fields
    pub value_us: i64,
    pub timezone: ::std::string::String,
    pub precision: Date_Precision,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Date {
    pub fn new() -> Date {
        ::std::default::Default::default()
    }

    // int64 value_us = 1;

    pub fn clear_value_us(&mut self) {
        self.value_us = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_us(&mut self, v: i64) {
        self.value_us = v;
    }

    pub fn get_value_us(&self) -> i64 {
        self.value_us
    }

    // string timezone = 2;

    pub fn clear_timezone(&mut self) {
        self.timezone.clear();
    }

    // Param is passed by value, moved
    pub fn set_timezone(&mut self, v: ::std::string::String) {
        self.timezone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timezone(&mut self) -> &mut ::std::string::String {
        &mut self.timezone
    }

    // Take field
    pub fn take_timezone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timezone, ::std::string::String::new())
    }

    pub fn get_timezone(&self) -> &str {
        &self.timezone
    }

    // .google.fhir.stu3.proto.Date.Precision precision = 3;

    pub fn clear_precision(&mut self) {
        self.precision = Date_Precision::PRECISION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: Date_Precision) {
        self.precision = v;
    }

    pub fn get_precision(&self) -> Date_Precision {
        self.precision
    }

    // .google.fhir.stu3.proto.String id = 4;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 5;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Date {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value_us = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timezone)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.precision, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value_us != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value_us, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.timezone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.timezone);
        }
        if self.precision != Date_Precision::PRECISION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.precision);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value_us != 0 {
            os.write_int64(1, self.value_us)?;
        }
        if !self.timezone.is_empty() {
            os.write_string(2, &self.timezone)?;
        }
        if self.precision != Date_Precision::PRECISION_UNSPECIFIED {
            os.write_enum(3, self.precision.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Date {
        Date::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value_us",
                    |m: &Date| { &m.value_us },
                    |m: &mut Date| { &mut m.value_us },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "timezone",
                    |m: &Date| { &m.timezone },
                    |m: &mut Date| { &mut m.timezone },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Date_Precision>>(
                    "precision",
                    |m: &Date| { &m.precision },
                    |m: &mut Date| { &mut m.precision },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Date| { &m.id },
                    |m: &mut Date| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Date| { &m.extension },
                    |m: &mut Date| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Date>(
                    "Date",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Date {
        static mut instance: ::protobuf::lazy::Lazy<Date> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Date,
        };
        unsafe {
            instance.get(Date::new)
        }
    }
}

impl ::protobuf::Clear for Date {
    fn clear(&mut self) {
        self.clear_value_us();
        self.clear_timezone();
        self.clear_precision();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Date {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Date {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Date_Precision {
    PRECISION_UNSPECIFIED = 0,
    YEAR = 1,
    MONTH = 2,
    DAY = 3,
}

impl ::protobuf::ProtobufEnum for Date_Precision {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Date_Precision> {
        match value {
            0 => ::std::option::Option::Some(Date_Precision::PRECISION_UNSPECIFIED),
            1 => ::std::option::Option::Some(Date_Precision::YEAR),
            2 => ::std::option::Option::Some(Date_Precision::MONTH),
            3 => ::std::option::Option::Some(Date_Precision::DAY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Date_Precision] = &[
            Date_Precision::PRECISION_UNSPECIFIED,
            Date_Precision::YEAR,
            Date_Precision::MONTH,
            Date_Precision::DAY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Date_Precision", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Date_Precision {
}

impl ::std::default::Default for Date_Precision {
    fn default() -> Self {
        Date_Precision::PRECISION_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Date_Precision {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DateTime {
    // message fields
    pub value_us: i64,
    pub timezone: ::std::string::String,
    pub precision: DateTime_Precision,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DateTime {
    pub fn new() -> DateTime {
        ::std::default::Default::default()
    }

    // int64 value_us = 1;

    pub fn clear_value_us(&mut self) {
        self.value_us = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_us(&mut self, v: i64) {
        self.value_us = v;
    }

    pub fn get_value_us(&self) -> i64 {
        self.value_us
    }

    // string timezone = 2;

    pub fn clear_timezone(&mut self) {
        self.timezone.clear();
    }

    // Param is passed by value, moved
    pub fn set_timezone(&mut self, v: ::std::string::String) {
        self.timezone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timezone(&mut self) -> &mut ::std::string::String {
        &mut self.timezone
    }

    // Take field
    pub fn take_timezone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timezone, ::std::string::String::new())
    }

    pub fn get_timezone(&self) -> &str {
        &self.timezone
    }

    // .google.fhir.stu3.proto.DateTime.Precision precision = 3;

    pub fn clear_precision(&mut self) {
        self.precision = DateTime_Precision::PRECISION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: DateTime_Precision) {
        self.precision = v;
    }

    pub fn get_precision(&self) -> DateTime_Precision {
        self.precision
    }

    // .google.fhir.stu3.proto.String id = 4;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 5;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DateTime {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value_us = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timezone)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.precision, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value_us != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value_us, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.timezone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.timezone);
        }
        if self.precision != DateTime_Precision::PRECISION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.precision);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value_us != 0 {
            os.write_int64(1, self.value_us)?;
        }
        if !self.timezone.is_empty() {
            os.write_string(2, &self.timezone)?;
        }
        if self.precision != DateTime_Precision::PRECISION_UNSPECIFIED {
            os.write_enum(3, self.precision.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DateTime {
        DateTime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value_us",
                    |m: &DateTime| { &m.value_us },
                    |m: &mut DateTime| { &mut m.value_us },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "timezone",
                    |m: &DateTime| { &m.timezone },
                    |m: &mut DateTime| { &mut m.timezone },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DateTime_Precision>>(
                    "precision",
                    |m: &DateTime| { &m.precision },
                    |m: &mut DateTime| { &mut m.precision },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &DateTime| { &m.id },
                    |m: &mut DateTime| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &DateTime| { &m.extension },
                    |m: &mut DateTime| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DateTime>(
                    "DateTime",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DateTime {
        static mut instance: ::protobuf::lazy::Lazy<DateTime> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DateTime,
        };
        unsafe {
            instance.get(DateTime::new)
        }
    }
}

impl ::protobuf::Clear for DateTime {
    fn clear(&mut self) {
        self.clear_value_us();
        self.clear_timezone();
        self.clear_precision();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DateTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DateTime {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DateTime_Precision {
    PRECISION_UNSPECIFIED = 0,
    YEAR = 1,
    MONTH = 2,
    DAY = 3,
    SECOND = 4,
    MILLISECOND = 5,
    MICROSECOND = 6,
}

impl ::protobuf::ProtobufEnum for DateTime_Precision {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DateTime_Precision> {
        match value {
            0 => ::std::option::Option::Some(DateTime_Precision::PRECISION_UNSPECIFIED),
            1 => ::std::option::Option::Some(DateTime_Precision::YEAR),
            2 => ::std::option::Option::Some(DateTime_Precision::MONTH),
            3 => ::std::option::Option::Some(DateTime_Precision::DAY),
            4 => ::std::option::Option::Some(DateTime_Precision::SECOND),
            5 => ::std::option::Option::Some(DateTime_Precision::MILLISECOND),
            6 => ::std::option::Option::Some(DateTime_Precision::MICROSECOND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DateTime_Precision] = &[
            DateTime_Precision::PRECISION_UNSPECIFIED,
            DateTime_Precision::YEAR,
            DateTime_Precision::MONTH,
            DateTime_Precision::DAY,
            DateTime_Precision::SECOND,
            DateTime_Precision::MILLISECOND,
            DateTime_Precision::MICROSECOND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DateTime_Precision", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DateTime_Precision {
}

impl ::std::default::Default for DateTime_Precision {
    fn default() -> Self {
        DateTime_Precision::PRECISION_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for DateTime_Precision {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Decimal {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Decimal {
    pub fn new() -> Decimal {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Decimal {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Decimal {
        Decimal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &Decimal| { &m.value },
                    |m: &mut Decimal| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Decimal| { &m.id },
                    |m: &mut Decimal| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Decimal| { &m.extension },
                    |m: &mut Decimal| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Decimal>(
                    "Decimal",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Decimal {
        static mut instance: ::protobuf::lazy::Lazy<Decimal> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Decimal,
        };
        unsafe {
            instance.get(Decimal::new)
        }
    }
}

impl ::protobuf::Clear for Decimal {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Decimal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Decimal {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Id {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Id {
    pub fn new() -> Id {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Id {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Id {
        Id::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &Id| { &m.value },
                    |m: &mut Id| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Id| { &m.id },
                    |m: &mut Id| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Id| { &m.extension },
                    |m: &mut Id| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Id>(
                    "Id",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Id {
        static mut instance: ::protobuf::lazy::Lazy<Id> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Id,
        };
        unsafe {
            instance.get(Id::new)
        }
    }
}

impl ::protobuf::Clear for Id {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Id {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Id {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Instant {
    // message fields
    pub value_us: i64,
    pub timezone: ::std::string::String,
    pub precision: Instant_Precision,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Instant {
    pub fn new() -> Instant {
        ::std::default::Default::default()
    }

    // int64 value_us = 1;

    pub fn clear_value_us(&mut self) {
        self.value_us = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_us(&mut self, v: i64) {
        self.value_us = v;
    }

    pub fn get_value_us(&self) -> i64 {
        self.value_us
    }

    // string timezone = 2;

    pub fn clear_timezone(&mut self) {
        self.timezone.clear();
    }

    // Param is passed by value, moved
    pub fn set_timezone(&mut self, v: ::std::string::String) {
        self.timezone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timezone(&mut self) -> &mut ::std::string::String {
        &mut self.timezone
    }

    // Take field
    pub fn take_timezone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timezone, ::std::string::String::new())
    }

    pub fn get_timezone(&self) -> &str {
        &self.timezone
    }

    // .google.fhir.stu3.proto.Instant.Precision precision = 3;

    pub fn clear_precision(&mut self) {
        self.precision = Instant_Precision::PRECISION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: Instant_Precision) {
        self.precision = v;
    }

    pub fn get_precision(&self) -> Instant_Precision {
        self.precision
    }

    // .google.fhir.stu3.proto.String id = 4;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 5;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Instant {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value_us = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timezone)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.precision, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value_us != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value_us, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.timezone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.timezone);
        }
        if self.precision != Instant_Precision::PRECISION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.precision);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value_us != 0 {
            os.write_int64(1, self.value_us)?;
        }
        if !self.timezone.is_empty() {
            os.write_string(2, &self.timezone)?;
        }
        if self.precision != Instant_Precision::PRECISION_UNSPECIFIED {
            os.write_enum(3, self.precision.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Instant {
        Instant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value_us",
                    |m: &Instant| { &m.value_us },
                    |m: &mut Instant| { &mut m.value_us },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "timezone",
                    |m: &Instant| { &m.timezone },
                    |m: &mut Instant| { &mut m.timezone },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Instant_Precision>>(
                    "precision",
                    |m: &Instant| { &m.precision },
                    |m: &mut Instant| { &mut m.precision },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Instant| { &m.id },
                    |m: &mut Instant| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Instant| { &m.extension },
                    |m: &mut Instant| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Instant>(
                    "Instant",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Instant {
        static mut instance: ::protobuf::lazy::Lazy<Instant> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Instant,
        };
        unsafe {
            instance.get(Instant::new)
        }
    }
}

impl ::protobuf::Clear for Instant {
    fn clear(&mut self) {
        self.clear_value_us();
        self.clear_timezone();
        self.clear_precision();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Instant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Instant {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Instant_Precision {
    PRECISION_UNSPECIFIED = 0,
    SECOND = 1,
    MILLISECOND = 2,
    MICROSECOND = 3,
}

impl ::protobuf::ProtobufEnum for Instant_Precision {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Instant_Precision> {
        match value {
            0 => ::std::option::Option::Some(Instant_Precision::PRECISION_UNSPECIFIED),
            1 => ::std::option::Option::Some(Instant_Precision::SECOND),
            2 => ::std::option::Option::Some(Instant_Precision::MILLISECOND),
            3 => ::std::option::Option::Some(Instant_Precision::MICROSECOND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Instant_Precision] = &[
            Instant_Precision::PRECISION_UNSPECIFIED,
            Instant_Precision::SECOND,
            Instant_Precision::MILLISECOND,
            Instant_Precision::MICROSECOND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Instant_Precision", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Instant_Precision {
}

impl ::std::default::Default for Instant_Precision {
    fn default() -> Self {
        Instant_Precision::PRECISION_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Instant_Precision {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Integer {
    // message fields
    pub value: i32,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Integer {
    pub fn new() -> Integer {
        ::std::default::Default::default()
    }

    // sint32 value = 1;

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }

    pub fn get_value(&self) -> i32 {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Integer {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_sint32(1, self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Integer {
        Integer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "value",
                    |m: &Integer| { &m.value },
                    |m: &mut Integer| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Integer| { &m.id },
                    |m: &mut Integer| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Integer| { &m.extension },
                    |m: &mut Integer| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Integer>(
                    "Integer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Integer {
        static mut instance: ::protobuf::lazy::Lazy<Integer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Integer,
        };
        unsafe {
            instance.get(Integer::new)
        }
    }
}

impl ::protobuf::Clear for Integer {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Integer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Integer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Markdown {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Markdown {
    pub fn new() -> Markdown {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Markdown {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Markdown {
        Markdown::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &Markdown| { &m.value },
                    |m: &mut Markdown| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Markdown| { &m.id },
                    |m: &mut Markdown| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Markdown| { &m.extension },
                    |m: &mut Markdown| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Markdown>(
                    "Markdown",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Markdown {
        static mut instance: ::protobuf::lazy::Lazy<Markdown> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Markdown,
        };
        unsafe {
            instance.get(Markdown::new)
        }
    }
}

impl ::protobuf::Clear for Markdown {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Markdown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Markdown {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Oid {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Oid {
    pub fn new() -> Oid {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Oid {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Oid {
        Oid::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &Oid| { &m.value },
                    |m: &mut Oid| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Oid| { &m.id },
                    |m: &mut Oid| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Oid| { &m.extension },
                    |m: &mut Oid| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Oid>(
                    "Oid",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Oid {
        static mut instance: ::protobuf::lazy::Lazy<Oid> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Oid,
        };
        unsafe {
            instance.get(Oid::new)
        }
    }
}

impl ::protobuf::Clear for Oid {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Oid {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Oid {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PositiveInt {
    // message fields
    pub value: u32,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PositiveInt {
    pub fn new() -> PositiveInt {
        ::std::default::Default::default()
    }

    // uint32 value = 1;

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = v;
    }

    pub fn get_value(&self) -> u32 {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for PositiveInt {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_uint32(1, self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PositiveInt {
        PositiveInt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value",
                    |m: &PositiveInt| { &m.value },
                    |m: &mut PositiveInt| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &PositiveInt| { &m.id },
                    |m: &mut PositiveInt| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &PositiveInt| { &m.extension },
                    |m: &mut PositiveInt| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PositiveInt>(
                    "PositiveInt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PositiveInt {
        static mut instance: ::protobuf::lazy::Lazy<PositiveInt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PositiveInt,
        };
        unsafe {
            instance.get(PositiveInt::new)
        }
    }
}

impl ::protobuf::Clear for PositiveInt {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PositiveInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PositiveInt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct String {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl String {
    pub fn new() -> String {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for String {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> String {
        String::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &String| { &m.value },
                    |m: &mut String| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &String| { &m.id },
                    |m: &mut String| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &String| { &m.extension },
                    |m: &mut String| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<String>(
                    "String",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static String {
        static mut instance: ::protobuf::lazy::Lazy<String> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const String,
        };
        unsafe {
            instance.get(String::new)
        }
    }
}

impl ::protobuf::Clear for String {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for String {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Time {
    // message fields
    pub value_us: i64,
    pub precision: Time_Precision,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Time {
    pub fn new() -> Time {
        ::std::default::Default::default()
    }

    // int64 value_us = 1;

    pub fn clear_value_us(&mut self) {
        self.value_us = 0;
    }

    // Param is passed by value, moved
    pub fn set_value_us(&mut self, v: i64) {
        self.value_us = v;
    }

    pub fn get_value_us(&self) -> i64 {
        self.value_us
    }

    // .google.fhir.stu3.proto.Time.Precision precision = 2;

    pub fn clear_precision(&mut self) {
        self.precision = Time_Precision::PRECISION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: Time_Precision) {
        self.precision = v;
    }

    pub fn get_precision(&self) -> Time_Precision {
        self.precision
    }

    // .google.fhir.stu3.proto.String id = 3;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 4;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Time {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.value_us = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.precision, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value_us != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value_us, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.precision != Time_Precision::PRECISION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.precision);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value_us != 0 {
            os.write_int64(1, self.value_us)?;
        }
        if self.precision != Time_Precision::PRECISION_UNSPECIFIED {
            os.write_enum(2, self.precision.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Time {
        Time::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value_us",
                    |m: &Time| { &m.value_us },
                    |m: &mut Time| { &mut m.value_us },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Time_Precision>>(
                    "precision",
                    |m: &Time| { &m.precision },
                    |m: &mut Time| { &mut m.precision },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Time| { &m.id },
                    |m: &mut Time| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Time| { &m.extension },
                    |m: &mut Time| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Time>(
                    "Time",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Time {
        static mut instance: ::protobuf::lazy::Lazy<Time> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Time,
        };
        unsafe {
            instance.get(Time::new)
        }
    }
}

impl ::protobuf::Clear for Time {
    fn clear(&mut self) {
        self.clear_value_us();
        self.clear_precision();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Time {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Time {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Time_Precision {
    PRECISION_UNSPECIFIED = 0,
    SECOND = 1,
    MILLISECOND = 2,
    MICROSECOND = 3,
}

impl ::protobuf::ProtobufEnum for Time_Precision {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Time_Precision> {
        match value {
            0 => ::std::option::Option::Some(Time_Precision::PRECISION_UNSPECIFIED),
            1 => ::std::option::Option::Some(Time_Precision::SECOND),
            2 => ::std::option::Option::Some(Time_Precision::MILLISECOND),
            3 => ::std::option::Option::Some(Time_Precision::MICROSECOND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Time_Precision] = &[
            Time_Precision::PRECISION_UNSPECIFIED,
            Time_Precision::SECOND,
            Time_Precision::MILLISECOND,
            Time_Precision::MICROSECOND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Time_Precision", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Time_Precision {
}

impl ::std::default::Default for Time_Precision {
    fn default() -> Self {
        Time_Precision::PRECISION_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Time_Precision {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnsignedInt {
    // message fields
    pub value: u32,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UnsignedInt {
    pub fn new() -> UnsignedInt {
        ::std::default::Default::default()
    }

    // uint32 value = 1;

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = v;
    }

    pub fn get_value(&self) -> u32 {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for UnsignedInt {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(1, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != 0 {
            os.write_uint32(1, self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnsignedInt {
        UnsignedInt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "value",
                    |m: &UnsignedInt| { &m.value },
                    |m: &mut UnsignedInt| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &UnsignedInt| { &m.id },
                    |m: &mut UnsignedInt| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &UnsignedInt| { &m.extension },
                    |m: &mut UnsignedInt| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnsignedInt>(
                    "UnsignedInt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnsignedInt {
        static mut instance: ::protobuf::lazy::Lazy<UnsignedInt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnsignedInt,
        };
        unsafe {
            instance.get(UnsignedInt::new)
        }
    }
}

impl ::protobuf::Clear for UnsignedInt {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnsignedInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsignedInt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Uri {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Uri {
    pub fn new() -> Uri {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Uri {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Uri {
        Uri::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &Uri| { &m.value },
                    |m: &mut Uri| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Uri| { &m.id },
                    |m: &mut Uri| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Uri| { &m.extension },
                    |m: &mut Uri| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Uri>(
                    "Uri",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Uri {
        static mut instance: ::protobuf::lazy::Lazy<Uri> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Uri,
        };
        unsafe {
            instance.get(Uri::new)
        }
    }
}

impl ::protobuf::Clear for Uri {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Uri {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uri {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Uuid {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Uuid {
    pub fn new() -> Uuid {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Uuid {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Uuid {
        Uuid::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &Uuid| { &m.value },
                    |m: &mut Uuid| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Uuid| { &m.id },
                    |m: &mut Uuid| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Uuid| { &m.extension },
                    |m: &mut Uuid| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Uuid>(
                    "Uuid",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Uuid {
        static mut instance: ::protobuf::lazy::Lazy<Uuid> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Uuid,
        };
        unsafe {
            instance.get(Uuid::new)
        }
    }
}

impl ::protobuf::Clear for Uuid {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Uuid {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Uuid {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Xhtml {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Xhtml {
    pub fn new() -> Xhtml {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }
}

impl ::protobuf::Message for Xhtml {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Xhtml {
        Xhtml::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &Xhtml| { &m.value },
                    |m: &mut Xhtml| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Xhtml| { &m.id },
                    |m: &mut Xhtml| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Xhtml>(
                    "Xhtml",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Xhtml {
        static mut instance: ::protobuf::lazy::Lazy<Xhtml> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Xhtml,
        };
        unsafe {
            instance.get(Xhtml::new)
        }
    }
}

impl ::protobuf::Clear for Xhtml {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Xhtml {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Xhtml {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Address {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub field_use: ::protobuf::SingularPtrField<AddressUseCode>,
    pub field_type: ::protobuf::SingularPtrField<AddressTypeCode>,
    pub text: ::protobuf::SingularPtrField<String>,
    pub line: ::protobuf::RepeatedField<String>,
    pub city: ::protobuf::SingularPtrField<String>,
    pub district: ::protobuf::SingularPtrField<String>,
    pub state: ::protobuf::SingularPtrField<String>,
    pub postal_code: ::protobuf::SingularPtrField<String>,
    pub country: ::protobuf::SingularPtrField<String>,
    pub period: ::protobuf::SingularPtrField<Period>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.AddressUseCode use = 3;

    pub fn clear_field_use(&mut self) {
        self.field_use.clear();
    }

    pub fn has_field_use(&self) -> bool {
        self.field_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_use(&mut self, v: AddressUseCode) {
        self.field_use = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_use(&mut self) -> &mut AddressUseCode {
        if self.field_use.is_none() {
            self.field_use.set_default();
        }
        self.field_use.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_use(&mut self) -> AddressUseCode {
        self.field_use.take().unwrap_or_else(|| AddressUseCode::new())
    }

    pub fn get_field_use(&self) -> &AddressUseCode {
        self.field_use.as_ref().unwrap_or_else(|| AddressUseCode::default_instance())
    }

    // .google.fhir.stu3.proto.AddressTypeCode type = 4;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AddressTypeCode) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut AddressTypeCode {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> AddressTypeCode {
        self.field_type.take().unwrap_or_else(|| AddressTypeCode::new())
    }

    pub fn get_field_type(&self) -> &AddressTypeCode {
        self.field_type.as_ref().unwrap_or_else(|| AddressTypeCode::default_instance())
    }

    // .google.fhir.stu3.proto.String text = 5;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: String) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> String {
        self.text.take().unwrap_or_else(|| String::new())
    }

    pub fn get_text(&self) -> &String {
        self.text.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.String line = 6;

    pub fn clear_line(&mut self) {
        self.line.clear();
    }

    // Param is passed by value, moved
    pub fn set_line(&mut self, v: ::protobuf::RepeatedField<String>) {
        self.line = v;
    }

    // Mutable pointer to the field.
    pub fn mut_line(&mut self) -> &mut ::protobuf::RepeatedField<String> {
        &mut self.line
    }

    // Take field
    pub fn take_line(&mut self) -> ::protobuf::RepeatedField<String> {
        ::std::mem::replace(&mut self.line, ::protobuf::RepeatedField::new())
    }

    pub fn get_line(&self) -> &[String] {
        &self.line
    }

    // .google.fhir.stu3.proto.String city = 7;

    pub fn clear_city(&mut self) {
        self.city.clear();
    }

    pub fn has_city(&self) -> bool {
        self.city.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city(&mut self, v: String) {
        self.city = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city(&mut self) -> &mut String {
        if self.city.is_none() {
            self.city.set_default();
        }
        self.city.as_mut().unwrap()
    }

    // Take field
    pub fn take_city(&mut self) -> String {
        self.city.take().unwrap_or_else(|| String::new())
    }

    pub fn get_city(&self) -> &String {
        self.city.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.String district = 8;

    pub fn clear_district(&mut self) {
        self.district.clear();
    }

    pub fn has_district(&self) -> bool {
        self.district.is_some()
    }

    // Param is passed by value, moved
    pub fn set_district(&mut self, v: String) {
        self.district = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_district(&mut self) -> &mut String {
        if self.district.is_none() {
            self.district.set_default();
        }
        self.district.as_mut().unwrap()
    }

    // Take field
    pub fn take_district(&mut self) -> String {
        self.district.take().unwrap_or_else(|| String::new())
    }

    pub fn get_district(&self) -> &String {
        self.district.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.String state = 9;

    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: String) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut String {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> String {
        self.state.take().unwrap_or_else(|| String::new())
    }

    pub fn get_state(&self) -> &String {
        self.state.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.String postal_code = 10;

    pub fn clear_postal_code(&mut self) {
        self.postal_code.clear();
    }

    pub fn has_postal_code(&self) -> bool {
        self.postal_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postal_code(&mut self, v: String) {
        self.postal_code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postal_code(&mut self) -> &mut String {
        if self.postal_code.is_none() {
            self.postal_code.set_default();
        }
        self.postal_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_postal_code(&mut self) -> String {
        self.postal_code.take().unwrap_or_else(|| String::new())
    }

    pub fn get_postal_code(&self) -> &String {
        self.postal_code.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.String country = 11;

    pub fn clear_country(&mut self) {
        self.country.clear();
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: String) {
        self.country = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut String {
        if self.country.is_none() {
            self.country.set_default();
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> String {
        self.country.take().unwrap_or_else(|| String::new())
    }

    pub fn get_country(&self) -> &String {
        self.country.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Period period = 12;

    pub fn clear_period(&mut self) {
        self.period.clear();
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: Period) {
        self.period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_period(&mut self) -> &mut Period {
        if self.period.is_none() {
            self.period.set_default();
        }
        self.period.as_mut().unwrap()
    }

    // Take field
    pub fn take_period(&mut self) -> Period {
        self.period.take().unwrap_or_else(|| Period::new())
    }

    pub fn get_period(&self) -> &Period {
        self.period.as_ref().unwrap_or_else(|| Period::default_instance())
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_use {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.line {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.city {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.district {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.postal_code {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.country {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.period {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_use)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.line)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.city)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.district)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postal_code)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.country)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.period)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.field_use.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.line {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.city.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.district.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.postal_code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.country.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.field_use.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.line {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.city.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.district.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.postal_code.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.country.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.period.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Address| { &m.id },
                    |m: &mut Address| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Address| { &m.extension },
                    |m: &mut Address| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressUseCode>>(
                    "use",
                    |m: &Address| { &m.field_use },
                    |m: &mut Address| { &mut m.field_use },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressTypeCode>>(
                    "type",
                    |m: &Address| { &m.field_type },
                    |m: &mut Address| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "text",
                    |m: &Address| { &m.text },
                    |m: &mut Address| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "line",
                    |m: &Address| { &m.line },
                    |m: &mut Address| { &mut m.line },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "city",
                    |m: &Address| { &m.city },
                    |m: &mut Address| { &mut m.city },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "district",
                    |m: &Address| { &m.district },
                    |m: &mut Address| { &mut m.district },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "state",
                    |m: &Address| { &m.state },
                    |m: &mut Address| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "postal_code",
                    |m: &Address| { &m.postal_code },
                    |m: &mut Address| { &mut m.postal_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "country",
                    |m: &Address| { &m.country },
                    |m: &mut Address| { &mut m.country },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Period>>(
                    "period",
                    |m: &Address| { &m.period },
                    |m: &mut Address| { &mut m.period },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Address>(
                    "Address",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Address {
        static mut instance: ::protobuf::lazy::Lazy<Address> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Address,
        };
        unsafe {
            instance.get(Address::new)
        }
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_field_use();
        self.clear_field_type();
        self.clear_text();
        self.clear_line();
        self.clear_city();
        self.clear_district();
        self.clear_state();
        self.clear_postal_code();
        self.clear_country();
        self.clear_period();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Address {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Age {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub value: ::protobuf::SingularPtrField<Decimal>,
    pub comparator: ::protobuf::SingularPtrField<QuantityComparatorCode>,
    pub unit: ::protobuf::SingularPtrField<String>,
    pub system: ::protobuf::SingularPtrField<Uri>,
    pub code: ::protobuf::SingularPtrField<Code>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Age {
    pub fn new() -> Age {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Decimal value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Decimal) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Decimal {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Decimal {
        self.value.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_value(&self) -> &Decimal {
        self.value.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.QuantityComparatorCode comparator = 4;

    pub fn clear_comparator(&mut self) {
        self.comparator.clear();
    }

    pub fn has_comparator(&self) -> bool {
        self.comparator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comparator(&mut self, v: QuantityComparatorCode) {
        self.comparator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comparator(&mut self) -> &mut QuantityComparatorCode {
        if self.comparator.is_none() {
            self.comparator.set_default();
        }
        self.comparator.as_mut().unwrap()
    }

    // Take field
    pub fn take_comparator(&mut self) -> QuantityComparatorCode {
        self.comparator.take().unwrap_or_else(|| QuantityComparatorCode::new())
    }

    pub fn get_comparator(&self) -> &QuantityComparatorCode {
        self.comparator.as_ref().unwrap_or_else(|| QuantityComparatorCode::default_instance())
    }

    // .google.fhir.stu3.proto.String unit = 5;

    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: String) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut String {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> String {
        self.unit.take().unwrap_or_else(|| String::new())
    }

    pub fn get_unit(&self) -> &String {
        self.unit.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Uri system = 6;

    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: Uri) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut Uri {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> Uri {
        self.system.take().unwrap_or_else(|| Uri::new())
    }

    pub fn get_system(&self) -> &Uri {
        self.system.as_ref().unwrap_or_else(|| Uri::default_instance())
    }

    // .google.fhir.stu3.proto.Code code = 7;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Code) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut Code {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> Code {
        self.code.take().unwrap_or_else(|| Code::new())
    }

    pub fn get_code(&self) -> &Code {
        self.code.as_ref().unwrap_or_else(|| Code::default_instance())
    }
}

impl ::protobuf::Message for Age {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.comparator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.comparator)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Age {
        Age::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Age| { &m.id },
                    |m: &mut Age| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Age| { &m.extension },
                    |m: &mut Age| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "value",
                    |m: &Age| { &m.value },
                    |m: &mut Age| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuantityComparatorCode>>(
                    "comparator",
                    |m: &Age| { &m.comparator },
                    |m: &mut Age| { &mut m.comparator },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "unit",
                    |m: &Age| { &m.unit },
                    |m: &mut Age| { &mut m.unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "system",
                    |m: &Age| { &m.system },
                    |m: &mut Age| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Code>>(
                    "code",
                    |m: &Age| { &m.code },
                    |m: &mut Age| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Age>(
                    "Age",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Age {
        static mut instance: ::protobuf::lazy::Lazy<Age> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Age,
        };
        unsafe {
            instance.get(Age::new)
        }
    }
}

impl ::protobuf::Clear for Age {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_value();
        self.clear_comparator();
        self.clear_unit();
        self.clear_system();
        self.clear_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Age {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Age {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Annotation {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub author: ::protobuf::SingularPtrField<Annotation_Author>,
    pub time: ::protobuf::SingularPtrField<DateTime>,
    pub text: ::protobuf::SingularPtrField<String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Annotation {
    pub fn new() -> Annotation {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Annotation.Author author = 3;

    pub fn clear_author(&mut self) {
        self.author.clear();
    }

    pub fn has_author(&self) -> bool {
        self.author.is_some()
    }

    // Param is passed by value, moved
    pub fn set_author(&mut self, v: Annotation_Author) {
        self.author = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_author(&mut self) -> &mut Annotation_Author {
        if self.author.is_none() {
            self.author.set_default();
        }
        self.author.as_mut().unwrap()
    }

    // Take field
    pub fn take_author(&mut self) -> Annotation_Author {
        self.author.take().unwrap_or_else(|| Annotation_Author::new())
    }

    pub fn get_author(&self) -> &Annotation_Author {
        self.author.as_ref().unwrap_or_else(|| Annotation_Author::default_instance())
    }

    // .google.fhir.stu3.proto.DateTime time = 4;

    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: DateTime) {
        self.time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut DateTime {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> DateTime {
        self.time.take().unwrap_or_else(|| DateTime::new())
    }

    pub fn get_time(&self) -> &DateTime {
        self.time.as_ref().unwrap_or_else(|| DateTime::default_instance())
    }

    // .google.fhir.stu3.proto.String text = 5;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: String) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> String {
        self.text.take().unwrap_or_else(|| String::new())
    }

    pub fn get_text(&self) -> &String {
        self.text.as_ref().unwrap_or_else(|| String::default_instance())
    }
}

impl ::protobuf::Message for Annotation {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.author {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.author)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.author.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.author.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Annotation {
        Annotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Annotation| { &m.id },
                    |m: &mut Annotation| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Annotation| { &m.extension },
                    |m: &mut Annotation| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Annotation_Author>>(
                    "author",
                    |m: &Annotation| { &m.author },
                    |m: &mut Annotation| { &mut m.author },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DateTime>>(
                    "time",
                    |m: &Annotation| { &m.time },
                    |m: &mut Annotation| { &mut m.time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "text",
                    |m: &Annotation| { &m.text },
                    |m: &mut Annotation| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Annotation>(
                    "Annotation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Annotation {
        static mut instance: ::protobuf::lazy::Lazy<Annotation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Annotation,
        };
        unsafe {
            instance.get(Annotation::new)
        }
    }
}

impl ::protobuf::Clear for Annotation {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_author();
        self.clear_time();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Annotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Annotation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Annotation_Author {
    // message oneof groups
    pub author: ::std::option::Option<Annotation_Author_oneof_author>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Annotation_Author_oneof_author {
    reference(Reference),
    string_value(String),
}

impl Annotation_Author {
    pub fn new() -> Annotation_Author {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.Reference reference = 1;

    pub fn clear_reference(&mut self) {
        self.author = ::std::option::Option::None;
    }

    pub fn has_reference(&self) -> bool {
        match self.author {
            ::std::option::Option::Some(Annotation_Author_oneof_author::reference(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reference(&mut self, v: Reference) {
        self.author = ::std::option::Option::Some(Annotation_Author_oneof_author::reference(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reference(&mut self) -> &mut Reference {
        if let ::std::option::Option::Some(Annotation_Author_oneof_author::reference(_)) = self.author {
        } else {
            self.author = ::std::option::Option::Some(Annotation_Author_oneof_author::reference(Reference::new()));
        }
        match self.author {
            ::std::option::Option::Some(Annotation_Author_oneof_author::reference(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reference(&mut self) -> Reference {
        if self.has_reference() {
            match self.author.take() {
                ::std::option::Option::Some(Annotation_Author_oneof_author::reference(v)) => v,
                _ => panic!(),
            }
        } else {
            Reference::new()
        }
    }

    pub fn get_reference(&self) -> &Reference {
        match self.author {
            ::std::option::Option::Some(Annotation_Author_oneof_author::reference(ref v)) => v,
            _ => Reference::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.String string_value = 2;

    pub fn clear_string_value(&mut self) {
        self.author = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.author {
            ::std::option::Option::Some(Annotation_Author_oneof_author::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: String) {
        self.author = ::std::option::Option::Some(Annotation_Author_oneof_author::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut String {
        if let ::std::option::Option::Some(Annotation_Author_oneof_author::string_value(_)) = self.author {
        } else {
            self.author = ::std::option::Option::Some(Annotation_Author_oneof_author::string_value(String::new()));
        }
        match self.author {
            ::std::option::Option::Some(Annotation_Author_oneof_author::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> String {
        if self.has_string_value() {
            match self.author.take() {
                ::std::option::Option::Some(Annotation_Author_oneof_author::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            String::new()
        }
    }

    pub fn get_string_value(&self) -> &String {
        match self.author {
            ::std::option::Option::Some(Annotation_Author_oneof_author::string_value(ref v)) => v,
            _ => String::default_instance(),
        }
    }
}

impl ::protobuf::Message for Annotation_Author {
    fn is_initialized(&self) -> bool {
        if let Some(Annotation_Author_oneof_author::reference(ref v)) = self.author {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Annotation_Author_oneof_author::string_value(ref v)) = self.author {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.author = ::std::option::Option::Some(Annotation_Author_oneof_author::reference(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.author = ::std::option::Option::Some(Annotation_Author_oneof_author::string_value(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.author {
            match v {
                &Annotation_Author_oneof_author::reference(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Annotation_Author_oneof_author::string_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.author {
            match v {
                &Annotation_Author_oneof_author::reference(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Annotation_Author_oneof_author::string_value(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Annotation_Author {
        Annotation_Author::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Reference>(
                    "reference",
                    Annotation_Author::has_reference,
                    Annotation_Author::get_reference,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, String>(
                    "string_value",
                    Annotation_Author::has_string_value,
                    Annotation_Author::get_string_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Annotation_Author>(
                    "Annotation_Author",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Annotation_Author {
        static mut instance: ::protobuf::lazy::Lazy<Annotation_Author> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Annotation_Author,
        };
        unsafe {
            instance.get(Annotation_Author::new)
        }
    }
}

impl ::protobuf::Clear for Annotation_Author {
    fn clear(&mut self) {
        self.clear_reference();
        self.clear_string_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Annotation_Author {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Annotation_Author {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Attachment {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub content_type: ::protobuf::SingularPtrField<MimeTypeCode>,
    pub language: ::protobuf::SingularPtrField<LanguageCode>,
    pub data: ::protobuf::SingularPtrField<Base64Binary>,
    pub url: ::protobuf::SingularPtrField<Uri>,
    pub size: ::protobuf::SingularPtrField<UnsignedInt>,
    pub hash: ::protobuf::SingularPtrField<Base64Binary>,
    pub title: ::protobuf::SingularPtrField<String>,
    pub creation: ::protobuf::SingularPtrField<DateTime>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Attachment {
    pub fn new() -> Attachment {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.MimeTypeCode content_type = 3;

    pub fn clear_content_type(&mut self) {
        self.content_type.clear();
    }

    pub fn has_content_type(&self) -> bool {
        self.content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: MimeTypeCode) {
        self.content_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_type(&mut self) -> &mut MimeTypeCode {
        if self.content_type.is_none() {
            self.content_type.set_default();
        }
        self.content_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_content_type(&mut self) -> MimeTypeCode {
        self.content_type.take().unwrap_or_else(|| MimeTypeCode::new())
    }

    pub fn get_content_type(&self) -> &MimeTypeCode {
        self.content_type.as_ref().unwrap_or_else(|| MimeTypeCode::default_instance())
    }

    // .google.fhir.stu3.proto.LanguageCode language = 4;

    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: LanguageCode) {
        self.language = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut LanguageCode {
        if self.language.is_none() {
            self.language.set_default();
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> LanguageCode {
        self.language.take().unwrap_or_else(|| LanguageCode::new())
    }

    pub fn get_language(&self) -> &LanguageCode {
        self.language.as_ref().unwrap_or_else(|| LanguageCode::default_instance())
    }

    // .google.fhir.stu3.proto.Base64Binary data = 5;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: Base64Binary) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut Base64Binary {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> Base64Binary {
        self.data.take().unwrap_or_else(|| Base64Binary::new())
    }

    pub fn get_data(&self) -> &Base64Binary {
        self.data.as_ref().unwrap_or_else(|| Base64Binary::default_instance())
    }

    // .google.fhir.stu3.proto.Uri url = 6;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: Uri) {
        self.url = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut Uri {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> Uri {
        self.url.take().unwrap_or_else(|| Uri::new())
    }

    pub fn get_url(&self) -> &Uri {
        self.url.as_ref().unwrap_or_else(|| Uri::default_instance())
    }

    // .google.fhir.stu3.proto.UnsignedInt size = 7;

    pub fn clear_size(&mut self) {
        self.size.clear();
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: UnsignedInt) {
        self.size = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_size(&mut self) -> &mut UnsignedInt {
        if self.size.is_none() {
            self.size.set_default();
        }
        self.size.as_mut().unwrap()
    }

    // Take field
    pub fn take_size(&mut self) -> UnsignedInt {
        self.size.take().unwrap_or_else(|| UnsignedInt::new())
    }

    pub fn get_size(&self) -> &UnsignedInt {
        self.size.as_ref().unwrap_or_else(|| UnsignedInt::default_instance())
    }

    // .google.fhir.stu3.proto.Base64Binary hash = 8;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: Base64Binary) {
        self.hash = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut Base64Binary {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> Base64Binary {
        self.hash.take().unwrap_or_else(|| Base64Binary::new())
    }

    pub fn get_hash(&self) -> &Base64Binary {
        self.hash.as_ref().unwrap_or_else(|| Base64Binary::default_instance())
    }

    // .google.fhir.stu3.proto.String title = 9;

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: String) {
        self.title = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut String {
        if self.title.is_none() {
            self.title.set_default();
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> String {
        self.title.take().unwrap_or_else(|| String::new())
    }

    pub fn get_title(&self) -> &String {
        self.title.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.DateTime creation = 10;

    pub fn clear_creation(&mut self) {
        self.creation.clear();
    }

    pub fn has_creation(&self) -> bool {
        self.creation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creation(&mut self, v: DateTime) {
        self.creation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creation(&mut self) -> &mut DateTime {
        if self.creation.is_none() {
            self.creation.set_default();
        }
        self.creation.as_mut().unwrap()
    }

    // Take field
    pub fn take_creation(&mut self) -> DateTime {
        self.creation.take().unwrap_or_else(|| DateTime::new())
    }

    pub fn get_creation(&self) -> &DateTime {
        self.creation.as_ref().unwrap_or_else(|| DateTime::default_instance())
    }
}

impl ::protobuf::Message for Attachment {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.content_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.language {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.url {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.size {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hash {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.title {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.content_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.language)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.url)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.size)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hash)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.title)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.content_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.language.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.size.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.title.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.creation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.content_type.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.language.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.size.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hash.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.title.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.creation.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attachment {
        Attachment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Attachment| { &m.id },
                    |m: &mut Attachment| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Attachment| { &m.extension },
                    |m: &mut Attachment| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MimeTypeCode>>(
                    "content_type",
                    |m: &Attachment| { &m.content_type },
                    |m: &mut Attachment| { &mut m.content_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LanguageCode>>(
                    "language",
                    |m: &Attachment| { &m.language },
                    |m: &mut Attachment| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Base64Binary>>(
                    "data",
                    |m: &Attachment| { &m.data },
                    |m: &mut Attachment| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "url",
                    |m: &Attachment| { &m.url },
                    |m: &mut Attachment| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnsignedInt>>(
                    "size",
                    |m: &Attachment| { &m.size },
                    |m: &mut Attachment| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Base64Binary>>(
                    "hash",
                    |m: &Attachment| { &m.hash },
                    |m: &mut Attachment| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "title",
                    |m: &Attachment| { &m.title },
                    |m: &mut Attachment| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DateTime>>(
                    "creation",
                    |m: &Attachment| { &m.creation },
                    |m: &mut Attachment| { &mut m.creation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Attachment>(
                    "Attachment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Attachment {
        static mut instance: ::protobuf::lazy::Lazy<Attachment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attachment,
        };
        unsafe {
            instance.get(Attachment::new)
        }
    }
}

impl ::protobuf::Clear for Attachment {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_content_type();
        self.clear_language();
        self.clear_data();
        self.clear_url();
        self.clear_size();
        self.clear_hash();
        self.clear_title();
        self.clear_creation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attachment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attachment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CodeableConcept {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub coding: ::protobuf::RepeatedField<Coding>,
    pub text: ::protobuf::SingularPtrField<String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CodeableConcept {
    pub fn new() -> CodeableConcept {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // repeated .google.fhir.stu3.proto.Coding coding = 3;

    pub fn clear_coding(&mut self) {
        self.coding.clear();
    }

    // Param is passed by value, moved
    pub fn set_coding(&mut self, v: ::protobuf::RepeatedField<Coding>) {
        self.coding = v;
    }

    // Mutable pointer to the field.
    pub fn mut_coding(&mut self) -> &mut ::protobuf::RepeatedField<Coding> {
        &mut self.coding
    }

    // Take field
    pub fn take_coding(&mut self) -> ::protobuf::RepeatedField<Coding> {
        ::std::mem::replace(&mut self.coding, ::protobuf::RepeatedField::new())
    }

    pub fn get_coding(&self) -> &[Coding] {
        &self.coding
    }

    // .google.fhir.stu3.proto.String text = 4;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: String) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> String {
        self.text.take().unwrap_or_else(|| String::new())
    }

    pub fn get_text(&self) -> &String {
        self.text.as_ref().unwrap_or_else(|| String::default_instance())
    }
}

impl ::protobuf::Message for CodeableConcept {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.coding {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.coding)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.coding {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.coding {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodeableConcept {
        CodeableConcept::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &CodeableConcept| { &m.id },
                    |m: &mut CodeableConcept| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &CodeableConcept| { &m.extension },
                    |m: &mut CodeableConcept| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coding>>(
                    "coding",
                    |m: &CodeableConcept| { &m.coding },
                    |m: &mut CodeableConcept| { &mut m.coding },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "text",
                    |m: &CodeableConcept| { &m.text },
                    |m: &mut CodeableConcept| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CodeableConcept>(
                    "CodeableConcept",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CodeableConcept {
        static mut instance: ::protobuf::lazy::Lazy<CodeableConcept> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CodeableConcept,
        };
        unsafe {
            instance.get(CodeableConcept::new)
        }
    }
}

impl ::protobuf::Clear for CodeableConcept {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_coding();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodeableConcept {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeableConcept {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Coding {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub system: ::protobuf::SingularPtrField<Uri>,
    pub version: ::protobuf::SingularPtrField<String>,
    pub code: ::protobuf::SingularPtrField<Code>,
    pub display: ::protobuf::SingularPtrField<String>,
    pub user_selected: ::protobuf::SingularPtrField<Boolean>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Coding {
    pub fn new() -> Coding {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Uri system = 3;

    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: Uri) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut Uri {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> Uri {
        self.system.take().unwrap_or_else(|| Uri::new())
    }

    pub fn get_system(&self) -> &Uri {
        self.system.as_ref().unwrap_or_else(|| Uri::default_instance())
    }

    // .google.fhir.stu3.proto.String version = 4;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: String) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> String {
        self.version.take().unwrap_or_else(|| String::new())
    }

    pub fn get_version(&self) -> &String {
        self.version.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Code code = 5;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Code) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut Code {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> Code {
        self.code.take().unwrap_or_else(|| Code::new())
    }

    pub fn get_code(&self) -> &Code {
        self.code.as_ref().unwrap_or_else(|| Code::default_instance())
    }

    // .google.fhir.stu3.proto.String display = 6;

    pub fn clear_display(&mut self) {
        self.display.clear();
    }

    pub fn has_display(&self) -> bool {
        self.display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display(&mut self, v: String) {
        self.display = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display(&mut self) -> &mut String {
        if self.display.is_none() {
            self.display.set_default();
        }
        self.display.as_mut().unwrap()
    }

    // Take field
    pub fn take_display(&mut self) -> String {
        self.display.take().unwrap_or_else(|| String::new())
    }

    pub fn get_display(&self) -> &String {
        self.display.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Boolean user_selected = 7;

    pub fn clear_user_selected(&mut self) {
        self.user_selected.clear();
    }

    pub fn has_user_selected(&self) -> bool {
        self.user_selected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_selected(&mut self, v: Boolean) {
        self.user_selected = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_selected(&mut self) -> &mut Boolean {
        if self.user_selected.is_none() {
            self.user_selected.set_default();
        }
        self.user_selected.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_selected(&mut self) -> Boolean {
        self.user_selected.take().unwrap_or_else(|| Boolean::new())
    }

    pub fn get_user_selected(&self) -> &Boolean {
        self.user_selected.as_ref().unwrap_or_else(|| Boolean::default_instance())
    }
}

impl ::protobuf::Message for Coding {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.display {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_selected {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.display)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_selected)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.display.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user_selected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.display.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user_selected.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Coding {
        Coding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Coding| { &m.id },
                    |m: &mut Coding| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Coding| { &m.extension },
                    |m: &mut Coding| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "system",
                    |m: &Coding| { &m.system },
                    |m: &mut Coding| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "version",
                    |m: &Coding| { &m.version },
                    |m: &mut Coding| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Code>>(
                    "code",
                    |m: &Coding| { &m.code },
                    |m: &mut Coding| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "display",
                    |m: &Coding| { &m.display },
                    |m: &mut Coding| { &mut m.display },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Boolean>>(
                    "user_selected",
                    |m: &Coding| { &m.user_selected },
                    |m: &mut Coding| { &mut m.user_selected },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Coding>(
                    "Coding",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Coding {
        static mut instance: ::protobuf::lazy::Lazy<Coding> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Coding,
        };
        unsafe {
            instance.get(Coding::new)
        }
    }
}

impl ::protobuf::Clear for Coding {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_system();
        self.clear_version();
        self.clear_code();
        self.clear_display();
        self.clear_user_selected();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Coding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Coding {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContactPoint {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub system: ::protobuf::SingularPtrField<ContactPointSystemCode>,
    pub value: ::protobuf::SingularPtrField<String>,
    pub field_use: ::protobuf::SingularPtrField<ContactPointUseCode>,
    pub rank: ::protobuf::SingularPtrField<PositiveInt>,
    pub period: ::protobuf::SingularPtrField<Period>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ContactPoint {
    pub fn new() -> ContactPoint {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.ContactPointSystemCode system = 3;

    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: ContactPointSystemCode) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut ContactPointSystemCode {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> ContactPointSystemCode {
        self.system.take().unwrap_or_else(|| ContactPointSystemCode::new())
    }

    pub fn get_system(&self) -> &ContactPointSystemCode {
        self.system.as_ref().unwrap_or_else(|| ContactPointSystemCode::default_instance())
    }

    // .google.fhir.stu3.proto.String value = 4;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: String) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> String {
        self.value.take().unwrap_or_else(|| String::new())
    }

    pub fn get_value(&self) -> &String {
        self.value.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.ContactPointUseCode use = 5;

    pub fn clear_field_use(&mut self) {
        self.field_use.clear();
    }

    pub fn has_field_use(&self) -> bool {
        self.field_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_use(&mut self, v: ContactPointUseCode) {
        self.field_use = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_use(&mut self) -> &mut ContactPointUseCode {
        if self.field_use.is_none() {
            self.field_use.set_default();
        }
        self.field_use.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_use(&mut self) -> ContactPointUseCode {
        self.field_use.take().unwrap_or_else(|| ContactPointUseCode::new())
    }

    pub fn get_field_use(&self) -> &ContactPointUseCode {
        self.field_use.as_ref().unwrap_or_else(|| ContactPointUseCode::default_instance())
    }

    // .google.fhir.stu3.proto.PositiveInt rank = 6;

    pub fn clear_rank(&mut self) {
        self.rank.clear();
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: PositiveInt) {
        self.rank = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rank(&mut self) -> &mut PositiveInt {
        if self.rank.is_none() {
            self.rank.set_default();
        }
        self.rank.as_mut().unwrap()
    }

    // Take field
    pub fn take_rank(&mut self) -> PositiveInt {
        self.rank.take().unwrap_or_else(|| PositiveInt::new())
    }

    pub fn get_rank(&self) -> &PositiveInt {
        self.rank.as_ref().unwrap_or_else(|| PositiveInt::default_instance())
    }

    // .google.fhir.stu3.proto.Period period = 7;

    pub fn clear_period(&mut self) {
        self.period.clear();
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: Period) {
        self.period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_period(&mut self) -> &mut Period {
        if self.period.is_none() {
            self.period.set_default();
        }
        self.period.as_mut().unwrap()
    }

    // Take field
    pub fn take_period(&mut self) -> Period {
        self.period.take().unwrap_or_else(|| Period::new())
    }

    pub fn get_period(&self) -> &Period {
        self.period.as_ref().unwrap_or_else(|| Period::default_instance())
    }
}

impl ::protobuf::Message for ContactPoint {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_use {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rank {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.period {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_use)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rank)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.period)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.field_use.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rank.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.field_use.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rank.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.period.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContactPoint {
        ContactPoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &ContactPoint| { &m.id },
                    |m: &mut ContactPoint| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &ContactPoint| { &m.extension },
                    |m: &mut ContactPoint| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContactPointSystemCode>>(
                    "system",
                    |m: &ContactPoint| { &m.system },
                    |m: &mut ContactPoint| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "value",
                    |m: &ContactPoint| { &m.value },
                    |m: &mut ContactPoint| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContactPointUseCode>>(
                    "use",
                    |m: &ContactPoint| { &m.field_use },
                    |m: &mut ContactPoint| { &mut m.field_use },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PositiveInt>>(
                    "rank",
                    |m: &ContactPoint| { &m.rank },
                    |m: &mut ContactPoint| { &mut m.rank },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Period>>(
                    "period",
                    |m: &ContactPoint| { &m.period },
                    |m: &mut ContactPoint| { &mut m.period },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContactPoint>(
                    "ContactPoint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContactPoint {
        static mut instance: ::protobuf::lazy::Lazy<ContactPoint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContactPoint,
        };
        unsafe {
            instance.get(ContactPoint::new)
        }
    }
}

impl ::protobuf::Clear for ContactPoint {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_system();
        self.clear_value();
        self.clear_field_use();
        self.clear_rank();
        self.clear_period();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContactPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactPoint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Count {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub value: ::protobuf::SingularPtrField<Decimal>,
    pub comparator: ::protobuf::SingularPtrField<QuantityComparatorCode>,
    pub unit: ::protobuf::SingularPtrField<String>,
    pub system: ::protobuf::SingularPtrField<Uri>,
    pub code: ::protobuf::SingularPtrField<Code>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Count {
    pub fn new() -> Count {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Decimal value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Decimal) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Decimal {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Decimal {
        self.value.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_value(&self) -> &Decimal {
        self.value.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.QuantityComparatorCode comparator = 4;

    pub fn clear_comparator(&mut self) {
        self.comparator.clear();
    }

    pub fn has_comparator(&self) -> bool {
        self.comparator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comparator(&mut self, v: QuantityComparatorCode) {
        self.comparator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comparator(&mut self) -> &mut QuantityComparatorCode {
        if self.comparator.is_none() {
            self.comparator.set_default();
        }
        self.comparator.as_mut().unwrap()
    }

    // Take field
    pub fn take_comparator(&mut self) -> QuantityComparatorCode {
        self.comparator.take().unwrap_or_else(|| QuantityComparatorCode::new())
    }

    pub fn get_comparator(&self) -> &QuantityComparatorCode {
        self.comparator.as_ref().unwrap_or_else(|| QuantityComparatorCode::default_instance())
    }

    // .google.fhir.stu3.proto.String unit = 5;

    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: String) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut String {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> String {
        self.unit.take().unwrap_or_else(|| String::new())
    }

    pub fn get_unit(&self) -> &String {
        self.unit.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Uri system = 6;

    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: Uri) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut Uri {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> Uri {
        self.system.take().unwrap_or_else(|| Uri::new())
    }

    pub fn get_system(&self) -> &Uri {
        self.system.as_ref().unwrap_or_else(|| Uri::default_instance())
    }

    // .google.fhir.stu3.proto.Code code = 7;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Code) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut Code {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> Code {
        self.code.take().unwrap_or_else(|| Code::new())
    }

    pub fn get_code(&self) -> &Code {
        self.code.as_ref().unwrap_or_else(|| Code::default_instance())
    }
}

impl ::protobuf::Message for Count {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.comparator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.comparator)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Count {
        Count::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Count| { &m.id },
                    |m: &mut Count| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Count| { &m.extension },
                    |m: &mut Count| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "value",
                    |m: &Count| { &m.value },
                    |m: &mut Count| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuantityComparatorCode>>(
                    "comparator",
                    |m: &Count| { &m.comparator },
                    |m: &mut Count| { &mut m.comparator },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "unit",
                    |m: &Count| { &m.unit },
                    |m: &mut Count| { &mut m.unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "system",
                    |m: &Count| { &m.system },
                    |m: &mut Count| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Code>>(
                    "code",
                    |m: &Count| { &m.code },
                    |m: &mut Count| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Count>(
                    "Count",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Count {
        static mut instance: ::protobuf::lazy::Lazy<Count> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Count,
        };
        unsafe {
            instance.get(Count::new)
        }
    }
}

impl ::protobuf::Clear for Count {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_value();
        self.clear_comparator();
        self.clear_unit();
        self.clear_system();
        self.clear_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Count {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Count {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Distance {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub value: ::protobuf::SingularPtrField<Decimal>,
    pub comparator: ::protobuf::SingularPtrField<QuantityComparatorCode>,
    pub unit: ::protobuf::SingularPtrField<String>,
    pub system: ::protobuf::SingularPtrField<Uri>,
    pub code: ::protobuf::SingularPtrField<Code>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Distance {
    pub fn new() -> Distance {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Decimal value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Decimal) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Decimal {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Decimal {
        self.value.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_value(&self) -> &Decimal {
        self.value.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.QuantityComparatorCode comparator = 4;

    pub fn clear_comparator(&mut self) {
        self.comparator.clear();
    }

    pub fn has_comparator(&self) -> bool {
        self.comparator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comparator(&mut self, v: QuantityComparatorCode) {
        self.comparator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comparator(&mut self) -> &mut QuantityComparatorCode {
        if self.comparator.is_none() {
            self.comparator.set_default();
        }
        self.comparator.as_mut().unwrap()
    }

    // Take field
    pub fn take_comparator(&mut self) -> QuantityComparatorCode {
        self.comparator.take().unwrap_or_else(|| QuantityComparatorCode::new())
    }

    pub fn get_comparator(&self) -> &QuantityComparatorCode {
        self.comparator.as_ref().unwrap_or_else(|| QuantityComparatorCode::default_instance())
    }

    // .google.fhir.stu3.proto.String unit = 5;

    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: String) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut String {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> String {
        self.unit.take().unwrap_or_else(|| String::new())
    }

    pub fn get_unit(&self) -> &String {
        self.unit.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Uri system = 6;

    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: Uri) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut Uri {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> Uri {
        self.system.take().unwrap_or_else(|| Uri::new())
    }

    pub fn get_system(&self) -> &Uri {
        self.system.as_ref().unwrap_or_else(|| Uri::default_instance())
    }

    // .google.fhir.stu3.proto.Code code = 7;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Code) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut Code {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> Code {
        self.code.take().unwrap_or_else(|| Code::new())
    }

    pub fn get_code(&self) -> &Code {
        self.code.as_ref().unwrap_or_else(|| Code::default_instance())
    }
}

impl ::protobuf::Message for Distance {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.comparator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.comparator)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Distance {
        Distance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Distance| { &m.id },
                    |m: &mut Distance| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Distance| { &m.extension },
                    |m: &mut Distance| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "value",
                    |m: &Distance| { &m.value },
                    |m: &mut Distance| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuantityComparatorCode>>(
                    "comparator",
                    |m: &Distance| { &m.comparator },
                    |m: &mut Distance| { &mut m.comparator },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "unit",
                    |m: &Distance| { &m.unit },
                    |m: &mut Distance| { &mut m.unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "system",
                    |m: &Distance| { &m.system },
                    |m: &mut Distance| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Code>>(
                    "code",
                    |m: &Distance| { &m.code },
                    |m: &mut Distance| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Distance>(
                    "Distance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Distance {
        static mut instance: ::protobuf::lazy::Lazy<Distance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Distance,
        };
        unsafe {
            instance.get(Distance::new)
        }
    }
}

impl ::protobuf::Clear for Distance {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_value();
        self.clear_comparator();
        self.clear_unit();
        self.clear_system();
        self.clear_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Distance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Distance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Dosage {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub sequence: ::protobuf::SingularPtrField<Integer>,
    pub text: ::protobuf::SingularPtrField<String>,
    pub additional_instruction: ::protobuf::RepeatedField<CodeableConcept>,
    pub patient_instruction: ::protobuf::SingularPtrField<String>,
    pub timing: ::protobuf::SingularPtrField<Timing>,
    pub as_needed: ::protobuf::SingularPtrField<Dosage_AsNeeded>,
    pub site: ::protobuf::SingularPtrField<CodeableConcept>,
    pub route: ::protobuf::SingularPtrField<CodeableConcept>,
    pub method: ::protobuf::SingularPtrField<CodeableConcept>,
    pub dose: ::protobuf::SingularPtrField<Dosage_Dose>,
    pub max_dose_per_period: ::protobuf::SingularPtrField<Ratio>,
    pub max_dose_per_administration: ::protobuf::SingularPtrField<SimpleQuantity>,
    pub max_dose_per_lifetime: ::protobuf::SingularPtrField<SimpleQuantity>,
    pub rate: ::protobuf::SingularPtrField<Dosage_Rate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Dosage {
    pub fn new() -> Dosage {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Integer sequence = 3;

    pub fn clear_sequence(&mut self) {
        self.sequence.clear();
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: Integer) {
        self.sequence = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence(&mut self) -> &mut Integer {
        if self.sequence.is_none() {
            self.sequence.set_default();
        }
        self.sequence.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequence(&mut self) -> Integer {
        self.sequence.take().unwrap_or_else(|| Integer::new())
    }

    pub fn get_sequence(&self) -> &Integer {
        self.sequence.as_ref().unwrap_or_else(|| Integer::default_instance())
    }

    // .google.fhir.stu3.proto.String text = 4;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: String) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> String {
        self.text.take().unwrap_or_else(|| String::new())
    }

    pub fn get_text(&self) -> &String {
        self.text.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.CodeableConcept additional_instruction = 5;

    pub fn clear_additional_instruction(&mut self) {
        self.additional_instruction.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_instruction(&mut self, v: ::protobuf::RepeatedField<CodeableConcept>) {
        self.additional_instruction = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_instruction(&mut self) -> &mut ::protobuf::RepeatedField<CodeableConcept> {
        &mut self.additional_instruction
    }

    // Take field
    pub fn take_additional_instruction(&mut self) -> ::protobuf::RepeatedField<CodeableConcept> {
        ::std::mem::replace(&mut self.additional_instruction, ::protobuf::RepeatedField::new())
    }

    pub fn get_additional_instruction(&self) -> &[CodeableConcept] {
        &self.additional_instruction
    }

    // .google.fhir.stu3.proto.String patient_instruction = 6;

    pub fn clear_patient_instruction(&mut self) {
        self.patient_instruction.clear();
    }

    pub fn has_patient_instruction(&self) -> bool {
        self.patient_instruction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patient_instruction(&mut self, v: String) {
        self.patient_instruction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_patient_instruction(&mut self) -> &mut String {
        if self.patient_instruction.is_none() {
            self.patient_instruction.set_default();
        }
        self.patient_instruction.as_mut().unwrap()
    }

    // Take field
    pub fn take_patient_instruction(&mut self) -> String {
        self.patient_instruction.take().unwrap_or_else(|| String::new())
    }

    pub fn get_patient_instruction(&self) -> &String {
        self.patient_instruction.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Timing timing = 7;

    pub fn clear_timing(&mut self) {
        self.timing.clear();
    }

    pub fn has_timing(&self) -> bool {
        self.timing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timing(&mut self, v: Timing) {
        self.timing = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timing(&mut self) -> &mut Timing {
        if self.timing.is_none() {
            self.timing.set_default();
        }
        self.timing.as_mut().unwrap()
    }

    // Take field
    pub fn take_timing(&mut self) -> Timing {
        self.timing.take().unwrap_or_else(|| Timing::new())
    }

    pub fn get_timing(&self) -> &Timing {
        self.timing.as_ref().unwrap_or_else(|| Timing::default_instance())
    }

    // .google.fhir.stu3.proto.Dosage.AsNeeded as_needed = 8;

    pub fn clear_as_needed(&mut self) {
        self.as_needed.clear();
    }

    pub fn has_as_needed(&self) -> bool {
        self.as_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_as_needed(&mut self, v: Dosage_AsNeeded) {
        self.as_needed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_as_needed(&mut self) -> &mut Dosage_AsNeeded {
        if self.as_needed.is_none() {
            self.as_needed.set_default();
        }
        self.as_needed.as_mut().unwrap()
    }

    // Take field
    pub fn take_as_needed(&mut self) -> Dosage_AsNeeded {
        self.as_needed.take().unwrap_or_else(|| Dosage_AsNeeded::new())
    }

    pub fn get_as_needed(&self) -> &Dosage_AsNeeded {
        self.as_needed.as_ref().unwrap_or_else(|| Dosage_AsNeeded::default_instance())
    }

    // .google.fhir.stu3.proto.CodeableConcept site = 9;

    pub fn clear_site(&mut self) {
        self.site.clear();
    }

    pub fn has_site(&self) -> bool {
        self.site.is_some()
    }

    // Param is passed by value, moved
    pub fn set_site(&mut self, v: CodeableConcept) {
        self.site = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_site(&mut self) -> &mut CodeableConcept {
        if self.site.is_none() {
            self.site.set_default();
        }
        self.site.as_mut().unwrap()
    }

    // Take field
    pub fn take_site(&mut self) -> CodeableConcept {
        self.site.take().unwrap_or_else(|| CodeableConcept::new())
    }

    pub fn get_site(&self) -> &CodeableConcept {
        self.site.as_ref().unwrap_or_else(|| CodeableConcept::default_instance())
    }

    // .google.fhir.stu3.proto.CodeableConcept route = 10;

    pub fn clear_route(&mut self) {
        self.route.clear();
    }

    pub fn has_route(&self) -> bool {
        self.route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: CodeableConcept) {
        self.route = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route(&mut self) -> &mut CodeableConcept {
        if self.route.is_none() {
            self.route.set_default();
        }
        self.route.as_mut().unwrap()
    }

    // Take field
    pub fn take_route(&mut self) -> CodeableConcept {
        self.route.take().unwrap_or_else(|| CodeableConcept::new())
    }

    pub fn get_route(&self) -> &CodeableConcept {
        self.route.as_ref().unwrap_or_else(|| CodeableConcept::default_instance())
    }

    // .google.fhir.stu3.proto.CodeableConcept method = 11;

    pub fn clear_method(&mut self) {
        self.method.clear();
    }

    pub fn has_method(&self) -> bool {
        self.method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: CodeableConcept) {
        self.method = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method(&mut self) -> &mut CodeableConcept {
        if self.method.is_none() {
            self.method.set_default();
        }
        self.method.as_mut().unwrap()
    }

    // Take field
    pub fn take_method(&mut self) -> CodeableConcept {
        self.method.take().unwrap_or_else(|| CodeableConcept::new())
    }

    pub fn get_method(&self) -> &CodeableConcept {
        self.method.as_ref().unwrap_or_else(|| CodeableConcept::default_instance())
    }

    // .google.fhir.stu3.proto.Dosage.Dose dose = 12;

    pub fn clear_dose(&mut self) {
        self.dose.clear();
    }

    pub fn has_dose(&self) -> bool {
        self.dose.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dose(&mut self, v: Dosage_Dose) {
        self.dose = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dose(&mut self) -> &mut Dosage_Dose {
        if self.dose.is_none() {
            self.dose.set_default();
        }
        self.dose.as_mut().unwrap()
    }

    // Take field
    pub fn take_dose(&mut self) -> Dosage_Dose {
        self.dose.take().unwrap_or_else(|| Dosage_Dose::new())
    }

    pub fn get_dose(&self) -> &Dosage_Dose {
        self.dose.as_ref().unwrap_or_else(|| Dosage_Dose::default_instance())
    }

    // .google.fhir.stu3.proto.Ratio max_dose_per_period = 13;

    pub fn clear_max_dose_per_period(&mut self) {
        self.max_dose_per_period.clear();
    }

    pub fn has_max_dose_per_period(&self) -> bool {
        self.max_dose_per_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_dose_per_period(&mut self, v: Ratio) {
        self.max_dose_per_period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_dose_per_period(&mut self) -> &mut Ratio {
        if self.max_dose_per_period.is_none() {
            self.max_dose_per_period.set_default();
        }
        self.max_dose_per_period.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_dose_per_period(&mut self) -> Ratio {
        self.max_dose_per_period.take().unwrap_or_else(|| Ratio::new())
    }

    pub fn get_max_dose_per_period(&self) -> &Ratio {
        self.max_dose_per_period.as_ref().unwrap_or_else(|| Ratio::default_instance())
    }

    // .google.fhir.stu3.proto.SimpleQuantity max_dose_per_administration = 14;

    pub fn clear_max_dose_per_administration(&mut self) {
        self.max_dose_per_administration.clear();
    }

    pub fn has_max_dose_per_administration(&self) -> bool {
        self.max_dose_per_administration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_dose_per_administration(&mut self, v: SimpleQuantity) {
        self.max_dose_per_administration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_dose_per_administration(&mut self) -> &mut SimpleQuantity {
        if self.max_dose_per_administration.is_none() {
            self.max_dose_per_administration.set_default();
        }
        self.max_dose_per_administration.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_dose_per_administration(&mut self) -> SimpleQuantity {
        self.max_dose_per_administration.take().unwrap_or_else(|| SimpleQuantity::new())
    }

    pub fn get_max_dose_per_administration(&self) -> &SimpleQuantity {
        self.max_dose_per_administration.as_ref().unwrap_or_else(|| SimpleQuantity::default_instance())
    }

    // .google.fhir.stu3.proto.SimpleQuantity max_dose_per_lifetime = 15;

    pub fn clear_max_dose_per_lifetime(&mut self) {
        self.max_dose_per_lifetime.clear();
    }

    pub fn has_max_dose_per_lifetime(&self) -> bool {
        self.max_dose_per_lifetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_dose_per_lifetime(&mut self, v: SimpleQuantity) {
        self.max_dose_per_lifetime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_dose_per_lifetime(&mut self) -> &mut SimpleQuantity {
        if self.max_dose_per_lifetime.is_none() {
            self.max_dose_per_lifetime.set_default();
        }
        self.max_dose_per_lifetime.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_dose_per_lifetime(&mut self) -> SimpleQuantity {
        self.max_dose_per_lifetime.take().unwrap_or_else(|| SimpleQuantity::new())
    }

    pub fn get_max_dose_per_lifetime(&self) -> &SimpleQuantity {
        self.max_dose_per_lifetime.as_ref().unwrap_or_else(|| SimpleQuantity::default_instance())
    }

    // .google.fhir.stu3.proto.Dosage.Rate rate = 16;

    pub fn clear_rate(&mut self) {
        self.rate.clear();
    }

    pub fn has_rate(&self) -> bool {
        self.rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rate(&mut self, v: Dosage_Rate) {
        self.rate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rate(&mut self) -> &mut Dosage_Rate {
        if self.rate.is_none() {
            self.rate.set_default();
        }
        self.rate.as_mut().unwrap()
    }

    // Take field
    pub fn take_rate(&mut self) -> Dosage_Rate {
        self.rate.take().unwrap_or_else(|| Dosage_Rate::new())
    }

    pub fn get_rate(&self) -> &Dosage_Rate {
        self.rate.as_ref().unwrap_or_else(|| Dosage_Rate::default_instance())
    }
}

impl ::protobuf::Message for Dosage {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sequence {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.additional_instruction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.patient_instruction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.timing {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.as_needed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.site {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.route {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.method {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dose {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_dose_per_period {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_dose_per_administration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_dose_per_lifetime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sequence)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.additional_instruction)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.patient_instruction)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timing)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.as_needed)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.site)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.method)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dose)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_dose_per_period)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_dose_per_administration)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_dose_per_lifetime)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.sequence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.additional_instruction {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.patient_instruction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.timing.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.as_needed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.site.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.route.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.method.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dose.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_dose_per_period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_dose_per_administration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_dose_per_lifetime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rate.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.sequence.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.additional_instruction {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.patient_instruction.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.timing.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.as_needed.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.site.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.route.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.method.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dose.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_dose_per_period.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_dose_per_administration.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_dose_per_lifetime.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rate.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dosage {
        Dosage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Dosage| { &m.id },
                    |m: &mut Dosage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Dosage| { &m.extension },
                    |m: &mut Dosage| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Integer>>(
                    "sequence",
                    |m: &Dosage| { &m.sequence },
                    |m: &mut Dosage| { &mut m.sequence },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "text",
                    |m: &Dosage| { &m.text },
                    |m: &mut Dosage| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodeableConcept>>(
                    "additional_instruction",
                    |m: &Dosage| { &m.additional_instruction },
                    |m: &mut Dosage| { &mut m.additional_instruction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "patient_instruction",
                    |m: &Dosage| { &m.patient_instruction },
                    |m: &mut Dosage| { &mut m.patient_instruction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timing>>(
                    "timing",
                    |m: &Dosage| { &m.timing },
                    |m: &mut Dosage| { &mut m.timing },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dosage_AsNeeded>>(
                    "as_needed",
                    |m: &Dosage| { &m.as_needed },
                    |m: &mut Dosage| { &mut m.as_needed },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodeableConcept>>(
                    "site",
                    |m: &Dosage| { &m.site },
                    |m: &mut Dosage| { &mut m.site },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodeableConcept>>(
                    "route",
                    |m: &Dosage| { &m.route },
                    |m: &mut Dosage| { &mut m.route },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodeableConcept>>(
                    "method",
                    |m: &Dosage| { &m.method },
                    |m: &mut Dosage| { &mut m.method },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dosage_Dose>>(
                    "dose",
                    |m: &Dosage| { &m.dose },
                    |m: &mut Dosage| { &mut m.dose },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Ratio>>(
                    "max_dose_per_period",
                    |m: &Dosage| { &m.max_dose_per_period },
                    |m: &mut Dosage| { &mut m.max_dose_per_period },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SimpleQuantity>>(
                    "max_dose_per_administration",
                    |m: &Dosage| { &m.max_dose_per_administration },
                    |m: &mut Dosage| { &mut m.max_dose_per_administration },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SimpleQuantity>>(
                    "max_dose_per_lifetime",
                    |m: &Dosage| { &m.max_dose_per_lifetime },
                    |m: &mut Dosage| { &mut m.max_dose_per_lifetime },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Dosage_Rate>>(
                    "rate",
                    |m: &Dosage| { &m.rate },
                    |m: &mut Dosage| { &mut m.rate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Dosage>(
                    "Dosage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Dosage {
        static mut instance: ::protobuf::lazy::Lazy<Dosage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Dosage,
        };
        unsafe {
            instance.get(Dosage::new)
        }
    }
}

impl ::protobuf::Clear for Dosage {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_sequence();
        self.clear_text();
        self.clear_additional_instruction();
        self.clear_patient_instruction();
        self.clear_timing();
        self.clear_as_needed();
        self.clear_site();
        self.clear_route();
        self.clear_method();
        self.clear_dose();
        self.clear_max_dose_per_period();
        self.clear_max_dose_per_administration();
        self.clear_max_dose_per_lifetime();
        self.clear_rate();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dosage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dosage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Dosage_AsNeeded {
    // message oneof groups
    pub as_needed: ::std::option::Option<Dosage_AsNeeded_oneof_as_needed>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Dosage_AsNeeded_oneof_as_needed {
    boolean(Boolean),
    codeable_concept(CodeableConcept),
}

impl Dosage_AsNeeded {
    pub fn new() -> Dosage_AsNeeded {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.Boolean boolean = 1;

    pub fn clear_boolean(&mut self) {
        self.as_needed = ::std::option::Option::None;
    }

    pub fn has_boolean(&self) -> bool {
        match self.as_needed {
            ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::boolean(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean(&mut self, v: Boolean) {
        self.as_needed = ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::boolean(v))
    }

    // Mutable pointer to the field.
    pub fn mut_boolean(&mut self) -> &mut Boolean {
        if let ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::boolean(_)) = self.as_needed {
        } else {
            self.as_needed = ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::boolean(Boolean::new()));
        }
        match self.as_needed {
            ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::boolean(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_boolean(&mut self) -> Boolean {
        if self.has_boolean() {
            match self.as_needed.take() {
                ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::boolean(v)) => v,
                _ => panic!(),
            }
        } else {
            Boolean::new()
        }
    }

    pub fn get_boolean(&self) -> &Boolean {
        match self.as_needed {
            ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::boolean(ref v)) => v,
            _ => Boolean::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.CodeableConcept codeable_concept = 2;

    pub fn clear_codeable_concept(&mut self) {
        self.as_needed = ::std::option::Option::None;
    }

    pub fn has_codeable_concept(&self) -> bool {
        match self.as_needed {
            ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::codeable_concept(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_codeable_concept(&mut self, v: CodeableConcept) {
        self.as_needed = ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::codeable_concept(v))
    }

    // Mutable pointer to the field.
    pub fn mut_codeable_concept(&mut self) -> &mut CodeableConcept {
        if let ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::codeable_concept(_)) = self.as_needed {
        } else {
            self.as_needed = ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::codeable_concept(CodeableConcept::new()));
        }
        match self.as_needed {
            ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::codeable_concept(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_codeable_concept(&mut self) -> CodeableConcept {
        if self.has_codeable_concept() {
            match self.as_needed.take() {
                ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::codeable_concept(v)) => v,
                _ => panic!(),
            }
        } else {
            CodeableConcept::new()
        }
    }

    pub fn get_codeable_concept(&self) -> &CodeableConcept {
        match self.as_needed {
            ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::codeable_concept(ref v)) => v,
            _ => CodeableConcept::default_instance(),
        }
    }
}

impl ::protobuf::Message for Dosage_AsNeeded {
    fn is_initialized(&self) -> bool {
        if let Some(Dosage_AsNeeded_oneof_as_needed::boolean(ref v)) = self.as_needed {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Dosage_AsNeeded_oneof_as_needed::codeable_concept(ref v)) = self.as_needed {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.as_needed = ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::boolean(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.as_needed = ::std::option::Option::Some(Dosage_AsNeeded_oneof_as_needed::codeable_concept(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.as_needed {
            match v {
                &Dosage_AsNeeded_oneof_as_needed::boolean(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Dosage_AsNeeded_oneof_as_needed::codeable_concept(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.as_needed {
            match v {
                &Dosage_AsNeeded_oneof_as_needed::boolean(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Dosage_AsNeeded_oneof_as_needed::codeable_concept(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dosage_AsNeeded {
        Dosage_AsNeeded::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Boolean>(
                    "boolean",
                    Dosage_AsNeeded::has_boolean,
                    Dosage_AsNeeded::get_boolean,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CodeableConcept>(
                    "codeable_concept",
                    Dosage_AsNeeded::has_codeable_concept,
                    Dosage_AsNeeded::get_codeable_concept,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Dosage_AsNeeded>(
                    "Dosage_AsNeeded",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Dosage_AsNeeded {
        static mut instance: ::protobuf::lazy::Lazy<Dosage_AsNeeded> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Dosage_AsNeeded,
        };
        unsafe {
            instance.get(Dosage_AsNeeded::new)
        }
    }
}

impl ::protobuf::Clear for Dosage_AsNeeded {
    fn clear(&mut self) {
        self.clear_boolean();
        self.clear_codeable_concept();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dosage_AsNeeded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dosage_AsNeeded {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Dosage_Dose {
    // message oneof groups
    pub dose: ::std::option::Option<Dosage_Dose_oneof_dose>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Dosage_Dose_oneof_dose {
    range(Range),
    quantity(SimpleQuantity),
}

impl Dosage_Dose {
    pub fn new() -> Dosage_Dose {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.Range range = 1;

    pub fn clear_range(&mut self) {
        self.dose = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        match self.dose {
            ::std::option::Option::Some(Dosage_Dose_oneof_dose::range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Range) {
        self.dose = ::std::option::Option::Some(Dosage_Dose_oneof_dose::range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_range(&mut self) -> &mut Range {
        if let ::std::option::Option::Some(Dosage_Dose_oneof_dose::range(_)) = self.dose {
        } else {
            self.dose = ::std::option::Option::Some(Dosage_Dose_oneof_dose::range(Range::new()));
        }
        match self.dose {
            ::std::option::Option::Some(Dosage_Dose_oneof_dose::range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_range(&mut self) -> Range {
        if self.has_range() {
            match self.dose.take() {
                ::std::option::Option::Some(Dosage_Dose_oneof_dose::range(v)) => v,
                _ => panic!(),
            }
        } else {
            Range::new()
        }
    }

    pub fn get_range(&self) -> &Range {
        match self.dose {
            ::std::option::Option::Some(Dosage_Dose_oneof_dose::range(ref v)) => v,
            _ => Range::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.SimpleQuantity quantity = 2;

    pub fn clear_quantity(&mut self) {
        self.dose = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        match self.dose {
            ::std::option::Option::Some(Dosage_Dose_oneof_dose::quantity(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: SimpleQuantity) {
        self.dose = ::std::option::Option::Some(Dosage_Dose_oneof_dose::quantity(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quantity(&mut self) -> &mut SimpleQuantity {
        if let ::std::option::Option::Some(Dosage_Dose_oneof_dose::quantity(_)) = self.dose {
        } else {
            self.dose = ::std::option::Option::Some(Dosage_Dose_oneof_dose::quantity(SimpleQuantity::new()));
        }
        match self.dose {
            ::std::option::Option::Some(Dosage_Dose_oneof_dose::quantity(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quantity(&mut self) -> SimpleQuantity {
        if self.has_quantity() {
            match self.dose.take() {
                ::std::option::Option::Some(Dosage_Dose_oneof_dose::quantity(v)) => v,
                _ => panic!(),
            }
        } else {
            SimpleQuantity::new()
        }
    }

    pub fn get_quantity(&self) -> &SimpleQuantity {
        match self.dose {
            ::std::option::Option::Some(Dosage_Dose_oneof_dose::quantity(ref v)) => v,
            _ => SimpleQuantity::default_instance(),
        }
    }
}

impl ::protobuf::Message for Dosage_Dose {
    fn is_initialized(&self) -> bool {
        if let Some(Dosage_Dose_oneof_dose::range(ref v)) = self.dose {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Dosage_Dose_oneof_dose::quantity(ref v)) = self.dose {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dose = ::std::option::Option::Some(Dosage_Dose_oneof_dose::range(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.dose = ::std::option::Option::Some(Dosage_Dose_oneof_dose::quantity(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.dose {
            match v {
                &Dosage_Dose_oneof_dose::range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Dosage_Dose_oneof_dose::quantity(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.dose {
            match v {
                &Dosage_Dose_oneof_dose::range(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Dosage_Dose_oneof_dose::quantity(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dosage_Dose {
        Dosage_Dose::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Range>(
                    "range",
                    Dosage_Dose::has_range,
                    Dosage_Dose::get_range,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SimpleQuantity>(
                    "quantity",
                    Dosage_Dose::has_quantity,
                    Dosage_Dose::get_quantity,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Dosage_Dose>(
                    "Dosage_Dose",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Dosage_Dose {
        static mut instance: ::protobuf::lazy::Lazy<Dosage_Dose> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Dosage_Dose,
        };
        unsafe {
            instance.get(Dosage_Dose::new)
        }
    }
}

impl ::protobuf::Clear for Dosage_Dose {
    fn clear(&mut self) {
        self.clear_range();
        self.clear_quantity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dosage_Dose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dosage_Dose {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Dosage_Rate {
    // message oneof groups
    pub rate: ::std::option::Option<Dosage_Rate_oneof_rate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Dosage_Rate_oneof_rate {
    ratio(Ratio),
    range(Range),
    quantity(SimpleQuantity),
}

impl Dosage_Rate {
    pub fn new() -> Dosage_Rate {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.Ratio ratio = 1;

    pub fn clear_ratio(&mut self) {
        self.rate = ::std::option::Option::None;
    }

    pub fn has_ratio(&self) -> bool {
        match self.rate {
            ::std::option::Option::Some(Dosage_Rate_oneof_rate::ratio(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ratio(&mut self, v: Ratio) {
        self.rate = ::std::option::Option::Some(Dosage_Rate_oneof_rate::ratio(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ratio(&mut self) -> &mut Ratio {
        if let ::std::option::Option::Some(Dosage_Rate_oneof_rate::ratio(_)) = self.rate {
        } else {
            self.rate = ::std::option::Option::Some(Dosage_Rate_oneof_rate::ratio(Ratio::new()));
        }
        match self.rate {
            ::std::option::Option::Some(Dosage_Rate_oneof_rate::ratio(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ratio(&mut self) -> Ratio {
        if self.has_ratio() {
            match self.rate.take() {
                ::std::option::Option::Some(Dosage_Rate_oneof_rate::ratio(v)) => v,
                _ => panic!(),
            }
        } else {
            Ratio::new()
        }
    }

    pub fn get_ratio(&self) -> &Ratio {
        match self.rate {
            ::std::option::Option::Some(Dosage_Rate_oneof_rate::ratio(ref v)) => v,
            _ => Ratio::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Range range = 2;

    pub fn clear_range(&mut self) {
        self.rate = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        match self.rate {
            ::std::option::Option::Some(Dosage_Rate_oneof_rate::range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Range) {
        self.rate = ::std::option::Option::Some(Dosage_Rate_oneof_rate::range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_range(&mut self) -> &mut Range {
        if let ::std::option::Option::Some(Dosage_Rate_oneof_rate::range(_)) = self.rate {
        } else {
            self.rate = ::std::option::Option::Some(Dosage_Rate_oneof_rate::range(Range::new()));
        }
        match self.rate {
            ::std::option::Option::Some(Dosage_Rate_oneof_rate::range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_range(&mut self) -> Range {
        if self.has_range() {
            match self.rate.take() {
                ::std::option::Option::Some(Dosage_Rate_oneof_rate::range(v)) => v,
                _ => panic!(),
            }
        } else {
            Range::new()
        }
    }

    pub fn get_range(&self) -> &Range {
        match self.rate {
            ::std::option::Option::Some(Dosage_Rate_oneof_rate::range(ref v)) => v,
            _ => Range::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.SimpleQuantity quantity = 3;

    pub fn clear_quantity(&mut self) {
        self.rate = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        match self.rate {
            ::std::option::Option::Some(Dosage_Rate_oneof_rate::quantity(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: SimpleQuantity) {
        self.rate = ::std::option::Option::Some(Dosage_Rate_oneof_rate::quantity(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quantity(&mut self) -> &mut SimpleQuantity {
        if let ::std::option::Option::Some(Dosage_Rate_oneof_rate::quantity(_)) = self.rate {
        } else {
            self.rate = ::std::option::Option::Some(Dosage_Rate_oneof_rate::quantity(SimpleQuantity::new()));
        }
        match self.rate {
            ::std::option::Option::Some(Dosage_Rate_oneof_rate::quantity(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quantity(&mut self) -> SimpleQuantity {
        if self.has_quantity() {
            match self.rate.take() {
                ::std::option::Option::Some(Dosage_Rate_oneof_rate::quantity(v)) => v,
                _ => panic!(),
            }
        } else {
            SimpleQuantity::new()
        }
    }

    pub fn get_quantity(&self) -> &SimpleQuantity {
        match self.rate {
            ::std::option::Option::Some(Dosage_Rate_oneof_rate::quantity(ref v)) => v,
            _ => SimpleQuantity::default_instance(),
        }
    }
}

impl ::protobuf::Message for Dosage_Rate {
    fn is_initialized(&self) -> bool {
        if let Some(Dosage_Rate_oneof_rate::ratio(ref v)) = self.rate {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Dosage_Rate_oneof_rate::range(ref v)) = self.rate {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Dosage_Rate_oneof_rate::quantity(ref v)) = self.rate {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rate = ::std::option::Option::Some(Dosage_Rate_oneof_rate::ratio(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rate = ::std::option::Option::Some(Dosage_Rate_oneof_rate::range(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rate = ::std::option::Option::Some(Dosage_Rate_oneof_rate::quantity(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.rate {
            match v {
                &Dosage_Rate_oneof_rate::ratio(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Dosage_Rate_oneof_rate::range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Dosage_Rate_oneof_rate::quantity(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.rate {
            match v {
                &Dosage_Rate_oneof_rate::ratio(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Dosage_Rate_oneof_rate::range(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Dosage_Rate_oneof_rate::quantity(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dosage_Rate {
        Dosage_Rate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Ratio>(
                    "ratio",
                    Dosage_Rate::has_ratio,
                    Dosage_Rate::get_ratio,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Range>(
                    "range",
                    Dosage_Rate::has_range,
                    Dosage_Rate::get_range,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SimpleQuantity>(
                    "quantity",
                    Dosage_Rate::has_quantity,
                    Dosage_Rate::get_quantity,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Dosage_Rate>(
                    "Dosage_Rate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Dosage_Rate {
        static mut instance: ::protobuf::lazy::Lazy<Dosage_Rate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Dosage_Rate,
        };
        unsafe {
            instance.get(Dosage_Rate::new)
        }
    }
}

impl ::protobuf::Clear for Dosage_Rate {
    fn clear(&mut self) {
        self.clear_ratio();
        self.clear_range();
        self.clear_quantity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dosage_Rate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dosage_Rate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Duration {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub value: ::protobuf::SingularPtrField<Decimal>,
    pub comparator: ::protobuf::SingularPtrField<QuantityComparatorCode>,
    pub unit: ::protobuf::SingularPtrField<String>,
    pub system: ::protobuf::SingularPtrField<Uri>,
    pub code: ::protobuf::SingularPtrField<Code>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Duration {
    pub fn new() -> Duration {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Decimal value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Decimal) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Decimal {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Decimal {
        self.value.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_value(&self) -> &Decimal {
        self.value.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.QuantityComparatorCode comparator = 4;

    pub fn clear_comparator(&mut self) {
        self.comparator.clear();
    }

    pub fn has_comparator(&self) -> bool {
        self.comparator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comparator(&mut self, v: QuantityComparatorCode) {
        self.comparator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comparator(&mut self) -> &mut QuantityComparatorCode {
        if self.comparator.is_none() {
            self.comparator.set_default();
        }
        self.comparator.as_mut().unwrap()
    }

    // Take field
    pub fn take_comparator(&mut self) -> QuantityComparatorCode {
        self.comparator.take().unwrap_or_else(|| QuantityComparatorCode::new())
    }

    pub fn get_comparator(&self) -> &QuantityComparatorCode {
        self.comparator.as_ref().unwrap_or_else(|| QuantityComparatorCode::default_instance())
    }

    // .google.fhir.stu3.proto.String unit = 5;

    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: String) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut String {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> String {
        self.unit.take().unwrap_or_else(|| String::new())
    }

    pub fn get_unit(&self) -> &String {
        self.unit.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Uri system = 6;

    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: Uri) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut Uri {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> Uri {
        self.system.take().unwrap_or_else(|| Uri::new())
    }

    pub fn get_system(&self) -> &Uri {
        self.system.as_ref().unwrap_or_else(|| Uri::default_instance())
    }

    // .google.fhir.stu3.proto.Code code = 7;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Code) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut Code {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> Code {
        self.code.take().unwrap_or_else(|| Code::new())
    }

    pub fn get_code(&self) -> &Code {
        self.code.as_ref().unwrap_or_else(|| Code::default_instance())
    }
}

impl ::protobuf::Message for Duration {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.comparator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.comparator)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Duration {
        Duration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Duration| { &m.id },
                    |m: &mut Duration| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Duration| { &m.extension },
                    |m: &mut Duration| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "value",
                    |m: &Duration| { &m.value },
                    |m: &mut Duration| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuantityComparatorCode>>(
                    "comparator",
                    |m: &Duration| { &m.comparator },
                    |m: &mut Duration| { &mut m.comparator },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "unit",
                    |m: &Duration| { &m.unit },
                    |m: &mut Duration| { &mut m.unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "system",
                    |m: &Duration| { &m.system },
                    |m: &mut Duration| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Code>>(
                    "code",
                    |m: &Duration| { &m.code },
                    |m: &mut Duration| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Duration>(
                    "Duration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Duration {
        static mut instance: ::protobuf::lazy::Lazy<Duration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Duration,
        };
        unsafe {
            instance.get(Duration::new)
        }
    }
}

impl ::protobuf::Clear for Duration {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_value();
        self.clear_comparator();
        self.clear_unit();
        self.clear_system();
        self.clear_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Duration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Duration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HumanName {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub field_use: ::protobuf::SingularPtrField<NameUseCode>,
    pub text: ::protobuf::SingularPtrField<String>,
    pub family: ::protobuf::SingularPtrField<String>,
    pub given: ::protobuf::RepeatedField<String>,
    pub prefix: ::protobuf::RepeatedField<String>,
    pub suffix: ::protobuf::RepeatedField<String>,
    pub period: ::protobuf::SingularPtrField<Period>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl HumanName {
    pub fn new() -> HumanName {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.NameUseCode use = 3;

    pub fn clear_field_use(&mut self) {
        self.field_use.clear();
    }

    pub fn has_field_use(&self) -> bool {
        self.field_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_use(&mut self, v: NameUseCode) {
        self.field_use = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_use(&mut self) -> &mut NameUseCode {
        if self.field_use.is_none() {
            self.field_use.set_default();
        }
        self.field_use.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_use(&mut self) -> NameUseCode {
        self.field_use.take().unwrap_or_else(|| NameUseCode::new())
    }

    pub fn get_field_use(&self) -> &NameUseCode {
        self.field_use.as_ref().unwrap_or_else(|| NameUseCode::default_instance())
    }

    // .google.fhir.stu3.proto.String text = 4;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: String) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut String {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> String {
        self.text.take().unwrap_or_else(|| String::new())
    }

    pub fn get_text(&self) -> &String {
        self.text.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.String family = 5;

    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    pub fn has_family(&self) -> bool {
        self.family.is_some()
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: String) {
        self.family = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_family(&mut self) -> &mut String {
        if self.family.is_none() {
            self.family.set_default();
        }
        self.family.as_mut().unwrap()
    }

    // Take field
    pub fn take_family(&mut self) -> String {
        self.family.take().unwrap_or_else(|| String::new())
    }

    pub fn get_family(&self) -> &String {
        self.family.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.String given = 6;

    pub fn clear_given(&mut self) {
        self.given.clear();
    }

    // Param is passed by value, moved
    pub fn set_given(&mut self, v: ::protobuf::RepeatedField<String>) {
        self.given = v;
    }

    // Mutable pointer to the field.
    pub fn mut_given(&mut self) -> &mut ::protobuf::RepeatedField<String> {
        &mut self.given
    }

    // Take field
    pub fn take_given(&mut self) -> ::protobuf::RepeatedField<String> {
        ::std::mem::replace(&mut self.given, ::protobuf::RepeatedField::new())
    }

    pub fn get_given(&self) -> &[String] {
        &self.given
    }

    // repeated .google.fhir.stu3.proto.String prefix = 7;

    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::protobuf::RepeatedField<String>) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prefix(&mut self) -> &mut ::protobuf::RepeatedField<String> {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::protobuf::RepeatedField<String> {
        ::std::mem::replace(&mut self.prefix, ::protobuf::RepeatedField::new())
    }

    pub fn get_prefix(&self) -> &[String] {
        &self.prefix
    }

    // repeated .google.fhir.stu3.proto.String suffix = 8;

    pub fn clear_suffix(&mut self) {
        self.suffix.clear();
    }

    // Param is passed by value, moved
    pub fn set_suffix(&mut self, v: ::protobuf::RepeatedField<String>) {
        self.suffix = v;
    }

    // Mutable pointer to the field.
    pub fn mut_suffix(&mut self) -> &mut ::protobuf::RepeatedField<String> {
        &mut self.suffix
    }

    // Take field
    pub fn take_suffix(&mut self) -> ::protobuf::RepeatedField<String> {
        ::std::mem::replace(&mut self.suffix, ::protobuf::RepeatedField::new())
    }

    pub fn get_suffix(&self) -> &[String] {
        &self.suffix
    }

    // .google.fhir.stu3.proto.Period period = 9;

    pub fn clear_period(&mut self) {
        self.period.clear();
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: Period) {
        self.period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_period(&mut self) -> &mut Period {
        if self.period.is_none() {
            self.period.set_default();
        }
        self.period.as_mut().unwrap()
    }

    // Take field
    pub fn take_period(&mut self) -> Period {
        self.period.take().unwrap_or_else(|| Period::new())
    }

    pub fn get_period(&self) -> &Period {
        self.period.as_ref().unwrap_or_else(|| Period::default_instance())
    }
}

impl ::protobuf::Message for HumanName {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_use {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.family {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.given {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.prefix {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.suffix {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.period {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_use)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.family)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.given)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prefix)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.suffix)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.period)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.field_use.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.family.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.given {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.prefix {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.suffix {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.field_use.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.family.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.given {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.prefix {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.suffix {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.period.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HumanName {
        HumanName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &HumanName| { &m.id },
                    |m: &mut HumanName| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &HumanName| { &m.extension },
                    |m: &mut HumanName| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NameUseCode>>(
                    "use",
                    |m: &HumanName| { &m.field_use },
                    |m: &mut HumanName| { &mut m.field_use },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "text",
                    |m: &HumanName| { &m.text },
                    |m: &mut HumanName| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "family",
                    |m: &HumanName| { &m.family },
                    |m: &mut HumanName| { &mut m.family },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "given",
                    |m: &HumanName| { &m.given },
                    |m: &mut HumanName| { &mut m.given },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "prefix",
                    |m: &HumanName| { &m.prefix },
                    |m: &mut HumanName| { &mut m.prefix },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "suffix",
                    |m: &HumanName| { &m.suffix },
                    |m: &mut HumanName| { &mut m.suffix },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Period>>(
                    "period",
                    |m: &HumanName| { &m.period },
                    |m: &mut HumanName| { &mut m.period },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HumanName>(
                    "HumanName",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HumanName {
        static mut instance: ::protobuf::lazy::Lazy<HumanName> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HumanName,
        };
        unsafe {
            instance.get(HumanName::new)
        }
    }
}

impl ::protobuf::Clear for HumanName {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_field_use();
        self.clear_text();
        self.clear_family();
        self.clear_given();
        self.clear_prefix();
        self.clear_suffix();
        self.clear_period();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HumanName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HumanName {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Identifier {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub field_use: ::protobuf::SingularPtrField<IdentifierUseCode>,
    pub field_type: ::protobuf::SingularPtrField<CodeableConcept>,
    pub system: ::protobuf::SingularPtrField<Uri>,
    pub value: ::protobuf::SingularPtrField<String>,
    pub period: ::protobuf::SingularPtrField<Period>,
    pub assigner: ::protobuf::SingularPtrField<Reference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Identifier {
    pub fn new() -> Identifier {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.IdentifierUseCode use = 3;

    pub fn clear_field_use(&mut self) {
        self.field_use.clear();
    }

    pub fn has_field_use(&self) -> bool {
        self.field_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_use(&mut self, v: IdentifierUseCode) {
        self.field_use = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_use(&mut self) -> &mut IdentifierUseCode {
        if self.field_use.is_none() {
            self.field_use.set_default();
        }
        self.field_use.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_use(&mut self) -> IdentifierUseCode {
        self.field_use.take().unwrap_or_else(|| IdentifierUseCode::new())
    }

    pub fn get_field_use(&self) -> &IdentifierUseCode {
        self.field_use.as_ref().unwrap_or_else(|| IdentifierUseCode::default_instance())
    }

    // .google.fhir.stu3.proto.CodeableConcept type = 4;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CodeableConcept) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut CodeableConcept {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> CodeableConcept {
        self.field_type.take().unwrap_or_else(|| CodeableConcept::new())
    }

    pub fn get_field_type(&self) -> &CodeableConcept {
        self.field_type.as_ref().unwrap_or_else(|| CodeableConcept::default_instance())
    }

    // .google.fhir.stu3.proto.Uri system = 5;

    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: Uri) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut Uri {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> Uri {
        self.system.take().unwrap_or_else(|| Uri::new())
    }

    pub fn get_system(&self) -> &Uri {
        self.system.as_ref().unwrap_or_else(|| Uri::default_instance())
    }

    // .google.fhir.stu3.proto.String value = 6;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: String) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> String {
        self.value.take().unwrap_or_else(|| String::new())
    }

    pub fn get_value(&self) -> &String {
        self.value.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Period period = 7;

    pub fn clear_period(&mut self) {
        self.period.clear();
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: Period) {
        self.period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_period(&mut self) -> &mut Period {
        if self.period.is_none() {
            self.period.set_default();
        }
        self.period.as_mut().unwrap()
    }

    // Take field
    pub fn take_period(&mut self) -> Period {
        self.period.take().unwrap_or_else(|| Period::new())
    }

    pub fn get_period(&self) -> &Period {
        self.period.as_ref().unwrap_or_else(|| Period::default_instance())
    }

    // .google.fhir.stu3.proto.Reference assigner = 8;

    pub fn clear_assigner(&mut self) {
        self.assigner.clear();
    }

    pub fn has_assigner(&self) -> bool {
        self.assigner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assigner(&mut self, v: Reference) {
        self.assigner = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assigner(&mut self) -> &mut Reference {
        if self.assigner.is_none() {
            self.assigner.set_default();
        }
        self.assigner.as_mut().unwrap()
    }

    // Take field
    pub fn take_assigner(&mut self) -> Reference {
        self.assigner.take().unwrap_or_else(|| Reference::new())
    }

    pub fn get_assigner(&self) -> &Reference {
        self.assigner.as_ref().unwrap_or_else(|| Reference::default_instance())
    }
}

impl ::protobuf::Message for Identifier {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_use {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.period {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.assigner {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_use)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.period)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assigner)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.field_use.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.assigner.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.field_use.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.period.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.assigner.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Identifier {
        Identifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Identifier| { &m.id },
                    |m: &mut Identifier| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Identifier| { &m.extension },
                    |m: &mut Identifier| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentifierUseCode>>(
                    "use",
                    |m: &Identifier| { &m.field_use },
                    |m: &mut Identifier| { &mut m.field_use },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodeableConcept>>(
                    "type",
                    |m: &Identifier| { &m.field_type },
                    |m: &mut Identifier| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "system",
                    |m: &Identifier| { &m.system },
                    |m: &mut Identifier| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "value",
                    |m: &Identifier| { &m.value },
                    |m: &mut Identifier| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Period>>(
                    "period",
                    |m: &Identifier| { &m.period },
                    |m: &mut Identifier| { &mut m.period },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Reference>>(
                    "assigner",
                    |m: &Identifier| { &m.assigner },
                    |m: &mut Identifier| { &mut m.assigner },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Identifier>(
                    "Identifier",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Identifier {
        static mut instance: ::protobuf::lazy::Lazy<Identifier> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Identifier,
        };
        unsafe {
            instance.get(Identifier::new)
        }
    }
}

impl ::protobuf::Clear for Identifier {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_field_use();
        self.clear_field_type();
        self.clear_system();
        self.clear_value();
        self.clear_period();
        self.clear_assigner();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Identifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Identifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Meta {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub version_id: ::protobuf::SingularPtrField<Id>,
    pub last_updated: ::protobuf::SingularPtrField<Instant>,
    pub profile: ::protobuf::RepeatedField<Uri>,
    pub security: ::protobuf::RepeatedField<Coding>,
    pub tag: ::protobuf::RepeatedField<Coding>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Meta {
    pub fn new() -> Meta {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Id version_id = 3;

    pub fn clear_version_id(&mut self) {
        self.version_id.clear();
    }

    pub fn has_version_id(&self) -> bool {
        self.version_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_id(&mut self, v: Id) {
        self.version_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_id(&mut self) -> &mut Id {
        if self.version_id.is_none() {
            self.version_id.set_default();
        }
        self.version_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_id(&mut self) -> Id {
        self.version_id.take().unwrap_or_else(|| Id::new())
    }

    pub fn get_version_id(&self) -> &Id {
        self.version_id.as_ref().unwrap_or_else(|| Id::default_instance())
    }

    // .google.fhir.stu3.proto.Instant last_updated = 4;

    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: Instant) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut Instant {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> Instant {
        self.last_updated.take().unwrap_or_else(|| Instant::new())
    }

    pub fn get_last_updated(&self) -> &Instant {
        self.last_updated.as_ref().unwrap_or_else(|| Instant::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Uri profile = 5;

    pub fn clear_profile(&mut self) {
        self.profile.clear();
    }

    // Param is passed by value, moved
    pub fn set_profile(&mut self, v: ::protobuf::RepeatedField<Uri>) {
        self.profile = v;
    }

    // Mutable pointer to the field.
    pub fn mut_profile(&mut self) -> &mut ::protobuf::RepeatedField<Uri> {
        &mut self.profile
    }

    // Take field
    pub fn take_profile(&mut self) -> ::protobuf::RepeatedField<Uri> {
        ::std::mem::replace(&mut self.profile, ::protobuf::RepeatedField::new())
    }

    pub fn get_profile(&self) -> &[Uri] {
        &self.profile
    }

    // repeated .google.fhir.stu3.proto.Coding security = 6;

    pub fn clear_security(&mut self) {
        self.security.clear();
    }

    // Param is passed by value, moved
    pub fn set_security(&mut self, v: ::protobuf::RepeatedField<Coding>) {
        self.security = v;
    }

    // Mutable pointer to the field.
    pub fn mut_security(&mut self) -> &mut ::protobuf::RepeatedField<Coding> {
        &mut self.security
    }

    // Take field
    pub fn take_security(&mut self) -> ::protobuf::RepeatedField<Coding> {
        ::std::mem::replace(&mut self.security, ::protobuf::RepeatedField::new())
    }

    pub fn get_security(&self) -> &[Coding] {
        &self.security
    }

    // repeated .google.fhir.stu3.proto.Coding tag = 7;

    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::protobuf::RepeatedField<Coding>) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tag(&mut self) -> &mut ::protobuf::RepeatedField<Coding> {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::protobuf::RepeatedField<Coding> {
        ::std::mem::replace(&mut self.tag, ::protobuf::RepeatedField::new())
    }

    pub fn get_tag(&self) -> &[Coding] {
        &self.tag
    }
}

impl ::protobuf::Message for Meta {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.version_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.security {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tag {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.profile)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.security)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.version_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.profile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.security {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tag {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.version_id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.profile {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.security {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tag {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Meta {
        Meta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Meta| { &m.id },
                    |m: &mut Meta| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Meta| { &m.extension },
                    |m: &mut Meta| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Id>>(
                    "version_id",
                    |m: &Meta| { &m.version_id },
                    |m: &mut Meta| { &mut m.version_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instant>>(
                    "last_updated",
                    |m: &Meta| { &m.last_updated },
                    |m: &mut Meta| { &mut m.last_updated },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "profile",
                    |m: &Meta| { &m.profile },
                    |m: &mut Meta| { &mut m.profile },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coding>>(
                    "security",
                    |m: &Meta| { &m.security },
                    |m: &mut Meta| { &mut m.security },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coding>>(
                    "tag",
                    |m: &Meta| { &m.tag },
                    |m: &mut Meta| { &mut m.tag },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Meta>(
                    "Meta",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Meta {
        static mut instance: ::protobuf::lazy::Lazy<Meta> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Meta,
        };
        unsafe {
            instance.get(Meta::new)
        }
    }
}

impl ::protobuf::Clear for Meta {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_version_id();
        self.clear_last_updated();
        self.clear_profile();
        self.clear_security();
        self.clear_tag();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Meta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Meta {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Money {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub value: ::protobuf::SingularPtrField<Decimal>,
    pub comparator: ::protobuf::SingularPtrField<QuantityComparatorCode>,
    pub unit: ::protobuf::SingularPtrField<String>,
    pub system: ::protobuf::SingularPtrField<Uri>,
    pub code: ::protobuf::SingularPtrField<Code>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Money {
    pub fn new() -> Money {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Decimal value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Decimal) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Decimal {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Decimal {
        self.value.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_value(&self) -> &Decimal {
        self.value.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.QuantityComparatorCode comparator = 4;

    pub fn clear_comparator(&mut self) {
        self.comparator.clear();
    }

    pub fn has_comparator(&self) -> bool {
        self.comparator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comparator(&mut self, v: QuantityComparatorCode) {
        self.comparator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comparator(&mut self) -> &mut QuantityComparatorCode {
        if self.comparator.is_none() {
            self.comparator.set_default();
        }
        self.comparator.as_mut().unwrap()
    }

    // Take field
    pub fn take_comparator(&mut self) -> QuantityComparatorCode {
        self.comparator.take().unwrap_or_else(|| QuantityComparatorCode::new())
    }

    pub fn get_comparator(&self) -> &QuantityComparatorCode {
        self.comparator.as_ref().unwrap_or_else(|| QuantityComparatorCode::default_instance())
    }

    // .google.fhir.stu3.proto.String unit = 5;

    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: String) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut String {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> String {
        self.unit.take().unwrap_or_else(|| String::new())
    }

    pub fn get_unit(&self) -> &String {
        self.unit.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Uri system = 6;

    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: Uri) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut Uri {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> Uri {
        self.system.take().unwrap_or_else(|| Uri::new())
    }

    pub fn get_system(&self) -> &Uri {
        self.system.as_ref().unwrap_or_else(|| Uri::default_instance())
    }

    // .google.fhir.stu3.proto.Code code = 7;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Code) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut Code {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> Code {
        self.code.take().unwrap_or_else(|| Code::new())
    }

    pub fn get_code(&self) -> &Code {
        self.code.as_ref().unwrap_or_else(|| Code::default_instance())
    }
}

impl ::protobuf::Message for Money {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.comparator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.comparator)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Money {
        Money::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Money| { &m.id },
                    |m: &mut Money| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Money| { &m.extension },
                    |m: &mut Money| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "value",
                    |m: &Money| { &m.value },
                    |m: &mut Money| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuantityComparatorCode>>(
                    "comparator",
                    |m: &Money| { &m.comparator },
                    |m: &mut Money| { &mut m.comparator },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "unit",
                    |m: &Money| { &m.unit },
                    |m: &mut Money| { &mut m.unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "system",
                    |m: &Money| { &m.system },
                    |m: &mut Money| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Code>>(
                    "code",
                    |m: &Money| { &m.code },
                    |m: &mut Money| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Money>(
                    "Money",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Money {
        static mut instance: ::protobuf::lazy::Lazy<Money> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Money,
        };
        unsafe {
            instance.get(Money::new)
        }
    }
}

impl ::protobuf::Clear for Money {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_value();
        self.clear_comparator();
        self.clear_unit();
        self.clear_system();
        self.clear_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Money {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Money {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Period {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub start: ::protobuf::SingularPtrField<DateTime>,
    pub end: ::protobuf::SingularPtrField<DateTime>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Period {
    pub fn new() -> Period {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.DateTime start = 3;

    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: DateTime) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut DateTime {
        if self.start.is_none() {
            self.start.set_default();
        }
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> DateTime {
        self.start.take().unwrap_or_else(|| DateTime::new())
    }

    pub fn get_start(&self) -> &DateTime {
        self.start.as_ref().unwrap_or_else(|| DateTime::default_instance())
    }

    // .google.fhir.stu3.proto.DateTime end = 4;

    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: DateTime) {
        self.end = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut DateTime {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> DateTime {
        self.end.take().unwrap_or_else(|| DateTime::new())
    }

    pub fn get_end(&self) -> &DateTime {
        self.end.as_ref().unwrap_or_else(|| DateTime::default_instance())
    }
}

impl ::protobuf::Message for Period {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.start.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Period {
        Period::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Period| { &m.id },
                    |m: &mut Period| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Period| { &m.extension },
                    |m: &mut Period| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DateTime>>(
                    "start",
                    |m: &Period| { &m.start },
                    |m: &mut Period| { &mut m.start },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DateTime>>(
                    "end",
                    |m: &Period| { &m.end },
                    |m: &mut Period| { &mut m.end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Period>(
                    "Period",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Period {
        static mut instance: ::protobuf::lazy::Lazy<Period> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Period,
        };
        unsafe {
            instance.get(Period::new)
        }
    }
}

impl ::protobuf::Clear for Period {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_start();
        self.clear_end();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Period {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Period {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Quantity {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub value: ::protobuf::SingularPtrField<Decimal>,
    pub comparator: ::protobuf::SingularPtrField<QuantityComparatorCode>,
    pub unit: ::protobuf::SingularPtrField<String>,
    pub system: ::protobuf::SingularPtrField<Uri>,
    pub code: ::protobuf::SingularPtrField<Code>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Quantity {
    pub fn new() -> Quantity {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Decimal value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Decimal) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Decimal {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Decimal {
        self.value.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_value(&self) -> &Decimal {
        self.value.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.QuantityComparatorCode comparator = 4;

    pub fn clear_comparator(&mut self) {
        self.comparator.clear();
    }

    pub fn has_comparator(&self) -> bool {
        self.comparator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comparator(&mut self, v: QuantityComparatorCode) {
        self.comparator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comparator(&mut self) -> &mut QuantityComparatorCode {
        if self.comparator.is_none() {
            self.comparator.set_default();
        }
        self.comparator.as_mut().unwrap()
    }

    // Take field
    pub fn take_comparator(&mut self) -> QuantityComparatorCode {
        self.comparator.take().unwrap_or_else(|| QuantityComparatorCode::new())
    }

    pub fn get_comparator(&self) -> &QuantityComparatorCode {
        self.comparator.as_ref().unwrap_or_else(|| QuantityComparatorCode::default_instance())
    }

    // .google.fhir.stu3.proto.String unit = 5;

    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: String) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut String {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> String {
        self.unit.take().unwrap_or_else(|| String::new())
    }

    pub fn get_unit(&self) -> &String {
        self.unit.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Uri system = 6;

    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: Uri) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut Uri {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> Uri {
        self.system.take().unwrap_or_else(|| Uri::new())
    }

    pub fn get_system(&self) -> &Uri {
        self.system.as_ref().unwrap_or_else(|| Uri::default_instance())
    }

    // .google.fhir.stu3.proto.Code code = 7;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Code) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut Code {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> Code {
        self.code.take().unwrap_or_else(|| Code::new())
    }

    pub fn get_code(&self) -> &Code {
        self.code.as_ref().unwrap_or_else(|| Code::default_instance())
    }
}

impl ::protobuf::Message for Quantity {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.comparator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.comparator)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.comparator.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Quantity {
        Quantity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Quantity| { &m.id },
                    |m: &mut Quantity| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Quantity| { &m.extension },
                    |m: &mut Quantity| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "value",
                    |m: &Quantity| { &m.value },
                    |m: &mut Quantity| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuantityComparatorCode>>(
                    "comparator",
                    |m: &Quantity| { &m.comparator },
                    |m: &mut Quantity| { &mut m.comparator },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "unit",
                    |m: &Quantity| { &m.unit },
                    |m: &mut Quantity| { &mut m.unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "system",
                    |m: &Quantity| { &m.system },
                    |m: &mut Quantity| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Code>>(
                    "code",
                    |m: &Quantity| { &m.code },
                    |m: &mut Quantity| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Quantity>(
                    "Quantity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Quantity {
        static mut instance: ::protobuf::lazy::Lazy<Quantity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Quantity,
        };
        unsafe {
            instance.get(Quantity::new)
        }
    }
}

impl ::protobuf::Clear for Quantity {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_value();
        self.clear_comparator();
        self.clear_unit();
        self.clear_system();
        self.clear_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Quantity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Quantity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Range {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub low: ::protobuf::SingularPtrField<SimpleQuantity>,
    pub high: ::protobuf::SingularPtrField<SimpleQuantity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Range {
    pub fn new() -> Range {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.SimpleQuantity low = 3;

    pub fn clear_low(&mut self) {
        self.low.clear();
    }

    pub fn has_low(&self) -> bool {
        self.low.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low(&mut self, v: SimpleQuantity) {
        self.low = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_low(&mut self) -> &mut SimpleQuantity {
        if self.low.is_none() {
            self.low.set_default();
        }
        self.low.as_mut().unwrap()
    }

    // Take field
    pub fn take_low(&mut self) -> SimpleQuantity {
        self.low.take().unwrap_or_else(|| SimpleQuantity::new())
    }

    pub fn get_low(&self) -> &SimpleQuantity {
        self.low.as_ref().unwrap_or_else(|| SimpleQuantity::default_instance())
    }

    // .google.fhir.stu3.proto.SimpleQuantity high = 4;

    pub fn clear_high(&mut self) {
        self.high.clear();
    }

    pub fn has_high(&self) -> bool {
        self.high.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high(&mut self, v: SimpleQuantity) {
        self.high = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_high(&mut self) -> &mut SimpleQuantity {
        if self.high.is_none() {
            self.high.set_default();
        }
        self.high.as_mut().unwrap()
    }

    // Take field
    pub fn take_high(&mut self) -> SimpleQuantity {
        self.high.take().unwrap_or_else(|| SimpleQuantity::new())
    }

    pub fn get_high(&self) -> &SimpleQuantity {
        self.high.as_ref().unwrap_or_else(|| SimpleQuantity::default_instance())
    }
}

impl ::protobuf::Message for Range {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.low {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.high {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.low)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.high)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.low.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.high.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.low.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.high.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Range {
        Range::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Range| { &m.id },
                    |m: &mut Range| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Range| { &m.extension },
                    |m: &mut Range| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SimpleQuantity>>(
                    "low",
                    |m: &Range| { &m.low },
                    |m: &mut Range| { &mut m.low },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SimpleQuantity>>(
                    "high",
                    |m: &Range| { &m.high },
                    |m: &mut Range| { &mut m.high },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Range>(
                    "Range",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Range {
        static mut instance: ::protobuf::lazy::Lazy<Range> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Range,
        };
        unsafe {
            instance.get(Range::new)
        }
    }
}

impl ::protobuf::Clear for Range {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_low();
        self.clear_high();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Range {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Ratio {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub numerator: ::protobuf::SingularPtrField<Quantity>,
    pub denominator: ::protobuf::SingularPtrField<Quantity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Ratio {
    pub fn new() -> Ratio {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Quantity numerator = 3;

    pub fn clear_numerator(&mut self) {
        self.numerator.clear();
    }

    pub fn has_numerator(&self) -> bool {
        self.numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numerator(&mut self, v: Quantity) {
        self.numerator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_numerator(&mut self) -> &mut Quantity {
        if self.numerator.is_none() {
            self.numerator.set_default();
        }
        self.numerator.as_mut().unwrap()
    }

    // Take field
    pub fn take_numerator(&mut self) -> Quantity {
        self.numerator.take().unwrap_or_else(|| Quantity::new())
    }

    pub fn get_numerator(&self) -> &Quantity {
        self.numerator.as_ref().unwrap_or_else(|| Quantity::default_instance())
    }

    // .google.fhir.stu3.proto.Quantity denominator = 4;

    pub fn clear_denominator(&mut self) {
        self.denominator.clear();
    }

    pub fn has_denominator(&self) -> bool {
        self.denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denominator(&mut self, v: Quantity) {
        self.denominator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_denominator(&mut self) -> &mut Quantity {
        if self.denominator.is_none() {
            self.denominator.set_default();
        }
        self.denominator.as_mut().unwrap()
    }

    // Take field
    pub fn take_denominator(&mut self) -> Quantity {
        self.denominator.take().unwrap_or_else(|| Quantity::new())
    }

    pub fn get_denominator(&self) -> &Quantity {
        self.denominator.as_ref().unwrap_or_else(|| Quantity::default_instance())
    }
}

impl ::protobuf::Message for Ratio {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.numerator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.denominator {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.numerator)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.denominator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.numerator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.denominator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.numerator.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.denominator.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Ratio {
        Ratio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Ratio| { &m.id },
                    |m: &mut Ratio| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Ratio| { &m.extension },
                    |m: &mut Ratio| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quantity>>(
                    "numerator",
                    |m: &Ratio| { &m.numerator },
                    |m: &mut Ratio| { &mut m.numerator },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quantity>>(
                    "denominator",
                    |m: &Ratio| { &m.denominator },
                    |m: &mut Ratio| { &mut m.denominator },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Ratio>(
                    "Ratio",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Ratio {
        static mut instance: ::protobuf::lazy::Lazy<Ratio> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ratio,
        };
        unsafe {
            instance.get(Ratio::new)
        }
    }
}

impl ::protobuf::Clear for Ratio {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_numerator();
        self.clear_denominator();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Ratio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ratio {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SampledData {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub origin: ::protobuf::SingularPtrField<SimpleQuantity>,
    pub period: ::protobuf::SingularPtrField<Decimal>,
    pub factor: ::protobuf::SingularPtrField<Decimal>,
    pub lower_limit: ::protobuf::SingularPtrField<Decimal>,
    pub upper_limit: ::protobuf::SingularPtrField<Decimal>,
    pub dimensions: ::protobuf::SingularPtrField<PositiveInt>,
    pub data: ::protobuf::SingularPtrField<String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SampledData {
    pub fn new() -> SampledData {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.SimpleQuantity origin = 3;

    pub fn clear_origin(&mut self) {
        self.origin.clear();
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: SimpleQuantity) {
        self.origin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin(&mut self) -> &mut SimpleQuantity {
        if self.origin.is_none() {
            self.origin.set_default();
        }
        self.origin.as_mut().unwrap()
    }

    // Take field
    pub fn take_origin(&mut self) -> SimpleQuantity {
        self.origin.take().unwrap_or_else(|| SimpleQuantity::new())
    }

    pub fn get_origin(&self) -> &SimpleQuantity {
        self.origin.as_ref().unwrap_or_else(|| SimpleQuantity::default_instance())
    }

    // .google.fhir.stu3.proto.Decimal period = 4;

    pub fn clear_period(&mut self) {
        self.period.clear();
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: Decimal) {
        self.period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_period(&mut self) -> &mut Decimal {
        if self.period.is_none() {
            self.period.set_default();
        }
        self.period.as_mut().unwrap()
    }

    // Take field
    pub fn take_period(&mut self) -> Decimal {
        self.period.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_period(&self) -> &Decimal {
        self.period.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.Decimal factor = 5;

    pub fn clear_factor(&mut self) {
        self.factor.clear();
    }

    pub fn has_factor(&self) -> bool {
        self.factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_factor(&mut self, v: Decimal) {
        self.factor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_factor(&mut self) -> &mut Decimal {
        if self.factor.is_none() {
            self.factor.set_default();
        }
        self.factor.as_mut().unwrap()
    }

    // Take field
    pub fn take_factor(&mut self) -> Decimal {
        self.factor.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_factor(&self) -> &Decimal {
        self.factor.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.Decimal lower_limit = 6;

    pub fn clear_lower_limit(&mut self) {
        self.lower_limit.clear();
    }

    pub fn has_lower_limit(&self) -> bool {
        self.lower_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lower_limit(&mut self, v: Decimal) {
        self.lower_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lower_limit(&mut self) -> &mut Decimal {
        if self.lower_limit.is_none() {
            self.lower_limit.set_default();
        }
        self.lower_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_lower_limit(&mut self) -> Decimal {
        self.lower_limit.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_lower_limit(&self) -> &Decimal {
        self.lower_limit.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.Decimal upper_limit = 7;

    pub fn clear_upper_limit(&mut self) {
        self.upper_limit.clear();
    }

    pub fn has_upper_limit(&self) -> bool {
        self.upper_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upper_limit(&mut self, v: Decimal) {
        self.upper_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upper_limit(&mut self) -> &mut Decimal {
        if self.upper_limit.is_none() {
            self.upper_limit.set_default();
        }
        self.upper_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_upper_limit(&mut self) -> Decimal {
        self.upper_limit.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_upper_limit(&self) -> &Decimal {
        self.upper_limit.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.PositiveInt dimensions = 8;

    pub fn clear_dimensions(&mut self) {
        self.dimensions.clear();
    }

    pub fn has_dimensions(&self) -> bool {
        self.dimensions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dimensions(&mut self, v: PositiveInt) {
        self.dimensions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dimensions(&mut self) -> &mut PositiveInt {
        if self.dimensions.is_none() {
            self.dimensions.set_default();
        }
        self.dimensions.as_mut().unwrap()
    }

    // Take field
    pub fn take_dimensions(&mut self) -> PositiveInt {
        self.dimensions.take().unwrap_or_else(|| PositiveInt::new())
    }

    pub fn get_dimensions(&self) -> &PositiveInt {
        self.dimensions.as_ref().unwrap_or_else(|| PositiveInt::default_instance())
    }

    // .google.fhir.stu3.proto.String data = 9;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: String) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut String {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> String {
        self.data.take().unwrap_or_else(|| String::new())
    }

    pub fn get_data(&self) -> &String {
        self.data.as_ref().unwrap_or_else(|| String::default_instance())
    }
}

impl ::protobuf::Message for SampledData {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.origin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.period {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.factor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lower_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.upper_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dimensions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.origin)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.period)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.factor)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lower_limit)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.upper_limit)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dimensions)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.factor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lower_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.upper_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dimensions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.origin.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.period.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.factor.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lower_limit.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.upper_limit.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dimensions.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SampledData {
        SampledData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &SampledData| { &m.id },
                    |m: &mut SampledData| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &SampledData| { &m.extension },
                    |m: &mut SampledData| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SimpleQuantity>>(
                    "origin",
                    |m: &SampledData| { &m.origin },
                    |m: &mut SampledData| { &mut m.origin },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "period",
                    |m: &SampledData| { &m.period },
                    |m: &mut SampledData| { &mut m.period },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "factor",
                    |m: &SampledData| { &m.factor },
                    |m: &mut SampledData| { &mut m.factor },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "lower_limit",
                    |m: &SampledData| { &m.lower_limit },
                    |m: &mut SampledData| { &mut m.lower_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "upper_limit",
                    |m: &SampledData| { &m.upper_limit },
                    |m: &mut SampledData| { &mut m.upper_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PositiveInt>>(
                    "dimensions",
                    |m: &SampledData| { &m.dimensions },
                    |m: &mut SampledData| { &mut m.dimensions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "data",
                    |m: &SampledData| { &m.data },
                    |m: &mut SampledData| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SampledData>(
                    "SampledData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SampledData {
        static mut instance: ::protobuf::lazy::Lazy<SampledData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SampledData,
        };
        unsafe {
            instance.get(SampledData::new)
        }
    }
}

impl ::protobuf::Clear for SampledData {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_origin();
        self.clear_period();
        self.clear_factor();
        self.clear_lower_limit();
        self.clear_upper_limit();
        self.clear_dimensions();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SampledData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SampledData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Signature {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub field_type: ::protobuf::RepeatedField<Coding>,
    pub when: ::protobuf::SingularPtrField<Instant>,
    pub who: ::protobuf::SingularPtrField<Signature_Who>,
    pub on_behalf_of: ::protobuf::SingularPtrField<Signature_OnBehalfOf>,
    pub content_type: ::protobuf::SingularPtrField<MimeTypeCode>,
    pub blob: ::protobuf::SingularPtrField<Base64Binary>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Signature {
    pub fn new() -> Signature {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // repeated .google.fhir.stu3.proto.Coding type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::protobuf::RepeatedField<Coding>) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field_type(&mut self) -> &mut ::protobuf::RepeatedField<Coding> {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::protobuf::RepeatedField<Coding> {
        ::std::mem::replace(&mut self.field_type, ::protobuf::RepeatedField::new())
    }

    pub fn get_field_type(&self) -> &[Coding] {
        &self.field_type
    }

    // .google.fhir.stu3.proto.Instant when = 4;

    pub fn clear_when(&mut self) {
        self.when.clear();
    }

    pub fn has_when(&self) -> bool {
        self.when.is_some()
    }

    // Param is passed by value, moved
    pub fn set_when(&mut self, v: Instant) {
        self.when = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_when(&mut self) -> &mut Instant {
        if self.when.is_none() {
            self.when.set_default();
        }
        self.when.as_mut().unwrap()
    }

    // Take field
    pub fn take_when(&mut self) -> Instant {
        self.when.take().unwrap_or_else(|| Instant::new())
    }

    pub fn get_when(&self) -> &Instant {
        self.when.as_ref().unwrap_or_else(|| Instant::default_instance())
    }

    // .google.fhir.stu3.proto.Signature.Who who = 5;

    pub fn clear_who(&mut self) {
        self.who.clear();
    }

    pub fn has_who(&self) -> bool {
        self.who.is_some()
    }

    // Param is passed by value, moved
    pub fn set_who(&mut self, v: Signature_Who) {
        self.who = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_who(&mut self) -> &mut Signature_Who {
        if self.who.is_none() {
            self.who.set_default();
        }
        self.who.as_mut().unwrap()
    }

    // Take field
    pub fn take_who(&mut self) -> Signature_Who {
        self.who.take().unwrap_or_else(|| Signature_Who::new())
    }

    pub fn get_who(&self) -> &Signature_Who {
        self.who.as_ref().unwrap_or_else(|| Signature_Who::default_instance())
    }

    // .google.fhir.stu3.proto.Signature.OnBehalfOf on_behalf_of = 6;

    pub fn clear_on_behalf_of(&mut self) {
        self.on_behalf_of.clear();
    }

    pub fn has_on_behalf_of(&self) -> bool {
        self.on_behalf_of.is_some()
    }

    // Param is passed by value, moved
    pub fn set_on_behalf_of(&mut self, v: Signature_OnBehalfOf) {
        self.on_behalf_of = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_on_behalf_of(&mut self) -> &mut Signature_OnBehalfOf {
        if self.on_behalf_of.is_none() {
            self.on_behalf_of.set_default();
        }
        self.on_behalf_of.as_mut().unwrap()
    }

    // Take field
    pub fn take_on_behalf_of(&mut self) -> Signature_OnBehalfOf {
        self.on_behalf_of.take().unwrap_or_else(|| Signature_OnBehalfOf::new())
    }

    pub fn get_on_behalf_of(&self) -> &Signature_OnBehalfOf {
        self.on_behalf_of.as_ref().unwrap_or_else(|| Signature_OnBehalfOf::default_instance())
    }

    // .google.fhir.stu3.proto.MimeTypeCode content_type = 7;

    pub fn clear_content_type(&mut self) {
        self.content_type.clear();
    }

    pub fn has_content_type(&self) -> bool {
        self.content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: MimeTypeCode) {
        self.content_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_type(&mut self) -> &mut MimeTypeCode {
        if self.content_type.is_none() {
            self.content_type.set_default();
        }
        self.content_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_content_type(&mut self) -> MimeTypeCode {
        self.content_type.take().unwrap_or_else(|| MimeTypeCode::new())
    }

    pub fn get_content_type(&self) -> &MimeTypeCode {
        self.content_type.as_ref().unwrap_or_else(|| MimeTypeCode::default_instance())
    }

    // .google.fhir.stu3.proto.Base64Binary blob = 8;

    pub fn clear_blob(&mut self) {
        self.blob.clear();
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: Base64Binary) {
        self.blob = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut Base64Binary {
        if self.blob.is_none() {
            self.blob.set_default();
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> Base64Binary {
        self.blob.take().unwrap_or_else(|| Base64Binary::new())
    }

    pub fn get_blob(&self) -> &Base64Binary {
        self.blob.as_ref().unwrap_or_else(|| Base64Binary::default_instance())
    }
}

impl ::protobuf::Message for Signature {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.when {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.who {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.on_behalf_of {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.content_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blob {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.when)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.who)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.on_behalf_of)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.content_type)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.field_type {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.when.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.who.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.on_behalf_of.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.content_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.blob.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.field_type {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.when.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.who.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.on_behalf_of.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.content_type.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.blob.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Signature {
        Signature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Signature| { &m.id },
                    |m: &mut Signature| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Signature| { &m.extension },
                    |m: &mut Signature| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Coding>>(
                    "type",
                    |m: &Signature| { &m.field_type },
                    |m: &mut Signature| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Instant>>(
                    "when",
                    |m: &Signature| { &m.when },
                    |m: &mut Signature| { &mut m.when },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Signature_Who>>(
                    "who",
                    |m: &Signature| { &m.who },
                    |m: &mut Signature| { &mut m.who },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Signature_OnBehalfOf>>(
                    "on_behalf_of",
                    |m: &Signature| { &m.on_behalf_of },
                    |m: &mut Signature| { &mut m.on_behalf_of },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MimeTypeCode>>(
                    "content_type",
                    |m: &Signature| { &m.content_type },
                    |m: &mut Signature| { &mut m.content_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Base64Binary>>(
                    "blob",
                    |m: &Signature| { &m.blob },
                    |m: &mut Signature| { &mut m.blob },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Signature>(
                    "Signature",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Signature {
        static mut instance: ::protobuf::lazy::Lazy<Signature> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Signature,
        };
        unsafe {
            instance.get(Signature::new)
        }
    }
}

impl ::protobuf::Clear for Signature {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_field_type();
        self.clear_when();
        self.clear_who();
        self.clear_on_behalf_of();
        self.clear_content_type();
        self.clear_blob();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Signature {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Signature_Who {
    // message oneof groups
    pub who: ::std::option::Option<Signature_Who_oneof_who>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Signature_Who_oneof_who {
    uri(Uri),
    reference(Reference),
}

impl Signature_Who {
    pub fn new() -> Signature_Who {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.Uri uri = 1;

    pub fn clear_uri(&mut self) {
        self.who = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        match self.who {
            ::std::option::Option::Some(Signature_Who_oneof_who::uri(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: Uri) {
        self.who = ::std::option::Option::Some(Signature_Who_oneof_who::uri(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uri(&mut self) -> &mut Uri {
        if let ::std::option::Option::Some(Signature_Who_oneof_who::uri(_)) = self.who {
        } else {
            self.who = ::std::option::Option::Some(Signature_Who_oneof_who::uri(Uri::new()));
        }
        match self.who {
            ::std::option::Option::Some(Signature_Who_oneof_who::uri(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uri(&mut self) -> Uri {
        if self.has_uri() {
            match self.who.take() {
                ::std::option::Option::Some(Signature_Who_oneof_who::uri(v)) => v,
                _ => panic!(),
            }
        } else {
            Uri::new()
        }
    }

    pub fn get_uri(&self) -> &Uri {
        match self.who {
            ::std::option::Option::Some(Signature_Who_oneof_who::uri(ref v)) => v,
            _ => Uri::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Reference reference = 2;

    pub fn clear_reference(&mut self) {
        self.who = ::std::option::Option::None;
    }

    pub fn has_reference(&self) -> bool {
        match self.who {
            ::std::option::Option::Some(Signature_Who_oneof_who::reference(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reference(&mut self, v: Reference) {
        self.who = ::std::option::Option::Some(Signature_Who_oneof_who::reference(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reference(&mut self) -> &mut Reference {
        if let ::std::option::Option::Some(Signature_Who_oneof_who::reference(_)) = self.who {
        } else {
            self.who = ::std::option::Option::Some(Signature_Who_oneof_who::reference(Reference::new()));
        }
        match self.who {
            ::std::option::Option::Some(Signature_Who_oneof_who::reference(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reference(&mut self) -> Reference {
        if self.has_reference() {
            match self.who.take() {
                ::std::option::Option::Some(Signature_Who_oneof_who::reference(v)) => v,
                _ => panic!(),
            }
        } else {
            Reference::new()
        }
    }

    pub fn get_reference(&self) -> &Reference {
        match self.who {
            ::std::option::Option::Some(Signature_Who_oneof_who::reference(ref v)) => v,
            _ => Reference::default_instance(),
        }
    }
}

impl ::protobuf::Message for Signature_Who {
    fn is_initialized(&self) -> bool {
        if let Some(Signature_Who_oneof_who::uri(ref v)) = self.who {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Signature_Who_oneof_who::reference(ref v)) = self.who {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.who = ::std::option::Option::Some(Signature_Who_oneof_who::uri(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.who = ::std::option::Option::Some(Signature_Who_oneof_who::reference(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.who {
            match v {
                &Signature_Who_oneof_who::uri(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Signature_Who_oneof_who::reference(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.who {
            match v {
                &Signature_Who_oneof_who::uri(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Signature_Who_oneof_who::reference(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Signature_Who {
        Signature_Who::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Uri>(
                    "uri",
                    Signature_Who::has_uri,
                    Signature_Who::get_uri,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Reference>(
                    "reference",
                    Signature_Who::has_reference,
                    Signature_Who::get_reference,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Signature_Who>(
                    "Signature_Who",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Signature_Who {
        static mut instance: ::protobuf::lazy::Lazy<Signature_Who> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Signature_Who,
        };
        unsafe {
            instance.get(Signature_Who::new)
        }
    }
}

impl ::protobuf::Clear for Signature_Who {
    fn clear(&mut self) {
        self.clear_uri();
        self.clear_reference();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Signature_Who {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Signature_Who {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Signature_OnBehalfOf {
    // message oneof groups
    pub on_behalf_of: ::std::option::Option<Signature_OnBehalfOf_oneof_on_behalf_of>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Signature_OnBehalfOf_oneof_on_behalf_of {
    uri(Uri),
    reference(Reference),
}

impl Signature_OnBehalfOf {
    pub fn new() -> Signature_OnBehalfOf {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.Uri uri = 1;

    pub fn clear_uri(&mut self) {
        self.on_behalf_of = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        match self.on_behalf_of {
            ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::uri(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: Uri) {
        self.on_behalf_of = ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::uri(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uri(&mut self) -> &mut Uri {
        if let ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::uri(_)) = self.on_behalf_of {
        } else {
            self.on_behalf_of = ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::uri(Uri::new()));
        }
        match self.on_behalf_of {
            ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::uri(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uri(&mut self) -> Uri {
        if self.has_uri() {
            match self.on_behalf_of.take() {
                ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::uri(v)) => v,
                _ => panic!(),
            }
        } else {
            Uri::new()
        }
    }

    pub fn get_uri(&self) -> &Uri {
        match self.on_behalf_of {
            ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::uri(ref v)) => v,
            _ => Uri::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Reference reference = 2;

    pub fn clear_reference(&mut self) {
        self.on_behalf_of = ::std::option::Option::None;
    }

    pub fn has_reference(&self) -> bool {
        match self.on_behalf_of {
            ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::reference(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reference(&mut self, v: Reference) {
        self.on_behalf_of = ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::reference(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reference(&mut self) -> &mut Reference {
        if let ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::reference(_)) = self.on_behalf_of {
        } else {
            self.on_behalf_of = ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::reference(Reference::new()));
        }
        match self.on_behalf_of {
            ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::reference(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reference(&mut self) -> Reference {
        if self.has_reference() {
            match self.on_behalf_of.take() {
                ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::reference(v)) => v,
                _ => panic!(),
            }
        } else {
            Reference::new()
        }
    }

    pub fn get_reference(&self) -> &Reference {
        match self.on_behalf_of {
            ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::reference(ref v)) => v,
            _ => Reference::default_instance(),
        }
    }
}

impl ::protobuf::Message for Signature_OnBehalfOf {
    fn is_initialized(&self) -> bool {
        if let Some(Signature_OnBehalfOf_oneof_on_behalf_of::uri(ref v)) = self.on_behalf_of {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Signature_OnBehalfOf_oneof_on_behalf_of::reference(ref v)) = self.on_behalf_of {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.on_behalf_of = ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::uri(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.on_behalf_of = ::std::option::Option::Some(Signature_OnBehalfOf_oneof_on_behalf_of::reference(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.on_behalf_of {
            match v {
                &Signature_OnBehalfOf_oneof_on_behalf_of::uri(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Signature_OnBehalfOf_oneof_on_behalf_of::reference(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.on_behalf_of {
            match v {
                &Signature_OnBehalfOf_oneof_on_behalf_of::uri(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Signature_OnBehalfOf_oneof_on_behalf_of::reference(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Signature_OnBehalfOf {
        Signature_OnBehalfOf::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Uri>(
                    "uri",
                    Signature_OnBehalfOf::has_uri,
                    Signature_OnBehalfOf::get_uri,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Reference>(
                    "reference",
                    Signature_OnBehalfOf::has_reference,
                    Signature_OnBehalfOf::get_reference,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Signature_OnBehalfOf>(
                    "Signature_OnBehalfOf",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Signature_OnBehalfOf {
        static mut instance: ::protobuf::lazy::Lazy<Signature_OnBehalfOf> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Signature_OnBehalfOf,
        };
        unsafe {
            instance.get(Signature_OnBehalfOf::new)
        }
    }
}

impl ::protobuf::Clear for Signature_OnBehalfOf {
    fn clear(&mut self) {
        self.clear_uri();
        self.clear_reference();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Signature_OnBehalfOf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Signature_OnBehalfOf {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SimpleQuantity {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub value: ::protobuf::SingularPtrField<Decimal>,
    pub unit: ::protobuf::SingularPtrField<String>,
    pub system: ::protobuf::SingularPtrField<Uri>,
    pub code: ::protobuf::SingularPtrField<Code>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SimpleQuantity {
    pub fn new() -> SimpleQuantity {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Decimal value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Decimal) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Decimal {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Decimal {
        self.value.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_value(&self) -> &Decimal {
        self.value.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.String unit = 5;

    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    pub fn has_unit(&self) -> bool {
        self.unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: String) {
        self.unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut String {
        if self.unit.is_none() {
            self.unit.set_default();
        }
        self.unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_unit(&mut self) -> String {
        self.unit.take().unwrap_or_else(|| String::new())
    }

    pub fn get_unit(&self) -> &String {
        self.unit.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Uri system = 6;

    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: Uri) {
        self.system = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut Uri {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> Uri {
        self.system.take().unwrap_or_else(|| Uri::new())
    }

    pub fn get_system(&self) -> &Uri {
        self.system.as_ref().unwrap_or_else(|| Uri::default_instance())
    }

    // .google.fhir.stu3.proto.Code code = 7;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Code) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut Code {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> Code {
        self.code.take().unwrap_or_else(|| Code::new())
    }

    pub fn get_code(&self) -> &Code {
        self.code.as_ref().unwrap_or_else(|| Code::default_instance())
    }
}

impl ::protobuf::Message for SimpleQuantity {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.system {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unit)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.system)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.system.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.system.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SimpleQuantity {
        SimpleQuantity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &SimpleQuantity| { &m.id },
                    |m: &mut SimpleQuantity| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &SimpleQuantity| { &m.extension },
                    |m: &mut SimpleQuantity| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "value",
                    |m: &SimpleQuantity| { &m.value },
                    |m: &mut SimpleQuantity| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "unit",
                    |m: &SimpleQuantity| { &m.unit },
                    |m: &mut SimpleQuantity| { &mut m.unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "system",
                    |m: &SimpleQuantity| { &m.system },
                    |m: &mut SimpleQuantity| { &mut m.system },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Code>>(
                    "code",
                    |m: &SimpleQuantity| { &m.code },
                    |m: &mut SimpleQuantity| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SimpleQuantity>(
                    "SimpleQuantity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SimpleQuantity {
        static mut instance: ::protobuf::lazy::Lazy<SimpleQuantity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SimpleQuantity,
        };
        unsafe {
            instance.get(SimpleQuantity::new)
        }
    }
}

impl ::protobuf::Clear for SimpleQuantity {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_value();
        self.clear_unit();
        self.clear_system();
        self.clear_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SimpleQuantity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SimpleQuantity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Timing {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub event: ::protobuf::RepeatedField<DateTime>,
    pub repeat: ::protobuf::SingularPtrField<Timing_Repeat>,
    pub code: ::protobuf::SingularPtrField<CodeableConcept>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Timing {
    pub fn new() -> Timing {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // repeated .google.fhir.stu3.proto.DateTime event = 3;

    pub fn clear_event(&mut self) {
        self.event.clear();
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: ::protobuf::RepeatedField<DateTime>) {
        self.event = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event(&mut self) -> &mut ::protobuf::RepeatedField<DateTime> {
        &mut self.event
    }

    // Take field
    pub fn take_event(&mut self) -> ::protobuf::RepeatedField<DateTime> {
        ::std::mem::replace(&mut self.event, ::protobuf::RepeatedField::new())
    }

    pub fn get_event(&self) -> &[DateTime] {
        &self.event
    }

    // .google.fhir.stu3.proto.Timing.Repeat repeat = 4;

    pub fn clear_repeat(&mut self) {
        self.repeat.clear();
    }

    pub fn has_repeat(&self) -> bool {
        self.repeat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeat(&mut self, v: Timing_Repeat) {
        self.repeat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_repeat(&mut self) -> &mut Timing_Repeat {
        if self.repeat.is_none() {
            self.repeat.set_default();
        }
        self.repeat.as_mut().unwrap()
    }

    // Take field
    pub fn take_repeat(&mut self) -> Timing_Repeat {
        self.repeat.take().unwrap_or_else(|| Timing_Repeat::new())
    }

    pub fn get_repeat(&self) -> &Timing_Repeat {
        self.repeat.as_ref().unwrap_or_else(|| Timing_Repeat::default_instance())
    }

    // .google.fhir.stu3.proto.CodeableConcept code = 5;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: CodeableConcept) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut CodeableConcept {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> CodeableConcept {
        self.code.take().unwrap_or_else(|| CodeableConcept::new())
    }

    pub fn get_code(&self) -> &CodeableConcept {
        self.code.as_ref().unwrap_or_else(|| CodeableConcept::default_instance())
    }
}

impl ::protobuf::Message for Timing {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.repeat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.event)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.repeat)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.event {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.repeat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.event {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.repeat.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Timing {
        Timing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Timing| { &m.id },
                    |m: &mut Timing| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Timing| { &m.extension },
                    |m: &mut Timing| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DateTime>>(
                    "event",
                    |m: &Timing| { &m.event },
                    |m: &mut Timing| { &mut m.event },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timing_Repeat>>(
                    "repeat",
                    |m: &Timing| { &m.repeat },
                    |m: &mut Timing| { &mut m.repeat },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodeableConcept>>(
                    "code",
                    |m: &Timing| { &m.code },
                    |m: &mut Timing| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Timing>(
                    "Timing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Timing {
        static mut instance: ::protobuf::lazy::Lazy<Timing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Timing,
        };
        unsafe {
            instance.get(Timing::new)
        }
    }
}

impl ::protobuf::Clear for Timing {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_event();
        self.clear_repeat();
        self.clear_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Timing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Timing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Timing_Repeat {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub bounds: ::protobuf::SingularPtrField<Timing_Repeat_Bounds>,
    pub count: ::protobuf::SingularPtrField<Integer>,
    pub count_max: ::protobuf::SingularPtrField<Integer>,
    pub duration: ::protobuf::SingularPtrField<Decimal>,
    pub duration_max: ::protobuf::SingularPtrField<Decimal>,
    pub duration_unit: ::protobuf::SingularPtrField<UnitsOfTimeCode>,
    pub frequency: ::protobuf::SingularPtrField<Integer>,
    pub frequency_max: ::protobuf::SingularPtrField<Integer>,
    pub period: ::protobuf::SingularPtrField<Decimal>,
    pub period_max: ::protobuf::SingularPtrField<Decimal>,
    pub period_unit: ::protobuf::SingularPtrField<UnitsOfTimeCode>,
    pub day_of_week: ::protobuf::RepeatedField<DaysOfWeekCode>,
    pub time_of_day: ::protobuf::RepeatedField<Time>,
    pub when: ::protobuf::RepeatedField<EventTimingCode>,
    pub offset: ::protobuf::SingularPtrField<UnsignedInt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Timing_Repeat {
    pub fn new() -> Timing_Repeat {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.Timing.Repeat.Bounds bounds = 3;

    pub fn clear_bounds(&mut self) {
        self.bounds.clear();
    }

    pub fn has_bounds(&self) -> bool {
        self.bounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounds(&mut self, v: Timing_Repeat_Bounds) {
        self.bounds = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bounds(&mut self) -> &mut Timing_Repeat_Bounds {
        if self.bounds.is_none() {
            self.bounds.set_default();
        }
        self.bounds.as_mut().unwrap()
    }

    // Take field
    pub fn take_bounds(&mut self) -> Timing_Repeat_Bounds {
        self.bounds.take().unwrap_or_else(|| Timing_Repeat_Bounds::new())
    }

    pub fn get_bounds(&self) -> &Timing_Repeat_Bounds {
        self.bounds.as_ref().unwrap_or_else(|| Timing_Repeat_Bounds::default_instance())
    }

    // .google.fhir.stu3.proto.Integer count = 4;

    pub fn clear_count(&mut self) {
        self.count.clear();
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: Integer) {
        self.count = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_count(&mut self) -> &mut Integer {
        if self.count.is_none() {
            self.count.set_default();
        }
        self.count.as_mut().unwrap()
    }

    // Take field
    pub fn take_count(&mut self) -> Integer {
        self.count.take().unwrap_or_else(|| Integer::new())
    }

    pub fn get_count(&self) -> &Integer {
        self.count.as_ref().unwrap_or_else(|| Integer::default_instance())
    }

    // .google.fhir.stu3.proto.Integer count_max = 5;

    pub fn clear_count_max(&mut self) {
        self.count_max.clear();
    }

    pub fn has_count_max(&self) -> bool {
        self.count_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_max(&mut self, v: Integer) {
        self.count_max = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_count_max(&mut self) -> &mut Integer {
        if self.count_max.is_none() {
            self.count_max.set_default();
        }
        self.count_max.as_mut().unwrap()
    }

    // Take field
    pub fn take_count_max(&mut self) -> Integer {
        self.count_max.take().unwrap_or_else(|| Integer::new())
    }

    pub fn get_count_max(&self) -> &Integer {
        self.count_max.as_ref().unwrap_or_else(|| Integer::default_instance())
    }

    // .google.fhir.stu3.proto.Decimal duration = 6;

    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: Decimal) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut Decimal {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> Decimal {
        self.duration.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_duration(&self) -> &Decimal {
        self.duration.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.Decimal duration_max = 7;

    pub fn clear_duration_max(&mut self) {
        self.duration_max.clear();
    }

    pub fn has_duration_max(&self) -> bool {
        self.duration_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_max(&mut self, v: Decimal) {
        self.duration_max = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration_max(&mut self) -> &mut Decimal {
        if self.duration_max.is_none() {
            self.duration_max.set_default();
        }
        self.duration_max.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration_max(&mut self) -> Decimal {
        self.duration_max.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_duration_max(&self) -> &Decimal {
        self.duration_max.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.UnitsOfTimeCode duration_unit = 8;

    pub fn clear_duration_unit(&mut self) {
        self.duration_unit.clear();
    }

    pub fn has_duration_unit(&self) -> bool {
        self.duration_unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_unit(&mut self, v: UnitsOfTimeCode) {
        self.duration_unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration_unit(&mut self) -> &mut UnitsOfTimeCode {
        if self.duration_unit.is_none() {
            self.duration_unit.set_default();
        }
        self.duration_unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration_unit(&mut self) -> UnitsOfTimeCode {
        self.duration_unit.take().unwrap_or_else(|| UnitsOfTimeCode::new())
    }

    pub fn get_duration_unit(&self) -> &UnitsOfTimeCode {
        self.duration_unit.as_ref().unwrap_or_else(|| UnitsOfTimeCode::default_instance())
    }

    // .google.fhir.stu3.proto.Integer frequency = 9;

    pub fn clear_frequency(&mut self) {
        self.frequency.clear();
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: Integer) {
        self.frequency = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequency(&mut self) -> &mut Integer {
        if self.frequency.is_none() {
            self.frequency.set_default();
        }
        self.frequency.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequency(&mut self) -> Integer {
        self.frequency.take().unwrap_or_else(|| Integer::new())
    }

    pub fn get_frequency(&self) -> &Integer {
        self.frequency.as_ref().unwrap_or_else(|| Integer::default_instance())
    }

    // .google.fhir.stu3.proto.Integer frequency_max = 10;

    pub fn clear_frequency_max(&mut self) {
        self.frequency_max.clear();
    }

    pub fn has_frequency_max(&self) -> bool {
        self.frequency_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency_max(&mut self, v: Integer) {
        self.frequency_max = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frequency_max(&mut self) -> &mut Integer {
        if self.frequency_max.is_none() {
            self.frequency_max.set_default();
        }
        self.frequency_max.as_mut().unwrap()
    }

    // Take field
    pub fn take_frequency_max(&mut self) -> Integer {
        self.frequency_max.take().unwrap_or_else(|| Integer::new())
    }

    pub fn get_frequency_max(&self) -> &Integer {
        self.frequency_max.as_ref().unwrap_or_else(|| Integer::default_instance())
    }

    // .google.fhir.stu3.proto.Decimal period = 11;

    pub fn clear_period(&mut self) {
        self.period.clear();
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: Decimal) {
        self.period = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_period(&mut self) -> &mut Decimal {
        if self.period.is_none() {
            self.period.set_default();
        }
        self.period.as_mut().unwrap()
    }

    // Take field
    pub fn take_period(&mut self) -> Decimal {
        self.period.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_period(&self) -> &Decimal {
        self.period.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.Decimal period_max = 12;

    pub fn clear_period_max(&mut self) {
        self.period_max.clear();
    }

    pub fn has_period_max(&self) -> bool {
        self.period_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period_max(&mut self, v: Decimal) {
        self.period_max = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_period_max(&mut self) -> &mut Decimal {
        if self.period_max.is_none() {
            self.period_max.set_default();
        }
        self.period_max.as_mut().unwrap()
    }

    // Take field
    pub fn take_period_max(&mut self) -> Decimal {
        self.period_max.take().unwrap_or_else(|| Decimal::new())
    }

    pub fn get_period_max(&self) -> &Decimal {
        self.period_max.as_ref().unwrap_or_else(|| Decimal::default_instance())
    }

    // .google.fhir.stu3.proto.UnitsOfTimeCode period_unit = 13;

    pub fn clear_period_unit(&mut self) {
        self.period_unit.clear();
    }

    pub fn has_period_unit(&self) -> bool {
        self.period_unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period_unit(&mut self, v: UnitsOfTimeCode) {
        self.period_unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_period_unit(&mut self) -> &mut UnitsOfTimeCode {
        if self.period_unit.is_none() {
            self.period_unit.set_default();
        }
        self.period_unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_period_unit(&mut self) -> UnitsOfTimeCode {
        self.period_unit.take().unwrap_or_else(|| UnitsOfTimeCode::new())
    }

    pub fn get_period_unit(&self) -> &UnitsOfTimeCode {
        self.period_unit.as_ref().unwrap_or_else(|| UnitsOfTimeCode::default_instance())
    }

    // repeated .google.fhir.stu3.proto.DaysOfWeekCode day_of_week = 14;

    pub fn clear_day_of_week(&mut self) {
        self.day_of_week.clear();
    }

    // Param is passed by value, moved
    pub fn set_day_of_week(&mut self, v: ::protobuf::RepeatedField<DaysOfWeekCode>) {
        self.day_of_week = v;
    }

    // Mutable pointer to the field.
    pub fn mut_day_of_week(&mut self) -> &mut ::protobuf::RepeatedField<DaysOfWeekCode> {
        &mut self.day_of_week
    }

    // Take field
    pub fn take_day_of_week(&mut self) -> ::protobuf::RepeatedField<DaysOfWeekCode> {
        ::std::mem::replace(&mut self.day_of_week, ::protobuf::RepeatedField::new())
    }

    pub fn get_day_of_week(&self) -> &[DaysOfWeekCode] {
        &self.day_of_week
    }

    // repeated .google.fhir.stu3.proto.Time time_of_day = 15;

    pub fn clear_time_of_day(&mut self) {
        self.time_of_day.clear();
    }

    // Param is passed by value, moved
    pub fn set_time_of_day(&mut self, v: ::protobuf::RepeatedField<Time>) {
        self.time_of_day = v;
    }

    // Mutable pointer to the field.
    pub fn mut_time_of_day(&mut self) -> &mut ::protobuf::RepeatedField<Time> {
        &mut self.time_of_day
    }

    // Take field
    pub fn take_time_of_day(&mut self) -> ::protobuf::RepeatedField<Time> {
        ::std::mem::replace(&mut self.time_of_day, ::protobuf::RepeatedField::new())
    }

    pub fn get_time_of_day(&self) -> &[Time] {
        &self.time_of_day
    }

    // repeated .google.fhir.stu3.proto.EventTimingCode when = 16;

    pub fn clear_when(&mut self) {
        self.when.clear();
    }

    // Param is passed by value, moved
    pub fn set_when(&mut self, v: ::protobuf::RepeatedField<EventTimingCode>) {
        self.when = v;
    }

    // Mutable pointer to the field.
    pub fn mut_when(&mut self) -> &mut ::protobuf::RepeatedField<EventTimingCode> {
        &mut self.when
    }

    // Take field
    pub fn take_when(&mut self) -> ::protobuf::RepeatedField<EventTimingCode> {
        ::std::mem::replace(&mut self.when, ::protobuf::RepeatedField::new())
    }

    pub fn get_when(&self) -> &[EventTimingCode] {
        &self.when
    }

    // .google.fhir.stu3.proto.UnsignedInt offset = 17;

    pub fn clear_offset(&mut self) {
        self.offset.clear();
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: UnsignedInt) {
        self.offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offset(&mut self) -> &mut UnsignedInt {
        if self.offset.is_none() {
            self.offset.set_default();
        }
        self.offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_offset(&mut self) -> UnsignedInt {
        self.offset.take().unwrap_or_else(|| UnsignedInt::new())
    }

    pub fn get_offset(&self) -> &UnsignedInt {
        self.offset.as_ref().unwrap_or_else(|| UnsignedInt::default_instance())
    }
}

impl ::protobuf::Message for Timing_Repeat {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bounds {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.count {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.count_max {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration_max {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration_unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frequency {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frequency_max {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.period {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.period_max {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.period_unit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.day_of_week {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_of_day {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.when {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bounds)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.count)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.count_max)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration_max)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration_unit)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequency)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frequency_max)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.period)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.period_max)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.period_unit)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.day_of_week)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.time_of_day)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.when)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.bounds.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.count_max.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration_max.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration_unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frequency.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frequency_max.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.period.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.period_max.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.period_unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.day_of_week {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.time_of_day {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.when {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.offset.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.bounds.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.count.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.count_max.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration_max.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration_unit.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frequency.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frequency_max.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.period.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.period_max.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.period_unit.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.day_of_week {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.time_of_day {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.when {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.offset.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Timing_Repeat {
        Timing_Repeat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Timing_Repeat| { &m.id },
                    |m: &mut Timing_Repeat| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Timing_Repeat| { &m.extension },
                    |m: &mut Timing_Repeat| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Timing_Repeat_Bounds>>(
                    "bounds",
                    |m: &Timing_Repeat| { &m.bounds },
                    |m: &mut Timing_Repeat| { &mut m.bounds },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Integer>>(
                    "count",
                    |m: &Timing_Repeat| { &m.count },
                    |m: &mut Timing_Repeat| { &mut m.count },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Integer>>(
                    "count_max",
                    |m: &Timing_Repeat| { &m.count_max },
                    |m: &mut Timing_Repeat| { &mut m.count_max },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "duration",
                    |m: &Timing_Repeat| { &m.duration },
                    |m: &mut Timing_Repeat| { &mut m.duration },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "duration_max",
                    |m: &Timing_Repeat| { &m.duration_max },
                    |m: &mut Timing_Repeat| { &mut m.duration_max },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitsOfTimeCode>>(
                    "duration_unit",
                    |m: &Timing_Repeat| { &m.duration_unit },
                    |m: &mut Timing_Repeat| { &mut m.duration_unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Integer>>(
                    "frequency",
                    |m: &Timing_Repeat| { &m.frequency },
                    |m: &mut Timing_Repeat| { &mut m.frequency },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Integer>>(
                    "frequency_max",
                    |m: &Timing_Repeat| { &m.frequency_max },
                    |m: &mut Timing_Repeat| { &mut m.frequency_max },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "period",
                    |m: &Timing_Repeat| { &m.period },
                    |m: &mut Timing_Repeat| { &mut m.period },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decimal>>(
                    "period_max",
                    |m: &Timing_Repeat| { &m.period_max },
                    |m: &mut Timing_Repeat| { &mut m.period_max },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnitsOfTimeCode>>(
                    "period_unit",
                    |m: &Timing_Repeat| { &m.period_unit },
                    |m: &mut Timing_Repeat| { &mut m.period_unit },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DaysOfWeekCode>>(
                    "day_of_week",
                    |m: &Timing_Repeat| { &m.day_of_week },
                    |m: &mut Timing_Repeat| { &mut m.day_of_week },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Time>>(
                    "time_of_day",
                    |m: &Timing_Repeat| { &m.time_of_day },
                    |m: &mut Timing_Repeat| { &mut m.time_of_day },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EventTimingCode>>(
                    "when",
                    |m: &Timing_Repeat| { &m.when },
                    |m: &mut Timing_Repeat| { &mut m.when },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnsignedInt>>(
                    "offset",
                    |m: &Timing_Repeat| { &m.offset },
                    |m: &mut Timing_Repeat| { &mut m.offset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Timing_Repeat>(
                    "Timing_Repeat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Timing_Repeat {
        static mut instance: ::protobuf::lazy::Lazy<Timing_Repeat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Timing_Repeat,
        };
        unsafe {
            instance.get(Timing_Repeat::new)
        }
    }
}

impl ::protobuf::Clear for Timing_Repeat {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_bounds();
        self.clear_count();
        self.clear_count_max();
        self.clear_duration();
        self.clear_duration_max();
        self.clear_duration_unit();
        self.clear_frequency();
        self.clear_frequency_max();
        self.clear_period();
        self.clear_period_max();
        self.clear_period_unit();
        self.clear_day_of_week();
        self.clear_time_of_day();
        self.clear_when();
        self.clear_offset();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Timing_Repeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Timing_Repeat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Timing_Repeat_Bounds {
    // message oneof groups
    pub bounds: ::std::option::Option<Timing_Repeat_Bounds_oneof_bounds>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Timing_Repeat_Bounds_oneof_bounds {
    duration(Duration),
    range(Range),
    period(Period),
}

impl Timing_Repeat_Bounds {
    pub fn new() -> Timing_Repeat_Bounds {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.Duration duration = 1;

    pub fn clear_duration(&mut self) {
        self.bounds = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        match self.bounds {
            ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::duration(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: Duration) {
        self.bounds = ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::duration(v))
    }

    // Mutable pointer to the field.
    pub fn mut_duration(&mut self) -> &mut Duration {
        if let ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::duration(_)) = self.bounds {
        } else {
            self.bounds = ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::duration(Duration::new()));
        }
        match self.bounds {
            ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::duration(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_duration(&mut self) -> Duration {
        if self.has_duration() {
            match self.bounds.take() {
                ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::duration(v)) => v,
                _ => panic!(),
            }
        } else {
            Duration::new()
        }
    }

    pub fn get_duration(&self) -> &Duration {
        match self.bounds {
            ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::duration(ref v)) => v,
            _ => Duration::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Range range = 2;

    pub fn clear_range(&mut self) {
        self.bounds = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        match self.bounds {
            ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Range) {
        self.bounds = ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_range(&mut self) -> &mut Range {
        if let ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::range(_)) = self.bounds {
        } else {
            self.bounds = ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::range(Range::new()));
        }
        match self.bounds {
            ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_range(&mut self) -> Range {
        if self.has_range() {
            match self.bounds.take() {
                ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::range(v)) => v,
                _ => panic!(),
            }
        } else {
            Range::new()
        }
    }

    pub fn get_range(&self) -> &Range {
        match self.bounds {
            ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::range(ref v)) => v,
            _ => Range::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Period period = 3;

    pub fn clear_period(&mut self) {
        self.bounds = ::std::option::Option::None;
    }

    pub fn has_period(&self) -> bool {
        match self.bounds {
            ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::period(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: Period) {
        self.bounds = ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::period(v))
    }

    // Mutable pointer to the field.
    pub fn mut_period(&mut self) -> &mut Period {
        if let ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::period(_)) = self.bounds {
        } else {
            self.bounds = ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::period(Period::new()));
        }
        match self.bounds {
            ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::period(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_period(&mut self) -> Period {
        if self.has_period() {
            match self.bounds.take() {
                ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::period(v)) => v,
                _ => panic!(),
            }
        } else {
            Period::new()
        }
    }

    pub fn get_period(&self) -> &Period {
        match self.bounds {
            ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::period(ref v)) => v,
            _ => Period::default_instance(),
        }
    }
}

impl ::protobuf::Message for Timing_Repeat_Bounds {
    fn is_initialized(&self) -> bool {
        if let Some(Timing_Repeat_Bounds_oneof_bounds::duration(ref v)) = self.bounds {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Timing_Repeat_Bounds_oneof_bounds::range(ref v)) = self.bounds {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Timing_Repeat_Bounds_oneof_bounds::period(ref v)) = self.bounds {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bounds = ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::duration(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bounds = ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::range(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.bounds = ::std::option::Option::Some(Timing_Repeat_Bounds_oneof_bounds::period(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.bounds {
            match v {
                &Timing_Repeat_Bounds_oneof_bounds::duration(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Timing_Repeat_Bounds_oneof_bounds::range(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Timing_Repeat_Bounds_oneof_bounds::period(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.bounds {
            match v {
                &Timing_Repeat_Bounds_oneof_bounds::duration(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Timing_Repeat_Bounds_oneof_bounds::range(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Timing_Repeat_Bounds_oneof_bounds::period(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Timing_Repeat_Bounds {
        Timing_Repeat_Bounds::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Duration>(
                    "duration",
                    Timing_Repeat_Bounds::has_duration,
                    Timing_Repeat_Bounds::get_duration,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Range>(
                    "range",
                    Timing_Repeat_Bounds::has_range,
                    Timing_Repeat_Bounds::get_range,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Period>(
                    "period",
                    Timing_Repeat_Bounds::has_period,
                    Timing_Repeat_Bounds::get_period,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Timing_Repeat_Bounds>(
                    "Timing_Repeat_Bounds",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Timing_Repeat_Bounds {
        static mut instance: ::protobuf::lazy::Lazy<Timing_Repeat_Bounds> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Timing_Repeat_Bounds,
        };
        unsafe {
            instance.get(Timing_Repeat_Bounds::new)
        }
    }
}

impl ::protobuf::Clear for Timing_Repeat_Bounds {
    fn clear(&mut self) {
        self.clear_duration();
        self.clear_range();
        self.clear_period();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Timing_Repeat_Bounds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Timing_Repeat_Bounds {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Extension {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub url: ::protobuf::SingularPtrField<Uri>,
    pub value: ::protobuf::SingularPtrField<Extension_Value>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Extension {
    pub fn new() -> Extension {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Uri url = 2;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: Uri) {
        self.url = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut Uri {
        if self.url.is_none() {
            self.url.set_default();
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> Uri {
        self.url.take().unwrap_or_else(|| Uri::new())
    }

    pub fn get_url(&self) -> &Uri {
        self.url.as_ref().unwrap_or_else(|| Uri::default_instance())
    }

    // .google.fhir.stu3.proto.Extension.Value value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Extension_Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Extension_Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Extension_Value {
        self.value.take().unwrap_or_else(|| Extension_Value::new())
    }

    pub fn get_value(&self) -> &Extension_Value {
        self.value.as_ref().unwrap_or_else(|| Extension_Value::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 4;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for Extension {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.url {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.url.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.url.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Extension {
        Extension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Extension| { &m.id },
                    |m: &mut Extension| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Uri>>(
                    "url",
                    |m: &Extension| { &m.url },
                    |m: &mut Extension| { &mut m.url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension_Value>>(
                    "value",
                    |m: &Extension| { &m.value },
                    |m: &mut Extension| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Extension| { &m.extension },
                    |m: &mut Extension| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Extension>(
                    "Extension",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Extension {
        static mut instance: ::protobuf::lazy::Lazy<Extension> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Extension,
        };
        unsafe {
            instance.get(Extension::new)
        }
    }
}

impl ::protobuf::Clear for Extension {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_url();
        self.clear_value();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Extension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Extension {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Extension_Value {
    // message oneof groups
    pub value: ::std::option::Option<Extension_Value_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Extension_Value_oneof_value {
    base64_binary(Base64Binary),
    boolean(Boolean),
    code(Code),
    date(Date),
    date_time(DateTime),
    decimal(Decimal),
    id(Id),
    instant(Instant),
    integer(Integer),
    markdown(Markdown),
    oid(Oid),
    positive_int(PositiveInt),
    string_value(String),
    time(Time),
    unsigned_int(UnsignedInt),
    uri(Uri),
    address(Address),
    age(Age),
    annotation(Annotation),
    attachment(Attachment),
    codeable_concept(CodeableConcept),
    coding(Coding),
    contact_point(ContactPoint),
    count(Count),
    distance(Distance),
    duration(Duration),
    human_name(HumanName),
    identifier(Identifier),
    money(Money),
    period(Period),
    quantity(Quantity),
    range(Range),
    ratio(Ratio),
    reference(Reference),
    sampled_data(SampledData),
    signature(Signature),
    timing(Timing),
    meta(Meta),
}

impl Extension_Value {
    pub fn new() -> Extension_Value {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.Base64Binary base64_binary = 1;

    pub fn clear_base64_binary(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_base64_binary(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::base64_binary(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_base64_binary(&mut self, v: Base64Binary) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::base64_binary(v))
    }

    // Mutable pointer to the field.
    pub fn mut_base64_binary(&mut self) -> &mut Base64Binary {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::base64_binary(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::base64_binary(Base64Binary::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::base64_binary(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_base64_binary(&mut self) -> Base64Binary {
        if self.has_base64_binary() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::base64_binary(v)) => v,
                _ => panic!(),
            }
        } else {
            Base64Binary::new()
        }
    }

    pub fn get_base64_binary(&self) -> &Base64Binary {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::base64_binary(ref v)) => v,
            _ => Base64Binary::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Boolean boolean = 2;

    pub fn clear_boolean(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_boolean(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::boolean(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_boolean(&mut self, v: Boolean) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::boolean(v))
    }

    // Mutable pointer to the field.
    pub fn mut_boolean(&mut self) -> &mut Boolean {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::boolean(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::boolean(Boolean::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::boolean(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_boolean(&mut self) -> Boolean {
        if self.has_boolean() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::boolean(v)) => v,
                _ => panic!(),
            }
        } else {
            Boolean::new()
        }
    }

    pub fn get_boolean(&self) -> &Boolean {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::boolean(ref v)) => v,
            _ => Boolean::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Code code = 3;

    pub fn clear_code(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::code(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Code) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::code(v))
    }

    // Mutable pointer to the field.
    pub fn mut_code(&mut self) -> &mut Code {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::code(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::code(Code::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::code(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_code(&mut self) -> Code {
        if self.has_code() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::code(v)) => v,
                _ => panic!(),
            }
        } else {
            Code::new()
        }
    }

    pub fn get_code(&self) -> &Code {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::code(ref v)) => v,
            _ => Code::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Date date = 4;

    pub fn clear_date(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::date(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: Date) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::date(v))
    }

    // Mutable pointer to the field.
    pub fn mut_date(&mut self) -> &mut Date {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::date(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::date(Date::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::date(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_date(&mut self) -> Date {
        if self.has_date() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::date(v)) => v,
                _ => panic!(),
            }
        } else {
            Date::new()
        }
    }

    pub fn get_date(&self) -> &Date {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::date(ref v)) => v,
            _ => Date::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.DateTime date_time = 5;

    pub fn clear_date_time(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_date_time(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::date_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_date_time(&mut self, v: DateTime) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::date_time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_date_time(&mut self) -> &mut DateTime {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::date_time(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::date_time(DateTime::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::date_time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_date_time(&mut self) -> DateTime {
        if self.has_date_time() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::date_time(v)) => v,
                _ => panic!(),
            }
        } else {
            DateTime::new()
        }
    }

    pub fn get_date_time(&self) -> &DateTime {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::date_time(ref v)) => v,
            _ => DateTime::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Decimal decimal = 6;

    pub fn clear_decimal(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_decimal(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::decimal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_decimal(&mut self, v: Decimal) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::decimal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_decimal(&mut self) -> &mut Decimal {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::decimal(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::decimal(Decimal::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::decimal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_decimal(&mut self) -> Decimal {
        if self.has_decimal() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::decimal(v)) => v,
                _ => panic!(),
            }
        } else {
            Decimal::new()
        }
    }

    pub fn get_decimal(&self) -> &Decimal {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::decimal(ref v)) => v,
            _ => Decimal::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Id id = 7;

    pub fn clear_id(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: Id) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut Id {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::id(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::id(Id::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> Id {
        if self.has_id() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::id(v)) => v,
                _ => panic!(),
            }
        } else {
            Id::new()
        }
    }

    pub fn get_id(&self) -> &Id {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::id(ref v)) => v,
            _ => Id::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Instant instant = 8;

    pub fn clear_instant(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_instant(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::instant(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instant(&mut self, v: Instant) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::instant(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instant(&mut self) -> &mut Instant {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::instant(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::instant(Instant::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::instant(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instant(&mut self) -> Instant {
        if self.has_instant() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::instant(v)) => v,
                _ => panic!(),
            }
        } else {
            Instant::new()
        }
    }

    pub fn get_instant(&self) -> &Instant {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::instant(ref v)) => v,
            _ => Instant::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Integer integer = 9;

    pub fn clear_integer(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_integer(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::integer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_integer(&mut self, v: Integer) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::integer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_integer(&mut self) -> &mut Integer {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::integer(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::integer(Integer::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::integer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_integer(&mut self) -> Integer {
        if self.has_integer() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::integer(v)) => v,
                _ => panic!(),
            }
        } else {
            Integer::new()
        }
    }

    pub fn get_integer(&self) -> &Integer {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::integer(ref v)) => v,
            _ => Integer::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Markdown markdown = 10;

    pub fn clear_markdown(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_markdown(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::markdown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_markdown(&mut self, v: Markdown) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::markdown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_markdown(&mut self) -> &mut Markdown {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::markdown(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::markdown(Markdown::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::markdown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_markdown(&mut self) -> Markdown {
        if self.has_markdown() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::markdown(v)) => v,
                _ => panic!(),
            }
        } else {
            Markdown::new()
        }
    }

    pub fn get_markdown(&self) -> &Markdown {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::markdown(ref v)) => v,
            _ => Markdown::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Oid oid = 11;

    pub fn clear_oid(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_oid(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::oid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_oid(&mut self, v: Oid) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::oid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_oid(&mut self) -> &mut Oid {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::oid(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::oid(Oid::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::oid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_oid(&mut self) -> Oid {
        if self.has_oid() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::oid(v)) => v,
                _ => panic!(),
            }
        } else {
            Oid::new()
        }
    }

    pub fn get_oid(&self) -> &Oid {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::oid(ref v)) => v,
            _ => Oid::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.PositiveInt positive_int = 12;

    pub fn clear_positive_int(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_positive_int(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::positive_int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_positive_int(&mut self, v: PositiveInt) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::positive_int(v))
    }

    // Mutable pointer to the field.
    pub fn mut_positive_int(&mut self) -> &mut PositiveInt {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::positive_int(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::positive_int(PositiveInt::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::positive_int(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_positive_int(&mut self) -> PositiveInt {
        if self.has_positive_int() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::positive_int(v)) => v,
                _ => panic!(),
            }
        } else {
            PositiveInt::new()
        }
    }

    pub fn get_positive_int(&self) -> &PositiveInt {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::positive_int(ref v)) => v,
            _ => PositiveInt::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.String string_value = 13;

    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: String) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut String {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::string_value(String::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> String {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            String::new()
        }
    }

    pub fn get_string_value(&self) -> &String {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::string_value(ref v)) => v,
            _ => String::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Time time = 14;

    pub fn clear_time(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: Time) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_time(&mut self) -> &mut Time {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::time(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::time(Time::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_time(&mut self) -> Time {
        if self.has_time() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::time(v)) => v,
                _ => panic!(),
            }
        } else {
            Time::new()
        }
    }

    pub fn get_time(&self) -> &Time {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::time(ref v)) => v,
            _ => Time::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.UnsignedInt unsigned_int = 15;

    pub fn clear_unsigned_int(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_unsigned_int(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::unsigned_int(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unsigned_int(&mut self, v: UnsignedInt) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::unsigned_int(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unsigned_int(&mut self) -> &mut UnsignedInt {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::unsigned_int(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::unsigned_int(UnsignedInt::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::unsigned_int(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unsigned_int(&mut self) -> UnsignedInt {
        if self.has_unsigned_int() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::unsigned_int(v)) => v,
                _ => panic!(),
            }
        } else {
            UnsignedInt::new()
        }
    }

    pub fn get_unsigned_int(&self) -> &UnsignedInt {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::unsigned_int(ref v)) => v,
            _ => UnsignedInt::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Uri uri = 16;

    pub fn clear_uri(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::uri(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: Uri) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::uri(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uri(&mut self) -> &mut Uri {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::uri(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::uri(Uri::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::uri(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uri(&mut self) -> Uri {
        if self.has_uri() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::uri(v)) => v,
                _ => panic!(),
            }
        } else {
            Uri::new()
        }
    }

    pub fn get_uri(&self) -> &Uri {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::uri(ref v)) => v,
            _ => Uri::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Address address = 17;

    pub fn clear_address(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::address(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::address(v))
    }

    // Mutable pointer to the field.
    pub fn mut_address(&mut self) -> &mut Address {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::address(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::address(Address::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::address(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        if self.has_address() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::address(v)) => v,
                _ => panic!(),
            }
        } else {
            Address::new()
        }
    }

    pub fn get_address(&self) -> &Address {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::address(ref v)) => v,
            _ => Address::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Age age = 18;

    pub fn clear_age(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_age(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::age(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_age(&mut self, v: Age) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::age(v))
    }

    // Mutable pointer to the field.
    pub fn mut_age(&mut self) -> &mut Age {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::age(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::age(Age::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::age(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_age(&mut self) -> Age {
        if self.has_age() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::age(v)) => v,
                _ => panic!(),
            }
        } else {
            Age::new()
        }
    }

    pub fn get_age(&self) -> &Age {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::age(ref v)) => v,
            _ => Age::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Annotation annotation = 19;

    pub fn clear_annotation(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_annotation(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::annotation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_annotation(&mut self, v: Annotation) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::annotation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_annotation(&mut self) -> &mut Annotation {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::annotation(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::annotation(Annotation::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::annotation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_annotation(&mut self) -> Annotation {
        if self.has_annotation() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::annotation(v)) => v,
                _ => panic!(),
            }
        } else {
            Annotation::new()
        }
    }

    pub fn get_annotation(&self) -> &Annotation {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::annotation(ref v)) => v,
            _ => Annotation::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Attachment attachment = 20;

    pub fn clear_attachment(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_attachment(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::attachment(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_attachment(&mut self, v: Attachment) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::attachment(v))
    }

    // Mutable pointer to the field.
    pub fn mut_attachment(&mut self) -> &mut Attachment {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::attachment(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::attachment(Attachment::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::attachment(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_attachment(&mut self) -> Attachment {
        if self.has_attachment() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::attachment(v)) => v,
                _ => panic!(),
            }
        } else {
            Attachment::new()
        }
    }

    pub fn get_attachment(&self) -> &Attachment {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::attachment(ref v)) => v,
            _ => Attachment::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.CodeableConcept codeable_concept = 21;

    pub fn clear_codeable_concept(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_codeable_concept(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::codeable_concept(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_codeable_concept(&mut self, v: CodeableConcept) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::codeable_concept(v))
    }

    // Mutable pointer to the field.
    pub fn mut_codeable_concept(&mut self) -> &mut CodeableConcept {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::codeable_concept(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::codeable_concept(CodeableConcept::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::codeable_concept(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_codeable_concept(&mut self) -> CodeableConcept {
        if self.has_codeable_concept() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::codeable_concept(v)) => v,
                _ => panic!(),
            }
        } else {
            CodeableConcept::new()
        }
    }

    pub fn get_codeable_concept(&self) -> &CodeableConcept {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::codeable_concept(ref v)) => v,
            _ => CodeableConcept::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Coding coding = 22;

    pub fn clear_coding(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_coding(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::coding(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_coding(&mut self, v: Coding) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::coding(v))
    }

    // Mutable pointer to the field.
    pub fn mut_coding(&mut self) -> &mut Coding {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::coding(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::coding(Coding::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::coding(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_coding(&mut self) -> Coding {
        if self.has_coding() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::coding(v)) => v,
                _ => panic!(),
            }
        } else {
            Coding::new()
        }
    }

    pub fn get_coding(&self) -> &Coding {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::coding(ref v)) => v,
            _ => Coding::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ContactPoint contact_point = 23;

    pub fn clear_contact_point(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_contact_point(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::contact_point(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contact_point(&mut self, v: ContactPoint) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::contact_point(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contact_point(&mut self) -> &mut ContactPoint {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::contact_point(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::contact_point(ContactPoint::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::contact_point(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contact_point(&mut self) -> ContactPoint {
        if self.has_contact_point() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::contact_point(v)) => v,
                _ => panic!(),
            }
        } else {
            ContactPoint::new()
        }
    }

    pub fn get_contact_point(&self) -> &ContactPoint {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::contact_point(ref v)) => v,
            _ => ContactPoint::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Count count = 24;

    pub fn clear_count(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::count(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: Count) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::count(v))
    }

    // Mutable pointer to the field.
    pub fn mut_count(&mut self) -> &mut Count {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::count(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::count(Count::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::count(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_count(&mut self) -> Count {
        if self.has_count() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::count(v)) => v,
                _ => panic!(),
            }
        } else {
            Count::new()
        }
    }

    pub fn get_count(&self) -> &Count {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::count(ref v)) => v,
            _ => Count::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Distance distance = 25;

    pub fn clear_distance(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::distance(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: Distance) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::distance(v))
    }

    // Mutable pointer to the field.
    pub fn mut_distance(&mut self) -> &mut Distance {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::distance(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::distance(Distance::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::distance(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_distance(&mut self) -> Distance {
        if self.has_distance() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::distance(v)) => v,
                _ => panic!(),
            }
        } else {
            Distance::new()
        }
    }

    pub fn get_distance(&self) -> &Distance {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::distance(ref v)) => v,
            _ => Distance::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Duration duration = 26;

    pub fn clear_duration(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::duration(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: Duration) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::duration(v))
    }

    // Mutable pointer to the field.
    pub fn mut_duration(&mut self) -> &mut Duration {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::duration(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::duration(Duration::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::duration(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_duration(&mut self) -> Duration {
        if self.has_duration() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::duration(v)) => v,
                _ => panic!(),
            }
        } else {
            Duration::new()
        }
    }

    pub fn get_duration(&self) -> &Duration {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::duration(ref v)) => v,
            _ => Duration::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.HumanName human_name = 27;

    pub fn clear_human_name(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_human_name(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::human_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_human_name(&mut self, v: HumanName) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::human_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_human_name(&mut self) -> &mut HumanName {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::human_name(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::human_name(HumanName::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::human_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_human_name(&mut self) -> HumanName {
        if self.has_human_name() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::human_name(v)) => v,
                _ => panic!(),
            }
        } else {
            HumanName::new()
        }
    }

    pub fn get_human_name(&self) -> &HumanName {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::human_name(ref v)) => v,
            _ => HumanName::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Identifier identifier = 28;

    pub fn clear_identifier(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_identifier(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::identifier(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: Identifier) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::identifier(v))
    }

    // Mutable pointer to the field.
    pub fn mut_identifier(&mut self) -> &mut Identifier {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::identifier(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::identifier(Identifier::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::identifier(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_identifier(&mut self) -> Identifier {
        if self.has_identifier() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::identifier(v)) => v,
                _ => panic!(),
            }
        } else {
            Identifier::new()
        }
    }

    pub fn get_identifier(&self) -> &Identifier {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::identifier(ref v)) => v,
            _ => Identifier::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Money money = 29;

    pub fn clear_money(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_money(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::money(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_money(&mut self, v: Money) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::money(v))
    }

    // Mutable pointer to the field.
    pub fn mut_money(&mut self) -> &mut Money {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::money(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::money(Money::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::money(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_money(&mut self) -> Money {
        if self.has_money() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::money(v)) => v,
                _ => panic!(),
            }
        } else {
            Money::new()
        }
    }

    pub fn get_money(&self) -> &Money {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::money(ref v)) => v,
            _ => Money::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Period period = 30;

    pub fn clear_period(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_period(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::period(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: Period) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::period(v))
    }

    // Mutable pointer to the field.
    pub fn mut_period(&mut self) -> &mut Period {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::period(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::period(Period::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::period(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_period(&mut self) -> Period {
        if self.has_period() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::period(v)) => v,
                _ => panic!(),
            }
        } else {
            Period::new()
        }
    }

    pub fn get_period(&self) -> &Period {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::period(ref v)) => v,
            _ => Period::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Quantity quantity = 31;

    pub fn clear_quantity(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::quantity(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: Quantity) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::quantity(v))
    }

    // Mutable pointer to the field.
    pub fn mut_quantity(&mut self) -> &mut Quantity {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::quantity(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::quantity(Quantity::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::quantity(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_quantity(&mut self) -> Quantity {
        if self.has_quantity() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::quantity(v)) => v,
                _ => panic!(),
            }
        } else {
            Quantity::new()
        }
    }

    pub fn get_quantity(&self) -> &Quantity {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::quantity(ref v)) => v,
            _ => Quantity::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Range range = 32;

    pub fn clear_range(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::range(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Range) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::range(v))
    }

    // Mutable pointer to the field.
    pub fn mut_range(&mut self) -> &mut Range {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::range(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::range(Range::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::range(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_range(&mut self) -> Range {
        if self.has_range() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::range(v)) => v,
                _ => panic!(),
            }
        } else {
            Range::new()
        }
    }

    pub fn get_range(&self) -> &Range {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::range(ref v)) => v,
            _ => Range::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Ratio ratio = 33;

    pub fn clear_ratio(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_ratio(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::ratio(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ratio(&mut self, v: Ratio) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::ratio(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ratio(&mut self) -> &mut Ratio {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::ratio(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::ratio(Ratio::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::ratio(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ratio(&mut self) -> Ratio {
        if self.has_ratio() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::ratio(v)) => v,
                _ => panic!(),
            }
        } else {
            Ratio::new()
        }
    }

    pub fn get_ratio(&self) -> &Ratio {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::ratio(ref v)) => v,
            _ => Ratio::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Reference reference = 34;

    pub fn clear_reference(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_reference(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::reference(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reference(&mut self, v: Reference) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::reference(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reference(&mut self) -> &mut Reference {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::reference(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::reference(Reference::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::reference(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reference(&mut self) -> Reference {
        if self.has_reference() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::reference(v)) => v,
                _ => panic!(),
            }
        } else {
            Reference::new()
        }
    }

    pub fn get_reference(&self) -> &Reference {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::reference(ref v)) => v,
            _ => Reference::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.SampledData sampled_data = 35;

    pub fn clear_sampled_data(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_sampled_data(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::sampled_data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sampled_data(&mut self, v: SampledData) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::sampled_data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sampled_data(&mut self) -> &mut SampledData {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::sampled_data(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::sampled_data(SampledData::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::sampled_data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sampled_data(&mut self) -> SampledData {
        if self.has_sampled_data() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::sampled_data(v)) => v,
                _ => panic!(),
            }
        } else {
            SampledData::new()
        }
    }

    pub fn get_sampled_data(&self) -> &SampledData {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::sampled_data(ref v)) => v,
            _ => SampledData::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Signature signature = 36;

    pub fn clear_signature(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::signature(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: Signature) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::signature(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signature(&mut self) -> &mut Signature {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::signature(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::signature(Signature::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::signature(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signature(&mut self) -> Signature {
        if self.has_signature() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::signature(v)) => v,
                _ => panic!(),
            }
        } else {
            Signature::new()
        }
    }

    pub fn get_signature(&self) -> &Signature {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::signature(ref v)) => v,
            _ => Signature::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Timing timing = 37;

    pub fn clear_timing(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_timing(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::timing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_timing(&mut self, v: Timing) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::timing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_timing(&mut self) -> &mut Timing {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::timing(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::timing(Timing::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::timing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_timing(&mut self) -> Timing {
        if self.has_timing() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::timing(v)) => v,
                _ => panic!(),
            }
        } else {
            Timing::new()
        }
    }

    pub fn get_timing(&self) -> &Timing {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::timing(ref v)) => v,
            _ => Timing::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Meta meta = 38;

    pub fn clear_meta(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_meta(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::meta(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_meta(&mut self, v: Meta) {
        self.value = ::std::option::Option::Some(Extension_Value_oneof_value::meta(v))
    }

    // Mutable pointer to the field.
    pub fn mut_meta(&mut self) -> &mut Meta {
        if let ::std::option::Option::Some(Extension_Value_oneof_value::meta(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Extension_Value_oneof_value::meta(Meta::new()));
        }
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::meta(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_meta(&mut self) -> Meta {
        if self.has_meta() {
            match self.value.take() {
                ::std::option::Option::Some(Extension_Value_oneof_value::meta(v)) => v,
                _ => panic!(),
            }
        } else {
            Meta::new()
        }
    }

    pub fn get_meta(&self) -> &Meta {
        match self.value {
            ::std::option::Option::Some(Extension_Value_oneof_value::meta(ref v)) => v,
            _ => Meta::default_instance(),
        }
    }
}

impl ::protobuf::Message for Extension_Value {
    fn is_initialized(&self) -> bool {
        if let Some(Extension_Value_oneof_value::base64_binary(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::boolean(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::code(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::date(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::date_time(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::decimal(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::id(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::instant(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::integer(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::markdown(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::oid(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::positive_int(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::string_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::time(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::unsigned_int(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::uri(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::address(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::age(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::annotation(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::attachment(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::codeable_concept(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::coding(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::contact_point(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::count(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::distance(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::duration(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::human_name(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::identifier(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::money(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::period(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::quantity(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::range(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::ratio(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::reference(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::sampled_data(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::signature(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::timing(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Extension_Value_oneof_value::meta(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::base64_binary(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::boolean(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::code(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::date(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::date_time(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::decimal(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::id(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::instant(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::integer(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::markdown(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::oid(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::positive_int(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::string_value(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::time(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::unsigned_int(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::uri(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::address(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::age(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::annotation(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::attachment(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::codeable_concept(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::coding(is.read_message()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::contact_point(is.read_message()?));
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::count(is.read_message()?));
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::distance(is.read_message()?));
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::duration(is.read_message()?));
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::human_name(is.read_message()?));
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::identifier(is.read_message()?));
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::money(is.read_message()?));
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::period(is.read_message()?));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::quantity(is.read_message()?));
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::range(is.read_message()?));
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::ratio(is.read_message()?));
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::reference(is.read_message()?));
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::sampled_data(is.read_message()?));
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::signature(is.read_message()?));
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::timing(is.read_message()?));
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Extension_Value_oneof_value::meta(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Extension_Value_oneof_value::base64_binary(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::boolean(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::code(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::date(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::date_time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::decimal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::instant(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::integer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::markdown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::oid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::positive_int(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::string_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::unsigned_int(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::uri(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::address(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::age(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::annotation(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::attachment(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::codeable_concept(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::coding(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::contact_point(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::count(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::distance(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::duration(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::human_name(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::identifier(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::money(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::period(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::quantity(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::range(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::ratio(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::reference(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::sampled_data(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::signature(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::timing(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Extension_Value_oneof_value::meta(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Extension_Value_oneof_value::base64_binary(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::boolean(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::code(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::date(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::date_time(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::decimal(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::id(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::instant(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::integer(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::markdown(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::oid(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::positive_int(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::string_value(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::time(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::unsigned_int(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::uri(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::address(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::age(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::annotation(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::attachment(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::codeable_concept(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::coding(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::contact_point(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::count(ref v) => {
                    os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::distance(ref v) => {
                    os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::duration(ref v) => {
                    os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::human_name(ref v) => {
                    os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::identifier(ref v) => {
                    os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::money(ref v) => {
                    os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::period(ref v) => {
                    os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::quantity(ref v) => {
                    os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::range(ref v) => {
                    os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::ratio(ref v) => {
                    os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::reference(ref v) => {
                    os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::sampled_data(ref v) => {
                    os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::signature(ref v) => {
                    os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::timing(ref v) => {
                    os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Extension_Value_oneof_value::meta(ref v) => {
                    os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Extension_Value {
        Extension_Value::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Base64Binary>(
                    "base64_binary",
                    Extension_Value::has_base64_binary,
                    Extension_Value::get_base64_binary,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Boolean>(
                    "boolean",
                    Extension_Value::has_boolean,
                    Extension_Value::get_boolean,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Code>(
                    "code",
                    Extension_Value::has_code,
                    Extension_Value::get_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Date>(
                    "date",
                    Extension_Value::has_date,
                    Extension_Value::get_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DateTime>(
                    "date_time",
                    Extension_Value::has_date_time,
                    Extension_Value::get_date_time,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Decimal>(
                    "decimal",
                    Extension_Value::has_decimal,
                    Extension_Value::get_decimal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Id>(
                    "id",
                    Extension_Value::has_id,
                    Extension_Value::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Instant>(
                    "instant",
                    Extension_Value::has_instant,
                    Extension_Value::get_instant,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Integer>(
                    "integer",
                    Extension_Value::has_integer,
                    Extension_Value::get_integer,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Markdown>(
                    "markdown",
                    Extension_Value::has_markdown,
                    Extension_Value::get_markdown,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Oid>(
                    "oid",
                    Extension_Value::has_oid,
                    Extension_Value::get_oid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, PositiveInt>(
                    "positive_int",
                    Extension_Value::has_positive_int,
                    Extension_Value::get_positive_int,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, String>(
                    "string_value",
                    Extension_Value::has_string_value,
                    Extension_Value::get_string_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Time>(
                    "time",
                    Extension_Value::has_time,
                    Extension_Value::get_time,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, UnsignedInt>(
                    "unsigned_int",
                    Extension_Value::has_unsigned_int,
                    Extension_Value::get_unsigned_int,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Uri>(
                    "uri",
                    Extension_Value::has_uri,
                    Extension_Value::get_uri,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Address>(
                    "address",
                    Extension_Value::has_address,
                    Extension_Value::get_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Age>(
                    "age",
                    Extension_Value::has_age,
                    Extension_Value::get_age,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Annotation>(
                    "annotation",
                    Extension_Value::has_annotation,
                    Extension_Value::get_annotation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Attachment>(
                    "attachment",
                    Extension_Value::has_attachment,
                    Extension_Value::get_attachment,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CodeableConcept>(
                    "codeable_concept",
                    Extension_Value::has_codeable_concept,
                    Extension_Value::get_codeable_concept,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Coding>(
                    "coding",
                    Extension_Value::has_coding,
                    Extension_Value::get_coding,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ContactPoint>(
                    "contact_point",
                    Extension_Value::has_contact_point,
                    Extension_Value::get_contact_point,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Count>(
                    "count",
                    Extension_Value::has_count,
                    Extension_Value::get_count,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Distance>(
                    "distance",
                    Extension_Value::has_distance,
                    Extension_Value::get_distance,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Duration>(
                    "duration",
                    Extension_Value::has_duration,
                    Extension_Value::get_duration,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HumanName>(
                    "human_name",
                    Extension_Value::has_human_name,
                    Extension_Value::get_human_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Identifier>(
                    "identifier",
                    Extension_Value::has_identifier,
                    Extension_Value::get_identifier,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Money>(
                    "money",
                    Extension_Value::has_money,
                    Extension_Value::get_money,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Period>(
                    "period",
                    Extension_Value::has_period,
                    Extension_Value::get_period,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Quantity>(
                    "quantity",
                    Extension_Value::has_quantity,
                    Extension_Value::get_quantity,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Range>(
                    "range",
                    Extension_Value::has_range,
                    Extension_Value::get_range,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Ratio>(
                    "ratio",
                    Extension_Value::has_ratio,
                    Extension_Value::get_ratio,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Reference>(
                    "reference",
                    Extension_Value::has_reference,
                    Extension_Value::get_reference,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SampledData>(
                    "sampled_data",
                    Extension_Value::has_sampled_data,
                    Extension_Value::get_sampled_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Signature>(
                    "signature",
                    Extension_Value::has_signature,
                    Extension_Value::get_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Timing>(
                    "timing",
                    Extension_Value::has_timing,
                    Extension_Value::get_timing,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Meta>(
                    "meta",
                    Extension_Value::has_meta,
                    Extension_Value::get_meta,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Extension_Value>(
                    "Extension_Value",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Extension_Value {
        static mut instance: ::protobuf::lazy::Lazy<Extension_Value> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Extension_Value,
        };
        unsafe {
            instance.get(Extension_Value::new)
        }
    }
}

impl ::protobuf::Clear for Extension_Value {
    fn clear(&mut self) {
        self.clear_base64_binary();
        self.clear_boolean();
        self.clear_code();
        self.clear_date();
        self.clear_date_time();
        self.clear_decimal();
        self.clear_id();
        self.clear_instant();
        self.clear_integer();
        self.clear_markdown();
        self.clear_oid();
        self.clear_positive_int();
        self.clear_string_value();
        self.clear_time();
        self.clear_unsigned_int();
        self.clear_uri();
        self.clear_address();
        self.clear_age();
        self.clear_annotation();
        self.clear_attachment();
        self.clear_codeable_concept();
        self.clear_coding();
        self.clear_contact_point();
        self.clear_count();
        self.clear_distance();
        self.clear_duration();
        self.clear_human_name();
        self.clear_identifier();
        self.clear_money();
        self.clear_period();
        self.clear_quantity();
        self.clear_range();
        self.clear_ratio();
        self.clear_reference();
        self.clear_sampled_data();
        self.clear_signature();
        self.clear_timing();
        self.clear_meta();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Extension_Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Extension_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CodingWithFixedSystem {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub version: ::protobuf::SingularPtrField<String>,
    pub code: ::protobuf::SingularPtrField<Code>,
    pub display: ::protobuf::SingularPtrField<String>,
    pub user_selected: ::protobuf::SingularPtrField<Boolean>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CodingWithFixedSystem {
    pub fn new() -> CodingWithFixedSystem {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.String version = 4;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: String) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> String {
        self.version.take().unwrap_or_else(|| String::new())
    }

    pub fn get_version(&self) -> &String {
        self.version.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Code code = 5;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Code) {
        self.code = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut Code {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> Code {
        self.code.take().unwrap_or_else(|| Code::new())
    }

    pub fn get_code(&self) -> &Code {
        self.code.as_ref().unwrap_or_else(|| Code::default_instance())
    }

    // .google.fhir.stu3.proto.String display = 6;

    pub fn clear_display(&mut self) {
        self.display.clear();
    }

    pub fn has_display(&self) -> bool {
        self.display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display(&mut self, v: String) {
        self.display = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display(&mut self) -> &mut String {
        if self.display.is_none() {
            self.display.set_default();
        }
        self.display.as_mut().unwrap()
    }

    // Take field
    pub fn take_display(&mut self) -> String {
        self.display.take().unwrap_or_else(|| String::new())
    }

    pub fn get_display(&self) -> &String {
        self.display.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Boolean user_selected = 7;

    pub fn clear_user_selected(&mut self) {
        self.user_selected.clear();
    }

    pub fn has_user_selected(&self) -> bool {
        self.user_selected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_selected(&mut self, v: Boolean) {
        self.user_selected = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_selected(&mut self) -> &mut Boolean {
        if self.user_selected.is_none() {
            self.user_selected.set_default();
        }
        self.user_selected.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_selected(&mut self) -> Boolean {
        self.user_selected.take().unwrap_or_else(|| Boolean::new())
    }

    pub fn get_user_selected(&self) -> &Boolean {
        self.user_selected.as_ref().unwrap_or_else(|| Boolean::default_instance())
    }
}

impl ::protobuf::Message for CodingWithFixedSystem {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.code {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.display {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_selected {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.display)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_selected)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.display.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user_selected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.version.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.code.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.display.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user_selected.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodingWithFixedSystem {
        CodingWithFixedSystem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &CodingWithFixedSystem| { &m.id },
                    |m: &mut CodingWithFixedSystem| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &CodingWithFixedSystem| { &m.extension },
                    |m: &mut CodingWithFixedSystem| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "version",
                    |m: &CodingWithFixedSystem| { &m.version },
                    |m: &mut CodingWithFixedSystem| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Code>>(
                    "code",
                    |m: &CodingWithFixedSystem| { &m.code },
                    |m: &mut CodingWithFixedSystem| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "display",
                    |m: &CodingWithFixedSystem| { &m.display },
                    |m: &mut CodingWithFixedSystem| { &mut m.display },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Boolean>>(
                    "user_selected",
                    |m: &CodingWithFixedSystem| { &m.user_selected },
                    |m: &mut CodingWithFixedSystem| { &mut m.user_selected },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CodingWithFixedSystem>(
                    "CodingWithFixedSystem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CodingWithFixedSystem {
        static mut instance: ::protobuf::lazy::Lazy<CodingWithFixedSystem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CodingWithFixedSystem,
        };
        unsafe {
            instance.get(CodingWithFixedSystem::new)
        }
    }
}

impl ::protobuf::Clear for CodingWithFixedSystem {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_version();
        self.clear_code();
        self.clear_display();
        self.clear_user_selected();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodingWithFixedSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodingWithFixedSystem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CodingWithFixedCode {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub version: ::protobuf::SingularPtrField<String>,
    pub display: ::protobuf::SingularPtrField<String>,
    pub user_selected: ::protobuf::SingularPtrField<Boolean>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CodingWithFixedCode {
    pub fn new() -> CodingWithFixedCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.String version = 4;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: String) {
        self.version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> String {
        self.version.take().unwrap_or_else(|| String::new())
    }

    pub fn get_version(&self) -> &String {
        self.version.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.String display = 6;

    pub fn clear_display(&mut self) {
        self.display.clear();
    }

    pub fn has_display(&self) -> bool {
        self.display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display(&mut self, v: String) {
        self.display = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display(&mut self) -> &mut String {
        if self.display.is_none() {
            self.display.set_default();
        }
        self.display.as_mut().unwrap()
    }

    // Take field
    pub fn take_display(&mut self) -> String {
        self.display.take().unwrap_or_else(|| String::new())
    }

    pub fn get_display(&self) -> &String {
        self.display.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // .google.fhir.stu3.proto.Boolean user_selected = 7;

    pub fn clear_user_selected(&mut self) {
        self.user_selected.clear();
    }

    pub fn has_user_selected(&self) -> bool {
        self.user_selected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_selected(&mut self, v: Boolean) {
        self.user_selected = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_selected(&mut self) -> &mut Boolean {
        if self.user_selected.is_none() {
            self.user_selected.set_default();
        }
        self.user_selected.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_selected(&mut self) -> Boolean {
        self.user_selected.take().unwrap_or_else(|| Boolean::new())
    }

    pub fn get_user_selected(&self) -> &Boolean {
        self.user_selected.as_ref().unwrap_or_else(|| Boolean::default_instance())
    }
}

impl ::protobuf::Message for CodingWithFixedCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.version {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.display {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user_selected {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.display)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_selected)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.display.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user_selected.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.version.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.display.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user_selected.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodingWithFixedCode {
        CodingWithFixedCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &CodingWithFixedCode| { &m.id },
                    |m: &mut CodingWithFixedCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &CodingWithFixedCode| { &m.extension },
                    |m: &mut CodingWithFixedCode| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "version",
                    |m: &CodingWithFixedCode| { &m.version },
                    |m: &mut CodingWithFixedCode| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "display",
                    |m: &CodingWithFixedCode| { &m.display },
                    |m: &mut CodingWithFixedCode| { &mut m.display },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Boolean>>(
                    "user_selected",
                    |m: &CodingWithFixedCode| { &m.user_selected },
                    |m: &mut CodingWithFixedCode| { &mut m.user_selected },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CodingWithFixedCode>(
                    "CodingWithFixedCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CodingWithFixedCode {
        static mut instance: ::protobuf::lazy::Lazy<CodingWithFixedCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CodingWithFixedCode,
        };
        unsafe {
            instance.get(CodingWithFixedCode::new)
        }
    }
}

impl ::protobuf::Clear for CodingWithFixedCode {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_version();
        self.clear_display();
        self.clear_user_selected();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodingWithFixedCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodingWithFixedCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Reference {
    // message fields
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    pub identifier: ::protobuf::SingularPtrField<Identifier>,
    pub display: ::protobuf::SingularPtrField<String>,
    // message oneof groups
    pub reference: ::std::option::Option<Reference_oneof_reference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Reference_oneof_reference {
    uri(String),
    fragment(String),
    account_id(ReferenceId),
    activity_definition_id(ReferenceId),
    adverse_event_id(ReferenceId),
    allergy_intolerance_id(ReferenceId),
    appointment_id(ReferenceId),
    appointment_response_id(ReferenceId),
    audit_event_id(ReferenceId),
    basic_id(ReferenceId),
    binary_id(ReferenceId),
    body_site_id(ReferenceId),
    bundle_id(ReferenceId),
    capability_statement_id(ReferenceId),
    care_plan_id(ReferenceId),
    care_team_id(ReferenceId),
    charge_item_id(ReferenceId),
    claim_id(ReferenceId),
    claim_response_id(ReferenceId),
    clinical_impression_id(ReferenceId),
    code_system_id(ReferenceId),
    communication_id(ReferenceId),
    communication_request_id(ReferenceId),
    compartment_definition_id(ReferenceId),
    composition_id(ReferenceId),
    concept_map_id(ReferenceId),
    condition_id(ReferenceId),
    consent_id(ReferenceId),
    contract_id(ReferenceId),
    coverage_id(ReferenceId),
    data_element_id(ReferenceId),
    detected_issue_id(ReferenceId),
    device_id(ReferenceId),
    device_component_id(ReferenceId),
    device_metric_id(ReferenceId),
    device_request_id(ReferenceId),
    device_usestatement_id(ReferenceId),
    diagnostic_report_id(ReferenceId),
    document_manifest_id(ReferenceId),
    document_reference_id(ReferenceId),
    eligibility_request_id(ReferenceId),
    eligibility_response_id(ReferenceId),
    encounter_id(ReferenceId),
    endpoint_id(ReferenceId),
    enrollment_request_id(ReferenceId),
    enrollment_response_id(ReferenceId),
    episode_ofcare_id(ReferenceId),
    expansion_profile_id(ReferenceId),
    explanation_ofbenefit_id(ReferenceId),
    family_memberhistory_id(ReferenceId),
    flag_id(ReferenceId),
    goal_id(ReferenceId),
    graph_definition_id(ReferenceId),
    group_id(ReferenceId),
    guidance_response_id(ReferenceId),
    healthcare_service_id(ReferenceId),
    imaging_manifest_id(ReferenceId),
    imaging_study_id(ReferenceId),
    immunization_id(ReferenceId),
    immunization_recommendation_id(ReferenceId),
    implementation_guide_id(ReferenceId),
    library_id(ReferenceId),
    linkage_id(ReferenceId),
    list_id(ReferenceId),
    location_id(ReferenceId),
    measure_id(ReferenceId),
    measure_report_id(ReferenceId),
    media_id(ReferenceId),
    medication_id(ReferenceId),
    medication_administration_id(ReferenceId),
    medication_dispense_id(ReferenceId),
    medication_request_id(ReferenceId),
    medication_statement_id(ReferenceId),
    message_definition_id(ReferenceId),
    message_header_id(ReferenceId),
    naming_system_id(ReferenceId),
    nutrition_order_id(ReferenceId),
    observation_id(ReferenceId),
    operation_definition_id(ReferenceId),
    operation_outcome_id(ReferenceId),
    organization_id(ReferenceId),
    parameters_id(ReferenceId),
    patient_id(ReferenceId),
    payment_notice_id(ReferenceId),
    payment_reconciliation_id(ReferenceId),
    person_id(ReferenceId),
    plan_definition_id(ReferenceId),
    practitioner_id(ReferenceId),
    practitioner_role_id(ReferenceId),
    procedure_id(ReferenceId),
    procedure_request_id(ReferenceId),
    process_request_id(ReferenceId),
    process_response_id(ReferenceId),
    provenance_id(ReferenceId),
    questionnaire_id(ReferenceId),
    questionnaire_response_id(ReferenceId),
    referral_request_id(ReferenceId),
    related_person_id(ReferenceId),
    request_group_id(ReferenceId),
    research_study_id(ReferenceId),
    research_subject_id(ReferenceId),
    risk_assessment_id(ReferenceId),
    schedule_id(ReferenceId),
    search_parameter_id(ReferenceId),
    sequence_id(ReferenceId),
    service_definition_id(ReferenceId),
    slot_id(ReferenceId),
    specimen_id(ReferenceId),
    structure_definition_id(ReferenceId),
    structure_map_id(ReferenceId),
    subscription_id(ReferenceId),
    substance_id(ReferenceId),
    supply_delivery_id(ReferenceId),
    supply_request_id(ReferenceId),
    task_id(ReferenceId),
    test_report_id(ReferenceId),
    test_script_id(ReferenceId),
    value_set_id(ReferenceId),
    vision_prescription_id(ReferenceId),
}

impl Reference {
    pub fn new() -> Reference {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.String id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 2;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }

    // .google.fhir.stu3.proto.String uri = 3;

    pub fn clear_uri(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_uri(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::uri(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: String) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::uri(v))
    }

    // Mutable pointer to the field.
    pub fn mut_uri(&mut self) -> &mut String {
        if let ::std::option::Option::Some(Reference_oneof_reference::uri(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::uri(String::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::uri(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_uri(&mut self) -> String {
        if self.has_uri() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::uri(v)) => v,
                _ => panic!(),
            }
        } else {
            String::new()
        }
    }

    pub fn get_uri(&self) -> &String {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::uri(ref v)) => v,
            _ => String::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.String fragment = 4;

    pub fn clear_fragment(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_fragment(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::fragment(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fragment(&mut self, v: String) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::fragment(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fragment(&mut self) -> &mut String {
        if let ::std::option::Option::Some(Reference_oneof_reference::fragment(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::fragment(String::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::fragment(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fragment(&mut self) -> String {
        if self.has_fragment() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::fragment(v)) => v,
                _ => panic!(),
            }
        } else {
            String::new()
        }
    }

    pub fn get_fragment(&self) -> &String {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::fragment(ref v)) => v,
            _ => String::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId account_id = 5;

    pub fn clear_account_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::account_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::account_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_account_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::account_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::account_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::account_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_account_id(&mut self) -> ReferenceId {
        if self.has_account_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::account_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_account_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::account_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId activity_definition_id = 6;

    pub fn clear_activity_definition_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_activity_definition_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::activity_definition_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_activity_definition_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::activity_definition_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_activity_definition_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::activity_definition_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::activity_definition_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::activity_definition_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_activity_definition_id(&mut self) -> ReferenceId {
        if self.has_activity_definition_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::activity_definition_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_activity_definition_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::activity_definition_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId adverse_event_id = 7;

    pub fn clear_adverse_event_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_adverse_event_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::adverse_event_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_adverse_event_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::adverse_event_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_adverse_event_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::adverse_event_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::adverse_event_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::adverse_event_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_adverse_event_id(&mut self) -> ReferenceId {
        if self.has_adverse_event_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::adverse_event_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_adverse_event_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::adverse_event_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId allergy_intolerance_id = 8;

    pub fn clear_allergy_intolerance_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_allergy_intolerance_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::allergy_intolerance_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_allergy_intolerance_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::allergy_intolerance_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_allergy_intolerance_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::allergy_intolerance_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::allergy_intolerance_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::allergy_intolerance_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_allergy_intolerance_id(&mut self) -> ReferenceId {
        if self.has_allergy_intolerance_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::allergy_intolerance_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_allergy_intolerance_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::allergy_intolerance_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId appointment_id = 9;

    pub fn clear_appointment_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_appointment_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::appointment_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_appointment_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::appointment_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_appointment_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::appointment_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::appointment_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::appointment_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_appointment_id(&mut self) -> ReferenceId {
        if self.has_appointment_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::appointment_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_appointment_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::appointment_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId appointment_response_id = 10;

    pub fn clear_appointment_response_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_appointment_response_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::appointment_response_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_appointment_response_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::appointment_response_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_appointment_response_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::appointment_response_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::appointment_response_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::appointment_response_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_appointment_response_id(&mut self) -> ReferenceId {
        if self.has_appointment_response_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::appointment_response_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_appointment_response_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::appointment_response_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId audit_event_id = 11;

    pub fn clear_audit_event_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_audit_event_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::audit_event_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audit_event_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::audit_event_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audit_event_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::audit_event_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::audit_event_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::audit_event_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audit_event_id(&mut self) -> ReferenceId {
        if self.has_audit_event_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::audit_event_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_audit_event_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::audit_event_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId basic_id = 12;

    pub fn clear_basic_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_basic_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::basic_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_basic_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::basic_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_basic_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::basic_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::basic_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::basic_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_basic_id(&mut self) -> ReferenceId {
        if self.has_basic_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::basic_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_basic_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::basic_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId binary_id = 13;

    pub fn clear_binary_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_binary_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::binary_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_binary_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::binary_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_binary_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::binary_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::binary_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::binary_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_binary_id(&mut self) -> ReferenceId {
        if self.has_binary_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::binary_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_binary_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::binary_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId body_site_id = 14;

    pub fn clear_body_site_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_body_site_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::body_site_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_body_site_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::body_site_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_body_site_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::body_site_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::body_site_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::body_site_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_body_site_id(&mut self) -> ReferenceId {
        if self.has_body_site_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::body_site_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_body_site_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::body_site_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId bundle_id = 15;

    pub fn clear_bundle_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_bundle_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::bundle_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bundle_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::bundle_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bundle_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::bundle_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::bundle_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::bundle_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bundle_id(&mut self) -> ReferenceId {
        if self.has_bundle_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::bundle_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_bundle_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::bundle_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId capability_statement_id = 16;

    pub fn clear_capability_statement_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_capability_statement_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::capability_statement_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_capability_statement_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::capability_statement_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_capability_statement_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::capability_statement_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::capability_statement_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::capability_statement_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_capability_statement_id(&mut self) -> ReferenceId {
        if self.has_capability_statement_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::capability_statement_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_capability_statement_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::capability_statement_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId care_plan_id = 17;

    pub fn clear_care_plan_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_care_plan_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::care_plan_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_care_plan_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::care_plan_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_care_plan_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::care_plan_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::care_plan_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::care_plan_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_care_plan_id(&mut self) -> ReferenceId {
        if self.has_care_plan_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::care_plan_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_care_plan_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::care_plan_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId care_team_id = 18;

    pub fn clear_care_team_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_care_team_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::care_team_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_care_team_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::care_team_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_care_team_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::care_team_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::care_team_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::care_team_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_care_team_id(&mut self) -> ReferenceId {
        if self.has_care_team_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::care_team_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_care_team_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::care_team_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId charge_item_id = 19;

    pub fn clear_charge_item_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_charge_item_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::charge_item_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_charge_item_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::charge_item_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_charge_item_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::charge_item_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::charge_item_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::charge_item_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_charge_item_id(&mut self) -> ReferenceId {
        if self.has_charge_item_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::charge_item_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_charge_item_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::charge_item_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId claim_id = 20;

    pub fn clear_claim_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_claim_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::claim_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_claim_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::claim_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_claim_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::claim_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::claim_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::claim_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_claim_id(&mut self) -> ReferenceId {
        if self.has_claim_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::claim_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_claim_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::claim_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId claim_response_id = 21;

    pub fn clear_claim_response_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_claim_response_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::claim_response_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_claim_response_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::claim_response_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_claim_response_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::claim_response_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::claim_response_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::claim_response_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_claim_response_id(&mut self) -> ReferenceId {
        if self.has_claim_response_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::claim_response_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_claim_response_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::claim_response_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId clinical_impression_id = 22;

    pub fn clear_clinical_impression_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_clinical_impression_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::clinical_impression_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clinical_impression_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::clinical_impression_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_clinical_impression_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::clinical_impression_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::clinical_impression_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::clinical_impression_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_clinical_impression_id(&mut self) -> ReferenceId {
        if self.has_clinical_impression_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::clinical_impression_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_clinical_impression_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::clinical_impression_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId code_system_id = 23;

    pub fn clear_code_system_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_code_system_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::code_system_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_code_system_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::code_system_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_code_system_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::code_system_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::code_system_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::code_system_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_code_system_id(&mut self) -> ReferenceId {
        if self.has_code_system_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::code_system_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_code_system_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::code_system_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId communication_id = 24;

    pub fn clear_communication_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_communication_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::communication_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_communication_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::communication_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_communication_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::communication_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::communication_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::communication_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_communication_id(&mut self) -> ReferenceId {
        if self.has_communication_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::communication_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_communication_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::communication_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId communication_request_id = 25;

    pub fn clear_communication_request_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_communication_request_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::communication_request_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_communication_request_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::communication_request_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_communication_request_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::communication_request_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::communication_request_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::communication_request_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_communication_request_id(&mut self) -> ReferenceId {
        if self.has_communication_request_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::communication_request_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_communication_request_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::communication_request_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId compartment_definition_id = 26;

    pub fn clear_compartment_definition_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_compartment_definition_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::compartment_definition_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_compartment_definition_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::compartment_definition_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_compartment_definition_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::compartment_definition_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::compartment_definition_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::compartment_definition_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_compartment_definition_id(&mut self) -> ReferenceId {
        if self.has_compartment_definition_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::compartment_definition_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_compartment_definition_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::compartment_definition_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId composition_id = 27;

    pub fn clear_composition_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_composition_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::composition_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_composition_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::composition_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_composition_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::composition_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::composition_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::composition_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_composition_id(&mut self) -> ReferenceId {
        if self.has_composition_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::composition_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_composition_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::composition_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId concept_map_id = 28;

    pub fn clear_concept_map_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_concept_map_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::concept_map_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_concept_map_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::concept_map_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_concept_map_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::concept_map_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::concept_map_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::concept_map_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_concept_map_id(&mut self) -> ReferenceId {
        if self.has_concept_map_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::concept_map_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_concept_map_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::concept_map_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId condition_id = 29;

    pub fn clear_condition_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_condition_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::condition_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_condition_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::condition_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_condition_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::condition_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::condition_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::condition_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_condition_id(&mut self) -> ReferenceId {
        if self.has_condition_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::condition_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_condition_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::condition_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId consent_id = 30;

    pub fn clear_consent_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_consent_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::consent_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_consent_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::consent_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_consent_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::consent_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::consent_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::consent_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_consent_id(&mut self) -> ReferenceId {
        if self.has_consent_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::consent_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_consent_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::consent_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId contract_id = 31;

    pub fn clear_contract_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_contract_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::contract_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contract_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::contract_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contract_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::contract_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::contract_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::contract_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contract_id(&mut self) -> ReferenceId {
        if self.has_contract_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::contract_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_contract_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::contract_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId coverage_id = 32;

    pub fn clear_coverage_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_coverage_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::coverage_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_coverage_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::coverage_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_coverage_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::coverage_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::coverage_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::coverage_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_coverage_id(&mut self) -> ReferenceId {
        if self.has_coverage_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::coverage_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_coverage_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::coverage_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId data_element_id = 33;

    pub fn clear_data_element_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_data_element_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::data_element_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data_element_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::data_element_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data_element_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::data_element_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::data_element_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::data_element_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data_element_id(&mut self) -> ReferenceId {
        if self.has_data_element_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::data_element_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_data_element_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::data_element_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId detected_issue_id = 34;

    pub fn clear_detected_issue_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_detected_issue_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::detected_issue_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_detected_issue_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::detected_issue_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_detected_issue_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::detected_issue_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::detected_issue_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::detected_issue_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_detected_issue_id(&mut self) -> ReferenceId {
        if self.has_detected_issue_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::detected_issue_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_detected_issue_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::detected_issue_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId device_id = 35;

    pub fn clear_device_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::device_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_id(&mut self) -> ReferenceId {
        if self.has_device_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::device_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_device_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId device_component_id = 36;

    pub fn clear_device_component_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_device_component_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_component_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_component_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_component_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_component_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::device_component_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_component_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_component_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_component_id(&mut self) -> ReferenceId {
        if self.has_device_component_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::device_component_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_device_component_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_component_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId device_metric_id = 37;

    pub fn clear_device_metric_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_device_metric_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_metric_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_metric_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_metric_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_metric_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::device_metric_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_metric_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_metric_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_metric_id(&mut self) -> ReferenceId {
        if self.has_device_metric_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::device_metric_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_device_metric_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_metric_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId device_request_id = 38;

    pub fn clear_device_request_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_device_request_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_request_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_request_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_request_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_request_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::device_request_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_request_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_request_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_request_id(&mut self) -> ReferenceId {
        if self.has_device_request_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::device_request_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_device_request_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_request_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId device_usestatement_id = 39;

    pub fn clear_device_usestatement_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_device_usestatement_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_usestatement_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_usestatement_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_usestatement_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_usestatement_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::device_usestatement_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_usestatement_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_usestatement_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_usestatement_id(&mut self) -> ReferenceId {
        if self.has_device_usestatement_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::device_usestatement_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_device_usestatement_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::device_usestatement_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId diagnostic_report_id = 40;

    pub fn clear_diagnostic_report_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_diagnostic_report_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::diagnostic_report_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_diagnostic_report_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::diagnostic_report_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_diagnostic_report_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::diagnostic_report_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::diagnostic_report_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::diagnostic_report_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_diagnostic_report_id(&mut self) -> ReferenceId {
        if self.has_diagnostic_report_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::diagnostic_report_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_diagnostic_report_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::diagnostic_report_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId document_manifest_id = 41;

    pub fn clear_document_manifest_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_document_manifest_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::document_manifest_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_document_manifest_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::document_manifest_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_document_manifest_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::document_manifest_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::document_manifest_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::document_manifest_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_document_manifest_id(&mut self) -> ReferenceId {
        if self.has_document_manifest_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::document_manifest_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_document_manifest_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::document_manifest_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId document_reference_id = 42;

    pub fn clear_document_reference_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_document_reference_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::document_reference_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_document_reference_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::document_reference_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_document_reference_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::document_reference_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::document_reference_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::document_reference_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_document_reference_id(&mut self) -> ReferenceId {
        if self.has_document_reference_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::document_reference_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_document_reference_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::document_reference_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId eligibility_request_id = 43;

    pub fn clear_eligibility_request_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_eligibility_request_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::eligibility_request_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_eligibility_request_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::eligibility_request_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_eligibility_request_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::eligibility_request_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::eligibility_request_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::eligibility_request_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_eligibility_request_id(&mut self) -> ReferenceId {
        if self.has_eligibility_request_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::eligibility_request_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_eligibility_request_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::eligibility_request_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId eligibility_response_id = 44;

    pub fn clear_eligibility_response_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_eligibility_response_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::eligibility_response_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_eligibility_response_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::eligibility_response_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_eligibility_response_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::eligibility_response_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::eligibility_response_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::eligibility_response_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_eligibility_response_id(&mut self) -> ReferenceId {
        if self.has_eligibility_response_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::eligibility_response_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_eligibility_response_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::eligibility_response_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId encounter_id = 45;

    pub fn clear_encounter_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_encounter_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::encounter_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_encounter_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::encounter_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_encounter_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::encounter_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::encounter_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::encounter_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_encounter_id(&mut self) -> ReferenceId {
        if self.has_encounter_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::encounter_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_encounter_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::encounter_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId endpoint_id = 46;

    pub fn clear_endpoint_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_endpoint_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::endpoint_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_endpoint_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::endpoint_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_endpoint_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::endpoint_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::endpoint_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::endpoint_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_endpoint_id(&mut self) -> ReferenceId {
        if self.has_endpoint_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::endpoint_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_endpoint_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::endpoint_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId enrollment_request_id = 47;

    pub fn clear_enrollment_request_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_enrollment_request_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::enrollment_request_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enrollment_request_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::enrollment_request_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enrollment_request_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::enrollment_request_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::enrollment_request_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::enrollment_request_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enrollment_request_id(&mut self) -> ReferenceId {
        if self.has_enrollment_request_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::enrollment_request_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_enrollment_request_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::enrollment_request_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId enrollment_response_id = 48;

    pub fn clear_enrollment_response_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_enrollment_response_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::enrollment_response_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enrollment_response_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::enrollment_response_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enrollment_response_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::enrollment_response_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::enrollment_response_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::enrollment_response_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enrollment_response_id(&mut self) -> ReferenceId {
        if self.has_enrollment_response_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::enrollment_response_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_enrollment_response_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::enrollment_response_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId episode_ofcare_id = 49;

    pub fn clear_episode_ofcare_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_episode_ofcare_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::episode_ofcare_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_episode_ofcare_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::episode_ofcare_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_episode_ofcare_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::episode_ofcare_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::episode_ofcare_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::episode_ofcare_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_episode_ofcare_id(&mut self) -> ReferenceId {
        if self.has_episode_ofcare_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::episode_ofcare_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_episode_ofcare_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::episode_ofcare_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId expansion_profile_id = 50;

    pub fn clear_expansion_profile_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_expansion_profile_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::expansion_profile_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_expansion_profile_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::expansion_profile_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_expansion_profile_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::expansion_profile_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::expansion_profile_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::expansion_profile_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_expansion_profile_id(&mut self) -> ReferenceId {
        if self.has_expansion_profile_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::expansion_profile_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_expansion_profile_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::expansion_profile_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId explanation_ofbenefit_id = 51;

    pub fn clear_explanation_ofbenefit_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_explanation_ofbenefit_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::explanation_ofbenefit_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_explanation_ofbenefit_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::explanation_ofbenefit_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_explanation_ofbenefit_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::explanation_ofbenefit_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::explanation_ofbenefit_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::explanation_ofbenefit_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_explanation_ofbenefit_id(&mut self) -> ReferenceId {
        if self.has_explanation_ofbenefit_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::explanation_ofbenefit_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_explanation_ofbenefit_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::explanation_ofbenefit_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId family_memberhistory_id = 52;

    pub fn clear_family_memberhistory_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_family_memberhistory_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::family_memberhistory_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_family_memberhistory_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::family_memberhistory_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_family_memberhistory_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::family_memberhistory_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::family_memberhistory_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::family_memberhistory_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_family_memberhistory_id(&mut self) -> ReferenceId {
        if self.has_family_memberhistory_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::family_memberhistory_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_family_memberhistory_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::family_memberhistory_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId flag_id = 53;

    pub fn clear_flag_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_flag_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::flag_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_flag_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::flag_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_flag_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::flag_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::flag_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::flag_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_flag_id(&mut self) -> ReferenceId {
        if self.has_flag_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::flag_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_flag_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::flag_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId goal_id = 54;

    pub fn clear_goal_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_goal_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::goal_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_goal_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::goal_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_goal_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::goal_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::goal_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::goal_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_goal_id(&mut self) -> ReferenceId {
        if self.has_goal_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::goal_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_goal_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::goal_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId graph_definition_id = 55;

    pub fn clear_graph_definition_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_graph_definition_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::graph_definition_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_graph_definition_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::graph_definition_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_graph_definition_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::graph_definition_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::graph_definition_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::graph_definition_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_graph_definition_id(&mut self) -> ReferenceId {
        if self.has_graph_definition_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::graph_definition_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_graph_definition_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::graph_definition_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId group_id = 56;

    pub fn clear_group_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::group_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::group_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_group_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::group_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::group_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::group_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_group_id(&mut self) -> ReferenceId {
        if self.has_group_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::group_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_group_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::group_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId guidance_response_id = 57;

    pub fn clear_guidance_response_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_guidance_response_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::guidance_response_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_guidance_response_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::guidance_response_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_guidance_response_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::guidance_response_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::guidance_response_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::guidance_response_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_guidance_response_id(&mut self) -> ReferenceId {
        if self.has_guidance_response_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::guidance_response_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_guidance_response_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::guidance_response_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId healthcare_service_id = 58;

    pub fn clear_healthcare_service_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_healthcare_service_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::healthcare_service_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_healthcare_service_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::healthcare_service_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_healthcare_service_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::healthcare_service_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::healthcare_service_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::healthcare_service_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_healthcare_service_id(&mut self) -> ReferenceId {
        if self.has_healthcare_service_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::healthcare_service_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_healthcare_service_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::healthcare_service_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId imaging_manifest_id = 59;

    pub fn clear_imaging_manifest_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_imaging_manifest_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::imaging_manifest_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_imaging_manifest_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::imaging_manifest_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_imaging_manifest_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::imaging_manifest_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::imaging_manifest_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::imaging_manifest_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_imaging_manifest_id(&mut self) -> ReferenceId {
        if self.has_imaging_manifest_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::imaging_manifest_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_imaging_manifest_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::imaging_manifest_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId imaging_study_id = 60;

    pub fn clear_imaging_study_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_imaging_study_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::imaging_study_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_imaging_study_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::imaging_study_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_imaging_study_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::imaging_study_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::imaging_study_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::imaging_study_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_imaging_study_id(&mut self) -> ReferenceId {
        if self.has_imaging_study_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::imaging_study_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_imaging_study_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::imaging_study_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId immunization_id = 61;

    pub fn clear_immunization_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_immunization_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::immunization_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_immunization_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::immunization_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_immunization_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::immunization_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::immunization_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::immunization_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_immunization_id(&mut self) -> ReferenceId {
        if self.has_immunization_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::immunization_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_immunization_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::immunization_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId immunization_recommendation_id = 62;

    pub fn clear_immunization_recommendation_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_immunization_recommendation_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::immunization_recommendation_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_immunization_recommendation_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::immunization_recommendation_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_immunization_recommendation_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::immunization_recommendation_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::immunization_recommendation_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::immunization_recommendation_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_immunization_recommendation_id(&mut self) -> ReferenceId {
        if self.has_immunization_recommendation_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::immunization_recommendation_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_immunization_recommendation_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::immunization_recommendation_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId implementation_guide_id = 63;

    pub fn clear_implementation_guide_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_implementation_guide_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::implementation_guide_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_implementation_guide_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::implementation_guide_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_implementation_guide_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::implementation_guide_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::implementation_guide_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::implementation_guide_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_implementation_guide_id(&mut self) -> ReferenceId {
        if self.has_implementation_guide_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::implementation_guide_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_implementation_guide_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::implementation_guide_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId library_id = 64;

    pub fn clear_library_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_library_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::library_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_library_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::library_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_library_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::library_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::library_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::library_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_library_id(&mut self) -> ReferenceId {
        if self.has_library_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::library_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_library_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::library_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId linkage_id = 65;

    pub fn clear_linkage_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_linkage_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::linkage_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_linkage_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::linkage_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_linkage_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::linkage_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::linkage_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::linkage_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_linkage_id(&mut self) -> ReferenceId {
        if self.has_linkage_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::linkage_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_linkage_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::linkage_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId list_id = 66;

    pub fn clear_list_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_list_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::list_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::list_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::list_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::list_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::list_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_id(&mut self) -> ReferenceId {
        if self.has_list_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::list_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_list_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::list_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId location_id = 67;

    pub fn clear_location_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_location_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::location_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_location_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::location_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_location_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::location_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::location_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::location_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_location_id(&mut self) -> ReferenceId {
        if self.has_location_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::location_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_location_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::location_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId measure_id = 68;

    pub fn clear_measure_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_measure_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::measure_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_measure_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::measure_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_measure_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::measure_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::measure_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::measure_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_measure_id(&mut self) -> ReferenceId {
        if self.has_measure_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::measure_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_measure_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::measure_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId measure_report_id = 69;

    pub fn clear_measure_report_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_measure_report_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::measure_report_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_measure_report_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::measure_report_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_measure_report_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::measure_report_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::measure_report_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::measure_report_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_measure_report_id(&mut self) -> ReferenceId {
        if self.has_measure_report_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::measure_report_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_measure_report_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::measure_report_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId media_id = 70;

    pub fn clear_media_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_media_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::media_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_media_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::media_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_media_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::media_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::media_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::media_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_media_id(&mut self) -> ReferenceId {
        if self.has_media_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::media_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_media_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::media_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId medication_id = 71;

    pub fn clear_medication_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_medication_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_medication_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_medication_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::medication_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_medication_id(&mut self) -> ReferenceId {
        if self.has_medication_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::medication_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_medication_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId medication_administration_id = 72;

    pub fn clear_medication_administration_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_medication_administration_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_administration_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_medication_administration_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_administration_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_medication_administration_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::medication_administration_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_administration_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_administration_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_medication_administration_id(&mut self) -> ReferenceId {
        if self.has_medication_administration_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::medication_administration_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_medication_administration_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_administration_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId medication_dispense_id = 73;

    pub fn clear_medication_dispense_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_medication_dispense_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_dispense_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_medication_dispense_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_dispense_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_medication_dispense_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::medication_dispense_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_dispense_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_dispense_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_medication_dispense_id(&mut self) -> ReferenceId {
        if self.has_medication_dispense_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::medication_dispense_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_medication_dispense_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_dispense_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId medication_request_id = 74;

    pub fn clear_medication_request_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_medication_request_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_request_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_medication_request_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_request_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_medication_request_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::medication_request_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_request_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_request_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_medication_request_id(&mut self) -> ReferenceId {
        if self.has_medication_request_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::medication_request_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_medication_request_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_request_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId medication_statement_id = 75;

    pub fn clear_medication_statement_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_medication_statement_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_statement_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_medication_statement_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_statement_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_medication_statement_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::medication_statement_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_statement_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_statement_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_medication_statement_id(&mut self) -> ReferenceId {
        if self.has_medication_statement_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::medication_statement_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_medication_statement_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::medication_statement_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId message_definition_id = 76;

    pub fn clear_message_definition_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_message_definition_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::message_definition_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message_definition_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::message_definition_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message_definition_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::message_definition_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::message_definition_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::message_definition_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message_definition_id(&mut self) -> ReferenceId {
        if self.has_message_definition_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::message_definition_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_message_definition_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::message_definition_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId message_header_id = 77;

    pub fn clear_message_header_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_message_header_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::message_header_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message_header_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::message_header_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message_header_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::message_header_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::message_header_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::message_header_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message_header_id(&mut self) -> ReferenceId {
        if self.has_message_header_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::message_header_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_message_header_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::message_header_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId naming_system_id = 78;

    pub fn clear_naming_system_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_naming_system_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::naming_system_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_naming_system_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::naming_system_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_naming_system_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::naming_system_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::naming_system_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::naming_system_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_naming_system_id(&mut self) -> ReferenceId {
        if self.has_naming_system_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::naming_system_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_naming_system_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::naming_system_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId nutrition_order_id = 79;

    pub fn clear_nutrition_order_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_nutrition_order_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::nutrition_order_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_nutrition_order_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::nutrition_order_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_nutrition_order_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::nutrition_order_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::nutrition_order_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::nutrition_order_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_nutrition_order_id(&mut self) -> ReferenceId {
        if self.has_nutrition_order_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::nutrition_order_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_nutrition_order_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::nutrition_order_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId observation_id = 80;

    pub fn clear_observation_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_observation_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::observation_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_observation_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::observation_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_observation_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::observation_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::observation_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::observation_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_observation_id(&mut self) -> ReferenceId {
        if self.has_observation_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::observation_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_observation_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::observation_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId operation_definition_id = 81;

    pub fn clear_operation_definition_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_operation_definition_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::operation_definition_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_operation_definition_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::operation_definition_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_operation_definition_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::operation_definition_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::operation_definition_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::operation_definition_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_operation_definition_id(&mut self) -> ReferenceId {
        if self.has_operation_definition_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::operation_definition_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_operation_definition_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::operation_definition_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId operation_outcome_id = 82;

    pub fn clear_operation_outcome_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_operation_outcome_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::operation_outcome_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_operation_outcome_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::operation_outcome_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_operation_outcome_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::operation_outcome_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::operation_outcome_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::operation_outcome_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_operation_outcome_id(&mut self) -> ReferenceId {
        if self.has_operation_outcome_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::operation_outcome_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_operation_outcome_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::operation_outcome_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId organization_id = 83;

    pub fn clear_organization_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_organization_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::organization_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_organization_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::organization_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_organization_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::organization_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::organization_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::organization_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_organization_id(&mut self) -> ReferenceId {
        if self.has_organization_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::organization_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_organization_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::organization_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId parameters_id = 84;

    pub fn clear_parameters_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_parameters_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::parameters_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_parameters_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::parameters_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_parameters_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::parameters_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::parameters_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::parameters_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_parameters_id(&mut self) -> ReferenceId {
        if self.has_parameters_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::parameters_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_parameters_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::parameters_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId patient_id = 85;

    pub fn clear_patient_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_patient_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::patient_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_patient_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::patient_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_patient_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::patient_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::patient_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::patient_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_patient_id(&mut self) -> ReferenceId {
        if self.has_patient_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::patient_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_patient_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::patient_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId payment_notice_id = 86;

    pub fn clear_payment_notice_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_payment_notice_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::payment_notice_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_payment_notice_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::payment_notice_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_payment_notice_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::payment_notice_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::payment_notice_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::payment_notice_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_payment_notice_id(&mut self) -> ReferenceId {
        if self.has_payment_notice_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::payment_notice_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_payment_notice_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::payment_notice_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId payment_reconciliation_id = 87;

    pub fn clear_payment_reconciliation_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_payment_reconciliation_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::payment_reconciliation_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_payment_reconciliation_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::payment_reconciliation_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_payment_reconciliation_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::payment_reconciliation_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::payment_reconciliation_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::payment_reconciliation_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_payment_reconciliation_id(&mut self) -> ReferenceId {
        if self.has_payment_reconciliation_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::payment_reconciliation_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_payment_reconciliation_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::payment_reconciliation_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId person_id = 88;

    pub fn clear_person_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_person_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::person_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_person_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::person_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_person_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::person_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::person_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::person_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_person_id(&mut self) -> ReferenceId {
        if self.has_person_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::person_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_person_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::person_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId plan_definition_id = 89;

    pub fn clear_plan_definition_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_plan_definition_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::plan_definition_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_plan_definition_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::plan_definition_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_plan_definition_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::plan_definition_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::plan_definition_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::plan_definition_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_plan_definition_id(&mut self) -> ReferenceId {
        if self.has_plan_definition_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::plan_definition_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_plan_definition_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::plan_definition_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId practitioner_id = 90;

    pub fn clear_practitioner_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_practitioner_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::practitioner_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_practitioner_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::practitioner_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_practitioner_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::practitioner_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::practitioner_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::practitioner_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_practitioner_id(&mut self) -> ReferenceId {
        if self.has_practitioner_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::practitioner_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_practitioner_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::practitioner_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId practitioner_role_id = 91;

    pub fn clear_practitioner_role_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_practitioner_role_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::practitioner_role_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_practitioner_role_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::practitioner_role_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_practitioner_role_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::practitioner_role_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::practitioner_role_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::practitioner_role_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_practitioner_role_id(&mut self) -> ReferenceId {
        if self.has_practitioner_role_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::practitioner_role_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_practitioner_role_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::practitioner_role_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId procedure_id = 92;

    pub fn clear_procedure_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_procedure_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::procedure_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_procedure_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::procedure_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_procedure_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::procedure_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::procedure_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::procedure_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_procedure_id(&mut self) -> ReferenceId {
        if self.has_procedure_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::procedure_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_procedure_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::procedure_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId procedure_request_id = 93;

    pub fn clear_procedure_request_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_procedure_request_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::procedure_request_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_procedure_request_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::procedure_request_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_procedure_request_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::procedure_request_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::procedure_request_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::procedure_request_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_procedure_request_id(&mut self) -> ReferenceId {
        if self.has_procedure_request_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::procedure_request_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_procedure_request_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::procedure_request_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId process_request_id = 94;

    pub fn clear_process_request_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_process_request_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::process_request_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_process_request_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::process_request_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_process_request_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::process_request_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::process_request_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::process_request_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_process_request_id(&mut self) -> ReferenceId {
        if self.has_process_request_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::process_request_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_process_request_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::process_request_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId process_response_id = 95;

    pub fn clear_process_response_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_process_response_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::process_response_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_process_response_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::process_response_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_process_response_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::process_response_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::process_response_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::process_response_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_process_response_id(&mut self) -> ReferenceId {
        if self.has_process_response_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::process_response_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_process_response_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::process_response_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId provenance_id = 96;

    pub fn clear_provenance_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_provenance_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::provenance_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_provenance_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::provenance_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_provenance_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::provenance_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::provenance_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::provenance_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_provenance_id(&mut self) -> ReferenceId {
        if self.has_provenance_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::provenance_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_provenance_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::provenance_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId questionnaire_id = 97;

    pub fn clear_questionnaire_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_questionnaire_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::questionnaire_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_questionnaire_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::questionnaire_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_questionnaire_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::questionnaire_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::questionnaire_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::questionnaire_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_questionnaire_id(&mut self) -> ReferenceId {
        if self.has_questionnaire_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::questionnaire_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_questionnaire_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::questionnaire_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId questionnaire_response_id = 98;

    pub fn clear_questionnaire_response_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_questionnaire_response_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::questionnaire_response_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_questionnaire_response_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::questionnaire_response_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_questionnaire_response_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::questionnaire_response_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::questionnaire_response_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::questionnaire_response_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_questionnaire_response_id(&mut self) -> ReferenceId {
        if self.has_questionnaire_response_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::questionnaire_response_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_questionnaire_response_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::questionnaire_response_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId referral_request_id = 99;

    pub fn clear_referral_request_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_referral_request_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::referral_request_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_referral_request_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::referral_request_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_referral_request_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::referral_request_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::referral_request_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::referral_request_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_referral_request_id(&mut self) -> ReferenceId {
        if self.has_referral_request_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::referral_request_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_referral_request_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::referral_request_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId related_person_id = 100;

    pub fn clear_related_person_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_related_person_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::related_person_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_related_person_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::related_person_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_related_person_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::related_person_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::related_person_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::related_person_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_related_person_id(&mut self) -> ReferenceId {
        if self.has_related_person_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::related_person_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_related_person_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::related_person_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId request_group_id = 101;

    pub fn clear_request_group_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_request_group_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::request_group_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_group_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::request_group_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_group_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::request_group_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::request_group_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::request_group_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_group_id(&mut self) -> ReferenceId {
        if self.has_request_group_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::request_group_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_request_group_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::request_group_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId research_study_id = 102;

    pub fn clear_research_study_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_research_study_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::research_study_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_research_study_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::research_study_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_research_study_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::research_study_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::research_study_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::research_study_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_research_study_id(&mut self) -> ReferenceId {
        if self.has_research_study_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::research_study_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_research_study_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::research_study_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId research_subject_id = 103;

    pub fn clear_research_subject_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_research_subject_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::research_subject_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_research_subject_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::research_subject_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_research_subject_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::research_subject_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::research_subject_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::research_subject_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_research_subject_id(&mut self) -> ReferenceId {
        if self.has_research_subject_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::research_subject_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_research_subject_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::research_subject_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId risk_assessment_id = 104;

    pub fn clear_risk_assessment_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_risk_assessment_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::risk_assessment_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_risk_assessment_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::risk_assessment_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_risk_assessment_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::risk_assessment_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::risk_assessment_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::risk_assessment_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_risk_assessment_id(&mut self) -> ReferenceId {
        if self.has_risk_assessment_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::risk_assessment_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_risk_assessment_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::risk_assessment_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId schedule_id = 105;

    pub fn clear_schedule_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_schedule_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::schedule_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_schedule_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::schedule_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_schedule_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::schedule_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::schedule_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::schedule_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_schedule_id(&mut self) -> ReferenceId {
        if self.has_schedule_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::schedule_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_schedule_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::schedule_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId search_parameter_id = 106;

    pub fn clear_search_parameter_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_search_parameter_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::search_parameter_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_search_parameter_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::search_parameter_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_search_parameter_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::search_parameter_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::search_parameter_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::search_parameter_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_search_parameter_id(&mut self) -> ReferenceId {
        if self.has_search_parameter_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::search_parameter_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_search_parameter_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::search_parameter_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId sequence_id = 107;

    pub fn clear_sequence_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_sequence_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::sequence_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sequence_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::sequence_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sequence_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::sequence_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::sequence_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::sequence_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sequence_id(&mut self) -> ReferenceId {
        if self.has_sequence_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::sequence_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_sequence_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::sequence_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId service_definition_id = 108;

    pub fn clear_service_definition_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_service_definition_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::service_definition_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_service_definition_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::service_definition_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_service_definition_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::service_definition_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::service_definition_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::service_definition_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_service_definition_id(&mut self) -> ReferenceId {
        if self.has_service_definition_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::service_definition_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_service_definition_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::service_definition_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId slot_id = 109;

    pub fn clear_slot_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::slot_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::slot_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_slot_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::slot_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::slot_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::slot_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_slot_id(&mut self) -> ReferenceId {
        if self.has_slot_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::slot_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_slot_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::slot_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId specimen_id = 110;

    pub fn clear_specimen_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_specimen_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::specimen_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_specimen_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::specimen_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_specimen_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::specimen_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::specimen_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::specimen_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_specimen_id(&mut self) -> ReferenceId {
        if self.has_specimen_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::specimen_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_specimen_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::specimen_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId structure_definition_id = 111;

    pub fn clear_structure_definition_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_structure_definition_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::structure_definition_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_structure_definition_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::structure_definition_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_structure_definition_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::structure_definition_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::structure_definition_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::structure_definition_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_structure_definition_id(&mut self) -> ReferenceId {
        if self.has_structure_definition_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::structure_definition_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_structure_definition_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::structure_definition_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId structure_map_id = 112;

    pub fn clear_structure_map_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_structure_map_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::structure_map_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_structure_map_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::structure_map_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_structure_map_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::structure_map_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::structure_map_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::structure_map_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_structure_map_id(&mut self) -> ReferenceId {
        if self.has_structure_map_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::structure_map_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_structure_map_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::structure_map_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId subscription_id = 113;

    pub fn clear_subscription_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_subscription_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::subscription_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_subscription_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::subscription_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_subscription_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::subscription_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::subscription_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::subscription_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_subscription_id(&mut self) -> ReferenceId {
        if self.has_subscription_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::subscription_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_subscription_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::subscription_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId substance_id = 114;

    pub fn clear_substance_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_substance_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::substance_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_substance_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::substance_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_substance_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::substance_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::substance_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::substance_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_substance_id(&mut self) -> ReferenceId {
        if self.has_substance_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::substance_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_substance_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::substance_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId supply_delivery_id = 115;

    pub fn clear_supply_delivery_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_supply_delivery_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::supply_delivery_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_supply_delivery_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::supply_delivery_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_supply_delivery_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::supply_delivery_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::supply_delivery_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::supply_delivery_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_supply_delivery_id(&mut self) -> ReferenceId {
        if self.has_supply_delivery_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::supply_delivery_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_supply_delivery_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::supply_delivery_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId supply_request_id = 116;

    pub fn clear_supply_request_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_supply_request_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::supply_request_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_supply_request_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::supply_request_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_supply_request_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::supply_request_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::supply_request_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::supply_request_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_supply_request_id(&mut self) -> ReferenceId {
        if self.has_supply_request_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::supply_request_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_supply_request_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::supply_request_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId task_id = 117;

    pub fn clear_task_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_task_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::task_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::task_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_task_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::task_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::task_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::task_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_task_id(&mut self) -> ReferenceId {
        if self.has_task_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::task_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_task_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::task_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId test_report_id = 118;

    pub fn clear_test_report_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_test_report_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::test_report_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_test_report_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::test_report_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_test_report_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::test_report_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::test_report_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::test_report_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_test_report_id(&mut self) -> ReferenceId {
        if self.has_test_report_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::test_report_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_test_report_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::test_report_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId test_script_id = 119;

    pub fn clear_test_script_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_test_script_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::test_script_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_test_script_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::test_script_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_test_script_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::test_script_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::test_script_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::test_script_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_test_script_id(&mut self) -> ReferenceId {
        if self.has_test_script_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::test_script_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_test_script_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::test_script_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId value_set_id = 120;

    pub fn clear_value_set_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_value_set_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::value_set_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_value_set_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::value_set_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_value_set_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::value_set_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::value_set_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::value_set_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_value_set_id(&mut self) -> ReferenceId {
        if self.has_value_set_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::value_set_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_value_set_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::value_set_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.ReferenceId vision_prescription_id = 121;

    pub fn clear_vision_prescription_id(&mut self) {
        self.reference = ::std::option::Option::None;
    }

    pub fn has_vision_prescription_id(&self) -> bool {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::vision_prescription_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vision_prescription_id(&mut self, v: ReferenceId) {
        self.reference = ::std::option::Option::Some(Reference_oneof_reference::vision_prescription_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vision_prescription_id(&mut self) -> &mut ReferenceId {
        if let ::std::option::Option::Some(Reference_oneof_reference::vision_prescription_id(_)) = self.reference {
        } else {
            self.reference = ::std::option::Option::Some(Reference_oneof_reference::vision_prescription_id(ReferenceId::new()));
        }
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::vision_prescription_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vision_prescription_id(&mut self) -> ReferenceId {
        if self.has_vision_prescription_id() {
            match self.reference.take() {
                ::std::option::Option::Some(Reference_oneof_reference::vision_prescription_id(v)) => v,
                _ => panic!(),
            }
        } else {
            ReferenceId::new()
        }
    }

    pub fn get_vision_prescription_id(&self) -> &ReferenceId {
        match self.reference {
            ::std::option::Option::Some(Reference_oneof_reference::vision_prescription_id(ref v)) => v,
            _ => ReferenceId::default_instance(),
        }
    }

    // .google.fhir.stu3.proto.Identifier identifier = 122;

    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: Identifier) {
        self.identifier = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut Identifier {
        if self.identifier.is_none() {
            self.identifier.set_default();
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> Identifier {
        self.identifier.take().unwrap_or_else(|| Identifier::new())
    }

    pub fn get_identifier(&self) -> &Identifier {
        self.identifier.as_ref().unwrap_or_else(|| Identifier::default_instance())
    }

    // .google.fhir.stu3.proto.String display = 123;

    pub fn clear_display(&mut self) {
        self.display.clear();
    }

    pub fn has_display(&self) -> bool {
        self.display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display(&mut self, v: String) {
        self.display = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display(&mut self) -> &mut String {
        if self.display.is_none() {
            self.display.set_default();
        }
        self.display.as_mut().unwrap()
    }

    // Take field
    pub fn take_display(&mut self) -> String {
        self.display.take().unwrap_or_else(|| String::new())
    }

    pub fn get_display(&self) -> &String {
        self.display.as_ref().unwrap_or_else(|| String::default_instance())
    }
}

impl ::protobuf::Message for Reference {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Reference_oneof_reference::uri(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::fragment(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::account_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::activity_definition_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::adverse_event_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::allergy_intolerance_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::appointment_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::appointment_response_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::audit_event_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::basic_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::binary_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::body_site_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::bundle_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::capability_statement_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::care_plan_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::care_team_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::charge_item_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::claim_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::claim_response_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::clinical_impression_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::code_system_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::communication_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::communication_request_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::compartment_definition_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::composition_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::concept_map_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::condition_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::consent_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::contract_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::coverage_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::data_element_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::detected_issue_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::device_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::device_component_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::device_metric_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::device_request_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::device_usestatement_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::diagnostic_report_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::document_manifest_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::document_reference_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::eligibility_request_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::eligibility_response_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::encounter_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::endpoint_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::enrollment_request_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::enrollment_response_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::episode_ofcare_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::expansion_profile_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::explanation_ofbenefit_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::family_memberhistory_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::flag_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::goal_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::graph_definition_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::group_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::guidance_response_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::healthcare_service_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::imaging_manifest_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::imaging_study_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::immunization_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::immunization_recommendation_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::implementation_guide_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::library_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::linkage_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::list_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::location_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::measure_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::measure_report_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::media_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::medication_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::medication_administration_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::medication_dispense_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::medication_request_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::medication_statement_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::message_definition_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::message_header_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::naming_system_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::nutrition_order_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::observation_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::operation_definition_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::operation_outcome_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::organization_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::parameters_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::patient_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::payment_notice_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::payment_reconciliation_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::person_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::plan_definition_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::practitioner_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::practitioner_role_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::procedure_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::procedure_request_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::process_request_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::process_response_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::provenance_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::questionnaire_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::questionnaire_response_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::referral_request_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::related_person_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::request_group_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::research_study_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::research_subject_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::risk_assessment_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::schedule_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::search_parameter_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::sequence_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::service_definition_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::slot_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::specimen_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::structure_definition_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::structure_map_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::subscription_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::substance_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::supply_delivery_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::supply_request_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::task_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::test_report_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::test_script_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::value_set_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Reference_oneof_reference::vision_prescription_id(ref v)) = self.reference {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.identifier {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.display {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::uri(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::fragment(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::account_id(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::activity_definition_id(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::adverse_event_id(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::allergy_intolerance_id(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::appointment_id(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::appointment_response_id(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::audit_event_id(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::basic_id(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::binary_id(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::body_site_id(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::bundle_id(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::capability_statement_id(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::care_plan_id(is.read_message()?));
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::care_team_id(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::charge_item_id(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::claim_id(is.read_message()?));
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::claim_response_id(is.read_message()?));
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::clinical_impression_id(is.read_message()?));
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::code_system_id(is.read_message()?));
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::communication_id(is.read_message()?));
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::communication_request_id(is.read_message()?));
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::compartment_definition_id(is.read_message()?));
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::composition_id(is.read_message()?));
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::concept_map_id(is.read_message()?));
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::condition_id(is.read_message()?));
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::consent_id(is.read_message()?));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::contract_id(is.read_message()?));
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::coverage_id(is.read_message()?));
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::data_element_id(is.read_message()?));
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::detected_issue_id(is.read_message()?));
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_id(is.read_message()?));
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_component_id(is.read_message()?));
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_metric_id(is.read_message()?));
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_request_id(is.read_message()?));
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::device_usestatement_id(is.read_message()?));
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::diagnostic_report_id(is.read_message()?));
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::document_manifest_id(is.read_message()?));
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::document_reference_id(is.read_message()?));
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::eligibility_request_id(is.read_message()?));
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::eligibility_response_id(is.read_message()?));
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::encounter_id(is.read_message()?));
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::endpoint_id(is.read_message()?));
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::enrollment_request_id(is.read_message()?));
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::enrollment_response_id(is.read_message()?));
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::episode_ofcare_id(is.read_message()?));
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::expansion_profile_id(is.read_message()?));
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::explanation_ofbenefit_id(is.read_message()?));
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::family_memberhistory_id(is.read_message()?));
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::flag_id(is.read_message()?));
                },
                54 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::goal_id(is.read_message()?));
                },
                55 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::graph_definition_id(is.read_message()?));
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::group_id(is.read_message()?));
                },
                57 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::guidance_response_id(is.read_message()?));
                },
                58 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::healthcare_service_id(is.read_message()?));
                },
                59 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::imaging_manifest_id(is.read_message()?));
                },
                60 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::imaging_study_id(is.read_message()?));
                },
                61 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::immunization_id(is.read_message()?));
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::immunization_recommendation_id(is.read_message()?));
                },
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::implementation_guide_id(is.read_message()?));
                },
                64 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::library_id(is.read_message()?));
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::linkage_id(is.read_message()?));
                },
                66 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::list_id(is.read_message()?));
                },
                67 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::location_id(is.read_message()?));
                },
                68 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::measure_id(is.read_message()?));
                },
                69 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::measure_report_id(is.read_message()?));
                },
                70 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::media_id(is.read_message()?));
                },
                71 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_id(is.read_message()?));
                },
                72 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_administration_id(is.read_message()?));
                },
                73 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_dispense_id(is.read_message()?));
                },
                74 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_request_id(is.read_message()?));
                },
                75 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::medication_statement_id(is.read_message()?));
                },
                76 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::message_definition_id(is.read_message()?));
                },
                77 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::message_header_id(is.read_message()?));
                },
                78 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::naming_system_id(is.read_message()?));
                },
                79 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::nutrition_order_id(is.read_message()?));
                },
                80 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::observation_id(is.read_message()?));
                },
                81 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::operation_definition_id(is.read_message()?));
                },
                82 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::operation_outcome_id(is.read_message()?));
                },
                83 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::organization_id(is.read_message()?));
                },
                84 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::parameters_id(is.read_message()?));
                },
                85 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::patient_id(is.read_message()?));
                },
                86 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::payment_notice_id(is.read_message()?));
                },
                87 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::payment_reconciliation_id(is.read_message()?));
                },
                88 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::person_id(is.read_message()?));
                },
                89 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::plan_definition_id(is.read_message()?));
                },
                90 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::practitioner_id(is.read_message()?));
                },
                91 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::practitioner_role_id(is.read_message()?));
                },
                92 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::procedure_id(is.read_message()?));
                },
                93 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::procedure_request_id(is.read_message()?));
                },
                94 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::process_request_id(is.read_message()?));
                },
                95 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::process_response_id(is.read_message()?));
                },
                96 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::provenance_id(is.read_message()?));
                },
                97 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::questionnaire_id(is.read_message()?));
                },
                98 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::questionnaire_response_id(is.read_message()?));
                },
                99 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::referral_request_id(is.read_message()?));
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::related_person_id(is.read_message()?));
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::request_group_id(is.read_message()?));
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::research_study_id(is.read_message()?));
                },
                103 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::research_subject_id(is.read_message()?));
                },
                104 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::risk_assessment_id(is.read_message()?));
                },
                105 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::schedule_id(is.read_message()?));
                },
                106 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::search_parameter_id(is.read_message()?));
                },
                107 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::sequence_id(is.read_message()?));
                },
                108 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::service_definition_id(is.read_message()?));
                },
                109 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::slot_id(is.read_message()?));
                },
                110 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::specimen_id(is.read_message()?));
                },
                111 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::structure_definition_id(is.read_message()?));
                },
                112 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::structure_map_id(is.read_message()?));
                },
                113 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::subscription_id(is.read_message()?));
                },
                114 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::substance_id(is.read_message()?));
                },
                115 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::supply_delivery_id(is.read_message()?));
                },
                116 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::supply_request_id(is.read_message()?));
                },
                117 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::task_id(is.read_message()?));
                },
                118 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::test_report_id(is.read_message()?));
                },
                119 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::test_script_id(is.read_message()?));
                },
                120 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::value_set_id(is.read_message()?));
                },
                121 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.reference = ::std::option::Option::Some(Reference_oneof_reference::vision_prescription_id(is.read_message()?));
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifier)?;
                },
                123 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.display)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.identifier.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.display.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.reference {
            match v {
                &Reference_oneof_reference::uri(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::fragment(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::account_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::activity_definition_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::adverse_event_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::allergy_intolerance_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::appointment_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::appointment_response_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::audit_event_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::basic_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::binary_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::body_site_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::bundle_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::capability_statement_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::care_plan_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::care_team_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::charge_item_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::claim_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::claim_response_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::clinical_impression_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::code_system_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::communication_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::communication_request_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::compartment_definition_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::composition_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::concept_map_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::condition_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::consent_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::contract_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::coverage_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::data_element_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::detected_issue_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::device_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::device_component_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::device_metric_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::device_request_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::device_usestatement_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::diagnostic_report_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::document_manifest_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::document_reference_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::eligibility_request_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::eligibility_response_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::encounter_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::endpoint_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::enrollment_request_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::enrollment_response_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::episode_ofcare_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::expansion_profile_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::explanation_ofbenefit_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::family_memberhistory_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::flag_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::goal_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::graph_definition_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::group_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::guidance_response_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::healthcare_service_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::imaging_manifest_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::imaging_study_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::immunization_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::immunization_recommendation_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::implementation_guide_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::library_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::linkage_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::list_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::location_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::measure_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::measure_report_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::media_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::medication_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::medication_administration_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::medication_dispense_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::medication_request_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::medication_statement_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::message_definition_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::message_header_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::naming_system_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::nutrition_order_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::observation_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::operation_definition_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::operation_outcome_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::organization_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::parameters_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::patient_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::payment_notice_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::payment_reconciliation_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::person_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::plan_definition_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::practitioner_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::practitioner_role_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::procedure_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::procedure_request_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::process_request_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::process_response_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::provenance_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::questionnaire_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::questionnaire_response_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::referral_request_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::related_person_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::request_group_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::research_study_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::research_subject_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::risk_assessment_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::schedule_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::search_parameter_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::sequence_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::service_definition_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::slot_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::specimen_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::structure_definition_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::structure_map_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::subscription_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::substance_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::supply_delivery_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::supply_request_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::task_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::test_report_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::test_script_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::value_set_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Reference_oneof_reference::vision_prescription_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.identifier.as_ref() {
            os.write_tag(122, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.display.as_ref() {
            os.write_tag(123, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.reference {
            match v {
                &Reference_oneof_reference::uri(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::fragment(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::account_id(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::activity_definition_id(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::adverse_event_id(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::allergy_intolerance_id(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::appointment_id(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::appointment_response_id(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::audit_event_id(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::basic_id(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::binary_id(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::body_site_id(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::bundle_id(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::capability_statement_id(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::care_plan_id(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::care_team_id(ref v) => {
                    os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::charge_item_id(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::claim_id(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::claim_response_id(ref v) => {
                    os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::clinical_impression_id(ref v) => {
                    os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::code_system_id(ref v) => {
                    os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::communication_id(ref v) => {
                    os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::communication_request_id(ref v) => {
                    os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::compartment_definition_id(ref v) => {
                    os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::composition_id(ref v) => {
                    os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::concept_map_id(ref v) => {
                    os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::condition_id(ref v) => {
                    os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::consent_id(ref v) => {
                    os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::contract_id(ref v) => {
                    os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::coverage_id(ref v) => {
                    os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::data_element_id(ref v) => {
                    os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::detected_issue_id(ref v) => {
                    os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::device_id(ref v) => {
                    os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::device_component_id(ref v) => {
                    os.write_tag(36, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::device_metric_id(ref v) => {
                    os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::device_request_id(ref v) => {
                    os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::device_usestatement_id(ref v) => {
                    os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::diagnostic_report_id(ref v) => {
                    os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::document_manifest_id(ref v) => {
                    os.write_tag(41, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::document_reference_id(ref v) => {
                    os.write_tag(42, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::eligibility_request_id(ref v) => {
                    os.write_tag(43, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::eligibility_response_id(ref v) => {
                    os.write_tag(44, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::encounter_id(ref v) => {
                    os.write_tag(45, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::endpoint_id(ref v) => {
                    os.write_tag(46, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::enrollment_request_id(ref v) => {
                    os.write_tag(47, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::enrollment_response_id(ref v) => {
                    os.write_tag(48, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::episode_ofcare_id(ref v) => {
                    os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::expansion_profile_id(ref v) => {
                    os.write_tag(50, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::explanation_ofbenefit_id(ref v) => {
                    os.write_tag(51, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::family_memberhistory_id(ref v) => {
                    os.write_tag(52, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::flag_id(ref v) => {
                    os.write_tag(53, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::goal_id(ref v) => {
                    os.write_tag(54, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::graph_definition_id(ref v) => {
                    os.write_tag(55, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::group_id(ref v) => {
                    os.write_tag(56, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::guidance_response_id(ref v) => {
                    os.write_tag(57, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::healthcare_service_id(ref v) => {
                    os.write_tag(58, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::imaging_manifest_id(ref v) => {
                    os.write_tag(59, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::imaging_study_id(ref v) => {
                    os.write_tag(60, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::immunization_id(ref v) => {
                    os.write_tag(61, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::immunization_recommendation_id(ref v) => {
                    os.write_tag(62, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::implementation_guide_id(ref v) => {
                    os.write_tag(63, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::library_id(ref v) => {
                    os.write_tag(64, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::linkage_id(ref v) => {
                    os.write_tag(65, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::list_id(ref v) => {
                    os.write_tag(66, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::location_id(ref v) => {
                    os.write_tag(67, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::measure_id(ref v) => {
                    os.write_tag(68, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::measure_report_id(ref v) => {
                    os.write_tag(69, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::media_id(ref v) => {
                    os.write_tag(70, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::medication_id(ref v) => {
                    os.write_tag(71, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::medication_administration_id(ref v) => {
                    os.write_tag(72, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::medication_dispense_id(ref v) => {
                    os.write_tag(73, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::medication_request_id(ref v) => {
                    os.write_tag(74, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::medication_statement_id(ref v) => {
                    os.write_tag(75, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::message_definition_id(ref v) => {
                    os.write_tag(76, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::message_header_id(ref v) => {
                    os.write_tag(77, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::naming_system_id(ref v) => {
                    os.write_tag(78, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::nutrition_order_id(ref v) => {
                    os.write_tag(79, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::observation_id(ref v) => {
                    os.write_tag(80, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::operation_definition_id(ref v) => {
                    os.write_tag(81, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::operation_outcome_id(ref v) => {
                    os.write_tag(82, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::organization_id(ref v) => {
                    os.write_tag(83, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::parameters_id(ref v) => {
                    os.write_tag(84, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::patient_id(ref v) => {
                    os.write_tag(85, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::payment_notice_id(ref v) => {
                    os.write_tag(86, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::payment_reconciliation_id(ref v) => {
                    os.write_tag(87, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::person_id(ref v) => {
                    os.write_tag(88, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::plan_definition_id(ref v) => {
                    os.write_tag(89, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::practitioner_id(ref v) => {
                    os.write_tag(90, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::practitioner_role_id(ref v) => {
                    os.write_tag(91, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::procedure_id(ref v) => {
                    os.write_tag(92, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::procedure_request_id(ref v) => {
                    os.write_tag(93, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::process_request_id(ref v) => {
                    os.write_tag(94, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::process_response_id(ref v) => {
                    os.write_tag(95, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::provenance_id(ref v) => {
                    os.write_tag(96, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::questionnaire_id(ref v) => {
                    os.write_tag(97, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::questionnaire_response_id(ref v) => {
                    os.write_tag(98, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::referral_request_id(ref v) => {
                    os.write_tag(99, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::related_person_id(ref v) => {
                    os.write_tag(100, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::request_group_id(ref v) => {
                    os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::research_study_id(ref v) => {
                    os.write_tag(102, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::research_subject_id(ref v) => {
                    os.write_tag(103, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::risk_assessment_id(ref v) => {
                    os.write_tag(104, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::schedule_id(ref v) => {
                    os.write_tag(105, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::search_parameter_id(ref v) => {
                    os.write_tag(106, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::sequence_id(ref v) => {
                    os.write_tag(107, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::service_definition_id(ref v) => {
                    os.write_tag(108, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::slot_id(ref v) => {
                    os.write_tag(109, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::specimen_id(ref v) => {
                    os.write_tag(110, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::structure_definition_id(ref v) => {
                    os.write_tag(111, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::structure_map_id(ref v) => {
                    os.write_tag(112, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::subscription_id(ref v) => {
                    os.write_tag(113, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::substance_id(ref v) => {
                    os.write_tag(114, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::supply_delivery_id(ref v) => {
                    os.write_tag(115, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::supply_request_id(ref v) => {
                    os.write_tag(116, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::task_id(ref v) => {
                    os.write_tag(117, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::test_report_id(ref v) => {
                    os.write_tag(118, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::test_script_id(ref v) => {
                    os.write_tag(119, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::value_set_id(ref v) => {
                    os.write_tag(120, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Reference_oneof_reference::vision_prescription_id(ref v) => {
                    os.write_tag(121, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Reference {
        Reference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &Reference| { &m.id },
                    |m: &mut Reference| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &Reference| { &m.extension },
                    |m: &mut Reference| { &mut m.extension },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, String>(
                    "uri",
                    Reference::has_uri,
                    Reference::get_uri,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, String>(
                    "fragment",
                    Reference::has_fragment,
                    Reference::get_fragment,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "account_id",
                    Reference::has_account_id,
                    Reference::get_account_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "activity_definition_id",
                    Reference::has_activity_definition_id,
                    Reference::get_activity_definition_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "adverse_event_id",
                    Reference::has_adverse_event_id,
                    Reference::get_adverse_event_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "allergy_intolerance_id",
                    Reference::has_allergy_intolerance_id,
                    Reference::get_allergy_intolerance_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "appointment_id",
                    Reference::has_appointment_id,
                    Reference::get_appointment_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "appointment_response_id",
                    Reference::has_appointment_response_id,
                    Reference::get_appointment_response_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "audit_event_id",
                    Reference::has_audit_event_id,
                    Reference::get_audit_event_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "basic_id",
                    Reference::has_basic_id,
                    Reference::get_basic_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "binary_id",
                    Reference::has_binary_id,
                    Reference::get_binary_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "body_site_id",
                    Reference::has_body_site_id,
                    Reference::get_body_site_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "bundle_id",
                    Reference::has_bundle_id,
                    Reference::get_bundle_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "capability_statement_id",
                    Reference::has_capability_statement_id,
                    Reference::get_capability_statement_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "care_plan_id",
                    Reference::has_care_plan_id,
                    Reference::get_care_plan_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "care_team_id",
                    Reference::has_care_team_id,
                    Reference::get_care_team_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "charge_item_id",
                    Reference::has_charge_item_id,
                    Reference::get_charge_item_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "claim_id",
                    Reference::has_claim_id,
                    Reference::get_claim_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "claim_response_id",
                    Reference::has_claim_response_id,
                    Reference::get_claim_response_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "clinical_impression_id",
                    Reference::has_clinical_impression_id,
                    Reference::get_clinical_impression_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "code_system_id",
                    Reference::has_code_system_id,
                    Reference::get_code_system_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "communication_id",
                    Reference::has_communication_id,
                    Reference::get_communication_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "communication_request_id",
                    Reference::has_communication_request_id,
                    Reference::get_communication_request_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "compartment_definition_id",
                    Reference::has_compartment_definition_id,
                    Reference::get_compartment_definition_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "composition_id",
                    Reference::has_composition_id,
                    Reference::get_composition_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "concept_map_id",
                    Reference::has_concept_map_id,
                    Reference::get_concept_map_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "condition_id",
                    Reference::has_condition_id,
                    Reference::get_condition_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "consent_id",
                    Reference::has_consent_id,
                    Reference::get_consent_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "contract_id",
                    Reference::has_contract_id,
                    Reference::get_contract_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "coverage_id",
                    Reference::has_coverage_id,
                    Reference::get_coverage_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "data_element_id",
                    Reference::has_data_element_id,
                    Reference::get_data_element_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "detected_issue_id",
                    Reference::has_detected_issue_id,
                    Reference::get_detected_issue_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "device_id",
                    Reference::has_device_id,
                    Reference::get_device_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "device_component_id",
                    Reference::has_device_component_id,
                    Reference::get_device_component_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "device_metric_id",
                    Reference::has_device_metric_id,
                    Reference::get_device_metric_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "device_request_id",
                    Reference::has_device_request_id,
                    Reference::get_device_request_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "device_usestatement_id",
                    Reference::has_device_usestatement_id,
                    Reference::get_device_usestatement_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "diagnostic_report_id",
                    Reference::has_diagnostic_report_id,
                    Reference::get_diagnostic_report_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "document_manifest_id",
                    Reference::has_document_manifest_id,
                    Reference::get_document_manifest_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "document_reference_id",
                    Reference::has_document_reference_id,
                    Reference::get_document_reference_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "eligibility_request_id",
                    Reference::has_eligibility_request_id,
                    Reference::get_eligibility_request_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "eligibility_response_id",
                    Reference::has_eligibility_response_id,
                    Reference::get_eligibility_response_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "encounter_id",
                    Reference::has_encounter_id,
                    Reference::get_encounter_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "endpoint_id",
                    Reference::has_endpoint_id,
                    Reference::get_endpoint_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "enrollment_request_id",
                    Reference::has_enrollment_request_id,
                    Reference::get_enrollment_request_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "enrollment_response_id",
                    Reference::has_enrollment_response_id,
                    Reference::get_enrollment_response_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "episode_ofcare_id",
                    Reference::has_episode_ofcare_id,
                    Reference::get_episode_ofcare_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "expansion_profile_id",
                    Reference::has_expansion_profile_id,
                    Reference::get_expansion_profile_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "explanation_ofbenefit_id",
                    Reference::has_explanation_ofbenefit_id,
                    Reference::get_explanation_ofbenefit_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "family_memberhistory_id",
                    Reference::has_family_memberhistory_id,
                    Reference::get_family_memberhistory_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "flag_id",
                    Reference::has_flag_id,
                    Reference::get_flag_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "goal_id",
                    Reference::has_goal_id,
                    Reference::get_goal_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "graph_definition_id",
                    Reference::has_graph_definition_id,
                    Reference::get_graph_definition_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "group_id",
                    Reference::has_group_id,
                    Reference::get_group_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "guidance_response_id",
                    Reference::has_guidance_response_id,
                    Reference::get_guidance_response_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "healthcare_service_id",
                    Reference::has_healthcare_service_id,
                    Reference::get_healthcare_service_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "imaging_manifest_id",
                    Reference::has_imaging_manifest_id,
                    Reference::get_imaging_manifest_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "imaging_study_id",
                    Reference::has_imaging_study_id,
                    Reference::get_imaging_study_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "immunization_id",
                    Reference::has_immunization_id,
                    Reference::get_immunization_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "immunization_recommendation_id",
                    Reference::has_immunization_recommendation_id,
                    Reference::get_immunization_recommendation_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "implementation_guide_id",
                    Reference::has_implementation_guide_id,
                    Reference::get_implementation_guide_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "library_id",
                    Reference::has_library_id,
                    Reference::get_library_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "linkage_id",
                    Reference::has_linkage_id,
                    Reference::get_linkage_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "list_id",
                    Reference::has_list_id,
                    Reference::get_list_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "location_id",
                    Reference::has_location_id,
                    Reference::get_location_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "measure_id",
                    Reference::has_measure_id,
                    Reference::get_measure_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "measure_report_id",
                    Reference::has_measure_report_id,
                    Reference::get_measure_report_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "media_id",
                    Reference::has_media_id,
                    Reference::get_media_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "medication_id",
                    Reference::has_medication_id,
                    Reference::get_medication_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "medication_administration_id",
                    Reference::has_medication_administration_id,
                    Reference::get_medication_administration_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "medication_dispense_id",
                    Reference::has_medication_dispense_id,
                    Reference::get_medication_dispense_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "medication_request_id",
                    Reference::has_medication_request_id,
                    Reference::get_medication_request_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "medication_statement_id",
                    Reference::has_medication_statement_id,
                    Reference::get_medication_statement_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "message_definition_id",
                    Reference::has_message_definition_id,
                    Reference::get_message_definition_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "message_header_id",
                    Reference::has_message_header_id,
                    Reference::get_message_header_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "naming_system_id",
                    Reference::has_naming_system_id,
                    Reference::get_naming_system_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "nutrition_order_id",
                    Reference::has_nutrition_order_id,
                    Reference::get_nutrition_order_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "observation_id",
                    Reference::has_observation_id,
                    Reference::get_observation_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "operation_definition_id",
                    Reference::has_operation_definition_id,
                    Reference::get_operation_definition_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "operation_outcome_id",
                    Reference::has_operation_outcome_id,
                    Reference::get_operation_outcome_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "organization_id",
                    Reference::has_organization_id,
                    Reference::get_organization_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "parameters_id",
                    Reference::has_parameters_id,
                    Reference::get_parameters_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "patient_id",
                    Reference::has_patient_id,
                    Reference::get_patient_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "payment_notice_id",
                    Reference::has_payment_notice_id,
                    Reference::get_payment_notice_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "payment_reconciliation_id",
                    Reference::has_payment_reconciliation_id,
                    Reference::get_payment_reconciliation_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "person_id",
                    Reference::has_person_id,
                    Reference::get_person_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "plan_definition_id",
                    Reference::has_plan_definition_id,
                    Reference::get_plan_definition_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "practitioner_id",
                    Reference::has_practitioner_id,
                    Reference::get_practitioner_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "practitioner_role_id",
                    Reference::has_practitioner_role_id,
                    Reference::get_practitioner_role_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "procedure_id",
                    Reference::has_procedure_id,
                    Reference::get_procedure_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "procedure_request_id",
                    Reference::has_procedure_request_id,
                    Reference::get_procedure_request_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "process_request_id",
                    Reference::has_process_request_id,
                    Reference::get_process_request_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "process_response_id",
                    Reference::has_process_response_id,
                    Reference::get_process_response_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "provenance_id",
                    Reference::has_provenance_id,
                    Reference::get_provenance_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "questionnaire_id",
                    Reference::has_questionnaire_id,
                    Reference::get_questionnaire_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "questionnaire_response_id",
                    Reference::has_questionnaire_response_id,
                    Reference::get_questionnaire_response_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "referral_request_id",
                    Reference::has_referral_request_id,
                    Reference::get_referral_request_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "related_person_id",
                    Reference::has_related_person_id,
                    Reference::get_related_person_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "request_group_id",
                    Reference::has_request_group_id,
                    Reference::get_request_group_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "research_study_id",
                    Reference::has_research_study_id,
                    Reference::get_research_study_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "research_subject_id",
                    Reference::has_research_subject_id,
                    Reference::get_research_subject_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "risk_assessment_id",
                    Reference::has_risk_assessment_id,
                    Reference::get_risk_assessment_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "schedule_id",
                    Reference::has_schedule_id,
                    Reference::get_schedule_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "search_parameter_id",
                    Reference::has_search_parameter_id,
                    Reference::get_search_parameter_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "sequence_id",
                    Reference::has_sequence_id,
                    Reference::get_sequence_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "service_definition_id",
                    Reference::has_service_definition_id,
                    Reference::get_service_definition_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "slot_id",
                    Reference::has_slot_id,
                    Reference::get_slot_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "specimen_id",
                    Reference::has_specimen_id,
                    Reference::get_specimen_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "structure_definition_id",
                    Reference::has_structure_definition_id,
                    Reference::get_structure_definition_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "structure_map_id",
                    Reference::has_structure_map_id,
                    Reference::get_structure_map_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "subscription_id",
                    Reference::has_subscription_id,
                    Reference::get_subscription_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "substance_id",
                    Reference::has_substance_id,
                    Reference::get_substance_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "supply_delivery_id",
                    Reference::has_supply_delivery_id,
                    Reference::get_supply_delivery_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "supply_request_id",
                    Reference::has_supply_request_id,
                    Reference::get_supply_request_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "task_id",
                    Reference::has_task_id,
                    Reference::get_task_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "test_report_id",
                    Reference::has_test_report_id,
                    Reference::get_test_report_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "test_script_id",
                    Reference::has_test_script_id,
                    Reference::get_test_script_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "value_set_id",
                    Reference::has_value_set_id,
                    Reference::get_value_set_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ReferenceId>(
                    "vision_prescription_id",
                    Reference::has_vision_prescription_id,
                    Reference::get_vision_prescription_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Identifier>>(
                    "identifier",
                    |m: &Reference| { &m.identifier },
                    |m: &mut Reference| { &mut m.identifier },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "display",
                    |m: &Reference| { &m.display },
                    |m: &mut Reference| { &mut m.display },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Reference>(
                    "Reference",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Reference {
        static mut instance: ::protobuf::lazy::Lazy<Reference> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Reference,
        };
        unsafe {
            instance.get(Reference::new)
        }
    }
}

impl ::protobuf::Clear for Reference {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_extension();
        self.clear_uri();
        self.clear_fragment();
        self.clear_account_id();
        self.clear_activity_definition_id();
        self.clear_adverse_event_id();
        self.clear_allergy_intolerance_id();
        self.clear_appointment_id();
        self.clear_appointment_response_id();
        self.clear_audit_event_id();
        self.clear_basic_id();
        self.clear_binary_id();
        self.clear_body_site_id();
        self.clear_bundle_id();
        self.clear_capability_statement_id();
        self.clear_care_plan_id();
        self.clear_care_team_id();
        self.clear_charge_item_id();
        self.clear_claim_id();
        self.clear_claim_response_id();
        self.clear_clinical_impression_id();
        self.clear_code_system_id();
        self.clear_communication_id();
        self.clear_communication_request_id();
        self.clear_compartment_definition_id();
        self.clear_composition_id();
        self.clear_concept_map_id();
        self.clear_condition_id();
        self.clear_consent_id();
        self.clear_contract_id();
        self.clear_coverage_id();
        self.clear_data_element_id();
        self.clear_detected_issue_id();
        self.clear_device_id();
        self.clear_device_component_id();
        self.clear_device_metric_id();
        self.clear_device_request_id();
        self.clear_device_usestatement_id();
        self.clear_diagnostic_report_id();
        self.clear_document_manifest_id();
        self.clear_document_reference_id();
        self.clear_eligibility_request_id();
        self.clear_eligibility_response_id();
        self.clear_encounter_id();
        self.clear_endpoint_id();
        self.clear_enrollment_request_id();
        self.clear_enrollment_response_id();
        self.clear_episode_ofcare_id();
        self.clear_expansion_profile_id();
        self.clear_explanation_ofbenefit_id();
        self.clear_family_memberhistory_id();
        self.clear_flag_id();
        self.clear_goal_id();
        self.clear_graph_definition_id();
        self.clear_group_id();
        self.clear_guidance_response_id();
        self.clear_healthcare_service_id();
        self.clear_imaging_manifest_id();
        self.clear_imaging_study_id();
        self.clear_immunization_id();
        self.clear_immunization_recommendation_id();
        self.clear_implementation_guide_id();
        self.clear_library_id();
        self.clear_linkage_id();
        self.clear_list_id();
        self.clear_location_id();
        self.clear_measure_id();
        self.clear_measure_report_id();
        self.clear_media_id();
        self.clear_medication_id();
        self.clear_medication_administration_id();
        self.clear_medication_dispense_id();
        self.clear_medication_request_id();
        self.clear_medication_statement_id();
        self.clear_message_definition_id();
        self.clear_message_header_id();
        self.clear_naming_system_id();
        self.clear_nutrition_order_id();
        self.clear_observation_id();
        self.clear_operation_definition_id();
        self.clear_operation_outcome_id();
        self.clear_organization_id();
        self.clear_parameters_id();
        self.clear_patient_id();
        self.clear_payment_notice_id();
        self.clear_payment_reconciliation_id();
        self.clear_person_id();
        self.clear_plan_definition_id();
        self.clear_practitioner_id();
        self.clear_practitioner_role_id();
        self.clear_procedure_id();
        self.clear_procedure_request_id();
        self.clear_process_request_id();
        self.clear_process_response_id();
        self.clear_provenance_id();
        self.clear_questionnaire_id();
        self.clear_questionnaire_response_id();
        self.clear_referral_request_id();
        self.clear_related_person_id();
        self.clear_request_group_id();
        self.clear_research_study_id();
        self.clear_research_subject_id();
        self.clear_risk_assessment_id();
        self.clear_schedule_id();
        self.clear_search_parameter_id();
        self.clear_sequence_id();
        self.clear_service_definition_id();
        self.clear_slot_id();
        self.clear_specimen_id();
        self.clear_structure_definition_id();
        self.clear_structure_map_id();
        self.clear_subscription_id();
        self.clear_substance_id();
        self.clear_supply_delivery_id();
        self.clear_supply_request_id();
        self.clear_task_id();
        self.clear_test_report_id();
        self.clear_test_script_id();
        self.clear_value_set_id();
        self.clear_vision_prescription_id();
        self.clear_identifier();
        self.clear_display();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Reference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Reference {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReferenceId {
    // message fields
    pub value: ::std::string::String,
    pub history: ::protobuf::SingularPtrField<Id>,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ReferenceId {
    pub fn new() -> ReferenceId {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.Id history = 2;

    pub fn clear_history(&mut self) {
        self.history.clear();
    }

    pub fn has_history(&self) -> bool {
        self.history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_history(&mut self, v: Id) {
        self.history = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_history(&mut self) -> &mut Id {
        if self.history.is_none() {
            self.history.set_default();
        }
        self.history.as_mut().unwrap()
    }

    // Take field
    pub fn take_history(&mut self) -> Id {
        self.history.take().unwrap_or_else(|| Id::new())
    }

    pub fn get_history(&self) -> &Id {
        self.history.as_ref().unwrap_or_else(|| Id::default_instance())
    }

    // .google.fhir.stu3.proto.String id = 3;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 4;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ReferenceId {
    fn is_initialized(&self) -> bool {
        for v in &self.history {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.history)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.history.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.history.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReferenceId {
        ReferenceId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &ReferenceId| { &m.value },
                    |m: &mut ReferenceId| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Id>>(
                    "history",
                    |m: &ReferenceId| { &m.history },
                    |m: &mut ReferenceId| { &mut m.history },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &ReferenceId| { &m.id },
                    |m: &mut ReferenceId| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &ReferenceId| { &m.extension },
                    |m: &mut ReferenceId| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReferenceId>(
                    "ReferenceId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReferenceId {
        static mut instance: ::protobuf::lazy::Lazy<ReferenceId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReferenceId,
        };
        unsafe {
            instance.get(ReferenceId::new)
        }
    }
}

impl ::protobuf::Clear for ReferenceId {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_history();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReferenceId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReferenceId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddressTypeCode {
    // message fields
    pub value: AddressTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AddressTypeCode {
    pub fn new() -> AddressTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AddressTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AddressTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AddressTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AddressTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AddressTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AddressTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AddressTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressTypeCode {
        AddressTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddressTypeCode_Value>>(
                    "value",
                    |m: &AddressTypeCode| { &m.value },
                    |m: &mut AddressTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &AddressTypeCode| { &m.id },
                    |m: &mut AddressTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &AddressTypeCode| { &m.extension },
                    |m: &mut AddressTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddressTypeCode>(
                    "AddressTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddressTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<AddressTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddressTypeCode,
        };
        unsafe {
            instance.get(AddressTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for AddressTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AddressTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    POSTAL = 1,
    PHYSICAL = 2,
    BOTH = 3,
}

impl ::protobuf::ProtobufEnum for AddressTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AddressTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AddressTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AddressTypeCode_Value::POSTAL),
            2 => ::std::option::Option::Some(AddressTypeCode_Value::PHYSICAL),
            3 => ::std::option::Option::Some(AddressTypeCode_Value::BOTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AddressTypeCode_Value] = &[
            AddressTypeCode_Value::INVALID_UNINITIALIZED,
            AddressTypeCode_Value::POSTAL,
            AddressTypeCode_Value::PHYSICAL,
            AddressTypeCode_Value::BOTH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AddressTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AddressTypeCode_Value {
}

impl ::std::default::Default for AddressTypeCode_Value {
    fn default() -> Self {
        AddressTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddressUseCode {
    // message fields
    pub value: AddressUseCode_Value,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AddressUseCode {
    pub fn new() -> AddressUseCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AddressUseCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AddressUseCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AddressUseCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AddressUseCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AddressUseCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AddressUseCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AddressUseCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressUseCode {
        AddressUseCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AddressUseCode_Value>>(
                    "value",
                    |m: &AddressUseCode| { &m.value },
                    |m: &mut AddressUseCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &AddressUseCode| { &m.id },
                    |m: &mut AddressUseCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &AddressUseCode| { &m.extension },
                    |m: &mut AddressUseCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddressUseCode>(
                    "AddressUseCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddressUseCode {
        static mut instance: ::protobuf::lazy::Lazy<AddressUseCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddressUseCode,
        };
        unsafe {
            instance.get(AddressUseCode::new)
        }
    }
}

impl ::protobuf::Clear for AddressUseCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressUseCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressUseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AddressUseCode_Value {
    INVALID_UNINITIALIZED = 0,
    HOME = 1,
    WORK = 2,
    TEMP = 3,
    OLD = 4,
}

impl ::protobuf::ProtobufEnum for AddressUseCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AddressUseCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AddressUseCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AddressUseCode_Value::HOME),
            2 => ::std::option::Option::Some(AddressUseCode_Value::WORK),
            3 => ::std::option::Option::Some(AddressUseCode_Value::TEMP),
            4 => ::std::option::Option::Some(AddressUseCode_Value::OLD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AddressUseCode_Value] = &[
            AddressUseCode_Value::INVALID_UNINITIALIZED,
            AddressUseCode_Value::HOME,
            AddressUseCode_Value::WORK,
            AddressUseCode_Value::TEMP,
            AddressUseCode_Value::OLD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AddressUseCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AddressUseCode_Value {
}

impl ::std::default::Default for AddressUseCode_Value {
    fn default() -> Self {
        AddressUseCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressUseCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContactPointSystemCode {
    // message fields
    pub value: ContactPointSystemCode_Value,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ContactPointSystemCode {
    pub fn new() -> ContactPointSystemCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ContactPointSystemCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ContactPointSystemCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ContactPointSystemCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ContactPointSystemCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ContactPointSystemCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ContactPointSystemCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ContactPointSystemCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContactPointSystemCode {
        ContactPointSystemCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContactPointSystemCode_Value>>(
                    "value",
                    |m: &ContactPointSystemCode| { &m.value },
                    |m: &mut ContactPointSystemCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &ContactPointSystemCode| { &m.id },
                    |m: &mut ContactPointSystemCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &ContactPointSystemCode| { &m.extension },
                    |m: &mut ContactPointSystemCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContactPointSystemCode>(
                    "ContactPointSystemCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContactPointSystemCode {
        static mut instance: ::protobuf::lazy::Lazy<ContactPointSystemCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContactPointSystemCode,
        };
        unsafe {
            instance.get(ContactPointSystemCode::new)
        }
    }
}

impl ::protobuf::Clear for ContactPointSystemCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContactPointSystemCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactPointSystemCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContactPointSystemCode_Value {
    INVALID_UNINITIALIZED = 0,
    PHONE = 1,
    FAX = 2,
    EMAIL = 3,
    PAGER = 4,
    URL = 5,
    SMS = 6,
    OTHER = 7,
}

impl ::protobuf::ProtobufEnum for ContactPointSystemCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContactPointSystemCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ContactPointSystemCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ContactPointSystemCode_Value::PHONE),
            2 => ::std::option::Option::Some(ContactPointSystemCode_Value::FAX),
            3 => ::std::option::Option::Some(ContactPointSystemCode_Value::EMAIL),
            4 => ::std::option::Option::Some(ContactPointSystemCode_Value::PAGER),
            5 => ::std::option::Option::Some(ContactPointSystemCode_Value::URL),
            6 => ::std::option::Option::Some(ContactPointSystemCode_Value::SMS),
            7 => ::std::option::Option::Some(ContactPointSystemCode_Value::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContactPointSystemCode_Value] = &[
            ContactPointSystemCode_Value::INVALID_UNINITIALIZED,
            ContactPointSystemCode_Value::PHONE,
            ContactPointSystemCode_Value::FAX,
            ContactPointSystemCode_Value::EMAIL,
            ContactPointSystemCode_Value::PAGER,
            ContactPointSystemCode_Value::URL,
            ContactPointSystemCode_Value::SMS,
            ContactPointSystemCode_Value::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContactPointSystemCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContactPointSystemCode_Value {
}

impl ::std::default::Default for ContactPointSystemCode_Value {
    fn default() -> Self {
        ContactPointSystemCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactPointSystemCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContactPointUseCode {
    // message fields
    pub value: ContactPointUseCode_Value,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ContactPointUseCode {
    pub fn new() -> ContactPointUseCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ContactPointUseCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ContactPointUseCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ContactPointUseCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ContactPointUseCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ContactPointUseCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ContactPointUseCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ContactPointUseCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContactPointUseCode {
        ContactPointUseCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContactPointUseCode_Value>>(
                    "value",
                    |m: &ContactPointUseCode| { &m.value },
                    |m: &mut ContactPointUseCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &ContactPointUseCode| { &m.id },
                    |m: &mut ContactPointUseCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &ContactPointUseCode| { &m.extension },
                    |m: &mut ContactPointUseCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContactPointUseCode>(
                    "ContactPointUseCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContactPointUseCode {
        static mut instance: ::protobuf::lazy::Lazy<ContactPointUseCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContactPointUseCode,
        };
        unsafe {
            instance.get(ContactPointUseCode::new)
        }
    }
}

impl ::protobuf::Clear for ContactPointUseCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContactPointUseCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactPointUseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContactPointUseCode_Value {
    INVALID_UNINITIALIZED = 0,
    HOME = 1,
    WORK = 2,
    TEMP = 3,
    OLD = 4,
    MOBILE = 5,
}

impl ::protobuf::ProtobufEnum for ContactPointUseCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContactPointUseCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ContactPointUseCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ContactPointUseCode_Value::HOME),
            2 => ::std::option::Option::Some(ContactPointUseCode_Value::WORK),
            3 => ::std::option::Option::Some(ContactPointUseCode_Value::TEMP),
            4 => ::std::option::Option::Some(ContactPointUseCode_Value::OLD),
            5 => ::std::option::Option::Some(ContactPointUseCode_Value::MOBILE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContactPointUseCode_Value] = &[
            ContactPointUseCode_Value::INVALID_UNINITIALIZED,
            ContactPointUseCode_Value::HOME,
            ContactPointUseCode_Value::WORK,
            ContactPointUseCode_Value::TEMP,
            ContactPointUseCode_Value::OLD,
            ContactPointUseCode_Value::MOBILE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContactPointUseCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContactPointUseCode_Value {
}

impl ::std::default::Default for ContactPointUseCode_Value {
    fn default() -> Self {
        ContactPointUseCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactPointUseCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DaysOfWeekCode {
    // message fields
    pub value: DaysOfWeekCode_Value,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DaysOfWeekCode {
    pub fn new() -> DaysOfWeekCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DaysOfWeekCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DaysOfWeekCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DaysOfWeekCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DaysOfWeekCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DaysOfWeekCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DaysOfWeekCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DaysOfWeekCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DaysOfWeekCode {
        DaysOfWeekCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DaysOfWeekCode_Value>>(
                    "value",
                    |m: &DaysOfWeekCode| { &m.value },
                    |m: &mut DaysOfWeekCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &DaysOfWeekCode| { &m.id },
                    |m: &mut DaysOfWeekCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &DaysOfWeekCode| { &m.extension },
                    |m: &mut DaysOfWeekCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DaysOfWeekCode>(
                    "DaysOfWeekCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DaysOfWeekCode {
        static mut instance: ::protobuf::lazy::Lazy<DaysOfWeekCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DaysOfWeekCode,
        };
        unsafe {
            instance.get(DaysOfWeekCode::new)
        }
    }
}

impl ::protobuf::Clear for DaysOfWeekCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DaysOfWeekCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaysOfWeekCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DaysOfWeekCode_Value {
    INVALID_UNINITIALIZED = 0,
    MON = 1,
    TUE = 2,
    WED = 3,
    THU = 4,
    FRI = 5,
    SAT = 6,
    SUN = 7,
}

impl ::protobuf::ProtobufEnum for DaysOfWeekCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DaysOfWeekCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DaysOfWeekCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DaysOfWeekCode_Value::MON),
            2 => ::std::option::Option::Some(DaysOfWeekCode_Value::TUE),
            3 => ::std::option::Option::Some(DaysOfWeekCode_Value::WED),
            4 => ::std::option::Option::Some(DaysOfWeekCode_Value::THU),
            5 => ::std::option::Option::Some(DaysOfWeekCode_Value::FRI),
            6 => ::std::option::Option::Some(DaysOfWeekCode_Value::SAT),
            7 => ::std::option::Option::Some(DaysOfWeekCode_Value::SUN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DaysOfWeekCode_Value] = &[
            DaysOfWeekCode_Value::INVALID_UNINITIALIZED,
            DaysOfWeekCode_Value::MON,
            DaysOfWeekCode_Value::TUE,
            DaysOfWeekCode_Value::WED,
            DaysOfWeekCode_Value::THU,
            DaysOfWeekCode_Value::FRI,
            DaysOfWeekCode_Value::SAT,
            DaysOfWeekCode_Value::SUN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DaysOfWeekCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DaysOfWeekCode_Value {
}

impl ::std::default::Default for DaysOfWeekCode_Value {
    fn default() -> Self {
        DaysOfWeekCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DaysOfWeekCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventTimingCode {
    // message fields
    pub value: EventTimingCode_Value,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EventTimingCode {
    pub fn new() -> EventTimingCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.EventTimingCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = EventTimingCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: EventTimingCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> EventTimingCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for EventTimingCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != EventTimingCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != EventTimingCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventTimingCode {
        EventTimingCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EventTimingCode_Value>>(
                    "value",
                    |m: &EventTimingCode| { &m.value },
                    |m: &mut EventTimingCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &EventTimingCode| { &m.id },
                    |m: &mut EventTimingCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &EventTimingCode| { &m.extension },
                    |m: &mut EventTimingCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EventTimingCode>(
                    "EventTimingCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EventTimingCode {
        static mut instance: ::protobuf::lazy::Lazy<EventTimingCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventTimingCode,
        };
        unsafe {
            instance.get(EventTimingCode::new)
        }
    }
}

impl ::protobuf::Clear for EventTimingCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventTimingCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventTimingCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EventTimingCode_Value {
    INVALID_UNINITIALIZED = 0,
    MORN = 1,
    AFT = 2,
    EVE = 3,
    NIGHT = 4,
    PHS = 5,
    HS = 6,
    WAKE = 7,
    C = 8,
    CM = 9,
    CD = 10,
    CV = 11,
    AC = 12,
    ACM = 13,
    ACD = 14,
    ACV = 15,
    PC = 16,
    PCM = 17,
    PCD = 18,
    PCV = 19,
}

impl ::protobuf::ProtobufEnum for EventTimingCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EventTimingCode_Value> {
        match value {
            0 => ::std::option::Option::Some(EventTimingCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(EventTimingCode_Value::MORN),
            2 => ::std::option::Option::Some(EventTimingCode_Value::AFT),
            3 => ::std::option::Option::Some(EventTimingCode_Value::EVE),
            4 => ::std::option::Option::Some(EventTimingCode_Value::NIGHT),
            5 => ::std::option::Option::Some(EventTimingCode_Value::PHS),
            6 => ::std::option::Option::Some(EventTimingCode_Value::HS),
            7 => ::std::option::Option::Some(EventTimingCode_Value::WAKE),
            8 => ::std::option::Option::Some(EventTimingCode_Value::C),
            9 => ::std::option::Option::Some(EventTimingCode_Value::CM),
            10 => ::std::option::Option::Some(EventTimingCode_Value::CD),
            11 => ::std::option::Option::Some(EventTimingCode_Value::CV),
            12 => ::std::option::Option::Some(EventTimingCode_Value::AC),
            13 => ::std::option::Option::Some(EventTimingCode_Value::ACM),
            14 => ::std::option::Option::Some(EventTimingCode_Value::ACD),
            15 => ::std::option::Option::Some(EventTimingCode_Value::ACV),
            16 => ::std::option::Option::Some(EventTimingCode_Value::PC),
            17 => ::std::option::Option::Some(EventTimingCode_Value::PCM),
            18 => ::std::option::Option::Some(EventTimingCode_Value::PCD),
            19 => ::std::option::Option::Some(EventTimingCode_Value::PCV),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EventTimingCode_Value] = &[
            EventTimingCode_Value::INVALID_UNINITIALIZED,
            EventTimingCode_Value::MORN,
            EventTimingCode_Value::AFT,
            EventTimingCode_Value::EVE,
            EventTimingCode_Value::NIGHT,
            EventTimingCode_Value::PHS,
            EventTimingCode_Value::HS,
            EventTimingCode_Value::WAKE,
            EventTimingCode_Value::C,
            EventTimingCode_Value::CM,
            EventTimingCode_Value::CD,
            EventTimingCode_Value::CV,
            EventTimingCode_Value::AC,
            EventTimingCode_Value::ACM,
            EventTimingCode_Value::ACD,
            EventTimingCode_Value::ACV,
            EventTimingCode_Value::PC,
            EventTimingCode_Value::PCM,
            EventTimingCode_Value::PCD,
            EventTimingCode_Value::PCV,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EventTimingCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EventTimingCode_Value {
}

impl ::std::default::Default for EventTimingCode_Value {
    fn default() -> Self {
        EventTimingCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for EventTimingCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IdentifierUseCode {
    // message fields
    pub value: IdentifierUseCode_Value,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl IdentifierUseCode {
    pub fn new() -> IdentifierUseCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.IdentifierUseCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = IdentifierUseCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: IdentifierUseCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> IdentifierUseCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for IdentifierUseCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != IdentifierUseCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != IdentifierUseCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdentifierUseCode {
        IdentifierUseCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IdentifierUseCode_Value>>(
                    "value",
                    |m: &IdentifierUseCode| { &m.value },
                    |m: &mut IdentifierUseCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &IdentifierUseCode| { &m.id },
                    |m: &mut IdentifierUseCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &IdentifierUseCode| { &m.extension },
                    |m: &mut IdentifierUseCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IdentifierUseCode>(
                    "IdentifierUseCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IdentifierUseCode {
        static mut instance: ::protobuf::lazy::Lazy<IdentifierUseCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IdentifierUseCode,
        };
        unsafe {
            instance.get(IdentifierUseCode::new)
        }
    }
}

impl ::protobuf::Clear for IdentifierUseCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdentifierUseCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentifierUseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IdentifierUseCode_Value {
    INVALID_UNINITIALIZED = 0,
    USUAL = 1,
    OFFICIAL = 2,
    TEMP = 3,
    SECONDARY = 4,
}

impl ::protobuf::ProtobufEnum for IdentifierUseCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IdentifierUseCode_Value> {
        match value {
            0 => ::std::option::Option::Some(IdentifierUseCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(IdentifierUseCode_Value::USUAL),
            2 => ::std::option::Option::Some(IdentifierUseCode_Value::OFFICIAL),
            3 => ::std::option::Option::Some(IdentifierUseCode_Value::TEMP),
            4 => ::std::option::Option::Some(IdentifierUseCode_Value::SECONDARY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IdentifierUseCode_Value] = &[
            IdentifierUseCode_Value::INVALID_UNINITIALIZED,
            IdentifierUseCode_Value::USUAL,
            IdentifierUseCode_Value::OFFICIAL,
            IdentifierUseCode_Value::TEMP,
            IdentifierUseCode_Value::SECONDARY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("IdentifierUseCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for IdentifierUseCode_Value {
}

impl ::std::default::Default for IdentifierUseCode_Value {
    fn default() -> Self {
        IdentifierUseCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentifierUseCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllLanguageCode {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AllLanguageCode {
    pub fn new() -> AllLanguageCode {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AllLanguageCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllLanguageCode {
        AllLanguageCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &AllLanguageCode| { &m.value },
                    |m: &mut AllLanguageCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &AllLanguageCode| { &m.id },
                    |m: &mut AllLanguageCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &AllLanguageCode| { &m.extension },
                    |m: &mut AllLanguageCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllLanguageCode>(
                    "AllLanguageCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AllLanguageCode {
        static mut instance: ::protobuf::lazy::Lazy<AllLanguageCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllLanguageCode,
        };
        unsafe {
            instance.get(AllLanguageCode::new)
        }
    }
}

impl ::protobuf::Clear for AllLanguageCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllLanguageCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllLanguageCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LanguageCode {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LanguageCode {
    pub fn new() -> LanguageCode {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for LanguageCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LanguageCode {
        LanguageCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &LanguageCode| { &m.value },
                    |m: &mut LanguageCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &LanguageCode| { &m.id },
                    |m: &mut LanguageCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &LanguageCode| { &m.extension },
                    |m: &mut LanguageCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LanguageCode>(
                    "LanguageCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LanguageCode {
        static mut instance: ::protobuf::lazy::Lazy<LanguageCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LanguageCode,
        };
        unsafe {
            instance.get(LanguageCode::new)
        }
    }
}

impl ::protobuf::Clear for LanguageCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LanguageCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LanguageCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MimeTypeCode {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MimeTypeCode {
    pub fn new() -> MimeTypeCode {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MimeTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MimeTypeCode {
        MimeTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &MimeTypeCode| { &m.value },
                    |m: &mut MimeTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &MimeTypeCode| { &m.id },
                    |m: &mut MimeTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &MimeTypeCode| { &m.extension },
                    |m: &mut MimeTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MimeTypeCode>(
                    "MimeTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MimeTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<MimeTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MimeTypeCode,
        };
        unsafe {
            instance.get(MimeTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for MimeTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MimeTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MimeTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NameUseCode {
    // message fields
    pub value: NameUseCode_Value,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NameUseCode {
    pub fn new() -> NameUseCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.NameUseCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = NameUseCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: NameUseCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> NameUseCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for NameUseCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != NameUseCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != NameUseCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NameUseCode {
        NameUseCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NameUseCode_Value>>(
                    "value",
                    |m: &NameUseCode| { &m.value },
                    |m: &mut NameUseCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &NameUseCode| { &m.id },
                    |m: &mut NameUseCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &NameUseCode| { &m.extension },
                    |m: &mut NameUseCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NameUseCode>(
                    "NameUseCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NameUseCode {
        static mut instance: ::protobuf::lazy::Lazy<NameUseCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NameUseCode,
        };
        unsafe {
            instance.get(NameUseCode::new)
        }
    }
}

impl ::protobuf::Clear for NameUseCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NameUseCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NameUseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NameUseCode_Value {
    INVALID_UNINITIALIZED = 0,
    USUAL = 1,
    OFFICIAL = 2,
    TEMP = 3,
    NICKNAME = 4,
    ANONYMOUS = 5,
    OLD = 6,
    MAIDEN = 7,
}

impl ::protobuf::ProtobufEnum for NameUseCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NameUseCode_Value> {
        match value {
            0 => ::std::option::Option::Some(NameUseCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(NameUseCode_Value::USUAL),
            2 => ::std::option::Option::Some(NameUseCode_Value::OFFICIAL),
            3 => ::std::option::Option::Some(NameUseCode_Value::TEMP),
            4 => ::std::option::Option::Some(NameUseCode_Value::NICKNAME),
            5 => ::std::option::Option::Some(NameUseCode_Value::ANONYMOUS),
            6 => ::std::option::Option::Some(NameUseCode_Value::OLD),
            7 => ::std::option::Option::Some(NameUseCode_Value::MAIDEN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NameUseCode_Value] = &[
            NameUseCode_Value::INVALID_UNINITIALIZED,
            NameUseCode_Value::USUAL,
            NameUseCode_Value::OFFICIAL,
            NameUseCode_Value::TEMP,
            NameUseCode_Value::NICKNAME,
            NameUseCode_Value::ANONYMOUS,
            NameUseCode_Value::OLD,
            NameUseCode_Value::MAIDEN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NameUseCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NameUseCode_Value {
}

impl ::std::default::Default for NameUseCode_Value {
    fn default() -> Self {
        NameUseCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for NameUseCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuantityComparatorCode {
    // message fields
    pub value: QuantityComparatorCode_Value,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl QuantityComparatorCode {
    pub fn new() -> QuantityComparatorCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.QuantityComparatorCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = QuantityComparatorCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: QuantityComparatorCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> QuantityComparatorCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for QuantityComparatorCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != QuantityComparatorCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != QuantityComparatorCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuantityComparatorCode {
        QuantityComparatorCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<QuantityComparatorCode_Value>>(
                    "value",
                    |m: &QuantityComparatorCode| { &m.value },
                    |m: &mut QuantityComparatorCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &QuantityComparatorCode| { &m.id },
                    |m: &mut QuantityComparatorCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &QuantityComparatorCode| { &m.extension },
                    |m: &mut QuantityComparatorCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QuantityComparatorCode>(
                    "QuantityComparatorCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QuantityComparatorCode {
        static mut instance: ::protobuf::lazy::Lazy<QuantityComparatorCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QuantityComparatorCode,
        };
        unsafe {
            instance.get(QuantityComparatorCode::new)
        }
    }
}

impl ::protobuf::Clear for QuantityComparatorCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuantityComparatorCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuantityComparatorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum QuantityComparatorCode_Value {
    INVALID_UNINITIALIZED = 0,
    LT = 1,
    LE = 2,
    GE = 3,
    GT = 4,
}

impl ::protobuf::ProtobufEnum for QuantityComparatorCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<QuantityComparatorCode_Value> {
        match value {
            0 => ::std::option::Option::Some(QuantityComparatorCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(QuantityComparatorCode_Value::LT),
            2 => ::std::option::Option::Some(QuantityComparatorCode_Value::LE),
            3 => ::std::option::Option::Some(QuantityComparatorCode_Value::GE),
            4 => ::std::option::Option::Some(QuantityComparatorCode_Value::GT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [QuantityComparatorCode_Value] = &[
            QuantityComparatorCode_Value::INVALID_UNINITIALIZED,
            QuantityComparatorCode_Value::LT,
            QuantityComparatorCode_Value::LE,
            QuantityComparatorCode_Value::GE,
            QuantityComparatorCode_Value::GT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("QuantityComparatorCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for QuantityComparatorCode_Value {
}

impl ::std::default::Default for QuantityComparatorCode_Value {
    fn default() -> Self {
        QuantityComparatorCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for QuantityComparatorCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnitsOfTimeCode {
    // message fields
    pub value: UnitsOfTimeCode_Value,
    pub id: ::protobuf::SingularPtrField<String>,
    pub extension: ::protobuf::RepeatedField<Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UnitsOfTimeCode {
    pub fn new() -> UnitsOfTimeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.UnitsOfTimeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = UnitsOfTimeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: UnitsOfTimeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> UnitsOfTimeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> String {
        self.id.take().unwrap_or_else(|| String::new())
    }

    pub fn get_id(&self) -> &String {
        self.id.as_ref().unwrap_or_else(|| String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for UnitsOfTimeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != UnitsOfTimeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != UnitsOfTimeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnitsOfTimeCode {
        UnitsOfTimeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UnitsOfTimeCode_Value>>(
                    "value",
                    |m: &UnitsOfTimeCode| { &m.value },
                    |m: &mut UnitsOfTimeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<String>>(
                    "id",
                    |m: &UnitsOfTimeCode| { &m.id },
                    |m: &mut UnitsOfTimeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Extension>>(
                    "extension",
                    |m: &UnitsOfTimeCode| { &m.extension },
                    |m: &mut UnitsOfTimeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnitsOfTimeCode>(
                    "UnitsOfTimeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnitsOfTimeCode {
        static mut instance: ::protobuf::lazy::Lazy<UnitsOfTimeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnitsOfTimeCode,
        };
        unsafe {
            instance.get(UnitsOfTimeCode::new)
        }
    }
}

impl ::protobuf::Clear for UnitsOfTimeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnitsOfTimeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitsOfTimeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UnitsOfTimeCode_Value {
    INVALID_UNINITIALIZED = 0,
    S = 1,
    MIN = 2,
    H = 3,
    D = 4,
    WK = 5,
    MO = 6,
    A = 7,
}

impl ::protobuf::ProtobufEnum for UnitsOfTimeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UnitsOfTimeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(UnitsOfTimeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(UnitsOfTimeCode_Value::S),
            2 => ::std::option::Option::Some(UnitsOfTimeCode_Value::MIN),
            3 => ::std::option::Option::Some(UnitsOfTimeCode_Value::H),
            4 => ::std::option::Option::Some(UnitsOfTimeCode_Value::D),
            5 => ::std::option::Option::Some(UnitsOfTimeCode_Value::WK),
            6 => ::std::option::Option::Some(UnitsOfTimeCode_Value::MO),
            7 => ::std::option::Option::Some(UnitsOfTimeCode_Value::A),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UnitsOfTimeCode_Value] = &[
            UnitsOfTimeCode_Value::INVALID_UNINITIALIZED,
            UnitsOfTimeCode_Value::S,
            UnitsOfTimeCode_Value::MIN,
            UnitsOfTimeCode_Value::H,
            UnitsOfTimeCode_Value::D,
            UnitsOfTimeCode_Value::WK,
            UnitsOfTimeCode_Value::MO,
            UnitsOfTimeCode_Value::A,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("UnitsOfTimeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for UnitsOfTimeCode_Value {
}

impl ::std::default::Default for UnitsOfTimeCode_Value {
    fn default() -> Self {
        UnitsOfTimeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for UnitsOfTimeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1aproto/stu3/datatypes.proto\x12\x16google.fhir.stu3.proto\x1a\x1cpr\
    oto/stu3/annotations.proto\"\xd7\x01\n\x0cBase64Binary\x12\x14\n\x05valu\
    e\x18\x01\x20\x01(\x0cR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.\
    google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension:@\xc0\x9f\xe3\xb6\
    \x05\x01\xb2\xfe\xe4\x97\x064http://hl7.org/fhir/StructureDefinition/bas\
    e64Binary\"\xcd\x01\n\x07Boolean\x12\x14\n\x05value\x18\x01\x20\x01(\x08\
    R\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto\
    .StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3\
    .proto.ExtensionR\textension:;\xb2\xfe\xe4\x97\x06/http://hl7.org/fhir/S\
    tructureDefinition/boolean\xc0\x9f\xe3\xb6\x05\x01\"\xe1\x01\n\x04Code\
    \x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension:R\
    \xc0\x9f\xe3\xb6\x05\x01\x92\xfa\xa2\x8c\x06\x14[^\\s]+([\\s]?[^\\s]+)*\
    \xb2\xfe\xe4\x97\x06,http://hl7.org/fhir/StructureDefinition/code\"\xb5\
    \x03\n\x04Date\x12\x19\n\x08value_us\x18\x01\x20\x01(\x03R\x07valueUs\
    \x12\x1a\n\x08timezone\x18\x02\x20\x01(\tR\x08timezone\x12D\n\tprecision\
    \x18\x03\x20\x01(\x0e2&.google.fhir.stu3.proto.Date.PrecisionR\tprecisio\
    n\x12.\n\x02id\x18\x04\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x05\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"D\n\tPrecision\x12\x19\n\x15PRECISION_UNSPECIFIED\
    \x10\0\x12\x08\n\x04YEAR\x10\x01\x12\t\n\x05MONTH\x10\x02\x12\x07\n\x03D\
    AY\x10\x03:y\xb2\xfe\xe4\x97\x06,http://hl7.org/fhir/StructureDefinition\
    /date\x92\xfa\xa2\x8c\x06;-?[0-9]{4}(-(0[1-9]|1[0-2])(-(0[0-9]|[1-2][0-9\
    ]|3[0-1]))?)?\xc0\x9f\xe3\xb6\x05\x01\"\xd4\x04\n\x08DateTime\x12\x19\n\
    \x08value_us\x18\x01\x20\x01(\x03R\x07valueUs\x12\x1a\n\x08timezone\x18\
    \x02\x20\x01(\tR\x08timezone\x12H\n\tprecision\x18\x03\x20\x01(\x0e2*.go\
    ogle.fhir.stu3.proto.DateTime.PrecisionR\tprecision\x12.\n\x02id\x18\x04\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x05\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"r\
    \n\tPrecision\x12\x19\n\x15PRECISION_UNSPECIFIED\x10\0\x12\x08\n\x04YEAR\
    \x10\x01\x12\t\n\x05MONTH\x10\x02\x12\x07\n\x03DAY\x10\x03\x12\n\n\x06SE\
    COND\x10\x04\x12\x0f\n\x0bMILLISECOND\x10\x05\x12\x0f\n\x0bMICROSECOND\
    \x10\x06:\xe1\x01\xc0\x9f\xe3\xb6\x05\x01\x92\xfa\xa2\x8c\x06\x9e\x01-?[\
    0-9]{4}(-(0[1-9]|1[0-2])(-(0[0-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3])\
    :[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|\
    14:00)))?)?)?\xb2\xfe\xe4\x97\x060http://hl7.org/fhir/StructureDefinitio\
    n/dateTime\"\xf3\x01\n\x07Decimal\x12\x14\n\x05value\x18\x01\x20\x01(\tR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension:a\x92\xfa\xa2\x8c\x06\x20-?([0]|([1-9][0-9]*\
    ))(\\.[0-9]+)?\xc0\x9f\xe3\xb6\x05\x01\xb2\xfe\xe4\x97\x06/http://hl7.or\
    g/fhir/StructureDefinition/decimal\"\xde\x01\n\x02Id\x12\x14\n\x05value\
    \x18\x01\x20\x01(\tR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goo\
    gle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b\
    2!.google.fhir.stu3.proto.ExtensionR\textension:Q\xc0\x9f\xe3\xb6\x05\
    \x01\x92\xfa\xa2\x8c\x06\x15[A-Za-z0-9\\-\\.]{1,64}\xb2\xfe\xe4\x97\x06*\
    http://hl7.org/fhir/StructureDefinition/id\"\x8d\x03\n\x07Instant\x12\
    \x19\n\x08value_us\x18\x01\x20\x01(\x03R\x07valueUs\x12\x1a\n\x08timezon\
    e\x18\x02\x20\x01(\tR\x08timezone\x12G\n\tprecision\x18\x03\x20\x01(\x0e\
    2).google.fhir.stu3.proto.Instant.PrecisionR\tprecision\x12.\n\x02id\x18\
    \x04\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x05\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"T\n\tPrecision\x12\x19\n\x15PRECISION_UNSPECIFIED\x10\0\x12\n\n\x06SE\
    COND\x10\x01\x12\x0f\n\x0bMILLISECOND\x10\x02\x12\x0f\n\x0bMICROSECOND\
    \x10\x03:;\xc0\x9f\xe3\xb6\x05\x01\xb2\xfe\xe4\x97\x06/http://hl7.org/fh\
    ir/StructureDefinition/instant\"\xe8\x01\n\x07Integer\x12\x14\n\x05value\
    \x18\x01\x20\x01(\x11R\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.g\
    oogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension:V\xb2\xfe\xe4\x97\
    \x06/http://hl7.org/fhir/StructureDefinition/integer\xc0\x9f\xe3\xb6\x05\
    \x01\x92\xfa\xa2\x8c\x06\x15-?([0]|([1-9][0-9]*))\"\xcf\x01\n\x08Markdow\
    n\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension:<\
    \xb2\xfe\xe4\x97\x060http://hl7.org/fhir/StructureDefinition/markdown\
    \xc0\x9f\xe3\xb6\x05\x01\"\xf6\x01\n\x03Oid\x12\x14\n\x05value\x18\x01\
    \x20\x01(\tR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir\
    .stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.googl\
    e.fhir.stu3.proto.ExtensionR\textension:h\x92\xfa\xa2\x8c\x06+urn:oid:(0\
    |[1-9][0-9]*)(\\.(0|[1-9][0-9]*))*\xb2\xfe\xe4\x97\x06+http://hl7.org/fh\
    ir/StructureDefinition/oid\xc0\x9f\xe3\xb6\x05\x01\"\xe6\x01\n\x0bPositi\
    veInt\x12\x14\n\x05value\x18\x01\x20\x01(\rR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n:P\x92\xfa\xa2\x8c\x06\x0b[1-9][0-9]*\xc0\x9f\xe3\xb6\x05\x01\xb2\xfe\
    \xe4\x97\x063http://hl7.org/fhir/StructureDefinition/positiveInt\"\xcb\
    \x01\n\x06String\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension::\xb2\xfe\xe4\x97\x06.http://hl7.org/fhir/StructureDefini\
    tion/string\xc0\x9f\xe3\xb6\x05\x01\"\xa1\x03\n\x04Time\x12\x19\n\x08val\
    ue_us\x18\x01\x20\x01(\x03R\x07valueUs\x12D\n\tprecision\x18\x02\x20\x01\
    (\x0e2&.google.fhir.stu3.proto.Time.PrecisionR\tprecision\x12.\n\x02id\
    \x18\x03\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x04\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"T\n\tPrecision\x12\x19\n\x15PRECISION_UNSPECIFIED\x10\0\x12\n\n\
    \x06SECOND\x10\x01\x12\x0f\n\x0bMILLISECOND\x10\x02\x12\x0f\n\x0bMICROSE\
    COND\x10\x03:q\xb2\xfe\xe4\x97\x06,http://hl7.org/fhir/StructureDefiniti\
    on/time\xc0\x9f\xe3\xb6\x05\x01\x92\xfa\xa2\x8c\x063([01][0-9]|2[0-3]):[\
    0-5][0-9]:[0-5][0-9](\\.[0-9]+)?\"\xec\x01\n\x0bUnsignedInt\x12\x14\n\
    \x05value\x18\x01\x20\x01(\rR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b\
    2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension:V\x92\xfa\xa2\
    \x8c\x06\x11[0]|([1-9][0-9]*)\xc0\x9f\xe3\xb6\x05\x01\xb2\xfe\xe4\x97\
    \x063http://hl7.org/fhir/StructureDefinition/unsignedInt\"\xc5\x01\n\x03\
    Uri\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension:7\
    \xb2\xfe\xe4\x97\x06+http://hl7.org/fhir/StructureDefinition/uri\xc0\x9f\
    \xe3\xb6\x05\x01\"\x93\x02\n\x04Uuid\x12\x14\n\x05value\x18\x01\x20\x01(\
    \tR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.pro\
    to.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.st\
    u3.proto.ExtensionR\textension:\x83\x01\x92\xfa\xa2\x8c\x06Eurn:uuid:[0-\
    9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\xb2\xfe\xe4\
    \x97\x06,http://hl7.org/fhir/StructureDefinition/uuid\xc0\x9f\xe3\xb6\
    \x05\x01\"\x90\x01\n\x05Xhtml\x12\x1c\n\x05value\x18\x01\x20\x01(\tR\x05\
    valueB\x06\xf0\xd0\x87\xeb\x04\x01\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id:9\xb2\xfe\xe4\x97\x06-http://h\
    l7.org/fhir/StructureDefinition/xhtml\xc0\x9f\xe3\xb6\x05\x01\"\xef\x05\
    \n\x07Address\x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.pr\
    oto.StringR\x02id\x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.s\
    tu3.proto.ExtensionR\textension\x128\n\x03use\x18\x03\x20\x01(\x0b2&.goo\
    gle.fhir.stu3.proto.AddressUseCodeR\x03use\x12;\n\x04type\x18\x04\x20\
    \x01(\x0b2'.google.fhir.stu3.proto.AddressTypeCodeR\x04type\x122\n\x04te\
    xt\x18\x05\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x04text\x122\
    \n\x04line\x18\x06\x20\x03(\x0b2\x1e.google.fhir.stu3.proto.StringR\x04l\
    ine\x122\n\x04city\x18\x07\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Stri\
    ngR\x04city\x12:\n\x08district\x18\x08\x20\x01(\x0b2\x1e.google.fhir.stu\
    3.proto.StringR\x08district\x124\n\x05state\x18\t\x20\x01(\x0b2\x1e.goog\
    le.fhir.stu3.proto.StringR\x05state\x12?\n\x0bpostal_code\x18\n\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\npostalCode\x128\n\x07country\
    \x18\x0b\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x07country\x12\
    6\n\x06period\x18\x0c\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.PeriodR\
    \x06period:;\xb2\xfe\xe4\x97\x06/http://hl7.org/fhir/StructureDefinition\
    /Address\xc0\x9f\xe3\xb6\x05\x02\"\xd1\x03\n\x03Age\x12.\n\x02id\x18\x01\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\
    \x125\n\x05value\x18\x03\x20\x01(\x0b2\x1f.google.fhir.stu3.proto.Decima\
    lR\x05value\x12N\n\ncomparator\x18\x04\x20\x01(\x0b2..google.fhir.stu3.p\
    roto.QuantityComparatorCodeR\ncomparator\x122\n\x04unit\x18\x05\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x04unit\x123\n\x06system\x18\
    \x06\x20\x01(\x0b2\x1b.google.fhir.stu3.proto.UriR\x06system\x120\n\x04c\
    ode\x18\x07\x20\x01(\x0b2\x1c.google.fhir.stu3.proto.CodeR\x04code:7\xc0\
    \x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\x97\x06+http://hl7.org/fhir/StructureDe\
    finition/Age\"\xc0\x05\n\nAnnotation\x12.\n\x02id\x18\x01\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x02\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\x12I\n\x06autho\
    r\x18\x03\x20\x01(\x0b2).google.fhir.stu3.proto.Annotation.AuthorR\x06au\
    thorB\x06\xf8\xe1\xe3\xc9\x05\x01\x124\n\x04time\x18\x04\x20\x01(\x0b2\
    \x20.google.fhir.stu3.proto.DateTimeR\x04time\x12:\n\x04text\x18\x05\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x04textB\x06\xf0\xd0\x87\
    \xeb\x04\x01\x1a\xc3\x02\n\x06Author\x12\xee\x01\n\treference\x18\x01\
    \x20\x01(\x0b2!.google.fhir.stu3.proto.ReferenceH\0R\treferenceB\xaa\x01\
    \xf2\xff\xfc\xc2\x064http://hl7.org/fhir/StructureDefinition/Practitione\
    r\xf2\xff\xfc\xc2\x06/http://hl7.org/fhir/StructureDefinition/Patient\
    \xf2\xff\xfc\xc2\x065http://hl7.org/fhir/StructureDefinition/RelatedPers\
    on\x12>\n\x0cstring_value\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.pro\
    to.StringH\0R\x06stringB\x08\n\x06author:>\xc0\x9f\xe3\xb6\x05\x02\xb2\
    \xfe\xe4\x97\x062http://hl7.org/fhir/StructureDefinition/Annotation\"\
    \x98\x05\n\nAttachment\x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhi\
    r.stu3.proto.StringR\x02id\x12?\n\textension\x18\x02\x20\x03(\x0b2!.goog\
    le.fhir.stu3.proto.ExtensionR\textension\x12G\n\x0ccontent_type\x18\x03\
    \x20\x01(\x0b2$.google.fhir.stu3.proto.MimeTypeCodeR\x0bcontentType\x12@\
    \n\x08language\x18\x04\x20\x01(\x0b2$.google.fhir.stu3.proto.LanguageCod\
    eR\x08language\x128\n\x04data\x18\x05\x20\x01(\x0b2$.google.fhir.stu3.pr\
    oto.Base64BinaryR\x04data\x12-\n\x03url\x18\x06\x20\x01(\x0b2\x1b.google\
    .fhir.stu3.proto.UriR\x03url\x127\n\x04size\x18\x07\x20\x01(\x0b2#.googl\
    e.fhir.stu3.proto.UnsignedIntR\x04size\x128\n\x04hash\x18\x08\x20\x01(\
    \x0b2$.google.fhir.stu3.proto.Base64BinaryR\x04hash\x124\n\x05title\x18\
    \t\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x05title\x12<\n\x08c\
    reation\x18\n\x20\x01(\x0b2\x20.google.fhir.stu3.proto.DateTimeR\x08crea\
    tion:>\xc0\x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\x97\x062http://hl7.org/fhir/S\
    tructureDefinition/Attachment\"\xb3\x02\n\x0fCodeableConcept\x12.\n\x02i\
    d\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\x126\n\x06coding\x18\x03\x20\x03(\x0b2\x1e.google.fhir.stu3.prot\
    o.CodingR\x06coding\x122\n\x04text\x18\x04\x20\x01(\x0b2\x1e.google.fhir\
    .stu3.proto.StringR\x04text:C\xc0\x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\x97\
    \x067http://hl7.org/fhir/StructureDefinition/CodeableConcept\"\xd6\x03\n\
    \x06Coding\x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto\
    .StringR\x02id\x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3\
    .proto.ExtensionR\textension\x123\n\x06system\x18\x03\x20\x01(\x0b2\x1b.\
    google.fhir.stu3.proto.UriR\x06system\x128\n\x07version\x18\x04\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x07version\x120\n\x04code\x18\
    \x05\x20\x01(\x0b2\x1c.google.fhir.stu3.proto.CodeR\x04code\x128\n\x07di\
    splay\x18\x06\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x07displa\
    y\x12D\n\ruser_selected\x18\x07\x20\x01(\x0b2\x1f.google.fhir.stu3.proto\
    .BooleanR\x0cuserSelected::\xb2\xfe\xe4\x97\x06.http://hl7.org/fhir/Stru\
    ctureDefinition/Coding\xc0\x9f\xe3\xb6\x05\x02\"\xef\x03\n\x0cContactPoi\
    nt\x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\x12F\n\x06system\x18\x03\x20\x01(\x0b2..google.fhir\
    .stu3.proto.ContactPointSystemCodeR\x06system\x124\n\x05value\x18\x04\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x05value\x12=\n\x03use\
    \x18\x05\x20\x01(\x0b2+.google.fhir.stu3.proto.ContactPointUseCodeR\x03u\
    se\x127\n\x04rank\x18\x06\x20\x01(\x0b2#.google.fhir.stu3.proto.Positive\
    IntR\x04rank\x126\n\x06period\x18\x07\x20\x01(\x0b2\x1e.google.fhir.stu3\
    .proto.PeriodR\x06period:@\xb2\xfe\xe4\x97\x064http://hl7.org/fhir/Struc\
    tureDefinition/ContactPoint\xc0\x9f\xe3\xb6\x05\x02\"\xd5\x03\n\x05Count\
    \x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\x125\n\x05value\x18\x03\x20\x01(\x0b2\x1f.google.fh\
    ir.stu3.proto.DecimalR\x05value\x12N\n\ncomparator\x18\x04\x20\x01(\x0b2\
    ..google.fhir.stu3.proto.QuantityComparatorCodeR\ncomparator\x122\n\x04u\
    nit\x18\x05\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x04unit\x12\
    3\n\x06system\x18\x06\x20\x01(\x0b2\x1b.google.fhir.stu3.proto.UriR\x06s\
    ystem\x120\n\x04code\x18\x07\x20\x01(\x0b2\x1c.google.fhir.stu3.proto.Co\
    deR\x04code:9\xc0\x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\x97\x06-http://hl7.org\
    /fhir/StructureDefinition/Count\"\xdb\x03\n\x08Distance\x12.\n\x02id\x18\
    \x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\x125\n\x05value\x18\x03\x20\x01(\x0b2\x1f.google.fhir.stu3.proto.Decim\
    alR\x05value\x12N\n\ncomparator\x18\x04\x20\x01(\x0b2..google.fhir.stu3.\
    proto.QuantityComparatorCodeR\ncomparator\x122\n\x04unit\x18\x05\x20\x01\
    (\x0b2\x1e.google.fhir.stu3.proto.StringR\x04unit\x123\n\x06system\x18\
    \x06\x20\x01(\x0b2\x1b.google.fhir.stu3.proto.UriR\x06system\x120\n\x04c\
    ode\x18\x07\x20\x01(\x0b2\x1c.google.fhir.stu3.proto.CodeR\x04code:<\xc0\
    \x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\x97\x060http://hl7.org/fhir/StructureDe\
    finition/Distance\"\xac\r\n\x06Dosage\x12.\n\x02id\x18\x01\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x02\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\x12;\n\x08seque\
    nce\x18\x03\x20\x01(\x0b2\x1f.google.fhir.stu3.proto.IntegerR\x08sequenc\
    e\x122\n\x04text\x18\x04\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.String\
    R\x04text\x12^\n\x16additional_instruction\x18\x05\x20\x03(\x0b2'.google\
    .fhir.stu3.proto.CodeableConceptR\x15additionalInstruction\x12O\n\x13pat\
    ient_instruction\x18\x06\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.String\
    R\x12patientInstruction\x126\n\x06timing\x18\x07\x20\x01(\x0b2\x1e.googl\
    e.fhir.stu3.proto.TimingR\x06timing\x12L\n\tas_needed\x18\x08\x20\x01(\
    \x0b2'.google.fhir.stu3.proto.Dosage.AsNeededR\x08asNeededB\x06\xf8\xe1\
    \xe3\xc9\x05\x01\x12;\n\x04site\x18\t\x20\x01(\x0b2'.google.fhir.stu3.pr\
    oto.CodeableConceptR\x04site\x12=\n\x05route\x18\n\x20\x01(\x0b2'.google\
    .fhir.stu3.proto.CodeableConceptR\x05route\x12?\n\x06method\x18\x0b\x20\
    \x01(\x0b2'.google.fhir.stu3.proto.CodeableConceptR\x06method\x12?\n\x04\
    dose\x18\x0c\x20\x01(\x0b2#.google.fhir.stu3.proto.Dosage.DoseR\x04doseB\
    \x06\xf8\xe1\xe3\xc9\x05\x01\x12L\n\x13max_dose_per_period\x18\r\x20\x01\
    (\x0b2\x1d.google.fhir.stu3.proto.RatioR\x10maxDosePerPeriod\x12e\n\x1bm\
    ax_dose_per_administration\x18\x0e\x20\x01(\x0b2&.google.fhir.stu3.proto\
    .SimpleQuantityR\x18maxDosePerAdministration\x12Y\n\x15max_dose_per_life\
    time\x18\x0f\x20\x01(\x0b2&.google.fhir.stu3.proto.SimpleQuantityR\x12ma\
    xDosePerLifetime\x12?\n\x04rate\x18\x10\x20\x01(\x0b2#.google.fhir.stu3.\
    proto.Dosage.RateR\x04rateB\x06\xf8\xe1\xe3\xc9\x05\x01\x1a\xaa\x01\n\
    \x08AsNeeded\x12;\n\x07boolean\x18\x01\x20\x01(\x0b2\x1f.google.fhir.stu\
    3.proto.BooleanH\0R\x07boolean\x12T\n\x10codeable_concept\x18\x02\x20\
    \x01(\x0b2'.google.fhir.stu3.proto.CodeableConceptH\0R\x0fcodeableConcep\
    tB\x0b\n\tas_needed\x1a\x8b\x01\n\x04Dose\x125\n\x05range\x18\x01\x20\
    \x01(\x0b2\x1d.google.fhir.stu3.proto.RangeH\0R\x05range\x12D\n\x08quant\
    ity\x18\x02\x20\x01(\x0b2&.google.fhir.stu3.proto.SimpleQuantityH\0R\x08\
    quantityB\x06\n\x04dose\x1a\xc2\x01\n\x04Rate\x125\n\x05ratio\x18\x01\
    \x20\x01(\x0b2\x1d.google.fhir.stu3.proto.RatioH\0R\x05ratio\x125\n\x05r\
    ange\x18\x02\x20\x01(\x0b2\x1d.google.fhir.stu3.proto.RangeH\0R\x05range\
    \x12D\n\x08quantity\x18\x03\x20\x01(\x0b2&.google.fhir.stu3.proto.Simple\
    QuantityH\0R\x08quantityB\x06\n\x04rate::\xb2\xfe\xe4\x97\x06.http://hl7\
    .org/fhir/StructureDefinition/Dosage\xc0\x9f\xe3\xb6\x05\x02\"\xdb\x03\n\
    \x08Duration\x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.pro\
    to.StringR\x02id\x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.st\
    u3.proto.ExtensionR\textension\x125\n\x05value\x18\x03\x20\x01(\x0b2\x1f\
    .google.fhir.stu3.proto.DecimalR\x05value\x12N\n\ncomparator\x18\x04\x20\
    \x01(\x0b2..google.fhir.stu3.proto.QuantityComparatorCodeR\ncomparator\
    \x122\n\x04unit\x18\x05\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x04unit\x123\n\x06system\x18\x06\x20\x01(\x0b2\x1b.google.fhir.stu3.pro\
    to.UriR\x06system\x120\n\x04code\x18\x07\x20\x01(\x0b2\x1c.google.fhir.s\
    tu3.proto.CodeR\x04code:<\xc0\x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\x97\x060ht\
    tp://hl7.org/fhir/StructureDefinition/Duration\"\xbc\x04\n\tHumanName\
    \x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\x125\n\x03use\x18\x03\x20\x01(\x0b2#.google.fhir.st\
    u3.proto.NameUseCodeR\x03use\x122\n\x04text\x18\x04\x20\x01(\x0b2\x1e.go\
    ogle.fhir.stu3.proto.StringR\x04text\x126\n\x06family\x18\x05\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x06family\x124\n\x05given\x18\
    \x06\x20\x03(\x0b2\x1e.google.fhir.stu3.proto.StringR\x05given\x126\n\
    \x06prefix\x18\x07\x20\x03(\x0b2\x1e.google.fhir.stu3.proto.StringR\x06p\
    refix\x126\n\x06suffix\x18\x08\x20\x03(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x06suffix\x126\n\x06period\x18\t\x20\x01(\x0b2\x1e.google.fhir.s\
    tu3.proto.PeriodR\x06period:=\xb2\xfe\xe4\x97\x061http://hl7.org/fhir/St\
    ructureDefinition/HumanName\xc0\x9f\xe3\xb6\x05\x02\"\xd5\x04\n\nIdentif\
    ier\x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.String\
    R\x02id\x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.\
    ExtensionR\textension\x12;\n\x03use\x18\x03\x20\x01(\x0b2).google.fhir.s\
    tu3.proto.IdentifierUseCodeR\x03use\x12;\n\x04type\x18\x04\x20\x01(\x0b2\
    '.google.fhir.stu3.proto.CodeableConceptR\x04type\x123\n\x06system\x18\
    \x05\x20\x01(\x0b2\x1b.google.fhir.stu3.proto.UriR\x06system\x124\n\x05v\
    alue\x18\x06\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x05value\
    \x126\n\x06period\x18\x07\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Perio\
    dR\x06period\x12y\n\x08assigner\x18\x08\x20\x01(\x0b2!.google.fhir.stu3.\
    proto.ReferenceR\x08assignerB:\xf2\xff\xfc\xc2\x064http://hl7.org/fhir/S\
    tructureDefinition/Organization:>\xc0\x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\
    \x97\x062http://hl7.org/fhir/StructureDefinition/Identifier\"\xd5\x03\n\
    \x04Meta\x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.S\
    tringR\x02id\x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.p\
    roto.ExtensionR\textension\x129\n\nversion_id\x18\x03\x20\x01(\x0b2\x1a.\
    google.fhir.stu3.proto.IdR\tversionId\x12B\n\x0clast_updated\x18\x04\x20\
    \x01(\x0b2\x1f.google.fhir.stu3.proto.InstantR\x0blastUpdated\x125\n\x07\
    profile\x18\x05\x20\x03(\x0b2\x1b.google.fhir.stu3.proto.UriR\x07profile\
    \x12:\n\x08security\x18\x06\x20\x03(\x0b2\x1e.google.fhir.stu3.proto.Cod\
    ingR\x08security\x120\n\x03tag\x18\x07\x20\x03(\x0b2\x1e.google.fhir.stu\
    3.proto.CodingR\x03tag:8\xc0\x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\x97\x06,htt\
    p://hl7.org/fhir/StructureDefinition/Meta\"\xd5\x03\n\x05Money\x12.\n\
    \x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\x125\n\x05value\x18\x03\x20\x01(\x0b2\x1f.google.fhir.stu\
    3.proto.DecimalR\x05value\x12N\n\ncomparator\x18\x04\x20\x01(\x0b2..goog\
    le.fhir.stu3.proto.QuantityComparatorCodeR\ncomparator\x122\n\x04unit\
    \x18\x05\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x04unit\x123\n\
    \x06system\x18\x06\x20\x01(\x0b2\x1b.google.fhir.stu3.proto.UriR\x06syst\
    em\x120\n\x04code\x18\x07\x20\x01(\x0b2\x1c.google.fhir.stu3.proto.CodeR\
    \x04code:9\xb2\xfe\xe4\x97\x06-http://hl7.org/fhir/StructureDefinition/M\
    oney\xc0\x9f\xe3\xb6\x05\x02\"\xa1\x02\n\x06Period\x12.\n\x02id\x18\x01\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\
    \x126\n\x05start\x18\x03\x20\x01(\x0b2\x20.google.fhir.stu3.proto.DateTi\
    meR\x05start\x122\n\x03end\x18\x04\x20\x01(\x0b2\x20.google.fhir.stu3.pr\
    oto.DateTimeR\x03end::\xc0\x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\x97\x06.http:\
    //hl7.org/fhir/StructureDefinition/Period\"\xdb\x03\n\x08Quantity\x12.\n\
    \x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\x125\n\x05value\x18\x03\x20\x01(\x0b2\x1f.google.fhir.stu\
    3.proto.DecimalR\x05value\x12N\n\ncomparator\x18\x04\x20\x01(\x0b2..goog\
    le.fhir.stu3.proto.QuantityComparatorCodeR\ncomparator\x122\n\x04unit\
    \x18\x05\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x04unit\x123\n\
    \x06system\x18\x06\x20\x01(\x0b2\x1b.google.fhir.stu3.proto.UriR\x06syst\
    em\x120\n\x04code\x18\x07\x20\x01(\x0b2\x1c.google.fhir.stu3.proto.CodeR\
    \x04code:<\xc0\x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\x97\x060http://hl7.org/fh\
    ir/StructureDefinition/Quantity\"\xa9\x02\n\x05Range\x12.\n\x02id\x18\
    \x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\x128\n\x03low\x18\x03\x20\x01(\x0b2&.google.fhir.stu3.proto.SimpleQuan\
    tityR\x03low\x12:\n\x04high\x18\x04\x20\x01(\x0b2&.google.fhir.stu3.prot\
    o.SimpleQuantityR\x04high:9\xc0\x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\x97\x06-\
    http://hl7.org/fhir/StructureDefinition/Range\"\xb7\x02\n\x05Ratio\x12.\
    \n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\x12>\n\tnumerator\x18\x03\x20\x01(\x0b2\x20.google.fhir.s\
    tu3.proto.QuantityR\tnumerator\x12B\n\x0bdenominator\x18\x04\x20\x01(\
    \x0b2\x20.google.fhir.stu3.proto.QuantityR\x0bdenominator:9\xc0\x9f\xe3\
    \xb6\x05\x02\xb2\xfe\xe4\x97\x06-http://hl7.org/fhir/StructureDefinition\
    /Ratio\"\x8e\x05\n\x0bSampledData\x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e\
    .google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x02\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\x12F\n\x06origin\x18\
    \x03\x20\x01(\x0b2&.google.fhir.stu3.proto.SimpleQuantityR\x06originB\
    \x06\xf0\xd0\x87\xeb\x04\x01\x12?\n\x06period\x18\x04\x20\x01(\x0b2\x1f.\
    google.fhir.stu3.proto.DecimalR\x06periodB\x06\xf0\xd0\x87\xeb\x04\x01\
    \x127\n\x06factor\x18\x05\x20\x01(\x0b2\x1f.google.fhir.stu3.proto.Decim\
    alR\x06factor\x12@\n\x0blower_limit\x18\x06\x20\x01(\x0b2\x1f.google.fhi\
    r.stu3.proto.DecimalR\nlowerLimit\x12@\n\x0bupper_limit\x18\x07\x20\x01(\
    \x0b2\x1f.google.fhir.stu3.proto.DecimalR\nupperLimit\x12K\n\ndimensions\
    \x18\x08\x20\x01(\x0b2#.google.fhir.stu3.proto.PositiveIntR\ndimensionsB\
    \x06\xf0\xd0\x87\xeb\x04\x01\x12:\n\x04data\x18\t\x20\x01(\x0b2\x1e.goog\
    le.fhir.stu3.proto.StringR\x04dataB\x06\xf0\xd0\x87\xeb\x04\x01:?\xc0\
    \x9f\xe3\xb6\x05\x02\xb2\xfe\xe4\x97\x063http://hl7.org/fhir/StructureDe\
    finition/SampledData\"\xa4\x0b\n\tSignature\x12.\n\x02id\x18\x01\x20\x01\
    (\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\
    \x02\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\x12:\n\
    \x04type\x18\x03\x20\x03(\x0b2\x1e.google.fhir.stu3.proto.CodingR\x04typ\
    eB\x06\xf0\xd0\x87\xeb\x04\x01\x12;\n\x04when\x18\x04\x20\x01(\x0b2\x1f.\
    google.fhir.stu3.proto.InstantR\x04whenB\x06\xf0\xd0\x87\xeb\x04\x01\x12\
    E\n\x03who\x18\x05\x20\x01(\x0b2%.google.fhir.stu3.proto.Signature.WhoR\
    \x03whoB\x0c\xf8\xe1\xe3\xc9\x05\x01\xf0\xd0\x87\xeb\x04\x01\x12V\n\x0co\
    n_behalf_of\x18\x06\x20\x01(\x0b2,.google.fhir.stu3.proto.Signature.OnBe\
    halfOfR\nonBehalfOfB\x06\xf8\xe1\xe3\xc9\x05\x01\x12G\n\x0ccontent_type\
    \x18\x07\x20\x01(\x0b2$.google.fhir.stu3.proto.MimeTypeCodeR\x0bcontentT\
    ype\x128\n\x04blob\x18\x08\x20\x01(\x0b2$.google.fhir.stu3.proto.Base64B\
    inaryR\x04blob\x1a\x9c\x03\n\x03Who\x12/\n\x03uri\x18\x01\x20\x01(\x0b2\
    \x1b.google.fhir.stu3.proto.UriH\0R\x03uri\x12\xdc\x02\n\treference\x18\
    \x02\x20\x01(\x0b2!.google.fhir.stu3.proto.ReferenceH\0R\treferenceB\x98\
    \x02\xf2\xff\xfc\xc2\x064http://hl7.org/fhir/StructureDefinition/Practit\
    ioner\xf2\xff\xfc\xc2\x065http://hl7.org/fhir/StructureDefinition/Relate\
    dPerson\xf2\xff\xfc\xc2\x06/http://hl7.org/fhir/StructureDefinition/Pati\
    ent\xf2\xff\xfc\xc2\x06.http://hl7.org/fhir/StructureDefinition/Device\
    \xf2\xff\xfc\xc2\x064http://hl7.org/fhir/StructureDefinition/Organizatio\
    nB\x05\n\x03who\x1a\xac\x03\n\nOnBehalfOf\x12/\n\x03uri\x18\x01\x20\x01(\
    \x0b2\x1b.google.fhir.stu3.proto.UriH\0R\x03uri\x12\xdc\x02\n\treference\
    \x18\x02\x20\x01(\x0b2!.google.fhir.stu3.proto.ReferenceH\0R\treferenceB\
    \x98\x02\xf2\xff\xfc\xc2\x064http://hl7.org/fhir/StructureDefinition/Pra\
    ctitioner\xf2\xff\xfc\xc2\x065http://hl7.org/fhir/StructureDefinition/Re\
    latedPerson\xf2\xff\xfc\xc2\x06/http://hl7.org/fhir/StructureDefinition/\
    Patient\xf2\xff\xfc\xc2\x06.http://hl7.org/fhir/StructureDefinition/Devi\
    ce\xf2\xff\xfc\xc2\x064http://hl7.org/fhir/StructureDefinition/Organizat\
    ionB\x0e\n\x0con_behalf_of:=\xb2\xfe\xe4\x97\x061http://hl7.org/fhir/Str\
    uctureDefinition/Signature\xc0\x9f\xe3\xb6\x05\x02\"\xcd\x03\n\x0eSimple\
    Quantity\x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.S\
    tringR\x02id\x12?\n\textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.p\
    roto.ExtensionR\textension\x125\n\x05value\x18\x03\x20\x01(\x0b2\x1f.goo\
    gle.fhir.stu3.proto.DecimalR\x05value\x122\n\x04unit\x18\x05\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x04unit\x123\n\x06system\x18\
    \x06\x20\x01(\x0b2\x1b.google.fhir.stu3.proto.UriR\x06system\x120\n\x04c\
    ode\x18\x07\x20\x01(\x0b2\x1c.google.fhir.stu3.proto.CodeR\x04code:x\xb2\
    \xfe\xe4\x97\x066http://hl7.org/fhir/StructureDefinition/SimpleQuantity\
    \x9a\xb5\x8e\x93\x060http://hl7.org/fhir/StructureDefinition/Quantity\
    \xc0\x9f\xe3\xb6\x05\x02\"\x85\r\n\x06Timing\x12.\n\x02id\x18\x01\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\x12\
    6\n\x05event\x18\x03\x20\x03(\x0b2\x20.google.fhir.stu3.proto.DateTimeR\
    \x05event\x12=\n\x06repeat\x18\x04\x20\x01(\x0b2%.google.fhir.stu3.proto\
    .Timing.RepeatR\x06repeat\x12;\n\x04code\x18\x05\x20\x01(\x0b2'.google.f\
    hir.stu3.proto.CodeableConceptR\x04code\x1a\x99\n\n\x06Repeat\x12.\n\x02\
    id\x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\x12L\n\x06bounds\x18\x03\x20\x01(\x0b2,.google.fhir.stu3.proto.T\
    iming.Repeat.BoundsR\x06boundsB\x06\xf8\xe1\xe3\xc9\x05\x01\x125\n\x05co\
    unt\x18\x04\x20\x01(\x0b2\x1f.google.fhir.stu3.proto.IntegerR\x05count\
    \x12<\n\tcount_max\x18\x05\x20\x01(\x0b2\x1f.google.fhir.stu3.proto.Inte\
    gerR\x08countMax\x12;\n\x08duration\x18\x06\x20\x01(\x0b2\x1f.google.fhi\
    r.stu3.proto.DecimalR\x08duration\x12B\n\x0cduration_max\x18\x07\x20\x01\
    (\x0b2\x1f.google.fhir.stu3.proto.DecimalR\x0bdurationMax\x12L\n\rdurati\
    on_unit\x18\x08\x20\x01(\x0b2'.google.fhir.stu3.proto.UnitsOfTimeCodeR\
    \x0cdurationUnit\x12=\n\tfrequency\x18\t\x20\x01(\x0b2\x1f.google.fhir.s\
    tu3.proto.IntegerR\tfrequency\x12D\n\rfrequency_max\x18\n\x20\x01(\x0b2\
    \x1f.google.fhir.stu3.proto.IntegerR\x0cfrequencyMax\x127\n\x06period\
    \x18\x0b\x20\x01(\x0b2\x1f.google.fhir.stu3.proto.DecimalR\x06period\x12\
    >\n\nperiod_max\x18\x0c\x20\x01(\x0b2\x1f.google.fhir.stu3.proto.Decimal\
    R\tperiodMax\x12H\n\x0bperiod_unit\x18\r\x20\x01(\x0b2'.google.fhir.stu3\
    .proto.UnitsOfTimeCodeR\nperiodUnit\x12F\n\x0bday_of_week\x18\x0e\x20\
    \x03(\x0b2&.google.fhir.stu3.proto.DaysOfWeekCodeR\tdayOfWeek\x12<\n\x0b\
    time_of_day\x18\x0f\x20\x03(\x0b2\x1c.google.fhir.stu3.proto.TimeR\ttime\
    OfDay\x12;\n\x04when\x18\x10\x20\x03(\x0b2'.google.fhir.stu3.proto.Event\
    TimingCodeR\x04when\x12;\n\x06offset\x18\x11\x20\x01(\x0b2#.google.fhir.\
    stu3.proto.UnsignedIntR\x06offset\x1a\xc3\x01\n\x06Bounds\x12>\n\x08dura\
    tion\x18\x01\x20\x01(\x0b2\x20.google.fhir.stu3.proto.DurationH\0R\x08du\
    ration\x125\n\x05range\x18\x02\x20\x01(\x0b2\x1d.google.fhir.stu3.proto.\
    RangeH\0R\x05range\x128\n\x06period\x18\x03\x20\x01(\x0b2\x1e.google.fhi\
    r.stu3.proto.PeriodH\0R\x06periodB\x08\n\x06bounds::\xc0\x9f\xe3\xb6\x05\
    \x02\xb2\xfe\xe4\x97\x06.http://hl7.org/fhir/StructureDefinition/Timing\
    \"\x83\x15\n\tExtension\x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.google.fh\
    ir.stu3.proto.StringR\x02id\x125\n\x03url\x18\x02\x20\x01(\x0b2\x1b.goog\
    le.fhir.stu3.proto.UriR\x03urlB\x06\xf0\xd0\x87\xeb\x04\x01\x12E\n\x05va\
    lue\x18\x03\x20\x01(\x0b2'.google.fhir.stu3.proto.Extension.ValueR\x05va\
    lueB\x06\xf8\xe1\xe3\xc9\x05\x01\x12?\n\textension\x18\x04\x20\x03(\x0b2\
    !.google.fhir.stu3.proto.ExtensionR\textension\x1a\xc7\x12\n\x05Value\
    \x12K\n\rbase64_binary\x18\x01\x20\x01(\x0b2$.google.fhir.stu3.proto.Bas\
    e64BinaryH\0R\x0cbase64Binary\x12;\n\x07boolean\x18\x02\x20\x01(\x0b2\
    \x1f.google.fhir.stu3.proto.BooleanH\0R\x07boolean\x122\n\x04code\x18\
    \x03\x20\x01(\x0b2\x1c.google.fhir.stu3.proto.CodeH\0R\x04code\x122\n\
    \x04date\x18\x04\x20\x01(\x0b2\x1c.google.fhir.stu3.proto.DateH\0R\x04da\
    te\x12?\n\tdate_time\x18\x05\x20\x01(\x0b2\x20.google.fhir.stu3.proto.Da\
    teTimeH\0R\x08dateTime\x12;\n\x07decimal\x18\x06\x20\x01(\x0b2\x1f.googl\
    e.fhir.stu3.proto.DecimalH\0R\x07decimal\x12,\n\x02id\x18\x07\x20\x01(\
    \x0b2\x1a.google.fhir.stu3.proto.IdH\0R\x02id\x12;\n\x07instant\x18\x08\
    \x20\x01(\x0b2\x1f.google.fhir.stu3.proto.InstantH\0R\x07instant\x12;\n\
    \x07integer\x18\t\x20\x01(\x0b2\x1f.google.fhir.stu3.proto.IntegerH\0R\
    \x07integer\x12>\n\x08markdown\x18\n\x20\x01(\x0b2\x20.google.fhir.stu3.\
    proto.MarkdownH\0R\x08markdown\x12/\n\x03oid\x18\x0b\x20\x01(\x0b2\x1b.g\
    oogle.fhir.stu3.proto.OidH\0R\x03oid\x12H\n\x0cpositive_int\x18\x0c\x20\
    \x01(\x0b2#.google.fhir.stu3.proto.PositiveIntH\0R\x0bpositiveInt\x12>\n\
    \x0cstring_value\x18\r\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringH\
    \0R\x06string\x122\n\x04time\x18\x0e\x20\x01(\x0b2\x1c.google.fhir.stu3.\
    proto.TimeH\0R\x04time\x12H\n\x0cunsigned_int\x18\x0f\x20\x01(\x0b2#.goo\
    gle.fhir.stu3.proto.UnsignedIntH\0R\x0bunsignedInt\x12/\n\x03uri\x18\x10\
    \x20\x01(\x0b2\x1b.google.fhir.stu3.proto.UriH\0R\x03uri\x12;\n\x07addre\
    ss\x18\x11\x20\x01(\x0b2\x1f.google.fhir.stu3.proto.AddressH\0R\x07addre\
    ss\x12/\n\x03age\x18\x12\x20\x01(\x0b2\x1b.google.fhir.stu3.proto.AgeH\0\
    R\x03age\x12D\n\nannotation\x18\x13\x20\x01(\x0b2\".google.fhir.stu3.pro\
    to.AnnotationH\0R\nannotation\x12D\n\nattachment\x18\x14\x20\x01(\x0b2\"\
    .google.fhir.stu3.proto.AttachmentH\0R\nattachment\x12T\n\x10codeable_co\
    ncept\x18\x15\x20\x01(\x0b2'.google.fhir.stu3.proto.CodeableConceptH\0R\
    \x0fcodeableConcept\x128\n\x06coding\x18\x16\x20\x01(\x0b2\x1e.google.fh\
    ir.stu3.proto.CodingH\0R\x06coding\x12K\n\rcontact_point\x18\x17\x20\x01\
    (\x0b2$.google.fhir.stu3.proto.ContactPointH\0R\x0ccontactPoint\x125\n\
    \x05count\x18\x18\x20\x01(\x0b2\x1d.google.fhir.stu3.proto.CountH\0R\x05\
    count\x12>\n\x08distance\x18\x19\x20\x01(\x0b2\x20.google.fhir.stu3.prot\
    o.DistanceH\0R\x08distance\x12>\n\x08duration\x18\x1a\x20\x01(\x0b2\x20.\
    google.fhir.stu3.proto.DurationH\0R\x08duration\x12B\n\nhuman_name\x18\
    \x1b\x20\x01(\x0b2!.google.fhir.stu3.proto.HumanNameH\0R\thumanName\x12D\
    \n\nidentifier\x18\x1c\x20\x01(\x0b2\".google.fhir.stu3.proto.Identifier\
    H\0R\nidentifier\x125\n\x05money\x18\x1d\x20\x01(\x0b2\x1d.google.fhir.s\
    tu3.proto.MoneyH\0R\x05money\x128\n\x06period\x18\x1e\x20\x01(\x0b2\x1e.\
    google.fhir.stu3.proto.PeriodH\0R\x06period\x12>\n\x08quantity\x18\x1f\
    \x20\x01(\x0b2\x20.google.fhir.stu3.proto.QuantityH\0R\x08quantity\x125\
    \n\x05range\x18\x20\x20\x01(\x0b2\x1d.google.fhir.stu3.proto.RangeH\0R\
    \x05range\x125\n\x05ratio\x18!\x20\x01(\x0b2\x1d.google.fhir.stu3.proto.\
    RatioH\0R\x05ratio\x12A\n\treference\x18\"\x20\x01(\x0b2!.google.fhir.st\
    u3.proto.ReferenceH\0R\treference\x12H\n\x0csampled_data\x18#\x20\x01(\
    \x0b2#.google.fhir.stu3.proto.SampledDataH\0R\x0bsampledData\x12A\n\tsig\
    nature\x18$\x20\x01(\x0b2!.google.fhir.stu3.proto.SignatureH\0R\tsignatu\
    re\x128\n\x06timing\x18%\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Timing\
    H\0R\x06timing\x122\n\x04meta\x18&\x20\x01(\x0b2\x1c.google.fhir.stu3.pr\
    oto.MetaH\0R\x04metaB\x07\n\x05value:=\xc0\x9f\xe3\xb6\x05\x02\xb2\xfe\
    \xe4\x97\x061http://hl7.org/fhir/StructureDefinition/Extension\"\xb6\x03\
    \n\x15CodingWithFixedSystem\x12.\n\x02id\x18\x01\x20\x01(\x0b2\x1e.googl\
    e.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x02\x20\x03(\x0b2!\
    .google.fhir.stu3.proto.ExtensionR\textension\x128\n\x07version\x18\x04\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x07version\x120\n\x04c\
    ode\x18\x05\x20\x01(\x0b2\x1c.google.fhir.stu3.proto.CodeR\x04code\x128\
    \n\x07display\x18\x06\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x07display\x12D\n\ruser_selected\x18\x07\x20\x01(\x0b2\x1f.google.fhir.\
    stu3.proto.BooleanR\x0cuserSelected::\xc0\x9f\xe3\xb6\x05\x02\xb2\xfe\
    \xe4\x97\x06.http://hl7.org/fhir/StructureDefinition/CodingJ\x04\x08\x03\
    \x10\x04\"\x88\x03\n\x13CodingWithFixedCode\x12.\n\x02id\x18\x01\x20\x01\
    (\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\
    \x02\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\x128\n\
    \x07version\x18\x04\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x07\
    version\x128\n\x07display\x18\x06\x20\x01(\x0b2\x1e.google.fhir.stu3.pro\
    to.StringR\x07display\x12D\n\ruser_selected\x18\x07\x20\x01(\x0b2\x1f.go\
    ogle.fhir.stu3.proto.BooleanR\x0cuserSelected::\xb2\xfe\xe4\x97\x06.http\
    ://hl7.org/fhir/StructureDefinition/Coding\xc0\x9f\xe3\xb6\x05\x02J\x04\
    \x08\x03\x10\x04J\x04\x08\x05\x10\x06\"\x8cN\n\tReference\x12.\n\x02id\
    \x18\x01\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x02\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\x128\n\x03uri\x18\x03\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Str\
    ingH\0R\treference\x12<\n\x08fragment\x18\x04\x20\x01(\x0b2\x1e.google.f\
    hir.stu3.proto.StringH\0R\x08fragment\x12D\n\naccount_id\x18\x05\x20\x01\
    (\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\taccountId\x12[\n\x16acti\
    vity_definition_id\x18\x06\x20\x01(\x0b2#.google.fhir.stu3.proto.Referen\
    ceIdH\0R\x14activityDefinitionId\x12O\n\x10adverse_event_id\x18\x07\x20\
    \x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0eadverseEventId\x12\
    [\n\x16allergy_intolerance_id\x18\x08\x20\x01(\x0b2#.google.fhir.stu3.pr\
    oto.ReferenceIdH\0R\x14allergyIntoleranceId\x12L\n\x0eappointment_id\x18\
    \t\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\rappointmentId\
    \x12]\n\x17appointment_response_id\x18\n\x20\x01(\x0b2#.google.fhir.stu3\
    .proto.ReferenceIdH\0R\x15appointmentResponseId\x12K\n\x0eaudit_event_id\
    \x18\x0b\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0cauditE\
    ventId\x12@\n\x08basic_id\x18\x0c\x20\x01(\x0b2#.google.fhir.stu3.proto.\
    ReferenceIdH\0R\x07basicId\x12B\n\tbinary_id\x18\r\x20\x01(\x0b2#.google\
    .fhir.stu3.proto.ReferenceIdH\0R\x08binaryId\x12G\n\x0cbody_site_id\x18\
    \x0e\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\nbodySiteId\
    \x12B\n\tbundle_id\x18\x0f\x20\x01(\x0b2#.google.fhir.stu3.proto.Referen\
    ceIdH\0R\x08bundleId\x12]\n\x17capability_statement_id\x18\x10\x20\x01(\
    \x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x15capabilityStatementId\
    \x12G\n\x0ccare_plan_id\x18\x11\x20\x01(\x0b2#.google.fhir.stu3.proto.Re\
    ferenceIdH\0R\ncarePlanId\x12G\n\x0ccare_team_id\x18\x12\x20\x01(\x0b2#.\
    google.fhir.stu3.proto.ReferenceIdH\0R\ncareTeamId\x12K\n\x0echarge_item\
    _id\x18\x13\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0ccha\
    rgeItemId\x12@\n\x08claim_id\x18\x14\x20\x01(\x0b2#.google.fhir.stu3.pro\
    to.ReferenceIdH\0R\x07claimId\x12Q\n\x11claim_response_id\x18\x15\x20\
    \x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0fclaimResponseId\
    \x12[\n\x16clinical_impression_id\x18\x16\x20\x01(\x0b2#.google.fhir.stu\
    3.proto.ReferenceIdH\0R\x14clinicalImpressionId\x12K\n\x0ecode_system_id\
    \x18\x17\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0ccodeSy\
    stemId\x12P\n\x10communication_id\x18\x18\x20\x01(\x0b2#.google.fhir.stu\
    3.proto.ReferenceIdH\0R\x0fcommunicationId\x12_\n\x18communication_reque\
    st_id\x18\x19\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x16c\
    ommunicationRequestId\x12a\n\x19compartment_definition_id\x18\x1a\x20\
    \x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x17compartmentDefinit\
    ionId\x12L\n\x0ecomposition_id\x18\x1b\x20\x01(\x0b2#.google.fhir.stu3.p\
    roto.ReferenceIdH\0R\rcompositionId\x12K\n\x0econcept_map_id\x18\x1c\x20\
    \x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0cconceptMapId\x12H\
    \n\x0ccondition_id\x18\x1d\x20\x01(\x0b2#.google.fhir.stu3.proto.Referen\
    ceIdH\0R\x0bconditionId\x12D\n\nconsent_id\x18\x1e\x20\x01(\x0b2#.google\
    .fhir.stu3.proto.ReferenceIdH\0R\tconsentId\x12F\n\x0bcontract_id\x18\
    \x1f\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\ncontractId\
    \x12F\n\x0bcoverage_id\x18\x20\x20\x01(\x0b2#.google.fhir.stu3.proto.Ref\
    erenceIdH\0R\ncoverageId\x12M\n\x0fdata_element_id\x18!\x20\x01(\x0b2#.g\
    oogle.fhir.stu3.proto.ReferenceIdH\0R\rdataElementId\x12Q\n\x11detected_\
    issue_id\x18\"\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0f\
    detectedIssueId\x12B\n\tdevice_id\x18#\x20\x01(\x0b2#.google.fhir.stu3.p\
    roto.ReferenceIdH\0R\x08deviceId\x12U\n\x13device_component_id\x18$\x20\
    \x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x11deviceComponentId\
    \x12O\n\x10device_metric_id\x18%\x20\x01(\x0b2#.google.fhir.stu3.proto.R\
    eferenceIdH\0R\x0edeviceMetricId\x12Q\n\x11device_request_id\x18&\x20\
    \x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0fdeviceRequestId\
    \x12[\n\x16device_usestatement_id\x18'\x20\x01(\x0b2#.google.fhir.stu3.p\
    roto.ReferenceIdH\0R\x14deviceUsestatementId\x12W\n\x14diagnostic_report\
    _id\x18(\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x12diagno\
    sticReportId\x12W\n\x14document_manifest_id\x18)\x20\x01(\x0b2#.google.f\
    hir.stu3.proto.ReferenceIdH\0R\x12documentManifestId\x12Y\n\x15document_\
    reference_id\x18*\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\
    \x13documentReferenceId\x12[\n\x16eligibility_request_id\x18+\x20\x01(\
    \x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x14eligibilityRequestId\
    \x12]\n\x17eligibility_response_id\x18,\x20\x01(\x0b2#.google.fhir.stu3.\
    proto.ReferenceIdH\0R\x15eligibilityResponseId\x12H\n\x0cencounter_id\
    \x18-\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0bencounter\
    Id\x12F\n\x0bendpoint_id\x18.\x20\x01(\x0b2#.google.fhir.stu3.proto.Refe\
    renceIdH\0R\nendpointId\x12Y\n\x15enrollment_request_id\x18/\x20\x01(\
    \x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x13enrollmentRequestId\x12\
    [\n\x16enrollment_response_id\x180\x20\x01(\x0b2#.google.fhir.stu3.proto\
    .ReferenceIdH\0R\x14enrollmentResponseId\x12Q\n\x11episode_ofcare_id\x18\
    1\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0fepisodeOfcare\
    Id\x12W\n\x14expansion_profile_id\x182\x20\x01(\x0b2#.google.fhir.stu3.p\
    roto.ReferenceIdH\0R\x12expansionProfileId\x12_\n\x18explanation_ofbenef\
    it_id\x183\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x16expl\
    anationOfbenefitId\x12]\n\x17family_memberhistory_id\x184\x20\x01(\x0b2#\
    .google.fhir.stu3.proto.ReferenceIdH\0R\x15familyMemberhistoryId\x12>\n\
    \x07flag_id\x185\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\
    \x06flagId\x12>\n\x07goal_id\x186\x20\x01(\x0b2#.google.fhir.stu3.proto.\
    ReferenceIdH\0R\x06goalId\x12U\n\x13graph_definition_id\x187\x20\x01(\
    \x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x11graphDefinitionId\x12@\
    \n\x08group_id\x188\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0\
    R\x07groupId\x12W\n\x14guidance_response_id\x189\x20\x01(\x0b2#.google.f\
    hir.stu3.proto.ReferenceIdH\0R\x12guidanceResponseId\x12Y\n\x15healthcar\
    e_service_id\x18:\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\
    \x13healthcareServiceId\x12U\n\x13imaging_manifest_id\x18;\x20\x01(\x0b2\
    #.google.fhir.stu3.proto.ReferenceIdH\0R\x11imagingManifestId\x12O\n\x10\
    imaging_study_id\x18<\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\
    \0R\x0eimagingStudyId\x12N\n\x0fimmunization_id\x18=\x20\x01(\x0b2#.goog\
    le.fhir.stu3.proto.ReferenceIdH\0R\x0eimmunizationId\x12k\n\x1eimmunizat\
    ion_recommendation_id\x18>\x20\x01(\x0b2#.google.fhir.stu3.proto.Referen\
    ceIdH\0R\x1cimmunizationRecommendationId\x12]\n\x17implementation_guide_\
    id\x18?\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x15impleme\
    ntationGuideId\x12D\n\nlibrary_id\x18@\x20\x01(\x0b2#.google.fhir.stu3.p\
    roto.ReferenceIdH\0R\tlibraryId\x12D\n\nlinkage_id\x18A\x20\x01(\x0b2#.g\
    oogle.fhir.stu3.proto.ReferenceIdH\0R\tlinkageId\x12>\n\x07list_id\x18B\
    \x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x06listId\x12F\n\
    \x0blocation_id\x18C\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\
    \0R\nlocationId\x12D\n\nmeasure_id\x18D\x20\x01(\x0b2#.google.fhir.stu3.\
    proto.ReferenceIdH\0R\tmeasureId\x12Q\n\x11measure_report_id\x18E\x20\
    \x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0fmeasureReportId\
    \x12@\n\x08media_id\x18F\x20\x01(\x0b2#.google.fhir.stu3.proto.Reference\
    IdH\0R\x07mediaId\x12J\n\rmedication_id\x18G\x20\x01(\x0b2#.google.fhir.\
    stu3.proto.ReferenceIdH\0R\x0cmedicationId\x12g\n\x1cmedication_administ\
    ration_id\x18H\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x1a\
    medicationAdministrationId\x12[\n\x16medication_dispense_id\x18I\x20\x01\
    (\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x14medicationDispenseId\
    \x12Y\n\x15medication_request_id\x18J\x20\x01(\x0b2#.google.fhir.stu3.pr\
    oto.ReferenceIdH\0R\x13medicationRequestId\x12]\n\x17medication_statemen\
    t_id\x18K\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x15medic\
    ationStatementId\x12Y\n\x15message_definition_id\x18L\x20\x01(\x0b2#.goo\
    gle.fhir.stu3.proto.ReferenceIdH\0R\x13messageDefinitionId\x12Q\n\x11mes\
    sage_header_id\x18M\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0\
    R\x0fmessageHeaderId\x12O\n\x10naming_system_id\x18N\x20\x01(\x0b2#.goog\
    le.fhir.stu3.proto.ReferenceIdH\0R\x0enamingSystemId\x12S\n\x12nutrition\
    _order_id\x18O\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x10\
    nutritionOrderId\x12L\n\x0eobservation_id\x18P\x20\x01(\x0b2#.google.fhi\
    r.stu3.proto.ReferenceIdH\0R\robservationId\x12]\n\x17operation_definiti\
    on_id\x18Q\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x15oper\
    ationDefinitionId\x12W\n\x14operation_outcome_id\x18R\x20\x01(\x0b2#.goo\
    gle.fhir.stu3.proto.ReferenceIdH\0R\x12operationOutcomeId\x12N\n\x0forga\
    nization_id\x18S\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\
    \x0eorganizationId\x12J\n\rparameters_id\x18T\x20\x01(\x0b2#.google.fhir\
    .stu3.proto.ReferenceIdH\0R\x0cparametersId\x12D\n\npatient_id\x18U\x20\
    \x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\tpatientId\x12Q\n\x11\
    payment_notice_id\x18V\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceId\
    H\0R\x0fpaymentNoticeId\x12a\n\x19payment_reconciliation_id\x18W\x20\x01\
    (\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x17paymentReconciliationI\
    d\x12B\n\tperson_id\x18X\x20\x01(\x0b2#.google.fhir.stu3.proto.Reference\
    IdH\0R\x08personId\x12S\n\x12plan_definition_id\x18Y\x20\x01(\x0b2#.goog\
    le.fhir.stu3.proto.ReferenceIdH\0R\x10planDefinitionId\x12N\n\x0fpractit\
    ioner_id\x18Z\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0ep\
    ractitionerId\x12W\n\x14practitioner_role_id\x18[\x20\x01(\x0b2#.google.\
    fhir.stu3.proto.ReferenceIdH\0R\x12practitionerRoleId\x12H\n\x0cprocedur\
    e_id\x18\\\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0bproc\
    edureId\x12W\n\x14procedure_request_id\x18]\x20\x01(\x0b2#.google.fhir.s\
    tu3.proto.ReferenceIdH\0R\x12procedureRequestId\x12S\n\x12process_reques\
    t_id\x18^\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x10proce\
    ssRequestId\x12U\n\x13process_response_id\x18_\x20\x01(\x0b2#.google.fhi\
    r.stu3.proto.ReferenceIdH\0R\x11processResponseId\x12J\n\rprovenance_id\
    \x18`\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0cprovenanc\
    eId\x12P\n\x10questionnaire_id\x18a\x20\x01(\x0b2#.google.fhir.stu3.prot\
    o.ReferenceIdH\0R\x0fquestionnaireId\x12a\n\x19questionnaire_response_id\
    \x18b\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x17questionn\
    aireResponseId\x12U\n\x13referral_request_id\x18c\x20\x01(\x0b2#.google.\
    fhir.stu3.proto.ReferenceIdH\0R\x11referralRequestId\x12Q\n\x11related_p\
    erson_id\x18d\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0fr\
    elatedPersonId\x12O\n\x10request_group_id\x18e\x20\x01(\x0b2#.google.fhi\
    r.stu3.proto.ReferenceIdH\0R\x0erequestGroupId\x12Q\n\x11research_study_\
    id\x18f\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0fresearc\
    hStudyId\x12U\n\x13research_subject_id\x18g\x20\x01(\x0b2#.google.fhir.s\
    tu3.proto.ReferenceIdH\0R\x11researchSubjectId\x12S\n\x12risk_assessment\
    _id\x18h\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x10riskAs\
    sessmentId\x12F\n\x0bschedule_id\x18i\x20\x01(\x0b2#.google.fhir.stu3.pr\
    oto.ReferenceIdH\0R\nscheduleId\x12U\n\x13search_parameter_id\x18j\x20\
    \x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x11searchParameterId\
    \x12F\n\x0bsequence_id\x18k\x20\x01(\x0b2#.google.fhir.stu3.proto.Refere\
    nceIdH\0R\nsequenceId\x12Y\n\x15service_definition_id\x18l\x20\x01(\x0b2\
    #.google.fhir.stu3.proto.ReferenceIdH\0R\x13serviceDefinitionId\x12>\n\
    \x07slot_id\x18m\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\
    \x06slotId\x12F\n\x0bspecimen_id\x18n\x20\x01(\x0b2#.google.fhir.stu3.pr\
    oto.ReferenceIdH\0R\nspecimenId\x12]\n\x17structure_definition_id\x18o\
    \x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x15structureDefin\
    itionId\x12O\n\x10structure_map_id\x18p\x20\x01(\x0b2#.google.fhir.stu3.\
    proto.ReferenceIdH\0R\x0estructureMapId\x12N\n\x0fsubscription_id\x18q\
    \x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0esubscriptionId\
    \x12H\n\x0csubstance_id\x18r\x20\x01(\x0b2#.google.fhir.stu3.proto.Refer\
    enceIdH\0R\x0bsubstanceId\x12S\n\x12supply_delivery_id\x18s\x20\x01(\x0b\
    2#.google.fhir.stu3.proto.ReferenceIdH\0R\x10supplyDeliveryId\x12Q\n\x11\
    supply_request_id\x18t\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceId\
    H\0R\x0fsupplyRequestId\x12>\n\x07task_id\x18u\x20\x01(\x0b2#.google.fhi\
    r.stu3.proto.ReferenceIdH\0R\x06taskId\x12K\n\x0etest_report_id\x18v\x20\
    \x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x0ctestReportId\x12K\
    \n\x0etest_script_id\x18w\x20\x01(\x0b2#.google.fhir.stu3.proto.Referenc\
    eIdH\0R\x0ctestScriptId\x12G\n\x0cvalue_set_id\x18x\x20\x01(\x0b2#.googl\
    e.fhir.stu3.proto.ReferenceIdH\0R\nvalueSetId\x12[\n\x16vision_prescript\
    ion_id\x18y\x20\x01(\x0b2#.google.fhir.stu3.proto.ReferenceIdH\0R\x14vis\
    ionPrescriptionId\x12B\n\nidentifier\x18z\x20\x01(\x0b2\".google.fhir.st\
    u3.proto.IdentifierR\nidentifier\x128\n\x07display\x18{\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x07displayB\x13\n\treference\x12\x06\
    \xb0\xee\x92\xb2\x06\x01:\x14\xc0\x9f\xe3\xb6\x05\x02\x8a\xa1\x96\xbc\
    \x05\x08Resource\"\xd2\x01\n\x0bReferenceId\x12\x14\n\x05value\x18\x01\
    \x20\x01(\tR\x05value\x124\n\x07history\x18\x02\x20\x01(\x0b2\x1a.google\
    .fhir.stu3.proto.IdR\x07history\x12.\n\x02id\x18\x03\x20\x01(\x0b2\x1e.g\
    oogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x04\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension:\x06\xc0\x9f\xe3\xb6\
    \x05\x01\"\xc6\x02\n\x0fAddressTypeCode\x12C\n\x05value\x18\x01\x20\x01(\
    \x0e2-.google.fhir.stu3.proto.AddressTypeCode.ValueR\x05value\x12.\n\x02\
    id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\"F\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\
    \x06POSTAL\x10\x01\x12\x0c\n\x08PHYSICAL\x10\x02\x12\x08\n\x04BOTH\x10\
    \x03:5\x8a\xf9\x83\xb2\x05)http://hl7.org/fhir/ValueSet/address-type\xc0\
    \x9f\xe3\xb6\x05\x01\"\xc6\x02\n\x0eAddressUseCode\x12B\n\x05value\x18\
    \x01\x20\x01(\x0e2,.google.fhir.stu3.proto.AddressUseCode.ValueR\x05valu\
    e\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"I\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x08\n\x04HOME\x10\x01\x12\x08\n\x04WORK\x10\x02\x12\x08\n\x04\
    TEMP\x10\x03\x12\x07\n\x03OLD\x10\x04:4\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\
    \x83\xb2\x05(http://hl7.org/fhir/ValueSet/address-use\"\xff\x02\n\x16Con\
    tactPointSystemCode\x12J\n\x05value\x18\x01\x20\x01(\x0e24.google.fhir.s\
    tu3.proto.ContactPointSystemCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"i\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05PHONE\
    \x10\x01\x12\x07\n\x03FAX\x10\x02\x12\t\n\x05EMAIL\x10\x03\x12\t\n\x05PA\
    GER\x10\x04\x12\x07\n\x03URL\x10\x05\x12\x07\n\x03SMS\x10\x06\x12\t\n\
    \x05OTHER\x10\x07:=\x8a\xf9\x83\xb2\x051http://hl7.org/fhir/ValueSet/con\
    tact-point-system\xc0\x9f\xe3\xb6\x05\x01\"\xe2\x02\n\x13ContactPointUse\
    Code\x12G\n\x05value\x18\x01\x20\x01(\x0e21.google.fhir.stu3.proto.Conta\
    ctPointUseCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.go\
    ogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"U\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04HOME\x10\x01\x12\x08\
    \n\x04WORK\x10\x02\x12\x08\n\x04TEMP\x10\x03\x12\x07\n\x03OLD\x10\x04\
    \x12\n\n\x06MOBILE\x10\x05::\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05\
    .http://hl7.org/fhir/ValueSet/contact-point-use\"\xdf\x02\n\x0eDaysOfWee\
    kCode\x12B\n\x05value\x18\x01\x20\x01(\x0e2,.google.fhir.stu3.proto.Days\
    OfWeekCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google\
    .fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.\
    google.fhir.stu3.proto.ExtensionR\textension\"a\n\x05Value\x12\x19\n\x15\
    INVALID_UNINITIALIZED\x10\0\x12\x07\n\x03MON\x10\x01\x12\x07\n\x03TUE\
    \x10\x02\x12\x07\n\x03WED\x10\x03\x12\x07\n\x03THU\x10\x04\x12\x07\n\x03\
    FRI\x10\x05\x12\x07\n\x03SAT\x10\x06\x12\x07\n\x03SUN\x10\x07:5\xc0\x9f\
    \xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05)http://hl7.org/fhir/ValueSet/days-o\
    f-week\"\x97\x05\n\x0fEventTimingCode\x12C\n\x05value\x18\x01\x20\x01(\
    \x0e2-.google.fhir.stu3.proto.EventTimingCode.ValueR\x05value\x12.\n\x02\
    id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\"\x96\x03\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x14\n\x04MORN\x10\x01\x1a\n\xba\x96\xbb\xb2\x05\x04MORN\x12\x12\n\
    \x03AFT\x10\x02\x1a\t\xba\x96\xbb\xb2\x05\x03AFT\x12\x12\n\x03EVE\x10\
    \x03\x1a\t\xba\x96\xbb\xb2\x05\x03EVE\x12\x16\n\x05NIGHT\x10\x04\x1a\x0b\
    \xba\x96\xbb\xb2\x05\x05NIGHT\x12\x12\n\x03PHS\x10\x05\x1a\t\xba\x96\xbb\
    \xb2\x05\x03PHS\x12\x10\n\x02HS\x10\x06\x1a\x08\xba\x96\xbb\xb2\x05\x02H\
    S\x12\x14\n\x04WAKE\x10\x07\x1a\n\xba\x96\xbb\xb2\x05\x04WAKE\x12\x0e\n\
    \x01C\x10\x08\x1a\x07\xba\x96\xbb\xb2\x05\x01C\x12\x10\n\x02CM\x10\t\x1a\
    \x08\xba\x96\xbb\xb2\x05\x02CM\x12\x10\n\x02CD\x10\n\x1a\x08\xba\x96\xbb\
    \xb2\x05\x02CD\x12\x10\n\x02CV\x10\x0b\x1a\x08\xba\x96\xbb\xb2\x05\x02CV\
    \x12\x10\n\x02AC\x10\x0c\x1a\x08\xba\x96\xbb\xb2\x05\x02AC\x12\x12\n\x03\
    ACM\x10\r\x1a\t\xba\x96\xbb\xb2\x05\x03ACM\x12\x12\n\x03ACD\x10\x0e\x1a\
    \t\xba\x96\xbb\xb2\x05\x03ACD\x12\x12\n\x03ACV\x10\x0f\x1a\t\xba\x96\xbb\
    \xb2\x05\x03ACV\x12\x10\n\x02PC\x10\x10\x1a\x08\xba\x96\xbb\xb2\x05\x02P\
    C\x12\x12\n\x03PCM\x10\x11\x1a\t\xba\x96\xbb\xb2\x05\x03PCM\x12\x12\n\
    \x03PCD\x10\x12\x1a\t\xba\x96\xbb\xb2\x05\x03PCD\x12\x12\n\x03PCV\x10\
    \x13\x1a\t\xba\x96\xbb\xb2\x05\x03PCV:5\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\
    \x83\xb2\x05)http://hl7.org/fhir/ValueSet/event-timing\"\xda\x02\n\x11Id\
    entifierUseCode\x12E\n\x05value\x18\x01\x20\x01(\x0e2/.google.fhir.stu3.\
    proto.IdentifierUseCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"T\n\x05Val\
    ue\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05USUAL\x10\x01\x12\
    \x0c\n\x08OFFICIAL\x10\x02\x12\x08\n\x04TEMP\x10\x03\x12\r\n\tSECONDARY\
    \x10\x04:7\x8a\xf9\x83\xb2\x05+http://hl7.org/fhir/ValueSet/identifier-u\
    se\xc0\x9f\xe3\xb6\x05\x01\"\xd0\x01\n\x0fAllLanguageCode\x12\x14\n\x05v\
    alue\x18\x01\x20\x01(\tR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e\
    .google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension:6\x8a\xf9\x83\xb2\
    \x05*http://hl7.org/fhir/ValueSet/all-languages\xc0\x9f\xe3\xb6\x05\x01\
    \"\xc9\x01\n\x0cLanguageCode\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05v\
    alue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Strin\
    gR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto\
    .ExtensionR\textension:2\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05&htt\
    p://hl7.org/fhir/ValueSet/languages\"\xca\x01\n\x0cMimeTypeCode\x12\x14\
    \n\x05value\x18\x01\x20\x01(\tR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension:3\x8a\xf9\
    \x83\xb2\x05'http://www.rfc-editor.org/bcp/bcp13.txt\xc0\x9f\xe3\xb6\x05\
    \x01\"\xeb\x02\n\x0bNameUseCode\x12?\n\x05value\x18\x01\x20\x01(\x0e2).g\
    oogle.fhir.stu3.proto.NameUseCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"w\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05USUAL\
    \x10\x01\x12\x0c\n\x08OFFICIAL\x10\x02\x12\x08\n\x04TEMP\x10\x03\x12\x0c\
    \n\x08NICKNAME\x10\x04\x12\r\n\tANONYMOUS\x10\x05\x12\x07\n\x03OLD\x10\
    \x06\x12\n\n\x06MAIDEN\x10\x07:1\x8a\xf9\x83\xb2\x05%http://hl7.org/fhir\
    /ValueSet/name-use\xc0\x9f\xe3\xb6\x05\x01\"\xfd\x02\n\x16QuantityCompar\
    atorCode\x12J\n\x05value\x18\x01\x20\x01(\x0e24.google.fhir.stu3.proto.Q\
    uantityComparatorCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"h\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0f\n\x02LT\x10\x01\x1a\
    \x07\xba\x96\xbb\xb2\x05\x01<\x12\x10\n\x02LE\x10\x02\x1a\x08\xba\x96\
    \xbb\xb2\x05\x02<=\x12\x10\n\x02GE\x10\x03\x1a\x08\xba\x96\xbb\xb2\x05\
    \x02>=\x12\x0f\n\x02GT\x10\x04\x1a\x07\xba\x96\xbb\xb2\x05\x01>:<\x8a\
    \xf9\x83\xb2\x050http://hl7.org/fhir/ValueSet/quantity-comparator\xc0\
    \x9f\xe3\xb6\x05\x01\"\xd8\x02\n\x0fUnitsOfTimeCode\x12C\n\x05value\x18\
    \x01\x20\x01(\x0e2-.google.fhir.stu3.proto.UnitsOfTimeCode.ValueR\x05val\
    ue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"W\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x05\n\x01S\x10\x01\x12\x07\n\x03MIN\x10\x02\x12\x05\n\x01H\
    \x10\x03\x12\x05\n\x01D\x10\x04\x12\x06\n\x02WK\x10\x05\x12\x06\n\x02MO\
    \x10\x06\x12\x05\n\x01A\x10\x07:6\x8a\xf9\x83\xb2\x05*http://hl7.org/fhi\
    r/ValueSet/units-of-time\xc0\x9f\xe3\xb6\x05\x01B\x1e\n\x1acom.google.fh\
    ir.stu3.protoP\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
