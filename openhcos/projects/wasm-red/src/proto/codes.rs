// This file is generated by rust-protobuf 2.1.4. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct AbstractTypeCode {
    // message fields
    pub value: AbstractTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AbstractTypeCode {
    pub fn new() -> AbstractTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AbstractTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AbstractTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AbstractTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AbstractTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AbstractTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AbstractTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AbstractTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbstractTypeCode {
        AbstractTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AbstractTypeCode_Value>>(
                    "value",
                    |m: &AbstractTypeCode| { &m.value },
                    |m: &mut AbstractTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AbstractTypeCode| { &m.id },
                    |m: &mut AbstractTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AbstractTypeCode| { &m.extension },
                    |m: &mut AbstractTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AbstractTypeCode>(
                    "AbstractTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AbstractTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<AbstractTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbstractTypeCode,
        };
        unsafe {
            instance.get(AbstractTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for AbstractTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbstractTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbstractTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AbstractTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    TYPE = 1,
    ANY = 2,
}

impl ::protobuf::ProtobufEnum for AbstractTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AbstractTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AbstractTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AbstractTypeCode_Value::TYPE),
            2 => ::std::option::Option::Some(AbstractTypeCode_Value::ANY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AbstractTypeCode_Value] = &[
            AbstractTypeCode_Value::INVALID_UNINITIALIZED,
            AbstractTypeCode_Value::TYPE,
            AbstractTypeCode_Value::ANY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AbstractTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AbstractTypeCode_Value {
}

impl ::std::default::Default for AbstractTypeCode_Value {
    fn default() -> Self {
        AbstractTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AbstractTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AggregationModeCode {
    // message fields
    pub value: AggregationModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AggregationModeCode {
    pub fn new() -> AggregationModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AggregationModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AggregationModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AggregationModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AggregationModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AggregationModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AggregationModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AggregationModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AggregationModeCode {
        AggregationModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AggregationModeCode_Value>>(
                    "value",
                    |m: &AggregationModeCode| { &m.value },
                    |m: &mut AggregationModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AggregationModeCode| { &m.id },
                    |m: &mut AggregationModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AggregationModeCode| { &m.extension },
                    |m: &mut AggregationModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AggregationModeCode>(
                    "AggregationModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AggregationModeCode {
        static mut instance: ::protobuf::lazy::Lazy<AggregationModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AggregationModeCode,
        };
        unsafe {
            instance.get(AggregationModeCode::new)
        }
    }
}

impl ::protobuf::Clear for AggregationModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AggregationModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AggregationModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AggregationModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    CONTAINED = 1,
    REFERENCED = 2,
    BUNDLED = 3,
}

impl ::protobuf::ProtobufEnum for AggregationModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AggregationModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AggregationModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AggregationModeCode_Value::CONTAINED),
            2 => ::std::option::Option::Some(AggregationModeCode_Value::REFERENCED),
            3 => ::std::option::Option::Some(AggregationModeCode_Value::BUNDLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AggregationModeCode_Value] = &[
            AggregationModeCode_Value::INVALID_UNINITIALIZED,
            AggregationModeCode_Value::CONTAINED,
            AggregationModeCode_Value::REFERENCED,
            AggregationModeCode_Value::BUNDLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AggregationModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AggregationModeCode_Value {
}

impl ::std::default::Default for AggregationModeCode_Value {
    fn default() -> Self {
        AggregationModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AggregationModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BindingStrengthCode {
    // message fields
    pub value: BindingStrengthCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BindingStrengthCode {
    pub fn new() -> BindingStrengthCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.BindingStrengthCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = BindingStrengthCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: BindingStrengthCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> BindingStrengthCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for BindingStrengthCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != BindingStrengthCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != BindingStrengthCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BindingStrengthCode {
        BindingStrengthCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BindingStrengthCode_Value>>(
                    "value",
                    |m: &BindingStrengthCode| { &m.value },
                    |m: &mut BindingStrengthCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &BindingStrengthCode| { &m.id },
                    |m: &mut BindingStrengthCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &BindingStrengthCode| { &m.extension },
                    |m: &mut BindingStrengthCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BindingStrengthCode>(
                    "BindingStrengthCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BindingStrengthCode {
        static mut instance: ::protobuf::lazy::Lazy<BindingStrengthCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BindingStrengthCode,
        };
        unsafe {
            instance.get(BindingStrengthCode::new)
        }
    }
}

impl ::protobuf::Clear for BindingStrengthCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BindingStrengthCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BindingStrengthCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BindingStrengthCode_Value {
    INVALID_UNINITIALIZED = 0,
    REQUIRED = 1,
    EXTENSIBLE = 2,
    PREFERRED = 3,
    EXAMPLE = 4,
}

impl ::protobuf::ProtobufEnum for BindingStrengthCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BindingStrengthCode_Value> {
        match value {
            0 => ::std::option::Option::Some(BindingStrengthCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(BindingStrengthCode_Value::REQUIRED),
            2 => ::std::option::Option::Some(BindingStrengthCode_Value::EXTENSIBLE),
            3 => ::std::option::Option::Some(BindingStrengthCode_Value::PREFERRED),
            4 => ::std::option::Option::Some(BindingStrengthCode_Value::EXAMPLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BindingStrengthCode_Value] = &[
            BindingStrengthCode_Value::INVALID_UNINITIALIZED,
            BindingStrengthCode_Value::REQUIRED,
            BindingStrengthCode_Value::EXTENSIBLE,
            BindingStrengthCode_Value::PREFERRED,
            BindingStrengthCode_Value::EXAMPLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BindingStrengthCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BindingStrengthCode_Value {
}

impl ::std::default::Default for BindingStrengthCode_Value {
    fn default() -> Self {
        BindingStrengthCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for BindingStrengthCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConstraintSeverityCode {
    // message fields
    pub value: ConstraintSeverityCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConstraintSeverityCode {
    pub fn new() -> ConstraintSeverityCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConstraintSeverityCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConstraintSeverityCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConstraintSeverityCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConstraintSeverityCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConstraintSeverityCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConstraintSeverityCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConstraintSeverityCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConstraintSeverityCode {
        ConstraintSeverityCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConstraintSeverityCode_Value>>(
                    "value",
                    |m: &ConstraintSeverityCode| { &m.value },
                    |m: &mut ConstraintSeverityCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConstraintSeverityCode| { &m.id },
                    |m: &mut ConstraintSeverityCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConstraintSeverityCode| { &m.extension },
                    |m: &mut ConstraintSeverityCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConstraintSeverityCode>(
                    "ConstraintSeverityCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConstraintSeverityCode {
        static mut instance: ::protobuf::lazy::Lazy<ConstraintSeverityCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConstraintSeverityCode,
        };
        unsafe {
            instance.get(ConstraintSeverityCode::new)
        }
    }
}

impl ::protobuf::Clear for ConstraintSeverityCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConstraintSeverityCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConstraintSeverityCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConstraintSeverityCode_Value {
    INVALID_UNINITIALIZED = 0,
    ERROR = 1,
    WARNING = 2,
}

impl ::protobuf::ProtobufEnum for ConstraintSeverityCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConstraintSeverityCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConstraintSeverityCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConstraintSeverityCode_Value::ERROR),
            2 => ::std::option::Option::Some(ConstraintSeverityCode_Value::WARNING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConstraintSeverityCode_Value] = &[
            ConstraintSeverityCode_Value::INVALID_UNINITIALIZED,
            ConstraintSeverityCode_Value::ERROR,
            ConstraintSeverityCode_Value::WARNING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConstraintSeverityCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConstraintSeverityCode_Value {
}

impl ::std::default::Default for ConstraintSeverityCode_Value {
    fn default() -> Self {
        ConstraintSeverityCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConstraintSeverityCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SlicingRulesCode {
    // message fields
    pub value: SlicingRulesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SlicingRulesCode {
    pub fn new() -> SlicingRulesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SlicingRulesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SlicingRulesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SlicingRulesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SlicingRulesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SlicingRulesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SlicingRulesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SlicingRulesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SlicingRulesCode {
        SlicingRulesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SlicingRulesCode_Value>>(
                    "value",
                    |m: &SlicingRulesCode| { &m.value },
                    |m: &mut SlicingRulesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SlicingRulesCode| { &m.id },
                    |m: &mut SlicingRulesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SlicingRulesCode| { &m.extension },
                    |m: &mut SlicingRulesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SlicingRulesCode>(
                    "SlicingRulesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SlicingRulesCode {
        static mut instance: ::protobuf::lazy::Lazy<SlicingRulesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SlicingRulesCode,
        };
        unsafe {
            instance.get(SlicingRulesCode::new)
        }
    }
}

impl ::protobuf::Clear for SlicingRulesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SlicingRulesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SlicingRulesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SlicingRulesCode_Value {
    INVALID_UNINITIALIZED = 0,
    CLOSED = 1,
    OPEN = 2,
    OPEN_AT_END = 3,
}

impl ::protobuf::ProtobufEnum for SlicingRulesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SlicingRulesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SlicingRulesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SlicingRulesCode_Value::CLOSED),
            2 => ::std::option::Option::Some(SlicingRulesCode_Value::OPEN),
            3 => ::std::option::Option::Some(SlicingRulesCode_Value::OPEN_AT_END),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SlicingRulesCode_Value] = &[
            SlicingRulesCode_Value::INVALID_UNINITIALIZED,
            SlicingRulesCode_Value::CLOSED,
            SlicingRulesCode_Value::OPEN,
            SlicingRulesCode_Value::OPEN_AT_END,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SlicingRulesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SlicingRulesCode_Value {
}

impl ::std::default::Default for SlicingRulesCode_Value {
    fn default() -> Self {
        SlicingRulesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SlicingRulesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiscriminatorTypeCode {
    // message fields
    pub value: DiscriminatorTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DiscriminatorTypeCode {
    pub fn new() -> DiscriminatorTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DiscriminatorTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DiscriminatorTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DiscriminatorTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DiscriminatorTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DiscriminatorTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DiscriminatorTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DiscriminatorTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiscriminatorTypeCode {
        DiscriminatorTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DiscriminatorTypeCode_Value>>(
                    "value",
                    |m: &DiscriminatorTypeCode| { &m.value },
                    |m: &mut DiscriminatorTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DiscriminatorTypeCode| { &m.id },
                    |m: &mut DiscriminatorTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DiscriminatorTypeCode| { &m.extension },
                    |m: &mut DiscriminatorTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DiscriminatorTypeCode>(
                    "DiscriminatorTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DiscriminatorTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<DiscriminatorTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DiscriminatorTypeCode,
        };
        unsafe {
            instance.get(DiscriminatorTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for DiscriminatorTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiscriminatorTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscriminatorTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DiscriminatorTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    VALUE = 1,
    EXISTS = 2,
    PATTERN = 3,
    TYPE = 4,
    PROFILE = 5,
}

impl ::protobuf::ProtobufEnum for DiscriminatorTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DiscriminatorTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DiscriminatorTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DiscriminatorTypeCode_Value::VALUE),
            2 => ::std::option::Option::Some(DiscriminatorTypeCode_Value::EXISTS),
            3 => ::std::option::Option::Some(DiscriminatorTypeCode_Value::PATTERN),
            4 => ::std::option::Option::Some(DiscriminatorTypeCode_Value::TYPE),
            5 => ::std::option::Option::Some(DiscriminatorTypeCode_Value::PROFILE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DiscriminatorTypeCode_Value] = &[
            DiscriminatorTypeCode_Value::INVALID_UNINITIALIZED,
            DiscriminatorTypeCode_Value::VALUE,
            DiscriminatorTypeCode_Value::EXISTS,
            DiscriminatorTypeCode_Value::PATTERN,
            DiscriminatorTypeCode_Value::TYPE,
            DiscriminatorTypeCode_Value::PROFILE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DiscriminatorTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DiscriminatorTypeCode_Value {
}

impl ::std::default::Default for DiscriminatorTypeCode_Value {
    fn default() -> Self {
        DiscriminatorTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DiscriminatorTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PropertyRepresentationCode {
    // message fields
    pub value: PropertyRepresentationCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PropertyRepresentationCode {
    pub fn new() -> PropertyRepresentationCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.PropertyRepresentationCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = PropertyRepresentationCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: PropertyRepresentationCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> PropertyRepresentationCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for PropertyRepresentationCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != PropertyRepresentationCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != PropertyRepresentationCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PropertyRepresentationCode {
        PropertyRepresentationCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PropertyRepresentationCode_Value>>(
                    "value",
                    |m: &PropertyRepresentationCode| { &m.value },
                    |m: &mut PropertyRepresentationCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &PropertyRepresentationCode| { &m.id },
                    |m: &mut PropertyRepresentationCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &PropertyRepresentationCode| { &m.extension },
                    |m: &mut PropertyRepresentationCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PropertyRepresentationCode>(
                    "PropertyRepresentationCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PropertyRepresentationCode {
        static mut instance: ::protobuf::lazy::Lazy<PropertyRepresentationCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PropertyRepresentationCode,
        };
        unsafe {
            instance.get(PropertyRepresentationCode::new)
        }
    }
}

impl ::protobuf::Clear for PropertyRepresentationCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PropertyRepresentationCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyRepresentationCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PropertyRepresentationCode_Value {
    INVALID_UNINITIALIZED = 0,
    XML_ATTR = 1,
    XML_TEXT = 2,
    TYPE_ATTR = 3,
    CDA_TEXT = 4,
    XHTML = 5,
}

impl ::protobuf::ProtobufEnum for PropertyRepresentationCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PropertyRepresentationCode_Value> {
        match value {
            0 => ::std::option::Option::Some(PropertyRepresentationCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(PropertyRepresentationCode_Value::XML_ATTR),
            2 => ::std::option::Option::Some(PropertyRepresentationCode_Value::XML_TEXT),
            3 => ::std::option::Option::Some(PropertyRepresentationCode_Value::TYPE_ATTR),
            4 => ::std::option::Option::Some(PropertyRepresentationCode_Value::CDA_TEXT),
            5 => ::std::option::Option::Some(PropertyRepresentationCode_Value::XHTML),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PropertyRepresentationCode_Value] = &[
            PropertyRepresentationCode_Value::INVALID_UNINITIALIZED,
            PropertyRepresentationCode_Value::XML_ATTR,
            PropertyRepresentationCode_Value::XML_TEXT,
            PropertyRepresentationCode_Value::TYPE_ATTR,
            PropertyRepresentationCode_Value::CDA_TEXT,
            PropertyRepresentationCode_Value::XHTML,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PropertyRepresentationCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PropertyRepresentationCode_Value {
}

impl ::std::default::Default for PropertyRepresentationCode_Value {
    fn default() -> Self {
        PropertyRepresentationCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyRepresentationCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReferenceVersionRulesCode {
    // message fields
    pub value: ReferenceVersionRulesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ReferenceVersionRulesCode {
    pub fn new() -> ReferenceVersionRulesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ReferenceVersionRulesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ReferenceVersionRulesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ReferenceVersionRulesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ReferenceVersionRulesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ReferenceVersionRulesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ReferenceVersionRulesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ReferenceVersionRulesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReferenceVersionRulesCode {
        ReferenceVersionRulesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReferenceVersionRulesCode_Value>>(
                    "value",
                    |m: &ReferenceVersionRulesCode| { &m.value },
                    |m: &mut ReferenceVersionRulesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ReferenceVersionRulesCode| { &m.id },
                    |m: &mut ReferenceVersionRulesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ReferenceVersionRulesCode| { &m.extension },
                    |m: &mut ReferenceVersionRulesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReferenceVersionRulesCode>(
                    "ReferenceVersionRulesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReferenceVersionRulesCode {
        static mut instance: ::protobuf::lazy::Lazy<ReferenceVersionRulesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReferenceVersionRulesCode,
        };
        unsafe {
            instance.get(ReferenceVersionRulesCode::new)
        }
    }
}

impl ::protobuf::Clear for ReferenceVersionRulesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReferenceVersionRulesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReferenceVersionRulesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReferenceVersionRulesCode_Value {
    INVALID_UNINITIALIZED = 0,
    EITHER = 1,
    INDEPENDENT = 2,
    SPECIFIC = 3,
}

impl ::protobuf::ProtobufEnum for ReferenceVersionRulesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReferenceVersionRulesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ReferenceVersionRulesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ReferenceVersionRulesCode_Value::EITHER),
            2 => ::std::option::Option::Some(ReferenceVersionRulesCode_Value::INDEPENDENT),
            3 => ::std::option::Option::Some(ReferenceVersionRulesCode_Value::SPECIFIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReferenceVersionRulesCode_Value] = &[
            ReferenceVersionRulesCode_Value::INVALID_UNINITIALIZED,
            ReferenceVersionRulesCode_Value::EITHER,
            ReferenceVersionRulesCode_Value::INDEPENDENT,
            ReferenceVersionRulesCode_Value::SPECIFIC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ReferenceVersionRulesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ReferenceVersionRulesCode_Value {
}

impl ::std::default::Default for ReferenceVersionRulesCode_Value {
    fn default() -> Self {
        ReferenceVersionRulesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ReferenceVersionRulesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountStatusCode {
    // message fields
    pub value: AccountStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountStatusCode {
    pub fn new() -> AccountStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AccountStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AccountStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AccountStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AccountStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AccountStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AccountStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AccountStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountStatusCode {
        AccountStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AccountStatusCode_Value>>(
                    "value",
                    |m: &AccountStatusCode| { &m.value },
                    |m: &mut AccountStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AccountStatusCode| { &m.id },
                    |m: &mut AccountStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AccountStatusCode| { &m.extension },
                    |m: &mut AccountStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountStatusCode>(
                    "AccountStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<AccountStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountStatusCode,
        };
        unsafe {
            instance.get(AccountStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for AccountStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AccountStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    INACTIVE = 2,
    ENTERED_IN_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for AccountStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AccountStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AccountStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AccountStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(AccountStatusCode_Value::INACTIVE),
            3 => ::std::option::Option::Some(AccountStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AccountStatusCode_Value] = &[
            AccountStatusCode_Value::INVALID_UNINITIALIZED,
            AccountStatusCode_Value::ACTIVE,
            AccountStatusCode_Value::INACTIVE,
            AccountStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AccountStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AccountStatusCode_Value {
}

impl ::std::default::Default for AccountStatusCode_Value {
    fn default() -> Self {
        AccountStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionCardinalityBehaviorCode {
    // message fields
    pub value: ActionCardinalityBehaviorCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ActionCardinalityBehaviorCode {
    pub fn new() -> ActionCardinalityBehaviorCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ActionCardinalityBehaviorCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ActionCardinalityBehaviorCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ActionCardinalityBehaviorCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ActionCardinalityBehaviorCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ActionCardinalityBehaviorCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ActionCardinalityBehaviorCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ActionCardinalityBehaviorCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionCardinalityBehaviorCode {
        ActionCardinalityBehaviorCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionCardinalityBehaviorCode_Value>>(
                    "value",
                    |m: &ActionCardinalityBehaviorCode| { &m.value },
                    |m: &mut ActionCardinalityBehaviorCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ActionCardinalityBehaviorCode| { &m.id },
                    |m: &mut ActionCardinalityBehaviorCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ActionCardinalityBehaviorCode| { &m.extension },
                    |m: &mut ActionCardinalityBehaviorCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActionCardinalityBehaviorCode>(
                    "ActionCardinalityBehaviorCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionCardinalityBehaviorCode {
        static mut instance: ::protobuf::lazy::Lazy<ActionCardinalityBehaviorCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActionCardinalityBehaviorCode,
        };
        unsafe {
            instance.get(ActionCardinalityBehaviorCode::new)
        }
    }
}

impl ::protobuf::Clear for ActionCardinalityBehaviorCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionCardinalityBehaviorCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionCardinalityBehaviorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionCardinalityBehaviorCode_Value {
    INVALID_UNINITIALIZED = 0,
    SINGLE = 1,
    MULTIPLE = 2,
}

impl ::protobuf::ProtobufEnum for ActionCardinalityBehaviorCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionCardinalityBehaviorCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ActionCardinalityBehaviorCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ActionCardinalityBehaviorCode_Value::SINGLE),
            2 => ::std::option::Option::Some(ActionCardinalityBehaviorCode_Value::MULTIPLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionCardinalityBehaviorCode_Value] = &[
            ActionCardinalityBehaviorCode_Value::INVALID_UNINITIALIZED,
            ActionCardinalityBehaviorCode_Value::SINGLE,
            ActionCardinalityBehaviorCode_Value::MULTIPLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ActionCardinalityBehaviorCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ActionCardinalityBehaviorCode_Value {
}

impl ::std::default::Default for ActionCardinalityBehaviorCode_Value {
    fn default() -> Self {
        ActionCardinalityBehaviorCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionCardinalityBehaviorCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionConditionKindCode {
    // message fields
    pub value: ActionConditionKindCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ActionConditionKindCode {
    pub fn new() -> ActionConditionKindCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ActionConditionKindCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ActionConditionKindCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ActionConditionKindCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ActionConditionKindCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ActionConditionKindCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ActionConditionKindCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ActionConditionKindCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionConditionKindCode {
        ActionConditionKindCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionConditionKindCode_Value>>(
                    "value",
                    |m: &ActionConditionKindCode| { &m.value },
                    |m: &mut ActionConditionKindCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ActionConditionKindCode| { &m.id },
                    |m: &mut ActionConditionKindCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ActionConditionKindCode| { &m.extension },
                    |m: &mut ActionConditionKindCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActionConditionKindCode>(
                    "ActionConditionKindCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionConditionKindCode {
        static mut instance: ::protobuf::lazy::Lazy<ActionConditionKindCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActionConditionKindCode,
        };
        unsafe {
            instance.get(ActionConditionKindCode::new)
        }
    }
}

impl ::protobuf::Clear for ActionConditionKindCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionConditionKindCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionConditionKindCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionConditionKindCode_Value {
    INVALID_UNINITIALIZED = 0,
    APPLICABILITY = 1,
    START = 2,
    STOP = 3,
}

impl ::protobuf::ProtobufEnum for ActionConditionKindCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionConditionKindCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ActionConditionKindCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ActionConditionKindCode_Value::APPLICABILITY),
            2 => ::std::option::Option::Some(ActionConditionKindCode_Value::START),
            3 => ::std::option::Option::Some(ActionConditionKindCode_Value::STOP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionConditionKindCode_Value] = &[
            ActionConditionKindCode_Value::INVALID_UNINITIALIZED,
            ActionConditionKindCode_Value::APPLICABILITY,
            ActionConditionKindCode_Value::START,
            ActionConditionKindCode_Value::STOP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ActionConditionKindCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ActionConditionKindCode_Value {
}

impl ::std::default::Default for ActionConditionKindCode_Value {
    fn default() -> Self {
        ActionConditionKindCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionConditionKindCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionGroupingBehaviorCode {
    // message fields
    pub value: ActionGroupingBehaviorCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ActionGroupingBehaviorCode {
    pub fn new() -> ActionGroupingBehaviorCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ActionGroupingBehaviorCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ActionGroupingBehaviorCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ActionGroupingBehaviorCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ActionGroupingBehaviorCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ActionGroupingBehaviorCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ActionGroupingBehaviorCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ActionGroupingBehaviorCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionGroupingBehaviorCode {
        ActionGroupingBehaviorCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionGroupingBehaviorCode_Value>>(
                    "value",
                    |m: &ActionGroupingBehaviorCode| { &m.value },
                    |m: &mut ActionGroupingBehaviorCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ActionGroupingBehaviorCode| { &m.id },
                    |m: &mut ActionGroupingBehaviorCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ActionGroupingBehaviorCode| { &m.extension },
                    |m: &mut ActionGroupingBehaviorCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActionGroupingBehaviorCode>(
                    "ActionGroupingBehaviorCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionGroupingBehaviorCode {
        static mut instance: ::protobuf::lazy::Lazy<ActionGroupingBehaviorCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActionGroupingBehaviorCode,
        };
        unsafe {
            instance.get(ActionGroupingBehaviorCode::new)
        }
    }
}

impl ::protobuf::Clear for ActionGroupingBehaviorCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionGroupingBehaviorCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionGroupingBehaviorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionGroupingBehaviorCode_Value {
    INVALID_UNINITIALIZED = 0,
    VISUAL_GROUP = 1,
    LOGICAL_GROUP = 2,
    SENTENCE_GROUP = 3,
}

impl ::protobuf::ProtobufEnum for ActionGroupingBehaviorCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionGroupingBehaviorCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ActionGroupingBehaviorCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ActionGroupingBehaviorCode_Value::VISUAL_GROUP),
            2 => ::std::option::Option::Some(ActionGroupingBehaviorCode_Value::LOGICAL_GROUP),
            3 => ::std::option::Option::Some(ActionGroupingBehaviorCode_Value::SENTENCE_GROUP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionGroupingBehaviorCode_Value] = &[
            ActionGroupingBehaviorCode_Value::INVALID_UNINITIALIZED,
            ActionGroupingBehaviorCode_Value::VISUAL_GROUP,
            ActionGroupingBehaviorCode_Value::LOGICAL_GROUP,
            ActionGroupingBehaviorCode_Value::SENTENCE_GROUP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ActionGroupingBehaviorCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ActionGroupingBehaviorCode_Value {
}

impl ::std::default::Default for ActionGroupingBehaviorCode_Value {
    fn default() -> Self {
        ActionGroupingBehaviorCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionGroupingBehaviorCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionListCode {
    // message fields
    pub value: ActionListCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ActionListCode {
    pub fn new() -> ActionListCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ActionListCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ActionListCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ActionListCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ActionListCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ActionListCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ActionListCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ActionListCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionListCode {
        ActionListCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionListCode_Value>>(
                    "value",
                    |m: &ActionListCode| { &m.value },
                    |m: &mut ActionListCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ActionListCode| { &m.id },
                    |m: &mut ActionListCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ActionListCode| { &m.extension },
                    |m: &mut ActionListCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActionListCode>(
                    "ActionListCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionListCode {
        static mut instance: ::protobuf::lazy::Lazy<ActionListCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActionListCode,
        };
        unsafe {
            instance.get(ActionListCode::new)
        }
    }
}

impl ::protobuf::Clear for ActionListCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionListCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionListCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionListCode_Value {
    INVALID_UNINITIALIZED = 0,
    CANCEL = 1,
    POLL = 2,
    REPROCESS = 3,
    STATUS = 4,
}

impl ::protobuf::ProtobufEnum for ActionListCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionListCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ActionListCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ActionListCode_Value::CANCEL),
            2 => ::std::option::Option::Some(ActionListCode_Value::POLL),
            3 => ::std::option::Option::Some(ActionListCode_Value::REPROCESS),
            4 => ::std::option::Option::Some(ActionListCode_Value::STATUS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionListCode_Value] = &[
            ActionListCode_Value::INVALID_UNINITIALIZED,
            ActionListCode_Value::CANCEL,
            ActionListCode_Value::POLL,
            ActionListCode_Value::REPROCESS,
            ActionListCode_Value::STATUS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ActionListCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ActionListCode_Value {
}

impl ::std::default::Default for ActionListCode_Value {
    fn default() -> Self {
        ActionListCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionListCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionParticipantTypeCode {
    // message fields
    pub value: ActionParticipantTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ActionParticipantTypeCode {
    pub fn new() -> ActionParticipantTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ActionParticipantTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ActionParticipantTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ActionParticipantTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ActionParticipantTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ActionParticipantTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ActionParticipantTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ActionParticipantTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionParticipantTypeCode {
        ActionParticipantTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionParticipantTypeCode_Value>>(
                    "value",
                    |m: &ActionParticipantTypeCode| { &m.value },
                    |m: &mut ActionParticipantTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ActionParticipantTypeCode| { &m.id },
                    |m: &mut ActionParticipantTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ActionParticipantTypeCode| { &m.extension },
                    |m: &mut ActionParticipantTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActionParticipantTypeCode>(
                    "ActionParticipantTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionParticipantTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ActionParticipantTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActionParticipantTypeCode,
        };
        unsafe {
            instance.get(ActionParticipantTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ActionParticipantTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionParticipantTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionParticipantTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionParticipantTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    PATIENT = 1,
    PRACTITIONER = 2,
    RELATED_PERSON = 3,
}

impl ::protobuf::ProtobufEnum for ActionParticipantTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionParticipantTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ActionParticipantTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ActionParticipantTypeCode_Value::PATIENT),
            2 => ::std::option::Option::Some(ActionParticipantTypeCode_Value::PRACTITIONER),
            3 => ::std::option::Option::Some(ActionParticipantTypeCode_Value::RELATED_PERSON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionParticipantTypeCode_Value] = &[
            ActionParticipantTypeCode_Value::INVALID_UNINITIALIZED,
            ActionParticipantTypeCode_Value::PATIENT,
            ActionParticipantTypeCode_Value::PRACTITIONER,
            ActionParticipantTypeCode_Value::RELATED_PERSON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ActionParticipantTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ActionParticipantTypeCode_Value {
}

impl ::std::default::Default for ActionParticipantTypeCode_Value {
    fn default() -> Self {
        ActionParticipantTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionParticipantTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionPrecheckBehaviorCode {
    // message fields
    pub value: ActionPrecheckBehaviorCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ActionPrecheckBehaviorCode {
    pub fn new() -> ActionPrecheckBehaviorCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ActionPrecheckBehaviorCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ActionPrecheckBehaviorCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ActionPrecheckBehaviorCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ActionPrecheckBehaviorCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ActionPrecheckBehaviorCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ActionPrecheckBehaviorCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ActionPrecheckBehaviorCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionPrecheckBehaviorCode {
        ActionPrecheckBehaviorCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionPrecheckBehaviorCode_Value>>(
                    "value",
                    |m: &ActionPrecheckBehaviorCode| { &m.value },
                    |m: &mut ActionPrecheckBehaviorCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ActionPrecheckBehaviorCode| { &m.id },
                    |m: &mut ActionPrecheckBehaviorCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ActionPrecheckBehaviorCode| { &m.extension },
                    |m: &mut ActionPrecheckBehaviorCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActionPrecheckBehaviorCode>(
                    "ActionPrecheckBehaviorCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionPrecheckBehaviorCode {
        static mut instance: ::protobuf::lazy::Lazy<ActionPrecheckBehaviorCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActionPrecheckBehaviorCode,
        };
        unsafe {
            instance.get(ActionPrecheckBehaviorCode::new)
        }
    }
}

impl ::protobuf::Clear for ActionPrecheckBehaviorCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionPrecheckBehaviorCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionPrecheckBehaviorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionPrecheckBehaviorCode_Value {
    INVALID_UNINITIALIZED = 0,
    YES = 1,
    NO = 2,
}

impl ::protobuf::ProtobufEnum for ActionPrecheckBehaviorCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionPrecheckBehaviorCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ActionPrecheckBehaviorCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ActionPrecheckBehaviorCode_Value::YES),
            2 => ::std::option::Option::Some(ActionPrecheckBehaviorCode_Value::NO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionPrecheckBehaviorCode_Value] = &[
            ActionPrecheckBehaviorCode_Value::INVALID_UNINITIALIZED,
            ActionPrecheckBehaviorCode_Value::YES,
            ActionPrecheckBehaviorCode_Value::NO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ActionPrecheckBehaviorCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ActionPrecheckBehaviorCode_Value {
}

impl ::std::default::Default for ActionPrecheckBehaviorCode_Value {
    fn default() -> Self {
        ActionPrecheckBehaviorCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionPrecheckBehaviorCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionRelationshipTypeCode {
    // message fields
    pub value: ActionRelationshipTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ActionRelationshipTypeCode {
    pub fn new() -> ActionRelationshipTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ActionRelationshipTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ActionRelationshipTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ActionRelationshipTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ActionRelationshipTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ActionRelationshipTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ActionRelationshipTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ActionRelationshipTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionRelationshipTypeCode {
        ActionRelationshipTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionRelationshipTypeCode_Value>>(
                    "value",
                    |m: &ActionRelationshipTypeCode| { &m.value },
                    |m: &mut ActionRelationshipTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ActionRelationshipTypeCode| { &m.id },
                    |m: &mut ActionRelationshipTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ActionRelationshipTypeCode| { &m.extension },
                    |m: &mut ActionRelationshipTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActionRelationshipTypeCode>(
                    "ActionRelationshipTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionRelationshipTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ActionRelationshipTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActionRelationshipTypeCode,
        };
        unsafe {
            instance.get(ActionRelationshipTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ActionRelationshipTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionRelationshipTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRelationshipTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionRelationshipTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    BEFORE_START = 1,
    BEFORE = 2,
    BEFORE_END = 3,
    CONCURRENT_WITH_START = 4,
    CONCURRENT = 5,
    CONCURRENT_WITH_END = 6,
    AFTER_START = 7,
    AFTER = 8,
    AFTER_END = 9,
}

impl ::protobuf::ProtobufEnum for ActionRelationshipTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionRelationshipTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ActionRelationshipTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ActionRelationshipTypeCode_Value::BEFORE_START),
            2 => ::std::option::Option::Some(ActionRelationshipTypeCode_Value::BEFORE),
            3 => ::std::option::Option::Some(ActionRelationshipTypeCode_Value::BEFORE_END),
            4 => ::std::option::Option::Some(ActionRelationshipTypeCode_Value::CONCURRENT_WITH_START),
            5 => ::std::option::Option::Some(ActionRelationshipTypeCode_Value::CONCURRENT),
            6 => ::std::option::Option::Some(ActionRelationshipTypeCode_Value::CONCURRENT_WITH_END),
            7 => ::std::option::Option::Some(ActionRelationshipTypeCode_Value::AFTER_START),
            8 => ::std::option::Option::Some(ActionRelationshipTypeCode_Value::AFTER),
            9 => ::std::option::Option::Some(ActionRelationshipTypeCode_Value::AFTER_END),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionRelationshipTypeCode_Value] = &[
            ActionRelationshipTypeCode_Value::INVALID_UNINITIALIZED,
            ActionRelationshipTypeCode_Value::BEFORE_START,
            ActionRelationshipTypeCode_Value::BEFORE,
            ActionRelationshipTypeCode_Value::BEFORE_END,
            ActionRelationshipTypeCode_Value::CONCURRENT_WITH_START,
            ActionRelationshipTypeCode_Value::CONCURRENT,
            ActionRelationshipTypeCode_Value::CONCURRENT_WITH_END,
            ActionRelationshipTypeCode_Value::AFTER_START,
            ActionRelationshipTypeCode_Value::AFTER,
            ActionRelationshipTypeCode_Value::AFTER_END,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ActionRelationshipTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ActionRelationshipTypeCode_Value {
}

impl ::std::default::Default for ActionRelationshipTypeCode_Value {
    fn default() -> Self {
        ActionRelationshipTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRelationshipTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionRequiredBehaviorCode {
    // message fields
    pub value: ActionRequiredBehaviorCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ActionRequiredBehaviorCode {
    pub fn new() -> ActionRequiredBehaviorCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ActionRequiredBehaviorCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ActionRequiredBehaviorCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ActionRequiredBehaviorCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ActionRequiredBehaviorCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ActionRequiredBehaviorCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ActionRequiredBehaviorCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ActionRequiredBehaviorCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionRequiredBehaviorCode {
        ActionRequiredBehaviorCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionRequiredBehaviorCode_Value>>(
                    "value",
                    |m: &ActionRequiredBehaviorCode| { &m.value },
                    |m: &mut ActionRequiredBehaviorCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ActionRequiredBehaviorCode| { &m.id },
                    |m: &mut ActionRequiredBehaviorCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ActionRequiredBehaviorCode| { &m.extension },
                    |m: &mut ActionRequiredBehaviorCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActionRequiredBehaviorCode>(
                    "ActionRequiredBehaviorCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionRequiredBehaviorCode {
        static mut instance: ::protobuf::lazy::Lazy<ActionRequiredBehaviorCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActionRequiredBehaviorCode,
        };
        unsafe {
            instance.get(ActionRequiredBehaviorCode::new)
        }
    }
}

impl ::protobuf::Clear for ActionRequiredBehaviorCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionRequiredBehaviorCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRequiredBehaviorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionRequiredBehaviorCode_Value {
    INVALID_UNINITIALIZED = 0,
    MUST = 1,
    COULD = 2,
    MUST_UNLESS_DOCUMENTED = 3,
}

impl ::protobuf::ProtobufEnum for ActionRequiredBehaviorCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionRequiredBehaviorCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ActionRequiredBehaviorCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ActionRequiredBehaviorCode_Value::MUST),
            2 => ::std::option::Option::Some(ActionRequiredBehaviorCode_Value::COULD),
            3 => ::std::option::Option::Some(ActionRequiredBehaviorCode_Value::MUST_UNLESS_DOCUMENTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionRequiredBehaviorCode_Value] = &[
            ActionRequiredBehaviorCode_Value::INVALID_UNINITIALIZED,
            ActionRequiredBehaviorCode_Value::MUST,
            ActionRequiredBehaviorCode_Value::COULD,
            ActionRequiredBehaviorCode_Value::MUST_UNLESS_DOCUMENTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ActionRequiredBehaviorCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ActionRequiredBehaviorCode_Value {
}

impl ::std::default::Default for ActionRequiredBehaviorCode_Value {
    fn default() -> Self {
        ActionRequiredBehaviorCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionRequiredBehaviorCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionSelectionBehaviorCode {
    // message fields
    pub value: ActionSelectionBehaviorCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ActionSelectionBehaviorCode {
    pub fn new() -> ActionSelectionBehaviorCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ActionSelectionBehaviorCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ActionSelectionBehaviorCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ActionSelectionBehaviorCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ActionSelectionBehaviorCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ActionSelectionBehaviorCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ActionSelectionBehaviorCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ActionSelectionBehaviorCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionSelectionBehaviorCode {
        ActionSelectionBehaviorCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionSelectionBehaviorCode_Value>>(
                    "value",
                    |m: &ActionSelectionBehaviorCode| { &m.value },
                    |m: &mut ActionSelectionBehaviorCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ActionSelectionBehaviorCode| { &m.id },
                    |m: &mut ActionSelectionBehaviorCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ActionSelectionBehaviorCode| { &m.extension },
                    |m: &mut ActionSelectionBehaviorCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActionSelectionBehaviorCode>(
                    "ActionSelectionBehaviorCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionSelectionBehaviorCode {
        static mut instance: ::protobuf::lazy::Lazy<ActionSelectionBehaviorCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActionSelectionBehaviorCode,
        };
        unsafe {
            instance.get(ActionSelectionBehaviorCode::new)
        }
    }
}

impl ::protobuf::Clear for ActionSelectionBehaviorCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionSelectionBehaviorCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSelectionBehaviorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionSelectionBehaviorCode_Value {
    INVALID_UNINITIALIZED = 0,
    ANY = 1,
    ALL = 2,
    ALL_OR_NONE = 3,
    EXACTLY_ONE = 4,
    AT_MOST_ONE = 5,
    ONE_OR_MORE = 6,
}

impl ::protobuf::ProtobufEnum for ActionSelectionBehaviorCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionSelectionBehaviorCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ActionSelectionBehaviorCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ActionSelectionBehaviorCode_Value::ANY),
            2 => ::std::option::Option::Some(ActionSelectionBehaviorCode_Value::ALL),
            3 => ::std::option::Option::Some(ActionSelectionBehaviorCode_Value::ALL_OR_NONE),
            4 => ::std::option::Option::Some(ActionSelectionBehaviorCode_Value::EXACTLY_ONE),
            5 => ::std::option::Option::Some(ActionSelectionBehaviorCode_Value::AT_MOST_ONE),
            6 => ::std::option::Option::Some(ActionSelectionBehaviorCode_Value::ONE_OR_MORE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionSelectionBehaviorCode_Value] = &[
            ActionSelectionBehaviorCode_Value::INVALID_UNINITIALIZED,
            ActionSelectionBehaviorCode_Value::ANY,
            ActionSelectionBehaviorCode_Value::ALL,
            ActionSelectionBehaviorCode_Value::ALL_OR_NONE,
            ActionSelectionBehaviorCode_Value::EXACTLY_ONE,
            ActionSelectionBehaviorCode_Value::AT_MOST_ONE,
            ActionSelectionBehaviorCode_Value::ONE_OR_MORE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ActionSelectionBehaviorCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ActionSelectionBehaviorCode_Value {
}

impl ::std::default::Default for ActionSelectionBehaviorCode_Value {
    fn default() -> Self {
        ActionSelectionBehaviorCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionSelectionBehaviorCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActionTypeCode {
    // message fields
    pub value: ActionTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ActionTypeCode {
    pub fn new() -> ActionTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ActionTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ActionTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ActionTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ActionTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ActionTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ActionTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ActionTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActionTypeCode {
        ActionTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionTypeCode_Value>>(
                    "value",
                    |m: &ActionTypeCode| { &m.value },
                    |m: &mut ActionTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ActionTypeCode| { &m.id },
                    |m: &mut ActionTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ActionTypeCode| { &m.extension },
                    |m: &mut ActionTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActionTypeCode>(
                    "ActionTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActionTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ActionTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActionTypeCode,
        };
        unsafe {
            instance.get(ActionTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ActionTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActionTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    CREATE = 1,
    UPDATE = 2,
    REMOVE = 3,
    FIRE_EVENT = 4,
}

impl ::protobuf::ProtobufEnum for ActionTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ActionTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ActionTypeCode_Value::CREATE),
            2 => ::std::option::Option::Some(ActionTypeCode_Value::UPDATE),
            3 => ::std::option::Option::Some(ActionTypeCode_Value::REMOVE),
            4 => ::std::option::Option::Some(ActionTypeCode_Value::FIRE_EVENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionTypeCode_Value] = &[
            ActionTypeCode_Value::INVALID_UNINITIALIZED,
            ActionTypeCode_Value::CREATE,
            ActionTypeCode_Value::UPDATE,
            ActionTypeCode_Value::REMOVE,
            ActionTypeCode_Value::FIRE_EVENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ActionTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ActionTypeCode_Value {
}

impl ::std::default::Default for ActionTypeCode_Value {
    fn default() -> Self {
        ActionTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActivityDefinitionCategoryCode {
    // message fields
    pub value: ActivityDefinitionCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ActivityDefinitionCategoryCode {
    pub fn new() -> ActivityDefinitionCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ActivityDefinitionCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ActivityDefinitionCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ActivityDefinitionCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ActivityDefinitionCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ActivityDefinitionCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ActivityDefinitionCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ActivityDefinitionCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActivityDefinitionCategoryCode {
        ActivityDefinitionCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActivityDefinitionCategoryCode_Value>>(
                    "value",
                    |m: &ActivityDefinitionCategoryCode| { &m.value },
                    |m: &mut ActivityDefinitionCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ActivityDefinitionCategoryCode| { &m.id },
                    |m: &mut ActivityDefinitionCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ActivityDefinitionCategoryCode| { &m.extension },
                    |m: &mut ActivityDefinitionCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActivityDefinitionCategoryCode>(
                    "ActivityDefinitionCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActivityDefinitionCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<ActivityDefinitionCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActivityDefinitionCategoryCode,
        };
        unsafe {
            instance.get(ActivityDefinitionCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for ActivityDefinitionCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActivityDefinitionCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityDefinitionCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActivityDefinitionCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    TREATMENT = 1,
    EDUCATION = 2,
    ASSESSMENT = 3,
}

impl ::protobuf::ProtobufEnum for ActivityDefinitionCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActivityDefinitionCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ActivityDefinitionCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ActivityDefinitionCategoryCode_Value::TREATMENT),
            2 => ::std::option::Option::Some(ActivityDefinitionCategoryCode_Value::EDUCATION),
            3 => ::std::option::Option::Some(ActivityDefinitionCategoryCode_Value::ASSESSMENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActivityDefinitionCategoryCode_Value] = &[
            ActivityDefinitionCategoryCode_Value::INVALID_UNINITIALIZED,
            ActivityDefinitionCategoryCode_Value::TREATMENT,
            ActivityDefinitionCategoryCode_Value::EDUCATION,
            ActivityDefinitionCategoryCode_Value::ASSESSMENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ActivityDefinitionCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ActivityDefinitionCategoryCode_Value {
}

impl ::std::default::Default for ActivityDefinitionCategoryCode_Value {
    fn default() -> Self {
        ActivityDefinitionCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityDefinitionCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdministrativeGenderCode {
    // message fields
    pub value: AdministrativeGenderCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AdministrativeGenderCode {
    pub fn new() -> AdministrativeGenderCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AdministrativeGenderCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AdministrativeGenderCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AdministrativeGenderCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AdministrativeGenderCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AdministrativeGenderCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AdministrativeGenderCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AdministrativeGenderCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdministrativeGenderCode {
        AdministrativeGenderCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AdministrativeGenderCode_Value>>(
                    "value",
                    |m: &AdministrativeGenderCode| { &m.value },
                    |m: &mut AdministrativeGenderCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AdministrativeGenderCode| { &m.id },
                    |m: &mut AdministrativeGenderCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AdministrativeGenderCode| { &m.extension },
                    |m: &mut AdministrativeGenderCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AdministrativeGenderCode>(
                    "AdministrativeGenderCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdministrativeGenderCode {
        static mut instance: ::protobuf::lazy::Lazy<AdministrativeGenderCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AdministrativeGenderCode,
        };
        unsafe {
            instance.get(AdministrativeGenderCode::new)
        }
    }
}

impl ::protobuf::Clear for AdministrativeGenderCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdministrativeGenderCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdministrativeGenderCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AdministrativeGenderCode_Value {
    INVALID_UNINITIALIZED = 0,
    MALE = 1,
    FEMALE = 2,
    OTHER = 3,
    UNKNOWN = 4,
}

impl ::protobuf::ProtobufEnum for AdministrativeGenderCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AdministrativeGenderCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AdministrativeGenderCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AdministrativeGenderCode_Value::MALE),
            2 => ::std::option::Option::Some(AdministrativeGenderCode_Value::FEMALE),
            3 => ::std::option::Option::Some(AdministrativeGenderCode_Value::OTHER),
            4 => ::std::option::Option::Some(AdministrativeGenderCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AdministrativeGenderCode_Value] = &[
            AdministrativeGenderCode_Value::INVALID_UNINITIALIZED,
            AdministrativeGenderCode_Value::MALE,
            AdministrativeGenderCode_Value::FEMALE,
            AdministrativeGenderCode_Value::OTHER,
            AdministrativeGenderCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AdministrativeGenderCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AdministrativeGenderCode_Value {
}

impl ::std::default::Default for AdministrativeGenderCode_Value {
    fn default() -> Self {
        AdministrativeGenderCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AdministrativeGenderCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdverseEventCategoryCode {
    // message fields
    pub value: AdverseEventCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AdverseEventCategoryCode {
    pub fn new() -> AdverseEventCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AdverseEventCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AdverseEventCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AdverseEventCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AdverseEventCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AdverseEventCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AdverseEventCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AdverseEventCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdverseEventCategoryCode {
        AdverseEventCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AdverseEventCategoryCode_Value>>(
                    "value",
                    |m: &AdverseEventCategoryCode| { &m.value },
                    |m: &mut AdverseEventCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AdverseEventCategoryCode| { &m.id },
                    |m: &mut AdverseEventCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AdverseEventCategoryCode| { &m.extension },
                    |m: &mut AdverseEventCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AdverseEventCategoryCode>(
                    "AdverseEventCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdverseEventCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<AdverseEventCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AdverseEventCategoryCode,
        };
        unsafe {
            instance.get(AdverseEventCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for AdverseEventCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdverseEventCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AdverseEventCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    AE = 1,
    PAE = 2,
}

impl ::protobuf::ProtobufEnum for AdverseEventCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AdverseEventCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AdverseEventCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AdverseEventCategoryCode_Value::AE),
            2 => ::std::option::Option::Some(AdverseEventCategoryCode_Value::PAE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AdverseEventCategoryCode_Value] = &[
            AdverseEventCategoryCode_Value::INVALID_UNINITIALIZED,
            AdverseEventCategoryCode_Value::AE,
            AdverseEventCategoryCode_Value::PAE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AdverseEventCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AdverseEventCategoryCode_Value {
}

impl ::std::default::Default for AdverseEventCategoryCode_Value {
    fn default() -> Self {
        AdverseEventCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdverseEventCausalityAssessmentCode {
    // message fields
    pub value: AdverseEventCausalityAssessmentCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AdverseEventCausalityAssessmentCode {
    pub fn new() -> AdverseEventCausalityAssessmentCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AdverseEventCausalityAssessmentCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AdverseEventCausalityAssessmentCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AdverseEventCausalityAssessmentCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AdverseEventCausalityAssessmentCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AdverseEventCausalityAssessmentCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AdverseEventCausalityAssessmentCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AdverseEventCausalityAssessmentCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdverseEventCausalityAssessmentCode {
        AdverseEventCausalityAssessmentCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AdverseEventCausalityAssessmentCode_Value>>(
                    "value",
                    |m: &AdverseEventCausalityAssessmentCode| { &m.value },
                    |m: &mut AdverseEventCausalityAssessmentCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AdverseEventCausalityAssessmentCode| { &m.id },
                    |m: &mut AdverseEventCausalityAssessmentCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AdverseEventCausalityAssessmentCode| { &m.extension },
                    |m: &mut AdverseEventCausalityAssessmentCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AdverseEventCausalityAssessmentCode>(
                    "AdverseEventCausalityAssessmentCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdverseEventCausalityAssessmentCode {
        static mut instance: ::protobuf::lazy::Lazy<AdverseEventCausalityAssessmentCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AdverseEventCausalityAssessmentCode,
        };
        unsafe {
            instance.get(AdverseEventCausalityAssessmentCode::new)
        }
    }
}

impl ::protobuf::Clear for AdverseEventCausalityAssessmentCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdverseEventCausalityAssessmentCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventCausalityAssessmentCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AdverseEventCausalityAssessmentCode_Value {
    INVALID_UNINITIALIZED = 0,
    ASSESS1 = 1,
    ASSESS2 = 2,
}

impl ::protobuf::ProtobufEnum for AdverseEventCausalityAssessmentCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AdverseEventCausalityAssessmentCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AdverseEventCausalityAssessmentCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AdverseEventCausalityAssessmentCode_Value::ASSESS1),
            2 => ::std::option::Option::Some(AdverseEventCausalityAssessmentCode_Value::ASSESS2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AdverseEventCausalityAssessmentCode_Value] = &[
            AdverseEventCausalityAssessmentCode_Value::INVALID_UNINITIALIZED,
            AdverseEventCausalityAssessmentCode_Value::ASSESS1,
            AdverseEventCausalityAssessmentCode_Value::ASSESS2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AdverseEventCausalityAssessmentCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AdverseEventCausalityAssessmentCode_Value {
}

impl ::std::default::Default for AdverseEventCausalityAssessmentCode_Value {
    fn default() -> Self {
        AdverseEventCausalityAssessmentCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventCausalityAssessmentCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdverseEventCausalityCode {
    // message fields
    pub value: AdverseEventCausalityCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AdverseEventCausalityCode {
    pub fn new() -> AdverseEventCausalityCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AdverseEventCausalityCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AdverseEventCausalityCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AdverseEventCausalityCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AdverseEventCausalityCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AdverseEventCausalityCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AdverseEventCausalityCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AdverseEventCausalityCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdverseEventCausalityCode {
        AdverseEventCausalityCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AdverseEventCausalityCode_Value>>(
                    "value",
                    |m: &AdverseEventCausalityCode| { &m.value },
                    |m: &mut AdverseEventCausalityCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AdverseEventCausalityCode| { &m.id },
                    |m: &mut AdverseEventCausalityCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AdverseEventCausalityCode| { &m.extension },
                    |m: &mut AdverseEventCausalityCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AdverseEventCausalityCode>(
                    "AdverseEventCausalityCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdverseEventCausalityCode {
        static mut instance: ::protobuf::lazy::Lazy<AdverseEventCausalityCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AdverseEventCausalityCode,
        };
        unsafe {
            instance.get(AdverseEventCausalityCode::new)
        }
    }
}

impl ::protobuf::Clear for AdverseEventCausalityCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdverseEventCausalityCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventCausalityCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AdverseEventCausalityCode_Value {
    INVALID_UNINITIALIZED = 0,
    CAUSALITY1 = 1,
    CAUSALITY2 = 2,
}

impl ::protobuf::ProtobufEnum for AdverseEventCausalityCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AdverseEventCausalityCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AdverseEventCausalityCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AdverseEventCausalityCode_Value::CAUSALITY1),
            2 => ::std::option::Option::Some(AdverseEventCausalityCode_Value::CAUSALITY2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AdverseEventCausalityCode_Value] = &[
            AdverseEventCausalityCode_Value::INVALID_UNINITIALIZED,
            AdverseEventCausalityCode_Value::CAUSALITY1,
            AdverseEventCausalityCode_Value::CAUSALITY2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AdverseEventCausalityCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AdverseEventCausalityCode_Value {
}

impl ::std::default::Default for AdverseEventCausalityCode_Value {
    fn default() -> Self {
        AdverseEventCausalityCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventCausalityCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdverseEventCausalityMethodCode {
    // message fields
    pub value: AdverseEventCausalityMethodCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AdverseEventCausalityMethodCode {
    pub fn new() -> AdverseEventCausalityMethodCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AdverseEventCausalityMethodCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AdverseEventCausalityMethodCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AdverseEventCausalityMethodCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AdverseEventCausalityMethodCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AdverseEventCausalityMethodCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AdverseEventCausalityMethodCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AdverseEventCausalityMethodCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdverseEventCausalityMethodCode {
        AdverseEventCausalityMethodCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AdverseEventCausalityMethodCode_Value>>(
                    "value",
                    |m: &AdverseEventCausalityMethodCode| { &m.value },
                    |m: &mut AdverseEventCausalityMethodCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AdverseEventCausalityMethodCode| { &m.id },
                    |m: &mut AdverseEventCausalityMethodCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AdverseEventCausalityMethodCode| { &m.extension },
                    |m: &mut AdverseEventCausalityMethodCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AdverseEventCausalityMethodCode>(
                    "AdverseEventCausalityMethodCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdverseEventCausalityMethodCode {
        static mut instance: ::protobuf::lazy::Lazy<AdverseEventCausalityMethodCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AdverseEventCausalityMethodCode,
        };
        unsafe {
            instance.get(AdverseEventCausalityMethodCode::new)
        }
    }
}

impl ::protobuf::Clear for AdverseEventCausalityMethodCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdverseEventCausalityMethodCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventCausalityMethodCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AdverseEventCausalityMethodCode_Value {
    INVALID_UNINITIALIZED = 0,
    METHOD1 = 1,
    METHOD2 = 2,
}

impl ::protobuf::ProtobufEnum for AdverseEventCausalityMethodCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AdverseEventCausalityMethodCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AdverseEventCausalityMethodCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AdverseEventCausalityMethodCode_Value::METHOD1),
            2 => ::std::option::Option::Some(AdverseEventCausalityMethodCode_Value::METHOD2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AdverseEventCausalityMethodCode_Value] = &[
            AdverseEventCausalityMethodCode_Value::INVALID_UNINITIALIZED,
            AdverseEventCausalityMethodCode_Value::METHOD1,
            AdverseEventCausalityMethodCode_Value::METHOD2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AdverseEventCausalityMethodCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AdverseEventCausalityMethodCode_Value {
}

impl ::std::default::Default for AdverseEventCausalityMethodCode_Value {
    fn default() -> Self {
        AdverseEventCausalityMethodCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventCausalityMethodCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdverseEventCausalityResultCode {
    // message fields
    pub value: AdverseEventCausalityResultCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AdverseEventCausalityResultCode {
    pub fn new() -> AdverseEventCausalityResultCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AdverseEventCausalityResultCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AdverseEventCausalityResultCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AdverseEventCausalityResultCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AdverseEventCausalityResultCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AdverseEventCausalityResultCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AdverseEventCausalityResultCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AdverseEventCausalityResultCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdverseEventCausalityResultCode {
        AdverseEventCausalityResultCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AdverseEventCausalityResultCode_Value>>(
                    "value",
                    |m: &AdverseEventCausalityResultCode| { &m.value },
                    |m: &mut AdverseEventCausalityResultCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AdverseEventCausalityResultCode| { &m.id },
                    |m: &mut AdverseEventCausalityResultCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AdverseEventCausalityResultCode| { &m.extension },
                    |m: &mut AdverseEventCausalityResultCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AdverseEventCausalityResultCode>(
                    "AdverseEventCausalityResultCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdverseEventCausalityResultCode {
        static mut instance: ::protobuf::lazy::Lazy<AdverseEventCausalityResultCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AdverseEventCausalityResultCode,
        };
        unsafe {
            instance.get(AdverseEventCausalityResultCode::new)
        }
    }
}

impl ::protobuf::Clear for AdverseEventCausalityResultCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdverseEventCausalityResultCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventCausalityResultCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AdverseEventCausalityResultCode_Value {
    INVALID_UNINITIALIZED = 0,
    RESULT1 = 1,
    RESULT2 = 2,
}

impl ::protobuf::ProtobufEnum for AdverseEventCausalityResultCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AdverseEventCausalityResultCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AdverseEventCausalityResultCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AdverseEventCausalityResultCode_Value::RESULT1),
            2 => ::std::option::Option::Some(AdverseEventCausalityResultCode_Value::RESULT2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AdverseEventCausalityResultCode_Value] = &[
            AdverseEventCausalityResultCode_Value::INVALID_UNINITIALIZED,
            AdverseEventCausalityResultCode_Value::RESULT1,
            AdverseEventCausalityResultCode_Value::RESULT2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AdverseEventCausalityResultCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AdverseEventCausalityResultCode_Value {
}

impl ::std::default::Default for AdverseEventCausalityResultCode_Value {
    fn default() -> Self {
        AdverseEventCausalityResultCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventCausalityResultCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdverseEventOutcomeCode {
    // message fields
    pub value: AdverseEventOutcomeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AdverseEventOutcomeCode {
    pub fn new() -> AdverseEventOutcomeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AdverseEventOutcomeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AdverseEventOutcomeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AdverseEventOutcomeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AdverseEventOutcomeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AdverseEventOutcomeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AdverseEventOutcomeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AdverseEventOutcomeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdverseEventOutcomeCode {
        AdverseEventOutcomeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AdverseEventOutcomeCode_Value>>(
                    "value",
                    |m: &AdverseEventOutcomeCode| { &m.value },
                    |m: &mut AdverseEventOutcomeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AdverseEventOutcomeCode| { &m.id },
                    |m: &mut AdverseEventOutcomeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AdverseEventOutcomeCode| { &m.extension },
                    |m: &mut AdverseEventOutcomeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AdverseEventOutcomeCode>(
                    "AdverseEventOutcomeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdverseEventOutcomeCode {
        static mut instance: ::protobuf::lazy::Lazy<AdverseEventOutcomeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AdverseEventOutcomeCode,
        };
        unsafe {
            instance.get(AdverseEventOutcomeCode::new)
        }
    }
}

impl ::protobuf::Clear for AdverseEventOutcomeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdverseEventOutcomeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventOutcomeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AdverseEventOutcomeCode_Value {
    INVALID_UNINITIALIZED = 0,
    RESOLVED = 1,
    RECOVERING = 2,
    ONGOING = 3,
    RESOLVEDWITHSEQUELAE = 4,
    FATAL = 5,
    UNKNOWN = 6,
}

impl ::protobuf::ProtobufEnum for AdverseEventOutcomeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AdverseEventOutcomeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AdverseEventOutcomeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AdverseEventOutcomeCode_Value::RESOLVED),
            2 => ::std::option::Option::Some(AdverseEventOutcomeCode_Value::RECOVERING),
            3 => ::std::option::Option::Some(AdverseEventOutcomeCode_Value::ONGOING),
            4 => ::std::option::Option::Some(AdverseEventOutcomeCode_Value::RESOLVEDWITHSEQUELAE),
            5 => ::std::option::Option::Some(AdverseEventOutcomeCode_Value::FATAL),
            6 => ::std::option::Option::Some(AdverseEventOutcomeCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AdverseEventOutcomeCode_Value] = &[
            AdverseEventOutcomeCode_Value::INVALID_UNINITIALIZED,
            AdverseEventOutcomeCode_Value::RESOLVED,
            AdverseEventOutcomeCode_Value::RECOVERING,
            AdverseEventOutcomeCode_Value::ONGOING,
            AdverseEventOutcomeCode_Value::RESOLVEDWITHSEQUELAE,
            AdverseEventOutcomeCode_Value::FATAL,
            AdverseEventOutcomeCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AdverseEventOutcomeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AdverseEventOutcomeCode_Value {
}

impl ::std::default::Default for AdverseEventOutcomeCode_Value {
    fn default() -> Self {
        AdverseEventOutcomeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventOutcomeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdverseEventSeriousnessCode {
    // message fields
    pub value: AdverseEventSeriousnessCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AdverseEventSeriousnessCode {
    pub fn new() -> AdverseEventSeriousnessCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AdverseEventSeriousnessCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AdverseEventSeriousnessCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AdverseEventSeriousnessCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AdverseEventSeriousnessCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AdverseEventSeriousnessCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AdverseEventSeriousnessCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AdverseEventSeriousnessCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdverseEventSeriousnessCode {
        AdverseEventSeriousnessCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AdverseEventSeriousnessCode_Value>>(
                    "value",
                    |m: &AdverseEventSeriousnessCode| { &m.value },
                    |m: &mut AdverseEventSeriousnessCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AdverseEventSeriousnessCode| { &m.id },
                    |m: &mut AdverseEventSeriousnessCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AdverseEventSeriousnessCode| { &m.extension },
                    |m: &mut AdverseEventSeriousnessCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AdverseEventSeriousnessCode>(
                    "AdverseEventSeriousnessCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdverseEventSeriousnessCode {
        static mut instance: ::protobuf::lazy::Lazy<AdverseEventSeriousnessCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AdverseEventSeriousnessCode,
        };
        unsafe {
            instance.get(AdverseEventSeriousnessCode::new)
        }
    }
}

impl ::protobuf::Clear for AdverseEventSeriousnessCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdverseEventSeriousnessCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventSeriousnessCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AdverseEventSeriousnessCode_Value {
    INVALID_UNINITIALIZED = 0,
    MILD = 1,
    MODERATE = 2,
    SEVERE = 3,
}

impl ::protobuf::ProtobufEnum for AdverseEventSeriousnessCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AdverseEventSeriousnessCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AdverseEventSeriousnessCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AdverseEventSeriousnessCode_Value::MILD),
            2 => ::std::option::Option::Some(AdverseEventSeriousnessCode_Value::MODERATE),
            3 => ::std::option::Option::Some(AdverseEventSeriousnessCode_Value::SEVERE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AdverseEventSeriousnessCode_Value] = &[
            AdverseEventSeriousnessCode_Value::INVALID_UNINITIALIZED,
            AdverseEventSeriousnessCode_Value::MILD,
            AdverseEventSeriousnessCode_Value::MODERATE,
            AdverseEventSeriousnessCode_Value::SEVERE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AdverseEventSeriousnessCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AdverseEventSeriousnessCode_Value {
}

impl ::std::default::Default for AdverseEventSeriousnessCode_Value {
    fn default() -> Self {
        AdverseEventSeriousnessCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AdverseEventSeriousnessCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllergyIntoleranceSubstanceExposureRiskCode {
    // message fields
    pub value: AllergyIntoleranceSubstanceExposureRiskCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AllergyIntoleranceSubstanceExposureRiskCode {
    pub fn new() -> AllergyIntoleranceSubstanceExposureRiskCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AllergyIntoleranceSubstanceExposureRiskCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AllergyIntoleranceSubstanceExposureRiskCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AllergyIntoleranceSubstanceExposureRiskCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AllergyIntoleranceSubstanceExposureRiskCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AllergyIntoleranceSubstanceExposureRiskCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AllergyIntoleranceSubstanceExposureRiskCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AllergyIntoleranceSubstanceExposureRiskCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllergyIntoleranceSubstanceExposureRiskCode {
        AllergyIntoleranceSubstanceExposureRiskCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AllergyIntoleranceSubstanceExposureRiskCode_Value>>(
                    "value",
                    |m: &AllergyIntoleranceSubstanceExposureRiskCode| { &m.value },
                    |m: &mut AllergyIntoleranceSubstanceExposureRiskCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AllergyIntoleranceSubstanceExposureRiskCode| { &m.id },
                    |m: &mut AllergyIntoleranceSubstanceExposureRiskCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AllergyIntoleranceSubstanceExposureRiskCode| { &m.extension },
                    |m: &mut AllergyIntoleranceSubstanceExposureRiskCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllergyIntoleranceSubstanceExposureRiskCode>(
                    "AllergyIntoleranceSubstanceExposureRiskCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AllergyIntoleranceSubstanceExposureRiskCode {
        static mut instance: ::protobuf::lazy::Lazy<AllergyIntoleranceSubstanceExposureRiskCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllergyIntoleranceSubstanceExposureRiskCode,
        };
        unsafe {
            instance.get(AllergyIntoleranceSubstanceExposureRiskCode::new)
        }
    }
}

impl ::protobuf::Clear for AllergyIntoleranceSubstanceExposureRiskCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllergyIntoleranceSubstanceExposureRiskCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceSubstanceExposureRiskCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AllergyIntoleranceSubstanceExposureRiskCode_Value {
    INVALID_UNINITIALIZED = 0,
    KNOWN_REACTION_RISK = 1,
    NO_KNOWN_REACTION_RISK = 2,
}

impl ::protobuf::ProtobufEnum for AllergyIntoleranceSubstanceExposureRiskCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AllergyIntoleranceSubstanceExposureRiskCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AllergyIntoleranceSubstanceExposureRiskCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AllergyIntoleranceSubstanceExposureRiskCode_Value::KNOWN_REACTION_RISK),
            2 => ::std::option::Option::Some(AllergyIntoleranceSubstanceExposureRiskCode_Value::NO_KNOWN_REACTION_RISK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AllergyIntoleranceSubstanceExposureRiskCode_Value] = &[
            AllergyIntoleranceSubstanceExposureRiskCode_Value::INVALID_UNINITIALIZED,
            AllergyIntoleranceSubstanceExposureRiskCode_Value::KNOWN_REACTION_RISK,
            AllergyIntoleranceSubstanceExposureRiskCode_Value::NO_KNOWN_REACTION_RISK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AllergyIntoleranceSubstanceExposureRiskCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AllergyIntoleranceSubstanceExposureRiskCode_Value {
}

impl ::std::default::Default for AllergyIntoleranceSubstanceExposureRiskCode_Value {
    fn default() -> Self {
        AllergyIntoleranceSubstanceExposureRiskCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceSubstanceExposureRiskCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllergyIntoleranceClinicalStatusCode {
    // message fields
    pub value: AllergyIntoleranceClinicalStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AllergyIntoleranceClinicalStatusCode {
    pub fn new() -> AllergyIntoleranceClinicalStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AllergyIntoleranceClinicalStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AllergyIntoleranceClinicalStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AllergyIntoleranceClinicalStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AllergyIntoleranceClinicalStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AllergyIntoleranceClinicalStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AllergyIntoleranceClinicalStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AllergyIntoleranceClinicalStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllergyIntoleranceClinicalStatusCode {
        AllergyIntoleranceClinicalStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AllergyIntoleranceClinicalStatusCode_Value>>(
                    "value",
                    |m: &AllergyIntoleranceClinicalStatusCode| { &m.value },
                    |m: &mut AllergyIntoleranceClinicalStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AllergyIntoleranceClinicalStatusCode| { &m.id },
                    |m: &mut AllergyIntoleranceClinicalStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AllergyIntoleranceClinicalStatusCode| { &m.extension },
                    |m: &mut AllergyIntoleranceClinicalStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllergyIntoleranceClinicalStatusCode>(
                    "AllergyIntoleranceClinicalStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AllergyIntoleranceClinicalStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<AllergyIntoleranceClinicalStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllergyIntoleranceClinicalStatusCode,
        };
        unsafe {
            instance.get(AllergyIntoleranceClinicalStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for AllergyIntoleranceClinicalStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllergyIntoleranceClinicalStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceClinicalStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AllergyIntoleranceClinicalStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    INACTIVE = 2,
    RESOLVED = 3,
}

impl ::protobuf::ProtobufEnum for AllergyIntoleranceClinicalStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AllergyIntoleranceClinicalStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AllergyIntoleranceClinicalStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AllergyIntoleranceClinicalStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(AllergyIntoleranceClinicalStatusCode_Value::INACTIVE),
            3 => ::std::option::Option::Some(AllergyIntoleranceClinicalStatusCode_Value::RESOLVED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AllergyIntoleranceClinicalStatusCode_Value] = &[
            AllergyIntoleranceClinicalStatusCode_Value::INVALID_UNINITIALIZED,
            AllergyIntoleranceClinicalStatusCode_Value::ACTIVE,
            AllergyIntoleranceClinicalStatusCode_Value::INACTIVE,
            AllergyIntoleranceClinicalStatusCode_Value::RESOLVED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AllergyIntoleranceClinicalStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AllergyIntoleranceClinicalStatusCode_Value {
}

impl ::std::default::Default for AllergyIntoleranceClinicalStatusCode_Value {
    fn default() -> Self {
        AllergyIntoleranceClinicalStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceClinicalStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllergyIntoleranceCategoryCode {
    // message fields
    pub value: AllergyIntoleranceCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AllergyIntoleranceCategoryCode {
    pub fn new() -> AllergyIntoleranceCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AllergyIntoleranceCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AllergyIntoleranceCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AllergyIntoleranceCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AllergyIntoleranceCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AllergyIntoleranceCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AllergyIntoleranceCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AllergyIntoleranceCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllergyIntoleranceCategoryCode {
        AllergyIntoleranceCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AllergyIntoleranceCategoryCode_Value>>(
                    "value",
                    |m: &AllergyIntoleranceCategoryCode| { &m.value },
                    |m: &mut AllergyIntoleranceCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AllergyIntoleranceCategoryCode| { &m.id },
                    |m: &mut AllergyIntoleranceCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AllergyIntoleranceCategoryCode| { &m.extension },
                    |m: &mut AllergyIntoleranceCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllergyIntoleranceCategoryCode>(
                    "AllergyIntoleranceCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AllergyIntoleranceCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<AllergyIntoleranceCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllergyIntoleranceCategoryCode,
        };
        unsafe {
            instance.get(AllergyIntoleranceCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for AllergyIntoleranceCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllergyIntoleranceCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AllergyIntoleranceCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    FOOD = 1,
    MEDICATION = 2,
    ENVIRONMENT = 3,
    BIOLOGIC = 4,
}

impl ::protobuf::ProtobufEnum for AllergyIntoleranceCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AllergyIntoleranceCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AllergyIntoleranceCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AllergyIntoleranceCategoryCode_Value::FOOD),
            2 => ::std::option::Option::Some(AllergyIntoleranceCategoryCode_Value::MEDICATION),
            3 => ::std::option::Option::Some(AllergyIntoleranceCategoryCode_Value::ENVIRONMENT),
            4 => ::std::option::Option::Some(AllergyIntoleranceCategoryCode_Value::BIOLOGIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AllergyIntoleranceCategoryCode_Value] = &[
            AllergyIntoleranceCategoryCode_Value::INVALID_UNINITIALIZED,
            AllergyIntoleranceCategoryCode_Value::FOOD,
            AllergyIntoleranceCategoryCode_Value::MEDICATION,
            AllergyIntoleranceCategoryCode_Value::ENVIRONMENT,
            AllergyIntoleranceCategoryCode_Value::BIOLOGIC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AllergyIntoleranceCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AllergyIntoleranceCategoryCode_Value {
}

impl ::std::default::Default for AllergyIntoleranceCategoryCode_Value {
    fn default() -> Self {
        AllergyIntoleranceCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllergyIntoleranceCriticalityCode {
    // message fields
    pub value: AllergyIntoleranceCriticalityCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AllergyIntoleranceCriticalityCode {
    pub fn new() -> AllergyIntoleranceCriticalityCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AllergyIntoleranceCriticalityCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AllergyIntoleranceCriticalityCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AllergyIntoleranceCriticalityCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AllergyIntoleranceCriticalityCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AllergyIntoleranceCriticalityCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AllergyIntoleranceCriticalityCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AllergyIntoleranceCriticalityCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllergyIntoleranceCriticalityCode {
        AllergyIntoleranceCriticalityCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AllergyIntoleranceCriticalityCode_Value>>(
                    "value",
                    |m: &AllergyIntoleranceCriticalityCode| { &m.value },
                    |m: &mut AllergyIntoleranceCriticalityCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AllergyIntoleranceCriticalityCode| { &m.id },
                    |m: &mut AllergyIntoleranceCriticalityCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AllergyIntoleranceCriticalityCode| { &m.extension },
                    |m: &mut AllergyIntoleranceCriticalityCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllergyIntoleranceCriticalityCode>(
                    "AllergyIntoleranceCriticalityCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AllergyIntoleranceCriticalityCode {
        static mut instance: ::protobuf::lazy::Lazy<AllergyIntoleranceCriticalityCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllergyIntoleranceCriticalityCode,
        };
        unsafe {
            instance.get(AllergyIntoleranceCriticalityCode::new)
        }
    }
}

impl ::protobuf::Clear for AllergyIntoleranceCriticalityCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllergyIntoleranceCriticalityCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceCriticalityCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AllergyIntoleranceCriticalityCode_Value {
    INVALID_UNINITIALIZED = 0,
    LOW = 1,
    HIGH = 2,
    UNABLE_TO_ASSESS = 3,
}

impl ::protobuf::ProtobufEnum for AllergyIntoleranceCriticalityCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AllergyIntoleranceCriticalityCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AllergyIntoleranceCriticalityCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AllergyIntoleranceCriticalityCode_Value::LOW),
            2 => ::std::option::Option::Some(AllergyIntoleranceCriticalityCode_Value::HIGH),
            3 => ::std::option::Option::Some(AllergyIntoleranceCriticalityCode_Value::UNABLE_TO_ASSESS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AllergyIntoleranceCriticalityCode_Value] = &[
            AllergyIntoleranceCriticalityCode_Value::INVALID_UNINITIALIZED,
            AllergyIntoleranceCriticalityCode_Value::LOW,
            AllergyIntoleranceCriticalityCode_Value::HIGH,
            AllergyIntoleranceCriticalityCode_Value::UNABLE_TO_ASSESS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AllergyIntoleranceCriticalityCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AllergyIntoleranceCriticalityCode_Value {
}

impl ::std::default::Default for AllergyIntoleranceCriticalityCode_Value {
    fn default() -> Self {
        AllergyIntoleranceCriticalityCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceCriticalityCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllergyIntoleranceTypeCode {
    // message fields
    pub value: AllergyIntoleranceTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AllergyIntoleranceTypeCode {
    pub fn new() -> AllergyIntoleranceTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AllergyIntoleranceTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AllergyIntoleranceTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AllergyIntoleranceTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AllergyIntoleranceTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AllergyIntoleranceTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AllergyIntoleranceTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AllergyIntoleranceTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllergyIntoleranceTypeCode {
        AllergyIntoleranceTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AllergyIntoleranceTypeCode_Value>>(
                    "value",
                    |m: &AllergyIntoleranceTypeCode| { &m.value },
                    |m: &mut AllergyIntoleranceTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AllergyIntoleranceTypeCode| { &m.id },
                    |m: &mut AllergyIntoleranceTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AllergyIntoleranceTypeCode| { &m.extension },
                    |m: &mut AllergyIntoleranceTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllergyIntoleranceTypeCode>(
                    "AllergyIntoleranceTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AllergyIntoleranceTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<AllergyIntoleranceTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllergyIntoleranceTypeCode,
        };
        unsafe {
            instance.get(AllergyIntoleranceTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for AllergyIntoleranceTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllergyIntoleranceTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AllergyIntoleranceTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    ALLERGY = 1,
    INTOLERANCE = 2,
}

impl ::protobuf::ProtobufEnum for AllergyIntoleranceTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AllergyIntoleranceTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AllergyIntoleranceTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AllergyIntoleranceTypeCode_Value::ALLERGY),
            2 => ::std::option::Option::Some(AllergyIntoleranceTypeCode_Value::INTOLERANCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AllergyIntoleranceTypeCode_Value] = &[
            AllergyIntoleranceTypeCode_Value::INVALID_UNINITIALIZED,
            AllergyIntoleranceTypeCode_Value::ALLERGY,
            AllergyIntoleranceTypeCode_Value::INTOLERANCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AllergyIntoleranceTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AllergyIntoleranceTypeCode_Value {
}

impl ::std::default::Default for AllergyIntoleranceTypeCode_Value {
    fn default() -> Self {
        AllergyIntoleranceTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllergyIntoleranceVerificationStatusCode {
    // message fields
    pub value: AllergyIntoleranceVerificationStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AllergyIntoleranceVerificationStatusCode {
    pub fn new() -> AllergyIntoleranceVerificationStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AllergyIntoleranceVerificationStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AllergyIntoleranceVerificationStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AllergyIntoleranceVerificationStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AllergyIntoleranceVerificationStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AllergyIntoleranceVerificationStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AllergyIntoleranceVerificationStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AllergyIntoleranceVerificationStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllergyIntoleranceVerificationStatusCode {
        AllergyIntoleranceVerificationStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AllergyIntoleranceVerificationStatusCode_Value>>(
                    "value",
                    |m: &AllergyIntoleranceVerificationStatusCode| { &m.value },
                    |m: &mut AllergyIntoleranceVerificationStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AllergyIntoleranceVerificationStatusCode| { &m.id },
                    |m: &mut AllergyIntoleranceVerificationStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AllergyIntoleranceVerificationStatusCode| { &m.extension },
                    |m: &mut AllergyIntoleranceVerificationStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllergyIntoleranceVerificationStatusCode>(
                    "AllergyIntoleranceVerificationStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AllergyIntoleranceVerificationStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<AllergyIntoleranceVerificationStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllergyIntoleranceVerificationStatusCode,
        };
        unsafe {
            instance.get(AllergyIntoleranceVerificationStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for AllergyIntoleranceVerificationStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllergyIntoleranceVerificationStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceVerificationStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AllergyIntoleranceVerificationStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    UNCONFIRMED = 1,
    CONFIRMED = 2,
    REFUTED = 3,
    ENTERED_IN_ERROR = 4,
}

impl ::protobuf::ProtobufEnum for AllergyIntoleranceVerificationStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AllergyIntoleranceVerificationStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AllergyIntoleranceVerificationStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AllergyIntoleranceVerificationStatusCode_Value::UNCONFIRMED),
            2 => ::std::option::Option::Some(AllergyIntoleranceVerificationStatusCode_Value::CONFIRMED),
            3 => ::std::option::Option::Some(AllergyIntoleranceVerificationStatusCode_Value::REFUTED),
            4 => ::std::option::Option::Some(AllergyIntoleranceVerificationStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AllergyIntoleranceVerificationStatusCode_Value] = &[
            AllergyIntoleranceVerificationStatusCode_Value::INVALID_UNINITIALIZED,
            AllergyIntoleranceVerificationStatusCode_Value::UNCONFIRMED,
            AllergyIntoleranceVerificationStatusCode_Value::CONFIRMED,
            AllergyIntoleranceVerificationStatusCode_Value::REFUTED,
            AllergyIntoleranceVerificationStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AllergyIntoleranceVerificationStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AllergyIntoleranceVerificationStatusCode_Value {
}

impl ::std::default::Default for AllergyIntoleranceVerificationStatusCode_Value {
    fn default() -> Self {
        AllergyIntoleranceVerificationStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceVerificationStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GenderStatusCode {
    // message fields
    pub value: GenderStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GenderStatusCode {
    pub fn new() -> GenderStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GenderStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GenderStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GenderStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GenderStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GenderStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GenderStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GenderStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GenderStatusCode {
        GenderStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GenderStatusCode_Value>>(
                    "value",
                    |m: &GenderStatusCode| { &m.value },
                    |m: &mut GenderStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GenderStatusCode| { &m.id },
                    |m: &mut GenderStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GenderStatusCode| { &m.extension },
                    |m: &mut GenderStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GenderStatusCode>(
                    "GenderStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GenderStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<GenderStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GenderStatusCode,
        };
        unsafe {
            instance.get(GenderStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for GenderStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GenderStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenderStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GenderStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    NEUTERED = 1,
    INTACT = 2,
    UNKNOWN = 3,
}

impl ::protobuf::ProtobufEnum for GenderStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GenderStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GenderStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GenderStatusCode_Value::NEUTERED),
            2 => ::std::option::Option::Some(GenderStatusCode_Value::INTACT),
            3 => ::std::option::Option::Some(GenderStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GenderStatusCode_Value] = &[
            GenderStatusCode_Value::INVALID_UNINITIALIZED,
            GenderStatusCode_Value::NEUTERED,
            GenderStatusCode_Value::INTACT,
            GenderStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GenderStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GenderStatusCode_Value {
}

impl ::std::default::Default for GenderStatusCode_Value {
    fn default() -> Self {
        GenderStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GenderStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppointmentStatusCode {
    // message fields
    pub value: AppointmentStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AppointmentStatusCode {
    pub fn new() -> AppointmentStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AppointmentStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AppointmentStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AppointmentStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AppointmentStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AppointmentStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AppointmentStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AppointmentStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppointmentStatusCode {
        AppointmentStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AppointmentStatusCode_Value>>(
                    "value",
                    |m: &AppointmentStatusCode| { &m.value },
                    |m: &mut AppointmentStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AppointmentStatusCode| { &m.id },
                    |m: &mut AppointmentStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AppointmentStatusCode| { &m.extension },
                    |m: &mut AppointmentStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppointmentStatusCode>(
                    "AppointmentStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AppointmentStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<AppointmentStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AppointmentStatusCode,
        };
        unsafe {
            instance.get(AppointmentStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for AppointmentStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppointmentStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppointmentStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AppointmentStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROPOSED = 1,
    PENDING = 2,
    BOOKED = 3,
    ARRIVED = 4,
    FULFILLED = 5,
    CANCELLED = 6,
    NOSHOW = 7,
    ENTERED_IN_ERROR = 8,
}

impl ::protobuf::ProtobufEnum for AppointmentStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AppointmentStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AppointmentStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AppointmentStatusCode_Value::PROPOSED),
            2 => ::std::option::Option::Some(AppointmentStatusCode_Value::PENDING),
            3 => ::std::option::Option::Some(AppointmentStatusCode_Value::BOOKED),
            4 => ::std::option::Option::Some(AppointmentStatusCode_Value::ARRIVED),
            5 => ::std::option::Option::Some(AppointmentStatusCode_Value::FULFILLED),
            6 => ::std::option::Option::Some(AppointmentStatusCode_Value::CANCELLED),
            7 => ::std::option::Option::Some(AppointmentStatusCode_Value::NOSHOW),
            8 => ::std::option::Option::Some(AppointmentStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AppointmentStatusCode_Value] = &[
            AppointmentStatusCode_Value::INVALID_UNINITIALIZED,
            AppointmentStatusCode_Value::PROPOSED,
            AppointmentStatusCode_Value::PENDING,
            AppointmentStatusCode_Value::BOOKED,
            AppointmentStatusCode_Value::ARRIVED,
            AppointmentStatusCode_Value::FULFILLED,
            AppointmentStatusCode_Value::CANCELLED,
            AppointmentStatusCode_Value::NOSHOW,
            AppointmentStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AppointmentStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AppointmentStatusCode_Value {
}

impl ::std::default::Default for AppointmentStatusCode_Value {
    fn default() -> Self {
        AppointmentStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AppointmentStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AssertionDirectionTypeCode {
    // message fields
    pub value: AssertionDirectionTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AssertionDirectionTypeCode {
    pub fn new() -> AssertionDirectionTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AssertionDirectionTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AssertionDirectionTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AssertionDirectionTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AssertionDirectionTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AssertionDirectionTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AssertionDirectionTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AssertionDirectionTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssertionDirectionTypeCode {
        AssertionDirectionTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AssertionDirectionTypeCode_Value>>(
                    "value",
                    |m: &AssertionDirectionTypeCode| { &m.value },
                    |m: &mut AssertionDirectionTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AssertionDirectionTypeCode| { &m.id },
                    |m: &mut AssertionDirectionTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AssertionDirectionTypeCode| { &m.extension },
                    |m: &mut AssertionDirectionTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AssertionDirectionTypeCode>(
                    "AssertionDirectionTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AssertionDirectionTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<AssertionDirectionTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AssertionDirectionTypeCode,
        };
        unsafe {
            instance.get(AssertionDirectionTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for AssertionDirectionTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssertionDirectionTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssertionDirectionTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AssertionDirectionTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    RESPONSE = 1,
    REQUEST = 2,
}

impl ::protobuf::ProtobufEnum for AssertionDirectionTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AssertionDirectionTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AssertionDirectionTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AssertionDirectionTypeCode_Value::RESPONSE),
            2 => ::std::option::Option::Some(AssertionDirectionTypeCode_Value::REQUEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AssertionDirectionTypeCode_Value] = &[
            AssertionDirectionTypeCode_Value::INVALID_UNINITIALIZED,
            AssertionDirectionTypeCode_Value::RESPONSE,
            AssertionDirectionTypeCode_Value::REQUEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AssertionDirectionTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AssertionDirectionTypeCode_Value {
}

impl ::std::default::Default for AssertionDirectionTypeCode_Value {
    fn default() -> Self {
        AssertionDirectionTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AssertionDirectionTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AssertionOperatorTypeCode {
    // message fields
    pub value: AssertionOperatorTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AssertionOperatorTypeCode {
    pub fn new() -> AssertionOperatorTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AssertionOperatorTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AssertionOperatorTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AssertionOperatorTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AssertionOperatorTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AssertionOperatorTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AssertionOperatorTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AssertionOperatorTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssertionOperatorTypeCode {
        AssertionOperatorTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AssertionOperatorTypeCode_Value>>(
                    "value",
                    |m: &AssertionOperatorTypeCode| { &m.value },
                    |m: &mut AssertionOperatorTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AssertionOperatorTypeCode| { &m.id },
                    |m: &mut AssertionOperatorTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AssertionOperatorTypeCode| { &m.extension },
                    |m: &mut AssertionOperatorTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AssertionOperatorTypeCode>(
                    "AssertionOperatorTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AssertionOperatorTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<AssertionOperatorTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AssertionOperatorTypeCode,
        };
        unsafe {
            instance.get(AssertionOperatorTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for AssertionOperatorTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssertionOperatorTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssertionOperatorTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AssertionOperatorTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    EQUALS = 1,
    NOTEQUALS = 2,
    IN = 3,
    NOTIN = 4,
    GREATERTHAN = 5,
    LESSTHAN = 6,
    EMPTY = 7,
    NOTEMPTY = 8,
    CONTAINS = 9,
    NOTCONTAINS = 10,
    EVAL = 11,
}

impl ::protobuf::ProtobufEnum for AssertionOperatorTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AssertionOperatorTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::EQUALS),
            2 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::NOTEQUALS),
            3 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::IN),
            4 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::NOTIN),
            5 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::GREATERTHAN),
            6 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::LESSTHAN),
            7 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::EMPTY),
            8 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::NOTEMPTY),
            9 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::CONTAINS),
            10 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::NOTCONTAINS),
            11 => ::std::option::Option::Some(AssertionOperatorTypeCode_Value::EVAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AssertionOperatorTypeCode_Value] = &[
            AssertionOperatorTypeCode_Value::INVALID_UNINITIALIZED,
            AssertionOperatorTypeCode_Value::EQUALS,
            AssertionOperatorTypeCode_Value::NOTEQUALS,
            AssertionOperatorTypeCode_Value::IN,
            AssertionOperatorTypeCode_Value::NOTIN,
            AssertionOperatorTypeCode_Value::GREATERTHAN,
            AssertionOperatorTypeCode_Value::LESSTHAN,
            AssertionOperatorTypeCode_Value::EMPTY,
            AssertionOperatorTypeCode_Value::NOTEMPTY,
            AssertionOperatorTypeCode_Value::CONTAINS,
            AssertionOperatorTypeCode_Value::NOTCONTAINS,
            AssertionOperatorTypeCode_Value::EVAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AssertionOperatorTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AssertionOperatorTypeCode_Value {
}

impl ::std::default::Default for AssertionOperatorTypeCode_Value {
    fn default() -> Self {
        AssertionOperatorTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AssertionOperatorTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AssertionResponseTypesCode {
    // message fields
    pub value: AssertionResponseTypesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AssertionResponseTypesCode {
    pub fn new() -> AssertionResponseTypesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AssertionResponseTypesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AssertionResponseTypesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AssertionResponseTypesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AssertionResponseTypesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AssertionResponseTypesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AssertionResponseTypesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AssertionResponseTypesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AssertionResponseTypesCode {
        AssertionResponseTypesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AssertionResponseTypesCode_Value>>(
                    "value",
                    |m: &AssertionResponseTypesCode| { &m.value },
                    |m: &mut AssertionResponseTypesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AssertionResponseTypesCode| { &m.id },
                    |m: &mut AssertionResponseTypesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AssertionResponseTypesCode| { &m.extension },
                    |m: &mut AssertionResponseTypesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AssertionResponseTypesCode>(
                    "AssertionResponseTypesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AssertionResponseTypesCode {
        static mut instance: ::protobuf::lazy::Lazy<AssertionResponseTypesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AssertionResponseTypesCode,
        };
        unsafe {
            instance.get(AssertionResponseTypesCode::new)
        }
    }
}

impl ::protobuf::Clear for AssertionResponseTypesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AssertionResponseTypesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssertionResponseTypesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AssertionResponseTypesCode_Value {
    INVALID_UNINITIALIZED = 0,
    OKAY = 1,
    CREATED = 2,
    NOCONTENT = 3,
    NOTMODIFIED = 4,
    BAD = 5,
    FORBIDDEN = 6,
    NOTFOUND = 7,
    METHODNOTALLOWED = 8,
    CONFLICT = 9,
    GONE = 10,
    PRECONDITIONFAILED = 11,
    UNPROCESSABLE = 12,
}

impl ::protobuf::ProtobufEnum for AssertionResponseTypesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AssertionResponseTypesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::OKAY),
            2 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::CREATED),
            3 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::NOCONTENT),
            4 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::NOTMODIFIED),
            5 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::BAD),
            6 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::FORBIDDEN),
            7 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::NOTFOUND),
            8 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::METHODNOTALLOWED),
            9 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::CONFLICT),
            10 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::GONE),
            11 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::PRECONDITIONFAILED),
            12 => ::std::option::Option::Some(AssertionResponseTypesCode_Value::UNPROCESSABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AssertionResponseTypesCode_Value] = &[
            AssertionResponseTypesCode_Value::INVALID_UNINITIALIZED,
            AssertionResponseTypesCode_Value::OKAY,
            AssertionResponseTypesCode_Value::CREATED,
            AssertionResponseTypesCode_Value::NOCONTENT,
            AssertionResponseTypesCode_Value::NOTMODIFIED,
            AssertionResponseTypesCode_Value::BAD,
            AssertionResponseTypesCode_Value::FORBIDDEN,
            AssertionResponseTypesCode_Value::NOTFOUND,
            AssertionResponseTypesCode_Value::METHODNOTALLOWED,
            AssertionResponseTypesCode_Value::CONFLICT,
            AssertionResponseTypesCode_Value::GONE,
            AssertionResponseTypesCode_Value::PRECONDITIONFAILED,
            AssertionResponseTypesCode_Value::UNPROCESSABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AssertionResponseTypesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AssertionResponseTypesCode_Value {
}

impl ::std::default::Default for AssertionResponseTypesCode_Value {
    fn default() -> Self {
        AssertionResponseTypesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AssertionResponseTypesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuditEventActionCode {
    // message fields
    pub value: AuditEventActionCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AuditEventActionCode {
    pub fn new() -> AuditEventActionCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AuditEventActionCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AuditEventActionCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AuditEventActionCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AuditEventActionCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AuditEventActionCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AuditEventActionCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AuditEventActionCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuditEventActionCode {
        AuditEventActionCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AuditEventActionCode_Value>>(
                    "value",
                    |m: &AuditEventActionCode| { &m.value },
                    |m: &mut AuditEventActionCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AuditEventActionCode| { &m.id },
                    |m: &mut AuditEventActionCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AuditEventActionCode| { &m.extension },
                    |m: &mut AuditEventActionCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuditEventActionCode>(
                    "AuditEventActionCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuditEventActionCode {
        static mut instance: ::protobuf::lazy::Lazy<AuditEventActionCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuditEventActionCode,
        };
        unsafe {
            instance.get(AuditEventActionCode::new)
        }
    }
}

impl ::protobuf::Clear for AuditEventActionCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuditEventActionCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditEventActionCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuditEventActionCode_Value {
    INVALID_UNINITIALIZED = 0,
    C = 1,
    R = 2,
    U = 3,
    D = 4,
    E = 5,
}

impl ::protobuf::ProtobufEnum for AuditEventActionCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuditEventActionCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AuditEventActionCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AuditEventActionCode_Value::C),
            2 => ::std::option::Option::Some(AuditEventActionCode_Value::R),
            3 => ::std::option::Option::Some(AuditEventActionCode_Value::U),
            4 => ::std::option::Option::Some(AuditEventActionCode_Value::D),
            5 => ::std::option::Option::Some(AuditEventActionCode_Value::E),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuditEventActionCode_Value] = &[
            AuditEventActionCode_Value::INVALID_UNINITIALIZED,
            AuditEventActionCode_Value::C,
            AuditEventActionCode_Value::R,
            AuditEventActionCode_Value::U,
            AuditEventActionCode_Value::D,
            AuditEventActionCode_Value::E,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AuditEventActionCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AuditEventActionCode_Value {
}

impl ::std::default::Default for AuditEventActionCode_Value {
    fn default() -> Self {
        AuditEventActionCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditEventActionCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuditEventOutcomeCode {
    // message fields
    pub value: AuditEventOutcomeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AuditEventOutcomeCode {
    pub fn new() -> AuditEventOutcomeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AuditEventOutcomeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AuditEventOutcomeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AuditEventOutcomeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AuditEventOutcomeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AuditEventOutcomeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AuditEventOutcomeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AuditEventOutcomeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuditEventOutcomeCode {
        AuditEventOutcomeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AuditEventOutcomeCode_Value>>(
                    "value",
                    |m: &AuditEventOutcomeCode| { &m.value },
                    |m: &mut AuditEventOutcomeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AuditEventOutcomeCode| { &m.id },
                    |m: &mut AuditEventOutcomeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AuditEventOutcomeCode| { &m.extension },
                    |m: &mut AuditEventOutcomeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuditEventOutcomeCode>(
                    "AuditEventOutcomeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuditEventOutcomeCode {
        static mut instance: ::protobuf::lazy::Lazy<AuditEventOutcomeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuditEventOutcomeCode,
        };
        unsafe {
            instance.get(AuditEventOutcomeCode::new)
        }
    }
}

impl ::protobuf::Clear for AuditEventOutcomeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuditEventOutcomeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditEventOutcomeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuditEventOutcomeCode_Value {
    INVALID_UNINITIALIZED = 0,
    SUCCESS = 1,
    MINOR_FAILURE = 2,
    SERIOUS_FAILURE = 3,
    MAJOR_FAILURE = 4,
}

impl ::protobuf::ProtobufEnum for AuditEventOutcomeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuditEventOutcomeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AuditEventOutcomeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AuditEventOutcomeCode_Value::SUCCESS),
            2 => ::std::option::Option::Some(AuditEventOutcomeCode_Value::MINOR_FAILURE),
            3 => ::std::option::Option::Some(AuditEventOutcomeCode_Value::SERIOUS_FAILURE),
            4 => ::std::option::Option::Some(AuditEventOutcomeCode_Value::MAJOR_FAILURE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuditEventOutcomeCode_Value] = &[
            AuditEventOutcomeCode_Value::INVALID_UNINITIALIZED,
            AuditEventOutcomeCode_Value::SUCCESS,
            AuditEventOutcomeCode_Value::MINOR_FAILURE,
            AuditEventOutcomeCode_Value::SERIOUS_FAILURE,
            AuditEventOutcomeCode_Value::MAJOR_FAILURE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AuditEventOutcomeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AuditEventOutcomeCode_Value {
}

impl ::std::default::Default for AuditEventOutcomeCode_Value {
    fn default() -> Self {
        AuditEventOutcomeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditEventOutcomeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BasicResourceTypesCode {
    // message fields
    pub value: BasicResourceTypesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BasicResourceTypesCode {
    pub fn new() -> BasicResourceTypesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.BasicResourceTypesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = BasicResourceTypesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: BasicResourceTypesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> BasicResourceTypesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for BasicResourceTypesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != BasicResourceTypesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != BasicResourceTypesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BasicResourceTypesCode {
        BasicResourceTypesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BasicResourceTypesCode_Value>>(
                    "value",
                    |m: &BasicResourceTypesCode| { &m.value },
                    |m: &mut BasicResourceTypesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &BasicResourceTypesCode| { &m.id },
                    |m: &mut BasicResourceTypesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &BasicResourceTypesCode| { &m.extension },
                    |m: &mut BasicResourceTypesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BasicResourceTypesCode>(
                    "BasicResourceTypesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BasicResourceTypesCode {
        static mut instance: ::protobuf::lazy::Lazy<BasicResourceTypesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BasicResourceTypesCode,
        };
        unsafe {
            instance.get(BasicResourceTypesCode::new)
        }
    }
}

impl ::protobuf::Clear for BasicResourceTypesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BasicResourceTypesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicResourceTypesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BasicResourceTypesCode_Value {
    INVALID_UNINITIALIZED = 0,
    CONSENT = 1,
    REFERRAL = 2,
    ADVEVENT = 3,
    APTMTREQ = 4,
    TRANSFER = 5,
    DIET = 6,
    ADMINACT = 7,
    EXPOSURE = 8,
    INVESTIGATION = 9,
    ACCOUNT = 10,
    INVOICE = 11,
    ADJUDICAT = 12,
    PREDETREQ = 13,
    PREDETERMINE = 14,
    STUDY = 15,
    PROTOCOL = 16,
}

impl ::protobuf::ProtobufEnum for BasicResourceTypesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BasicResourceTypesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(BasicResourceTypesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(BasicResourceTypesCode_Value::CONSENT),
            2 => ::std::option::Option::Some(BasicResourceTypesCode_Value::REFERRAL),
            3 => ::std::option::Option::Some(BasicResourceTypesCode_Value::ADVEVENT),
            4 => ::std::option::Option::Some(BasicResourceTypesCode_Value::APTMTREQ),
            5 => ::std::option::Option::Some(BasicResourceTypesCode_Value::TRANSFER),
            6 => ::std::option::Option::Some(BasicResourceTypesCode_Value::DIET),
            7 => ::std::option::Option::Some(BasicResourceTypesCode_Value::ADMINACT),
            8 => ::std::option::Option::Some(BasicResourceTypesCode_Value::EXPOSURE),
            9 => ::std::option::Option::Some(BasicResourceTypesCode_Value::INVESTIGATION),
            10 => ::std::option::Option::Some(BasicResourceTypesCode_Value::ACCOUNT),
            11 => ::std::option::Option::Some(BasicResourceTypesCode_Value::INVOICE),
            12 => ::std::option::Option::Some(BasicResourceTypesCode_Value::ADJUDICAT),
            13 => ::std::option::Option::Some(BasicResourceTypesCode_Value::PREDETREQ),
            14 => ::std::option::Option::Some(BasicResourceTypesCode_Value::PREDETERMINE),
            15 => ::std::option::Option::Some(BasicResourceTypesCode_Value::STUDY),
            16 => ::std::option::Option::Some(BasicResourceTypesCode_Value::PROTOCOL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BasicResourceTypesCode_Value] = &[
            BasicResourceTypesCode_Value::INVALID_UNINITIALIZED,
            BasicResourceTypesCode_Value::CONSENT,
            BasicResourceTypesCode_Value::REFERRAL,
            BasicResourceTypesCode_Value::ADVEVENT,
            BasicResourceTypesCode_Value::APTMTREQ,
            BasicResourceTypesCode_Value::TRANSFER,
            BasicResourceTypesCode_Value::DIET,
            BasicResourceTypesCode_Value::ADMINACT,
            BasicResourceTypesCode_Value::EXPOSURE,
            BasicResourceTypesCode_Value::INVESTIGATION,
            BasicResourceTypesCode_Value::ACCOUNT,
            BasicResourceTypesCode_Value::INVOICE,
            BasicResourceTypesCode_Value::ADJUDICAT,
            BasicResourceTypesCode_Value::PREDETREQ,
            BasicResourceTypesCode_Value::PREDETERMINE,
            BasicResourceTypesCode_Value::STUDY,
            BasicResourceTypesCode_Value::PROTOCOL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BasicResourceTypesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BasicResourceTypesCode_Value {
}

impl ::std::default::Default for BasicResourceTypesCode_Value {
    fn default() -> Self {
        BasicResourceTypesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for BasicResourceTypesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BundleTypeCode {
    // message fields
    pub value: BundleTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BundleTypeCode {
    pub fn new() -> BundleTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.BundleTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = BundleTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: BundleTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> BundleTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for BundleTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != BundleTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != BundleTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BundleTypeCode {
        BundleTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BundleTypeCode_Value>>(
                    "value",
                    |m: &BundleTypeCode| { &m.value },
                    |m: &mut BundleTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &BundleTypeCode| { &m.id },
                    |m: &mut BundleTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &BundleTypeCode| { &m.extension },
                    |m: &mut BundleTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BundleTypeCode>(
                    "BundleTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BundleTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<BundleTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BundleTypeCode,
        };
        unsafe {
            instance.get(BundleTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for BundleTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BundleTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BundleTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BundleTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    DOCUMENT = 1,
    MESSAGE = 2,
    TRANSACTION = 3,
    TRANSACTION_RESPONSE = 4,
    BATCH = 5,
    BATCH_RESPONSE = 6,
    HISTORY = 7,
    SEARCHSET = 8,
    COLLECTION = 9,
}

impl ::protobuf::ProtobufEnum for BundleTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BundleTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(BundleTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(BundleTypeCode_Value::DOCUMENT),
            2 => ::std::option::Option::Some(BundleTypeCode_Value::MESSAGE),
            3 => ::std::option::Option::Some(BundleTypeCode_Value::TRANSACTION),
            4 => ::std::option::Option::Some(BundleTypeCode_Value::TRANSACTION_RESPONSE),
            5 => ::std::option::Option::Some(BundleTypeCode_Value::BATCH),
            6 => ::std::option::Option::Some(BundleTypeCode_Value::BATCH_RESPONSE),
            7 => ::std::option::Option::Some(BundleTypeCode_Value::HISTORY),
            8 => ::std::option::Option::Some(BundleTypeCode_Value::SEARCHSET),
            9 => ::std::option::Option::Some(BundleTypeCode_Value::COLLECTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BundleTypeCode_Value] = &[
            BundleTypeCode_Value::INVALID_UNINITIALIZED,
            BundleTypeCode_Value::DOCUMENT,
            BundleTypeCode_Value::MESSAGE,
            BundleTypeCode_Value::TRANSACTION,
            BundleTypeCode_Value::TRANSACTION_RESPONSE,
            BundleTypeCode_Value::BATCH,
            BundleTypeCode_Value::BATCH_RESPONSE,
            BundleTypeCode_Value::HISTORY,
            BundleTypeCode_Value::SEARCHSET,
            BundleTypeCode_Value::COLLECTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("BundleTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for BundleTypeCode_Value {
}

impl ::std::default::Default for BundleTypeCode_Value {
    fn default() -> Self {
        BundleTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for BundleTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CapabilityStatementKindCode {
    // message fields
    pub value: CapabilityStatementKindCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CapabilityStatementKindCode {
    pub fn new() -> CapabilityStatementKindCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CapabilityStatementKindCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CapabilityStatementKindCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CapabilityStatementKindCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CapabilityStatementKindCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CapabilityStatementKindCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CapabilityStatementKindCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CapabilityStatementKindCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CapabilityStatementKindCode {
        CapabilityStatementKindCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CapabilityStatementKindCode_Value>>(
                    "value",
                    |m: &CapabilityStatementKindCode| { &m.value },
                    |m: &mut CapabilityStatementKindCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CapabilityStatementKindCode| { &m.id },
                    |m: &mut CapabilityStatementKindCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CapabilityStatementKindCode| { &m.extension },
                    |m: &mut CapabilityStatementKindCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CapabilityStatementKindCode>(
                    "CapabilityStatementKindCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CapabilityStatementKindCode {
        static mut instance: ::protobuf::lazy::Lazy<CapabilityStatementKindCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CapabilityStatementKindCode,
        };
        unsafe {
            instance.get(CapabilityStatementKindCode::new)
        }
    }
}

impl ::protobuf::Clear for CapabilityStatementKindCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CapabilityStatementKindCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilityStatementKindCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CapabilityStatementKindCode_Value {
    INVALID_UNINITIALIZED = 0,
    INSTANCE = 1,
    CAPABILITY = 2,
    REQUIREMENTS = 3,
}

impl ::protobuf::ProtobufEnum for CapabilityStatementKindCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CapabilityStatementKindCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CapabilityStatementKindCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CapabilityStatementKindCode_Value::INSTANCE),
            2 => ::std::option::Option::Some(CapabilityStatementKindCode_Value::CAPABILITY),
            3 => ::std::option::Option::Some(CapabilityStatementKindCode_Value::REQUIREMENTS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CapabilityStatementKindCode_Value] = &[
            CapabilityStatementKindCode_Value::INVALID_UNINITIALIZED,
            CapabilityStatementKindCode_Value::INSTANCE,
            CapabilityStatementKindCode_Value::CAPABILITY,
            CapabilityStatementKindCode_Value::REQUIREMENTS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CapabilityStatementKindCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CapabilityStatementKindCode_Value {
}

impl ::std::default::Default for CapabilityStatementKindCode_Value {
    fn default() -> Self {
        CapabilityStatementKindCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CapabilityStatementKindCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CarePlanActivityCategoryCode {
    // message fields
    pub value: CarePlanActivityCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CarePlanActivityCategoryCode {
    pub fn new() -> CarePlanActivityCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CarePlanActivityCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CarePlanActivityCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CarePlanActivityCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CarePlanActivityCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CarePlanActivityCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CarePlanActivityCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CarePlanActivityCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarePlanActivityCategoryCode {
        CarePlanActivityCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CarePlanActivityCategoryCode_Value>>(
                    "value",
                    |m: &CarePlanActivityCategoryCode| { &m.value },
                    |m: &mut CarePlanActivityCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CarePlanActivityCategoryCode| { &m.id },
                    |m: &mut CarePlanActivityCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CarePlanActivityCategoryCode| { &m.extension },
                    |m: &mut CarePlanActivityCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CarePlanActivityCategoryCode>(
                    "CarePlanActivityCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CarePlanActivityCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<CarePlanActivityCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CarePlanActivityCategoryCode,
        };
        unsafe {
            instance.get(CarePlanActivityCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for CarePlanActivityCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarePlanActivityCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarePlanActivityCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CarePlanActivityCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    DIET = 1,
    DRUG = 2,
    ENCOUNTER = 3,
    OBSERVATION = 4,
    PROCEDURE = 5,
    SUPPLY = 6,
    OTHER = 7,
}

impl ::protobuf::ProtobufEnum for CarePlanActivityCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CarePlanActivityCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CarePlanActivityCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CarePlanActivityCategoryCode_Value::DIET),
            2 => ::std::option::Option::Some(CarePlanActivityCategoryCode_Value::DRUG),
            3 => ::std::option::Option::Some(CarePlanActivityCategoryCode_Value::ENCOUNTER),
            4 => ::std::option::Option::Some(CarePlanActivityCategoryCode_Value::OBSERVATION),
            5 => ::std::option::Option::Some(CarePlanActivityCategoryCode_Value::PROCEDURE),
            6 => ::std::option::Option::Some(CarePlanActivityCategoryCode_Value::SUPPLY),
            7 => ::std::option::Option::Some(CarePlanActivityCategoryCode_Value::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CarePlanActivityCategoryCode_Value] = &[
            CarePlanActivityCategoryCode_Value::INVALID_UNINITIALIZED,
            CarePlanActivityCategoryCode_Value::DIET,
            CarePlanActivityCategoryCode_Value::DRUG,
            CarePlanActivityCategoryCode_Value::ENCOUNTER,
            CarePlanActivityCategoryCode_Value::OBSERVATION,
            CarePlanActivityCategoryCode_Value::PROCEDURE,
            CarePlanActivityCategoryCode_Value::SUPPLY,
            CarePlanActivityCategoryCode_Value::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CarePlanActivityCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CarePlanActivityCategoryCode_Value {
}

impl ::std::default::Default for CarePlanActivityCategoryCode_Value {
    fn default() -> Self {
        CarePlanActivityCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CarePlanActivityCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CarePlanActivityStatusCode {
    // message fields
    pub value: CarePlanActivityStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CarePlanActivityStatusCode {
    pub fn new() -> CarePlanActivityStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CarePlanActivityStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CarePlanActivityStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CarePlanActivityStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CarePlanActivityStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CarePlanActivityStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CarePlanActivityStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CarePlanActivityStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarePlanActivityStatusCode {
        CarePlanActivityStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CarePlanActivityStatusCode_Value>>(
                    "value",
                    |m: &CarePlanActivityStatusCode| { &m.value },
                    |m: &mut CarePlanActivityStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CarePlanActivityStatusCode| { &m.id },
                    |m: &mut CarePlanActivityStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CarePlanActivityStatusCode| { &m.extension },
                    |m: &mut CarePlanActivityStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CarePlanActivityStatusCode>(
                    "CarePlanActivityStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CarePlanActivityStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<CarePlanActivityStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CarePlanActivityStatusCode,
        };
        unsafe {
            instance.get(CarePlanActivityStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for CarePlanActivityStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarePlanActivityStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarePlanActivityStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CarePlanActivityStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    NOT_STARTED = 1,
    SCHEDULED = 2,
    IN_PROGRESS = 3,
    ON_HOLD = 4,
    COMPLETED = 5,
    CANCELLED = 6,
    UNKNOWN = 7,
}

impl ::protobuf::ProtobufEnum for CarePlanActivityStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CarePlanActivityStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CarePlanActivityStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CarePlanActivityStatusCode_Value::NOT_STARTED),
            2 => ::std::option::Option::Some(CarePlanActivityStatusCode_Value::SCHEDULED),
            3 => ::std::option::Option::Some(CarePlanActivityStatusCode_Value::IN_PROGRESS),
            4 => ::std::option::Option::Some(CarePlanActivityStatusCode_Value::ON_HOLD),
            5 => ::std::option::Option::Some(CarePlanActivityStatusCode_Value::COMPLETED),
            6 => ::std::option::Option::Some(CarePlanActivityStatusCode_Value::CANCELLED),
            7 => ::std::option::Option::Some(CarePlanActivityStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CarePlanActivityStatusCode_Value] = &[
            CarePlanActivityStatusCode_Value::INVALID_UNINITIALIZED,
            CarePlanActivityStatusCode_Value::NOT_STARTED,
            CarePlanActivityStatusCode_Value::SCHEDULED,
            CarePlanActivityStatusCode_Value::IN_PROGRESS,
            CarePlanActivityStatusCode_Value::ON_HOLD,
            CarePlanActivityStatusCode_Value::COMPLETED,
            CarePlanActivityStatusCode_Value::CANCELLED,
            CarePlanActivityStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CarePlanActivityStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CarePlanActivityStatusCode_Value {
}

impl ::std::default::Default for CarePlanActivityStatusCode_Value {
    fn default() -> Self {
        CarePlanActivityStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CarePlanActivityStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CarePlanIntentCode {
    // message fields
    pub value: CarePlanIntentCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CarePlanIntentCode {
    pub fn new() -> CarePlanIntentCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CarePlanIntentCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CarePlanIntentCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CarePlanIntentCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CarePlanIntentCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CarePlanIntentCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CarePlanIntentCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CarePlanIntentCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarePlanIntentCode {
        CarePlanIntentCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CarePlanIntentCode_Value>>(
                    "value",
                    |m: &CarePlanIntentCode| { &m.value },
                    |m: &mut CarePlanIntentCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CarePlanIntentCode| { &m.id },
                    |m: &mut CarePlanIntentCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CarePlanIntentCode| { &m.extension },
                    |m: &mut CarePlanIntentCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CarePlanIntentCode>(
                    "CarePlanIntentCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CarePlanIntentCode {
        static mut instance: ::protobuf::lazy::Lazy<CarePlanIntentCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CarePlanIntentCode,
        };
        unsafe {
            instance.get(CarePlanIntentCode::new)
        }
    }
}

impl ::protobuf::Clear for CarePlanIntentCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarePlanIntentCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarePlanIntentCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CarePlanIntentCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROPOSAL = 1,
    PLAN = 2,
    ORDER = 3,
    OPTION = 4,
}

impl ::protobuf::ProtobufEnum for CarePlanIntentCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CarePlanIntentCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CarePlanIntentCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CarePlanIntentCode_Value::PROPOSAL),
            2 => ::std::option::Option::Some(CarePlanIntentCode_Value::PLAN),
            3 => ::std::option::Option::Some(CarePlanIntentCode_Value::ORDER),
            4 => ::std::option::Option::Some(CarePlanIntentCode_Value::OPTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CarePlanIntentCode_Value] = &[
            CarePlanIntentCode_Value::INVALID_UNINITIALIZED,
            CarePlanIntentCode_Value::PROPOSAL,
            CarePlanIntentCode_Value::PLAN,
            CarePlanIntentCode_Value::ORDER,
            CarePlanIntentCode_Value::OPTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CarePlanIntentCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CarePlanIntentCode_Value {
}

impl ::std::default::Default for CarePlanIntentCode_Value {
    fn default() -> Self {
        CarePlanIntentCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CarePlanIntentCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CarePlanStatusCode {
    // message fields
    pub value: CarePlanStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CarePlanStatusCode {
    pub fn new() -> CarePlanStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CarePlanStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CarePlanStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CarePlanStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CarePlanStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CarePlanStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CarePlanStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CarePlanStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CarePlanStatusCode {
        CarePlanStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CarePlanStatusCode_Value>>(
                    "value",
                    |m: &CarePlanStatusCode| { &m.value },
                    |m: &mut CarePlanStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CarePlanStatusCode| { &m.id },
                    |m: &mut CarePlanStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CarePlanStatusCode| { &m.extension },
                    |m: &mut CarePlanStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CarePlanStatusCode>(
                    "CarePlanStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CarePlanStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<CarePlanStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CarePlanStatusCode,
        };
        unsafe {
            instance.get(CarePlanStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for CarePlanStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CarePlanStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CarePlanStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CarePlanStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    DRAFT = 1,
    ACTIVE = 2,
    SUSPENDED = 3,
    COMPLETED = 4,
    ENTERED_IN_ERROR = 5,
    CANCELLED = 6,
    UNKNOWN = 7,
}

impl ::protobuf::ProtobufEnum for CarePlanStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CarePlanStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CarePlanStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CarePlanStatusCode_Value::DRAFT),
            2 => ::std::option::Option::Some(CarePlanStatusCode_Value::ACTIVE),
            3 => ::std::option::Option::Some(CarePlanStatusCode_Value::SUSPENDED),
            4 => ::std::option::Option::Some(CarePlanStatusCode_Value::COMPLETED),
            5 => ::std::option::Option::Some(CarePlanStatusCode_Value::ENTERED_IN_ERROR),
            6 => ::std::option::Option::Some(CarePlanStatusCode_Value::CANCELLED),
            7 => ::std::option::Option::Some(CarePlanStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CarePlanStatusCode_Value] = &[
            CarePlanStatusCode_Value::INVALID_UNINITIALIZED,
            CarePlanStatusCode_Value::DRAFT,
            CarePlanStatusCode_Value::ACTIVE,
            CarePlanStatusCode_Value::SUSPENDED,
            CarePlanStatusCode_Value::COMPLETED,
            CarePlanStatusCode_Value::ENTERED_IN_ERROR,
            CarePlanStatusCode_Value::CANCELLED,
            CarePlanStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CarePlanStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CarePlanStatusCode_Value {
}

impl ::std::default::Default for CarePlanStatusCode_Value {
    fn default() -> Self {
        CarePlanStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CarePlanStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CareTeamCategoryCode {
    // message fields
    pub value: CareTeamCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CareTeamCategoryCode {
    pub fn new() -> CareTeamCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CareTeamCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CareTeamCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CareTeamCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CareTeamCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CareTeamCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CareTeamCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CareTeamCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CareTeamCategoryCode {
        CareTeamCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CareTeamCategoryCode_Value>>(
                    "value",
                    |m: &CareTeamCategoryCode| { &m.value },
                    |m: &mut CareTeamCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CareTeamCategoryCode| { &m.id },
                    |m: &mut CareTeamCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CareTeamCategoryCode| { &m.extension },
                    |m: &mut CareTeamCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CareTeamCategoryCode>(
                    "CareTeamCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CareTeamCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<CareTeamCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CareTeamCategoryCode,
        };
        unsafe {
            instance.get(CareTeamCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for CareTeamCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CareTeamCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CareTeamCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CareTeamCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    EVENT = 1,
    ENCOUNTER = 2,
    EPISODE = 3,
    LONGITUDINAL = 4,
    CONDITION = 5,
    CLINICAL_RESEARCH = 6,
}

impl ::protobuf::ProtobufEnum for CareTeamCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CareTeamCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CareTeamCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CareTeamCategoryCode_Value::EVENT),
            2 => ::std::option::Option::Some(CareTeamCategoryCode_Value::ENCOUNTER),
            3 => ::std::option::Option::Some(CareTeamCategoryCode_Value::EPISODE),
            4 => ::std::option::Option::Some(CareTeamCategoryCode_Value::LONGITUDINAL),
            5 => ::std::option::Option::Some(CareTeamCategoryCode_Value::CONDITION),
            6 => ::std::option::Option::Some(CareTeamCategoryCode_Value::CLINICAL_RESEARCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CareTeamCategoryCode_Value] = &[
            CareTeamCategoryCode_Value::INVALID_UNINITIALIZED,
            CareTeamCategoryCode_Value::EVENT,
            CareTeamCategoryCode_Value::ENCOUNTER,
            CareTeamCategoryCode_Value::EPISODE,
            CareTeamCategoryCode_Value::LONGITUDINAL,
            CareTeamCategoryCode_Value::CONDITION,
            CareTeamCategoryCode_Value::CLINICAL_RESEARCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CareTeamCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CareTeamCategoryCode_Value {
}

impl ::std::default::Default for CareTeamCategoryCode_Value {
    fn default() -> Self {
        CareTeamCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CareTeamCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CareTeamStatusCode {
    // message fields
    pub value: CareTeamStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CareTeamStatusCode {
    pub fn new() -> CareTeamStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CareTeamStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CareTeamStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CareTeamStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CareTeamStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CareTeamStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CareTeamStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CareTeamStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CareTeamStatusCode {
        CareTeamStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CareTeamStatusCode_Value>>(
                    "value",
                    |m: &CareTeamStatusCode| { &m.value },
                    |m: &mut CareTeamStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CareTeamStatusCode| { &m.id },
                    |m: &mut CareTeamStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CareTeamStatusCode| { &m.extension },
                    |m: &mut CareTeamStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CareTeamStatusCode>(
                    "CareTeamStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CareTeamStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<CareTeamStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CareTeamStatusCode,
        };
        unsafe {
            instance.get(CareTeamStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for CareTeamStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CareTeamStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CareTeamStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CareTeamStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROPOSED = 1,
    ACTIVE = 2,
    SUSPENDED = 3,
    INACTIVE = 4,
    ENTERED_IN_ERROR = 5,
}

impl ::protobuf::ProtobufEnum for CareTeamStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CareTeamStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CareTeamStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CareTeamStatusCode_Value::PROPOSED),
            2 => ::std::option::Option::Some(CareTeamStatusCode_Value::ACTIVE),
            3 => ::std::option::Option::Some(CareTeamStatusCode_Value::SUSPENDED),
            4 => ::std::option::Option::Some(CareTeamStatusCode_Value::INACTIVE),
            5 => ::std::option::Option::Some(CareTeamStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CareTeamStatusCode_Value] = &[
            CareTeamStatusCode_Value::INVALID_UNINITIALIZED,
            CareTeamStatusCode_Value::PROPOSED,
            CareTeamStatusCode_Value::ACTIVE,
            CareTeamStatusCode_Value::SUSPENDED,
            CareTeamStatusCode_Value::INACTIVE,
            CareTeamStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CareTeamStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CareTeamStatusCode_Value {
}

impl ::std::default::Default for CareTeamStatusCode_Value {
    fn default() -> Self {
        CareTeamStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CareTeamStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChargeItemStatusCode {
    // message fields
    pub value: ChargeItemStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChargeItemStatusCode {
    pub fn new() -> ChargeItemStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ChargeItemStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ChargeItemStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ChargeItemStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ChargeItemStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ChargeItemStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ChargeItemStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ChargeItemStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChargeItemStatusCode {
        ChargeItemStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChargeItemStatusCode_Value>>(
                    "value",
                    |m: &ChargeItemStatusCode| { &m.value },
                    |m: &mut ChargeItemStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ChargeItemStatusCode| { &m.id },
                    |m: &mut ChargeItemStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ChargeItemStatusCode| { &m.extension },
                    |m: &mut ChargeItemStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChargeItemStatusCode>(
                    "ChargeItemStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChargeItemStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ChargeItemStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChargeItemStatusCode,
        };
        unsafe {
            instance.get(ChargeItemStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ChargeItemStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChargeItemStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChargeItemStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChargeItemStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PLANNED = 1,
    BILLABLE = 2,
    NOT_BILLABLE = 3,
    ABORTED = 4,
    BILLED = 5,
    ENTERED_IN_ERROR = 6,
    UNKNOWN = 7,
}

impl ::protobuf::ProtobufEnum for ChargeItemStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChargeItemStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ChargeItemStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ChargeItemStatusCode_Value::PLANNED),
            2 => ::std::option::Option::Some(ChargeItemStatusCode_Value::BILLABLE),
            3 => ::std::option::Option::Some(ChargeItemStatusCode_Value::NOT_BILLABLE),
            4 => ::std::option::Option::Some(ChargeItemStatusCode_Value::ABORTED),
            5 => ::std::option::Option::Some(ChargeItemStatusCode_Value::BILLED),
            6 => ::std::option::Option::Some(ChargeItemStatusCode_Value::ENTERED_IN_ERROR),
            7 => ::std::option::Option::Some(ChargeItemStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChargeItemStatusCode_Value] = &[
            ChargeItemStatusCode_Value::INVALID_UNINITIALIZED,
            ChargeItemStatusCode_Value::PLANNED,
            ChargeItemStatusCode_Value::BILLABLE,
            ChargeItemStatusCode_Value::NOT_BILLABLE,
            ChargeItemStatusCode_Value::ABORTED,
            ChargeItemStatusCode_Value::BILLED,
            ChargeItemStatusCode_Value::ENTERED_IN_ERROR,
            ChargeItemStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ChargeItemStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ChargeItemStatusCode_Value {
}

impl ::std::default::Default for ChargeItemStatusCode_Value {
    fn default() -> Self {
        ChargeItemStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ChargeItemStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChoiceListOrientationCode {
    // message fields
    pub value: ChoiceListOrientationCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ChoiceListOrientationCode {
    pub fn new() -> ChoiceListOrientationCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ChoiceListOrientationCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ChoiceListOrientationCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ChoiceListOrientationCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ChoiceListOrientationCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ChoiceListOrientationCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ChoiceListOrientationCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ChoiceListOrientationCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChoiceListOrientationCode {
        ChoiceListOrientationCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChoiceListOrientationCode_Value>>(
                    "value",
                    |m: &ChoiceListOrientationCode| { &m.value },
                    |m: &mut ChoiceListOrientationCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ChoiceListOrientationCode| { &m.id },
                    |m: &mut ChoiceListOrientationCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ChoiceListOrientationCode| { &m.extension },
                    |m: &mut ChoiceListOrientationCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChoiceListOrientationCode>(
                    "ChoiceListOrientationCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChoiceListOrientationCode {
        static mut instance: ::protobuf::lazy::Lazy<ChoiceListOrientationCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChoiceListOrientationCode,
        };
        unsafe {
            instance.get(ChoiceListOrientationCode::new)
        }
    }
}

impl ::protobuf::Clear for ChoiceListOrientationCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChoiceListOrientationCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChoiceListOrientationCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChoiceListOrientationCode_Value {
    INVALID_UNINITIALIZED = 0,
    HORIZONTAL = 1,
    VERTICAL = 2,
}

impl ::protobuf::ProtobufEnum for ChoiceListOrientationCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChoiceListOrientationCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ChoiceListOrientationCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ChoiceListOrientationCode_Value::HORIZONTAL),
            2 => ::std::option::Option::Some(ChoiceListOrientationCode_Value::VERTICAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChoiceListOrientationCode_Value] = &[
            ChoiceListOrientationCode_Value::INVALID_UNINITIALIZED,
            ChoiceListOrientationCode_Value::HORIZONTAL,
            ChoiceListOrientationCode_Value::VERTICAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ChoiceListOrientationCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ChoiceListOrientationCode_Value {
}

impl ::std::default::Default for ChoiceListOrientationCode_Value {
    fn default() -> Self {
        ChoiceListOrientationCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ChoiceListOrientationCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UseCode {
    // message fields
    pub value: UseCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UseCode {
    pub fn new() -> UseCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.UseCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = UseCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: UseCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> UseCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for UseCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != UseCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != UseCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UseCode {
        UseCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UseCode_Value>>(
                    "value",
                    |m: &UseCode| { &m.value },
                    |m: &mut UseCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &UseCode| { &m.id },
                    |m: &mut UseCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &UseCode| { &m.extension },
                    |m: &mut UseCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UseCode>(
                    "UseCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UseCode {
        static mut instance: ::protobuf::lazy::Lazy<UseCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UseCode,
        };
        unsafe {
            instance.get(UseCode::new)
        }
    }
}

impl ::protobuf::Clear for UseCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UseCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UseCode_Value {
    INVALID_UNINITIALIZED = 0,
    COMPLETE = 1,
    PROPOSED = 2,
    EXPLORATORY = 3,
    OTHER = 4,
}

impl ::protobuf::ProtobufEnum for UseCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UseCode_Value> {
        match value {
            0 => ::std::option::Option::Some(UseCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(UseCode_Value::COMPLETE),
            2 => ::std::option::Option::Some(UseCode_Value::PROPOSED),
            3 => ::std::option::Option::Some(UseCode_Value::EXPLORATORY),
            4 => ::std::option::Option::Some(UseCode_Value::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UseCode_Value] = &[
            UseCode_Value::INVALID_UNINITIALIZED,
            UseCode_Value::COMPLETE,
            UseCode_Value::PROPOSED,
            UseCode_Value::EXPLORATORY,
            UseCode_Value::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("UseCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for UseCode_Value {
}

impl ::std::default::Default for UseCode_Value {
    fn default() -> Self {
        UseCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for UseCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClassificationOrContextCode {
    // message fields
    pub value: ClassificationOrContextCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ClassificationOrContextCode {
    pub fn new() -> ClassificationOrContextCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ClassificationOrContextCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ClassificationOrContextCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ClassificationOrContextCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ClassificationOrContextCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ClassificationOrContextCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ClassificationOrContextCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ClassificationOrContextCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClassificationOrContextCode {
        ClassificationOrContextCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClassificationOrContextCode_Value>>(
                    "value",
                    |m: &ClassificationOrContextCode| { &m.value },
                    |m: &mut ClassificationOrContextCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ClassificationOrContextCode| { &m.id },
                    |m: &mut ClassificationOrContextCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ClassificationOrContextCode| { &m.extension },
                    |m: &mut ClassificationOrContextCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClassificationOrContextCode>(
                    "ClassificationOrContextCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClassificationOrContextCode {
        static mut instance: ::protobuf::lazy::Lazy<ClassificationOrContextCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClassificationOrContextCode,
        };
        unsafe {
            instance.get(ClassificationOrContextCode::new)
        }
    }
}

impl ::protobuf::Clear for ClassificationOrContextCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClassificationOrContextCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClassificationOrContextCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClassificationOrContextCode_Value {
    INVALID_UNINITIALIZED = 0,
    CLASSIFICATION = 1,
    CONTEXT = 2,
}

impl ::protobuf::ProtobufEnum for ClassificationOrContextCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClassificationOrContextCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ClassificationOrContextCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ClassificationOrContextCode_Value::CLASSIFICATION),
            2 => ::std::option::Option::Some(ClassificationOrContextCode_Value::CONTEXT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClassificationOrContextCode_Value] = &[
            ClassificationOrContextCode_Value::INVALID_UNINITIALIZED,
            ClassificationOrContextCode_Value::CLASSIFICATION,
            ClassificationOrContextCode_Value::CONTEXT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ClassificationOrContextCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ClassificationOrContextCode_Value {
}

impl ::std::default::Default for ClassificationOrContextCode_Value {
    fn default() -> Self {
        ClassificationOrContextCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ClassificationOrContextCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClinicalImpressionStatusCode {
    // message fields
    pub value: ClinicalImpressionStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ClinicalImpressionStatusCode {
    pub fn new() -> ClinicalImpressionStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ClinicalImpressionStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ClinicalImpressionStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ClinicalImpressionStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ClinicalImpressionStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ClinicalImpressionStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ClinicalImpressionStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ClinicalImpressionStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClinicalImpressionStatusCode {
        ClinicalImpressionStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClinicalImpressionStatusCode_Value>>(
                    "value",
                    |m: &ClinicalImpressionStatusCode| { &m.value },
                    |m: &mut ClinicalImpressionStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ClinicalImpressionStatusCode| { &m.id },
                    |m: &mut ClinicalImpressionStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ClinicalImpressionStatusCode| { &m.extension },
                    |m: &mut ClinicalImpressionStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClinicalImpressionStatusCode>(
                    "ClinicalImpressionStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClinicalImpressionStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ClinicalImpressionStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClinicalImpressionStatusCode,
        };
        unsafe {
            instance.get(ClinicalImpressionStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ClinicalImpressionStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClinicalImpressionStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClinicalImpressionStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClinicalImpressionStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    DRAFT = 1,
    COMPLETED = 2,
    ENTERED_IN_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for ClinicalImpressionStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClinicalImpressionStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ClinicalImpressionStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ClinicalImpressionStatusCode_Value::DRAFT),
            2 => ::std::option::Option::Some(ClinicalImpressionStatusCode_Value::COMPLETED),
            3 => ::std::option::Option::Some(ClinicalImpressionStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClinicalImpressionStatusCode_Value] = &[
            ClinicalImpressionStatusCode_Value::INVALID_UNINITIALIZED,
            ClinicalImpressionStatusCode_Value::DRAFT,
            ClinicalImpressionStatusCode_Value::COMPLETED,
            ClinicalImpressionStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ClinicalImpressionStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ClinicalImpressionStatusCode_Value {
}

impl ::std::default::Default for ClinicalImpressionStatusCode_Value {
    fn default() -> Self {
        ClinicalImpressionStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ClinicalImpressionStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CodeSystemContentModeCode {
    // message fields
    pub value: CodeSystemContentModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CodeSystemContentModeCode {
    pub fn new() -> CodeSystemContentModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CodeSystemContentModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CodeSystemContentModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CodeSystemContentModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CodeSystemContentModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CodeSystemContentModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CodeSystemContentModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CodeSystemContentModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodeSystemContentModeCode {
        CodeSystemContentModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CodeSystemContentModeCode_Value>>(
                    "value",
                    |m: &CodeSystemContentModeCode| { &m.value },
                    |m: &mut CodeSystemContentModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CodeSystemContentModeCode| { &m.id },
                    |m: &mut CodeSystemContentModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CodeSystemContentModeCode| { &m.extension },
                    |m: &mut CodeSystemContentModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CodeSystemContentModeCode>(
                    "CodeSystemContentModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CodeSystemContentModeCode {
        static mut instance: ::protobuf::lazy::Lazy<CodeSystemContentModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CodeSystemContentModeCode,
        };
        unsafe {
            instance.get(CodeSystemContentModeCode::new)
        }
    }
}

impl ::protobuf::Clear for CodeSystemContentModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodeSystemContentModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeSystemContentModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CodeSystemContentModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    NOT_PRESENT = 1,
    EXAMPLE = 2,
    FRAGMENT = 3,
    COMPLETE = 4,
}

impl ::protobuf::ProtobufEnum for CodeSystemContentModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CodeSystemContentModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CodeSystemContentModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CodeSystemContentModeCode_Value::NOT_PRESENT),
            2 => ::std::option::Option::Some(CodeSystemContentModeCode_Value::EXAMPLE),
            3 => ::std::option::Option::Some(CodeSystemContentModeCode_Value::FRAGMENT),
            4 => ::std::option::Option::Some(CodeSystemContentModeCode_Value::COMPLETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CodeSystemContentModeCode_Value] = &[
            CodeSystemContentModeCode_Value::INVALID_UNINITIALIZED,
            CodeSystemContentModeCode_Value::NOT_PRESENT,
            CodeSystemContentModeCode_Value::EXAMPLE,
            CodeSystemContentModeCode_Value::FRAGMENT,
            CodeSystemContentModeCode_Value::COMPLETE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CodeSystemContentModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CodeSystemContentModeCode_Value {
}

impl ::std::default::Default for CodeSystemContentModeCode_Value {
    fn default() -> Self {
        CodeSystemContentModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeSystemContentModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CodeSystemHierarchyMeaningCode {
    // message fields
    pub value: CodeSystemHierarchyMeaningCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CodeSystemHierarchyMeaningCode {
    pub fn new() -> CodeSystemHierarchyMeaningCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CodeSystemHierarchyMeaningCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CodeSystemHierarchyMeaningCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CodeSystemHierarchyMeaningCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CodeSystemHierarchyMeaningCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CodeSystemHierarchyMeaningCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CodeSystemHierarchyMeaningCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CodeSystemHierarchyMeaningCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodeSystemHierarchyMeaningCode {
        CodeSystemHierarchyMeaningCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CodeSystemHierarchyMeaningCode_Value>>(
                    "value",
                    |m: &CodeSystemHierarchyMeaningCode| { &m.value },
                    |m: &mut CodeSystemHierarchyMeaningCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CodeSystemHierarchyMeaningCode| { &m.id },
                    |m: &mut CodeSystemHierarchyMeaningCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CodeSystemHierarchyMeaningCode| { &m.extension },
                    |m: &mut CodeSystemHierarchyMeaningCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CodeSystemHierarchyMeaningCode>(
                    "CodeSystemHierarchyMeaningCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CodeSystemHierarchyMeaningCode {
        static mut instance: ::protobuf::lazy::Lazy<CodeSystemHierarchyMeaningCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CodeSystemHierarchyMeaningCode,
        };
        unsafe {
            instance.get(CodeSystemHierarchyMeaningCode::new)
        }
    }
}

impl ::protobuf::Clear for CodeSystemHierarchyMeaningCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodeSystemHierarchyMeaningCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeSystemHierarchyMeaningCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CodeSystemHierarchyMeaningCode_Value {
    INVALID_UNINITIALIZED = 0,
    GROUPED_BY = 1,
    IS_A = 2,
    PART_OF = 3,
    CLASSIFIED_WITH = 4,
}

impl ::protobuf::ProtobufEnum for CodeSystemHierarchyMeaningCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CodeSystemHierarchyMeaningCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CodeSystemHierarchyMeaningCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CodeSystemHierarchyMeaningCode_Value::GROUPED_BY),
            2 => ::std::option::Option::Some(CodeSystemHierarchyMeaningCode_Value::IS_A),
            3 => ::std::option::Option::Some(CodeSystemHierarchyMeaningCode_Value::PART_OF),
            4 => ::std::option::Option::Some(CodeSystemHierarchyMeaningCode_Value::CLASSIFIED_WITH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CodeSystemHierarchyMeaningCode_Value] = &[
            CodeSystemHierarchyMeaningCode_Value::INVALID_UNINITIALIZED,
            CodeSystemHierarchyMeaningCode_Value::GROUPED_BY,
            CodeSystemHierarchyMeaningCode_Value::IS_A,
            CodeSystemHierarchyMeaningCode_Value::PART_OF,
            CodeSystemHierarchyMeaningCode_Value::CLASSIFIED_WITH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CodeSystemHierarchyMeaningCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CodeSystemHierarchyMeaningCode_Value {
}

impl ::std::default::Default for CodeSystemHierarchyMeaningCode_Value {
    fn default() -> Self {
        CodeSystemHierarchyMeaningCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeSystemHierarchyMeaningCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommonTagsCode {
    // message fields
    pub value: CommonTagsCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommonTagsCode {
    pub fn new() -> CommonTagsCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CommonTagsCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CommonTagsCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CommonTagsCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CommonTagsCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CommonTagsCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CommonTagsCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CommonTagsCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommonTagsCode {
        CommonTagsCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommonTagsCode_Value>>(
                    "value",
                    |m: &CommonTagsCode| { &m.value },
                    |m: &mut CommonTagsCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CommonTagsCode| { &m.id },
                    |m: &mut CommonTagsCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CommonTagsCode| { &m.extension },
                    |m: &mut CommonTagsCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommonTagsCode>(
                    "CommonTagsCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommonTagsCode {
        static mut instance: ::protobuf::lazy::Lazy<CommonTagsCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommonTagsCode,
        };
        unsafe {
            instance.get(CommonTagsCode::new)
        }
    }
}

impl ::protobuf::Clear for CommonTagsCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommonTagsCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonTagsCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommonTagsCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIONABLE = 1,
}

impl ::protobuf::ProtobufEnum for CommonTagsCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommonTagsCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CommonTagsCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CommonTagsCode_Value::ACTIONABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommonTagsCode_Value] = &[
            CommonTagsCode_Value::INVALID_UNINITIALIZED,
            CommonTagsCode_Value::ACTIONABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommonTagsCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommonTagsCode_Value {
}

impl ::std::default::Default for CommonTagsCode_Value {
    fn default() -> Self {
        CommonTagsCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonTagsCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommunicationCategoryCode {
    // message fields
    pub value: CommunicationCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommunicationCategoryCode {
    pub fn new() -> CommunicationCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CommunicationCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CommunicationCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CommunicationCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CommunicationCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CommunicationCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CommunicationCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CommunicationCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommunicationCategoryCode {
        CommunicationCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommunicationCategoryCode_Value>>(
                    "value",
                    |m: &CommunicationCategoryCode| { &m.value },
                    |m: &mut CommunicationCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CommunicationCategoryCode| { &m.id },
                    |m: &mut CommunicationCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CommunicationCategoryCode| { &m.extension },
                    |m: &mut CommunicationCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommunicationCategoryCode>(
                    "CommunicationCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommunicationCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<CommunicationCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommunicationCategoryCode,
        };
        unsafe {
            instance.get(CommunicationCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for CommunicationCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommunicationCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommunicationCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommunicationCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    ALERT = 1,
    NOTIFICATION = 2,
    REMINDER = 3,
    INSTRUCTION = 4,
}

impl ::protobuf::ProtobufEnum for CommunicationCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommunicationCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CommunicationCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CommunicationCategoryCode_Value::ALERT),
            2 => ::std::option::Option::Some(CommunicationCategoryCode_Value::NOTIFICATION),
            3 => ::std::option::Option::Some(CommunicationCategoryCode_Value::REMINDER),
            4 => ::std::option::Option::Some(CommunicationCategoryCode_Value::INSTRUCTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommunicationCategoryCode_Value] = &[
            CommunicationCategoryCode_Value::INVALID_UNINITIALIZED,
            CommunicationCategoryCode_Value::ALERT,
            CommunicationCategoryCode_Value::NOTIFICATION,
            CommunicationCategoryCode_Value::REMINDER,
            CommunicationCategoryCode_Value::INSTRUCTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommunicationCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommunicationCategoryCode_Value {
}

impl ::std::default::Default for CommunicationCategoryCode_Value {
    fn default() -> Self {
        CommunicationCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CommunicationCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommunicationNotDoneReasonCode {
    // message fields
    pub value: CommunicationNotDoneReasonCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CommunicationNotDoneReasonCode {
    pub fn new() -> CommunicationNotDoneReasonCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CommunicationNotDoneReasonCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CommunicationNotDoneReasonCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CommunicationNotDoneReasonCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CommunicationNotDoneReasonCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CommunicationNotDoneReasonCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CommunicationNotDoneReasonCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CommunicationNotDoneReasonCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommunicationNotDoneReasonCode {
        CommunicationNotDoneReasonCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommunicationNotDoneReasonCode_Value>>(
                    "value",
                    |m: &CommunicationNotDoneReasonCode| { &m.value },
                    |m: &mut CommunicationNotDoneReasonCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CommunicationNotDoneReasonCode| { &m.id },
                    |m: &mut CommunicationNotDoneReasonCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CommunicationNotDoneReasonCode| { &m.extension },
                    |m: &mut CommunicationNotDoneReasonCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommunicationNotDoneReasonCode>(
                    "CommunicationNotDoneReasonCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommunicationNotDoneReasonCode {
        static mut instance: ::protobuf::lazy::Lazy<CommunicationNotDoneReasonCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommunicationNotDoneReasonCode,
        };
        unsafe {
            instance.get(CommunicationNotDoneReasonCode::new)
        }
    }
}

impl ::protobuf::Clear for CommunicationNotDoneReasonCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommunicationNotDoneReasonCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommunicationNotDoneReasonCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommunicationNotDoneReasonCode_Value {
    INVALID_UNINITIALIZED = 0,
    UNKNOWN = 1,
    SYSTEM_ERROR = 2,
    INVALID_PHONE_NUMBER = 3,
    RECIPIENT_UNAVAILABLE = 4,
    FAMILY_OBJECTION = 5,
    PATIENT_OBJECTION = 6,
}

impl ::protobuf::ProtobufEnum for CommunicationNotDoneReasonCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommunicationNotDoneReasonCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CommunicationNotDoneReasonCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CommunicationNotDoneReasonCode_Value::UNKNOWN),
            2 => ::std::option::Option::Some(CommunicationNotDoneReasonCode_Value::SYSTEM_ERROR),
            3 => ::std::option::Option::Some(CommunicationNotDoneReasonCode_Value::INVALID_PHONE_NUMBER),
            4 => ::std::option::Option::Some(CommunicationNotDoneReasonCode_Value::RECIPIENT_UNAVAILABLE),
            5 => ::std::option::Option::Some(CommunicationNotDoneReasonCode_Value::FAMILY_OBJECTION),
            6 => ::std::option::Option::Some(CommunicationNotDoneReasonCode_Value::PATIENT_OBJECTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommunicationNotDoneReasonCode_Value] = &[
            CommunicationNotDoneReasonCode_Value::INVALID_UNINITIALIZED,
            CommunicationNotDoneReasonCode_Value::UNKNOWN,
            CommunicationNotDoneReasonCode_Value::SYSTEM_ERROR,
            CommunicationNotDoneReasonCode_Value::INVALID_PHONE_NUMBER,
            CommunicationNotDoneReasonCode_Value::RECIPIENT_UNAVAILABLE,
            CommunicationNotDoneReasonCode_Value::FAMILY_OBJECTION,
            CommunicationNotDoneReasonCode_Value::PATIENT_OBJECTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CommunicationNotDoneReasonCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CommunicationNotDoneReasonCode_Value {
}

impl ::std::default::Default for CommunicationNotDoneReasonCode_Value {
    fn default() -> Self {
        CommunicationNotDoneReasonCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CommunicationNotDoneReasonCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompartmentTypeCode {
    // message fields
    pub value: CompartmentTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CompartmentTypeCode {
    pub fn new() -> CompartmentTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CompartmentTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CompartmentTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CompartmentTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CompartmentTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CompartmentTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CompartmentTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CompartmentTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompartmentTypeCode {
        CompartmentTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CompartmentTypeCode_Value>>(
                    "value",
                    |m: &CompartmentTypeCode| { &m.value },
                    |m: &mut CompartmentTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CompartmentTypeCode| { &m.id },
                    |m: &mut CompartmentTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CompartmentTypeCode| { &m.extension },
                    |m: &mut CompartmentTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompartmentTypeCode>(
                    "CompartmentTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CompartmentTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<CompartmentTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompartmentTypeCode,
        };
        unsafe {
            instance.get(CompartmentTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for CompartmentTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompartmentTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompartmentTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CompartmentTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    PATIENT = 1,
    ENCOUNTER = 2,
    RELATEDPERSON = 3,
    PRACTITIONER = 4,
    DEVICE = 5,
}

impl ::protobuf::ProtobufEnum for CompartmentTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompartmentTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CompartmentTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CompartmentTypeCode_Value::PATIENT),
            2 => ::std::option::Option::Some(CompartmentTypeCode_Value::ENCOUNTER),
            3 => ::std::option::Option::Some(CompartmentTypeCode_Value::RELATEDPERSON),
            4 => ::std::option::Option::Some(CompartmentTypeCode_Value::PRACTITIONER),
            5 => ::std::option::Option::Some(CompartmentTypeCode_Value::DEVICE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CompartmentTypeCode_Value] = &[
            CompartmentTypeCode_Value::INVALID_UNINITIALIZED,
            CompartmentTypeCode_Value::PATIENT,
            CompartmentTypeCode_Value::ENCOUNTER,
            CompartmentTypeCode_Value::RELATEDPERSON,
            CompartmentTypeCode_Value::PRACTITIONER,
            CompartmentTypeCode_Value::DEVICE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CompartmentTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CompartmentTypeCode_Value {
}

impl ::std::default::Default for CompartmentTypeCode_Value {
    fn default() -> Self {
        CompartmentTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CompartmentTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompositeMeasureScoringCode {
    // message fields
    pub value: CompositeMeasureScoringCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CompositeMeasureScoringCode {
    pub fn new() -> CompositeMeasureScoringCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CompositeMeasureScoringCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CompositeMeasureScoringCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CompositeMeasureScoringCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CompositeMeasureScoringCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CompositeMeasureScoringCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CompositeMeasureScoringCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CompositeMeasureScoringCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompositeMeasureScoringCode {
        CompositeMeasureScoringCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CompositeMeasureScoringCode_Value>>(
                    "value",
                    |m: &CompositeMeasureScoringCode| { &m.value },
                    |m: &mut CompositeMeasureScoringCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CompositeMeasureScoringCode| { &m.id },
                    |m: &mut CompositeMeasureScoringCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CompositeMeasureScoringCode| { &m.extension },
                    |m: &mut CompositeMeasureScoringCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompositeMeasureScoringCode>(
                    "CompositeMeasureScoringCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CompositeMeasureScoringCode {
        static mut instance: ::protobuf::lazy::Lazy<CompositeMeasureScoringCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompositeMeasureScoringCode,
        };
        unsafe {
            instance.get(CompositeMeasureScoringCode::new)
        }
    }
}

impl ::protobuf::Clear for CompositeMeasureScoringCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompositeMeasureScoringCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompositeMeasureScoringCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CompositeMeasureScoringCode_Value {
    INVALID_UNINITIALIZED = 0,
    OPPORTUNITY = 1,
    ALL_OR_NOTHING = 2,
    LINEAR = 3,
    WEIGHTED = 4,
}

impl ::protobuf::ProtobufEnum for CompositeMeasureScoringCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompositeMeasureScoringCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CompositeMeasureScoringCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CompositeMeasureScoringCode_Value::OPPORTUNITY),
            2 => ::std::option::Option::Some(CompositeMeasureScoringCode_Value::ALL_OR_NOTHING),
            3 => ::std::option::Option::Some(CompositeMeasureScoringCode_Value::LINEAR),
            4 => ::std::option::Option::Some(CompositeMeasureScoringCode_Value::WEIGHTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CompositeMeasureScoringCode_Value] = &[
            CompositeMeasureScoringCode_Value::INVALID_UNINITIALIZED,
            CompositeMeasureScoringCode_Value::OPPORTUNITY,
            CompositeMeasureScoringCode_Value::ALL_OR_NOTHING,
            CompositeMeasureScoringCode_Value::LINEAR,
            CompositeMeasureScoringCode_Value::WEIGHTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CompositeMeasureScoringCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CompositeMeasureScoringCode_Value {
}

impl ::std::default::Default for CompositeMeasureScoringCode_Value {
    fn default() -> Self {
        CompositeMeasureScoringCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CompositeMeasureScoringCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompositionAttestationModeCode {
    // message fields
    pub value: CompositionAttestationModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CompositionAttestationModeCode {
    pub fn new() -> CompositionAttestationModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CompositionAttestationModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CompositionAttestationModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CompositionAttestationModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CompositionAttestationModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CompositionAttestationModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CompositionAttestationModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CompositionAttestationModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompositionAttestationModeCode {
        CompositionAttestationModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CompositionAttestationModeCode_Value>>(
                    "value",
                    |m: &CompositionAttestationModeCode| { &m.value },
                    |m: &mut CompositionAttestationModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CompositionAttestationModeCode| { &m.id },
                    |m: &mut CompositionAttestationModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CompositionAttestationModeCode| { &m.extension },
                    |m: &mut CompositionAttestationModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompositionAttestationModeCode>(
                    "CompositionAttestationModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CompositionAttestationModeCode {
        static mut instance: ::protobuf::lazy::Lazy<CompositionAttestationModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompositionAttestationModeCode,
        };
        unsafe {
            instance.get(CompositionAttestationModeCode::new)
        }
    }
}

impl ::protobuf::Clear for CompositionAttestationModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompositionAttestationModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompositionAttestationModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CompositionAttestationModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    PERSONAL = 1,
    PROFESSIONAL = 2,
    LEGAL = 3,
    OFFICIAL = 4,
}

impl ::protobuf::ProtobufEnum for CompositionAttestationModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompositionAttestationModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CompositionAttestationModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CompositionAttestationModeCode_Value::PERSONAL),
            2 => ::std::option::Option::Some(CompositionAttestationModeCode_Value::PROFESSIONAL),
            3 => ::std::option::Option::Some(CompositionAttestationModeCode_Value::LEGAL),
            4 => ::std::option::Option::Some(CompositionAttestationModeCode_Value::OFFICIAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CompositionAttestationModeCode_Value] = &[
            CompositionAttestationModeCode_Value::INVALID_UNINITIALIZED,
            CompositionAttestationModeCode_Value::PERSONAL,
            CompositionAttestationModeCode_Value::PROFESSIONAL,
            CompositionAttestationModeCode_Value::LEGAL,
            CompositionAttestationModeCode_Value::OFFICIAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CompositionAttestationModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CompositionAttestationModeCode_Value {
}

impl ::std::default::Default for CompositionAttestationModeCode_Value {
    fn default() -> Self {
        CompositionAttestationModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CompositionAttestationModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompositionStatusCode {
    // message fields
    pub value: CompositionStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CompositionStatusCode {
    pub fn new() -> CompositionStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CompositionStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CompositionStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CompositionStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CompositionStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CompositionStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CompositionStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CompositionStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompositionStatusCode {
        CompositionStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CompositionStatusCode_Value>>(
                    "value",
                    |m: &CompositionStatusCode| { &m.value },
                    |m: &mut CompositionStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CompositionStatusCode| { &m.id },
                    |m: &mut CompositionStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CompositionStatusCode| { &m.extension },
                    |m: &mut CompositionStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompositionStatusCode>(
                    "CompositionStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CompositionStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<CompositionStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompositionStatusCode,
        };
        unsafe {
            instance.get(CompositionStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for CompositionStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompositionStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompositionStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CompositionStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PRELIMINARY = 1,
    FINAL = 2,
    AMENDED = 3,
    ENTERED_IN_ERROR = 4,
}

impl ::protobuf::ProtobufEnum for CompositionStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompositionStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CompositionStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CompositionStatusCode_Value::PRELIMINARY),
            2 => ::std::option::Option::Some(CompositionStatusCode_Value::FINAL),
            3 => ::std::option::Option::Some(CompositionStatusCode_Value::AMENDED),
            4 => ::std::option::Option::Some(CompositionStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CompositionStatusCode_Value] = &[
            CompositionStatusCode_Value::INVALID_UNINITIALIZED,
            CompositionStatusCode_Value::PRELIMINARY,
            CompositionStatusCode_Value::FINAL,
            CompositionStatusCode_Value::AMENDED,
            CompositionStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CompositionStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CompositionStatusCode_Value {
}

impl ::std::default::Default for CompositionStatusCode_Value {
    fn default() -> Self {
        CompositionStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CompositionStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptMapEquivalenceCode {
    // message fields
    pub value: ConceptMapEquivalenceCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConceptMapEquivalenceCode {
    pub fn new() -> ConceptMapEquivalenceCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConceptMapEquivalenceCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConceptMapEquivalenceCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConceptMapEquivalenceCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConceptMapEquivalenceCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConceptMapEquivalenceCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConceptMapEquivalenceCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConceptMapEquivalenceCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptMapEquivalenceCode {
        ConceptMapEquivalenceCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConceptMapEquivalenceCode_Value>>(
                    "value",
                    |m: &ConceptMapEquivalenceCode| { &m.value },
                    |m: &mut ConceptMapEquivalenceCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConceptMapEquivalenceCode| { &m.id },
                    |m: &mut ConceptMapEquivalenceCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConceptMapEquivalenceCode| { &m.extension },
                    |m: &mut ConceptMapEquivalenceCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptMapEquivalenceCode>(
                    "ConceptMapEquivalenceCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptMapEquivalenceCode {
        static mut instance: ::protobuf::lazy::Lazy<ConceptMapEquivalenceCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptMapEquivalenceCode,
        };
        unsafe {
            instance.get(ConceptMapEquivalenceCode::new)
        }
    }
}

impl ::protobuf::Clear for ConceptMapEquivalenceCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptMapEquivalenceCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptMapEquivalenceCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConceptMapEquivalenceCode_Value {
    INVALID_UNINITIALIZED = 0,
    RELATEDTO = 1,
    EQUIVALENT = 2,
    EQUAL = 3,
    WIDER = 4,
    SUBSUMES = 5,
    NARROWER = 6,
    SPECIALIZES = 7,
    INEXACT = 8,
    UNMATCHED = 9,
    DISJOINT = 10,
}

impl ::protobuf::ProtobufEnum for ConceptMapEquivalenceCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConceptMapEquivalenceCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConceptMapEquivalenceCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConceptMapEquivalenceCode_Value::RELATEDTO),
            2 => ::std::option::Option::Some(ConceptMapEquivalenceCode_Value::EQUIVALENT),
            3 => ::std::option::Option::Some(ConceptMapEquivalenceCode_Value::EQUAL),
            4 => ::std::option::Option::Some(ConceptMapEquivalenceCode_Value::WIDER),
            5 => ::std::option::Option::Some(ConceptMapEquivalenceCode_Value::SUBSUMES),
            6 => ::std::option::Option::Some(ConceptMapEquivalenceCode_Value::NARROWER),
            7 => ::std::option::Option::Some(ConceptMapEquivalenceCode_Value::SPECIALIZES),
            8 => ::std::option::Option::Some(ConceptMapEquivalenceCode_Value::INEXACT),
            9 => ::std::option::Option::Some(ConceptMapEquivalenceCode_Value::UNMATCHED),
            10 => ::std::option::Option::Some(ConceptMapEquivalenceCode_Value::DISJOINT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConceptMapEquivalenceCode_Value] = &[
            ConceptMapEquivalenceCode_Value::INVALID_UNINITIALIZED,
            ConceptMapEquivalenceCode_Value::RELATEDTO,
            ConceptMapEquivalenceCode_Value::EQUIVALENT,
            ConceptMapEquivalenceCode_Value::EQUAL,
            ConceptMapEquivalenceCode_Value::WIDER,
            ConceptMapEquivalenceCode_Value::SUBSUMES,
            ConceptMapEquivalenceCode_Value::NARROWER,
            ConceptMapEquivalenceCode_Value::SPECIALIZES,
            ConceptMapEquivalenceCode_Value::INEXACT,
            ConceptMapEquivalenceCode_Value::UNMATCHED,
            ConceptMapEquivalenceCode_Value::DISJOINT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConceptMapEquivalenceCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConceptMapEquivalenceCode_Value {
}

impl ::std::default::Default for ConceptMapEquivalenceCode_Value {
    fn default() -> Self {
        ConceptMapEquivalenceCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptMapEquivalenceCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConceptMapGroupUnmappedModeCode {
    // message fields
    pub value: ConceptMapGroupUnmappedModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConceptMapGroupUnmappedModeCode {
    pub fn new() -> ConceptMapGroupUnmappedModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConceptMapGroupUnmappedModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConceptMapGroupUnmappedModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConceptMapGroupUnmappedModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConceptMapGroupUnmappedModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConceptMapGroupUnmappedModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConceptMapGroupUnmappedModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConceptMapGroupUnmappedModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConceptMapGroupUnmappedModeCode {
        ConceptMapGroupUnmappedModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConceptMapGroupUnmappedModeCode_Value>>(
                    "value",
                    |m: &ConceptMapGroupUnmappedModeCode| { &m.value },
                    |m: &mut ConceptMapGroupUnmappedModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConceptMapGroupUnmappedModeCode| { &m.id },
                    |m: &mut ConceptMapGroupUnmappedModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConceptMapGroupUnmappedModeCode| { &m.extension },
                    |m: &mut ConceptMapGroupUnmappedModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConceptMapGroupUnmappedModeCode>(
                    "ConceptMapGroupUnmappedModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConceptMapGroupUnmappedModeCode {
        static mut instance: ::protobuf::lazy::Lazy<ConceptMapGroupUnmappedModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConceptMapGroupUnmappedModeCode,
        };
        unsafe {
            instance.get(ConceptMapGroupUnmappedModeCode::new)
        }
    }
}

impl ::protobuf::Clear for ConceptMapGroupUnmappedModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConceptMapGroupUnmappedModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptMapGroupUnmappedModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConceptMapGroupUnmappedModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROVIDED = 1,
    FIXED = 2,
    OTHER_MAP = 3,
}

impl ::protobuf::ProtobufEnum for ConceptMapGroupUnmappedModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConceptMapGroupUnmappedModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConceptMapGroupUnmappedModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConceptMapGroupUnmappedModeCode_Value::PROVIDED),
            2 => ::std::option::Option::Some(ConceptMapGroupUnmappedModeCode_Value::FIXED),
            3 => ::std::option::Option::Some(ConceptMapGroupUnmappedModeCode_Value::OTHER_MAP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConceptMapGroupUnmappedModeCode_Value] = &[
            ConceptMapGroupUnmappedModeCode_Value::INVALID_UNINITIALIZED,
            ConceptMapGroupUnmappedModeCode_Value::PROVIDED,
            ConceptMapGroupUnmappedModeCode_Value::FIXED,
            ConceptMapGroupUnmappedModeCode_Value::OTHER_MAP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConceptMapGroupUnmappedModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConceptMapGroupUnmappedModeCode_Value {
}

impl ::std::default::Default for ConceptMapGroupUnmappedModeCode_Value {
    fn default() -> Self {
        ConceptMapGroupUnmappedModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConceptMapGroupUnmappedModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PropertyTypeCode {
    // message fields
    pub value: PropertyTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PropertyTypeCode {
    pub fn new() -> PropertyTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.PropertyTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = PropertyTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: PropertyTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> PropertyTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for PropertyTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != PropertyTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != PropertyTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PropertyTypeCode {
        PropertyTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PropertyTypeCode_Value>>(
                    "value",
                    |m: &PropertyTypeCode| { &m.value },
                    |m: &mut PropertyTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &PropertyTypeCode| { &m.id },
                    |m: &mut PropertyTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &PropertyTypeCode| { &m.extension },
                    |m: &mut PropertyTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PropertyTypeCode>(
                    "PropertyTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PropertyTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<PropertyTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PropertyTypeCode,
        };
        unsafe {
            instance.get(PropertyTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for PropertyTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PropertyTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PropertyTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    CODE = 1,
    CODING = 2,
    STRING = 3,
    INTEGER = 4,
    BOOLEAN = 5,
    DATETIME = 6,
}

impl ::protobuf::ProtobufEnum for PropertyTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PropertyTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(PropertyTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(PropertyTypeCode_Value::CODE),
            2 => ::std::option::Option::Some(PropertyTypeCode_Value::CODING),
            3 => ::std::option::Option::Some(PropertyTypeCode_Value::STRING),
            4 => ::std::option::Option::Some(PropertyTypeCode_Value::INTEGER),
            5 => ::std::option::Option::Some(PropertyTypeCode_Value::BOOLEAN),
            6 => ::std::option::Option::Some(PropertyTypeCode_Value::DATETIME),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PropertyTypeCode_Value] = &[
            PropertyTypeCode_Value::INVALID_UNINITIALIZED,
            PropertyTypeCode_Value::CODE,
            PropertyTypeCode_Value::CODING,
            PropertyTypeCode_Value::STRING,
            PropertyTypeCode_Value::INTEGER,
            PropertyTypeCode_Value::BOOLEAN,
            PropertyTypeCode_Value::DATETIME,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PropertyTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PropertyTypeCode_Value {
}

impl ::std::default::Default for PropertyTypeCode_Value {
    fn default() -> Self {
        PropertyTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConditionalDeleteStatusCode {
    // message fields
    pub value: ConditionalDeleteStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConditionalDeleteStatusCode {
    pub fn new() -> ConditionalDeleteStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConditionalDeleteStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConditionalDeleteStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConditionalDeleteStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConditionalDeleteStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConditionalDeleteStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConditionalDeleteStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConditionalDeleteStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConditionalDeleteStatusCode {
        ConditionalDeleteStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConditionalDeleteStatusCode_Value>>(
                    "value",
                    |m: &ConditionalDeleteStatusCode| { &m.value },
                    |m: &mut ConditionalDeleteStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConditionalDeleteStatusCode| { &m.id },
                    |m: &mut ConditionalDeleteStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConditionalDeleteStatusCode| { &m.extension },
                    |m: &mut ConditionalDeleteStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConditionalDeleteStatusCode>(
                    "ConditionalDeleteStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConditionalDeleteStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ConditionalDeleteStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConditionalDeleteStatusCode,
        };
        unsafe {
            instance.get(ConditionalDeleteStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ConditionalDeleteStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConditionalDeleteStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionalDeleteStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConditionalDeleteStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    NOT_SUPPORTED = 1,
    SINGLE = 2,
    MULTIPLE = 3,
}

impl ::protobuf::ProtobufEnum for ConditionalDeleteStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConditionalDeleteStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConditionalDeleteStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConditionalDeleteStatusCode_Value::NOT_SUPPORTED),
            2 => ::std::option::Option::Some(ConditionalDeleteStatusCode_Value::SINGLE),
            3 => ::std::option::Option::Some(ConditionalDeleteStatusCode_Value::MULTIPLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConditionalDeleteStatusCode_Value] = &[
            ConditionalDeleteStatusCode_Value::INVALID_UNINITIALIZED,
            ConditionalDeleteStatusCode_Value::NOT_SUPPORTED,
            ConditionalDeleteStatusCode_Value::SINGLE,
            ConditionalDeleteStatusCode_Value::MULTIPLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConditionalDeleteStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConditionalDeleteStatusCode_Value {
}

impl ::std::default::Default for ConditionalDeleteStatusCode_Value {
    fn default() -> Self {
        ConditionalDeleteStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionalDeleteStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConditionalReadStatusCode {
    // message fields
    pub value: ConditionalReadStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConditionalReadStatusCode {
    pub fn new() -> ConditionalReadStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConditionalReadStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConditionalReadStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConditionalReadStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConditionalReadStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConditionalReadStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConditionalReadStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConditionalReadStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConditionalReadStatusCode {
        ConditionalReadStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConditionalReadStatusCode_Value>>(
                    "value",
                    |m: &ConditionalReadStatusCode| { &m.value },
                    |m: &mut ConditionalReadStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConditionalReadStatusCode| { &m.id },
                    |m: &mut ConditionalReadStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConditionalReadStatusCode| { &m.extension },
                    |m: &mut ConditionalReadStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConditionalReadStatusCode>(
                    "ConditionalReadStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConditionalReadStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ConditionalReadStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConditionalReadStatusCode,
        };
        unsafe {
            instance.get(ConditionalReadStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ConditionalReadStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConditionalReadStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionalReadStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConditionalReadStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    NOT_SUPPORTED = 1,
    MODIFIED_SINCE = 2,
    NOT_MATCH = 3,
    FULL_SUPPORT = 4,
}

impl ::protobuf::ProtobufEnum for ConditionalReadStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConditionalReadStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConditionalReadStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConditionalReadStatusCode_Value::NOT_SUPPORTED),
            2 => ::std::option::Option::Some(ConditionalReadStatusCode_Value::MODIFIED_SINCE),
            3 => ::std::option::Option::Some(ConditionalReadStatusCode_Value::NOT_MATCH),
            4 => ::std::option::Option::Some(ConditionalReadStatusCode_Value::FULL_SUPPORT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConditionalReadStatusCode_Value] = &[
            ConditionalReadStatusCode_Value::INVALID_UNINITIALIZED,
            ConditionalReadStatusCode_Value::NOT_SUPPORTED,
            ConditionalReadStatusCode_Value::MODIFIED_SINCE,
            ConditionalReadStatusCode_Value::NOT_MATCH,
            ConditionalReadStatusCode_Value::FULL_SUPPORT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConditionalReadStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConditionalReadStatusCode_Value {
}

impl ::std::default::Default for ConditionalReadStatusCode_Value {
    fn default() -> Self {
        ConditionalReadStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionalReadStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConditionCategoryCodesCode {
    // message fields
    pub value: ConditionCategoryCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConditionCategoryCodesCode {
    pub fn new() -> ConditionCategoryCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConditionCategoryCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConditionCategoryCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConditionCategoryCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConditionCategoryCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConditionCategoryCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConditionCategoryCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConditionCategoryCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConditionCategoryCodesCode {
        ConditionCategoryCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConditionCategoryCodesCode_Value>>(
                    "value",
                    |m: &ConditionCategoryCodesCode| { &m.value },
                    |m: &mut ConditionCategoryCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConditionCategoryCodesCode| { &m.id },
                    |m: &mut ConditionCategoryCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConditionCategoryCodesCode| { &m.extension },
                    |m: &mut ConditionCategoryCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConditionCategoryCodesCode>(
                    "ConditionCategoryCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConditionCategoryCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ConditionCategoryCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConditionCategoryCodesCode,
        };
        unsafe {
            instance.get(ConditionCategoryCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ConditionCategoryCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConditionCategoryCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionCategoryCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConditionCategoryCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROBLEM_LIST_ITEM = 1,
    ENCOUNTER_DIAGNOSIS = 2,
}

impl ::protobuf::ProtobufEnum for ConditionCategoryCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConditionCategoryCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConditionCategoryCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConditionCategoryCodesCode_Value::PROBLEM_LIST_ITEM),
            2 => ::std::option::Option::Some(ConditionCategoryCodesCode_Value::ENCOUNTER_DIAGNOSIS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConditionCategoryCodesCode_Value] = &[
            ConditionCategoryCodesCode_Value::INVALID_UNINITIALIZED,
            ConditionCategoryCodesCode_Value::PROBLEM_LIST_ITEM,
            ConditionCategoryCodesCode_Value::ENCOUNTER_DIAGNOSIS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConditionCategoryCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConditionCategoryCodesCode_Value {
}

impl ::std::default::Default for ConditionCategoryCodesCode_Value {
    fn default() -> Self {
        ConditionCategoryCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionCategoryCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConditionClinicalStatusCodesCode {
    // message fields
    pub value: ConditionClinicalStatusCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConditionClinicalStatusCodesCode {
    pub fn new() -> ConditionClinicalStatusCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConditionClinicalStatusCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConditionClinicalStatusCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConditionClinicalStatusCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConditionClinicalStatusCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConditionClinicalStatusCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConditionClinicalStatusCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConditionClinicalStatusCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConditionClinicalStatusCodesCode {
        ConditionClinicalStatusCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConditionClinicalStatusCodesCode_Value>>(
                    "value",
                    |m: &ConditionClinicalStatusCodesCode| { &m.value },
                    |m: &mut ConditionClinicalStatusCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConditionClinicalStatusCodesCode| { &m.id },
                    |m: &mut ConditionClinicalStatusCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConditionClinicalStatusCodesCode| { &m.extension },
                    |m: &mut ConditionClinicalStatusCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConditionClinicalStatusCodesCode>(
                    "ConditionClinicalStatusCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConditionClinicalStatusCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ConditionClinicalStatusCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConditionClinicalStatusCodesCode,
        };
        unsafe {
            instance.get(ConditionClinicalStatusCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ConditionClinicalStatusCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConditionClinicalStatusCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionClinicalStatusCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConditionClinicalStatusCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    RECURRENCE = 2,
    INACTIVE = 3,
    REMISSION = 4,
    RESOLVED = 5,
}

impl ::protobuf::ProtobufEnum for ConditionClinicalStatusCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConditionClinicalStatusCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConditionClinicalStatusCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConditionClinicalStatusCodesCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(ConditionClinicalStatusCodesCode_Value::RECURRENCE),
            3 => ::std::option::Option::Some(ConditionClinicalStatusCodesCode_Value::INACTIVE),
            4 => ::std::option::Option::Some(ConditionClinicalStatusCodesCode_Value::REMISSION),
            5 => ::std::option::Option::Some(ConditionClinicalStatusCodesCode_Value::RESOLVED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConditionClinicalStatusCodesCode_Value] = &[
            ConditionClinicalStatusCodesCode_Value::INVALID_UNINITIALIZED,
            ConditionClinicalStatusCodesCode_Value::ACTIVE,
            ConditionClinicalStatusCodesCode_Value::RECURRENCE,
            ConditionClinicalStatusCodesCode_Value::INACTIVE,
            ConditionClinicalStatusCodesCode_Value::REMISSION,
            ConditionClinicalStatusCodesCode_Value::RESOLVED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConditionClinicalStatusCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConditionClinicalStatusCodesCode_Value {
}

impl ::std::default::Default for ConditionClinicalStatusCodesCode_Value {
    fn default() -> Self {
        ConditionClinicalStatusCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionClinicalStatusCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConditionStateCode {
    // message fields
    pub value: ConditionStateCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConditionStateCode {
    pub fn new() -> ConditionStateCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConditionStateCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConditionStateCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConditionStateCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConditionStateCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConditionStateCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConditionStateCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConditionStateCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConditionStateCode {
        ConditionStateCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConditionStateCode_Value>>(
                    "value",
                    |m: &ConditionStateCode| { &m.value },
                    |m: &mut ConditionStateCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConditionStateCode| { &m.id },
                    |m: &mut ConditionStateCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConditionStateCode| { &m.extension },
                    |m: &mut ConditionStateCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConditionStateCode>(
                    "ConditionStateCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConditionStateCode {
        static mut instance: ::protobuf::lazy::Lazy<ConditionStateCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConditionStateCode,
        };
        unsafe {
            instance.get(ConditionStateCode::new)
        }
    }
}

impl ::protobuf::Clear for ConditionStateCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConditionStateCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionStateCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConditionStateCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    INACTIVE = 2,
    RESOLVED = 3,
}

impl ::protobuf::ProtobufEnum for ConditionStateCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConditionStateCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConditionStateCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConditionStateCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(ConditionStateCode_Value::INACTIVE),
            3 => ::std::option::Option::Some(ConditionStateCode_Value::RESOLVED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConditionStateCode_Value] = &[
            ConditionStateCode_Value::INVALID_UNINITIALIZED,
            ConditionStateCode_Value::ACTIVE,
            ConditionStateCode_Value::INACTIVE,
            ConditionStateCode_Value::RESOLVED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConditionStateCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConditionStateCode_Value {
}

impl ::std::default::Default for ConditionStateCode_Value {
    fn default() -> Self {
        ConditionStateCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionStateCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConditionVerificationStatusCode {
    // message fields
    pub value: ConditionVerificationStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConditionVerificationStatusCode {
    pub fn new() -> ConditionVerificationStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConditionVerificationStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConditionVerificationStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConditionVerificationStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConditionVerificationStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConditionVerificationStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConditionVerificationStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConditionVerificationStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConditionVerificationStatusCode {
        ConditionVerificationStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConditionVerificationStatusCode_Value>>(
                    "value",
                    |m: &ConditionVerificationStatusCode| { &m.value },
                    |m: &mut ConditionVerificationStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConditionVerificationStatusCode| { &m.id },
                    |m: &mut ConditionVerificationStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConditionVerificationStatusCode| { &m.extension },
                    |m: &mut ConditionVerificationStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConditionVerificationStatusCode>(
                    "ConditionVerificationStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConditionVerificationStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ConditionVerificationStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConditionVerificationStatusCode,
        };
        unsafe {
            instance.get(ConditionVerificationStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ConditionVerificationStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConditionVerificationStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionVerificationStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConditionVerificationStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROVISIONAL = 1,
    DIFFERENTIAL = 2,
    CONFIRMED = 3,
    REFUTED = 4,
    ENTERED_IN_ERROR = 5,
    UNKNOWN = 6,
}

impl ::protobuf::ProtobufEnum for ConditionVerificationStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConditionVerificationStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConditionVerificationStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConditionVerificationStatusCode_Value::PROVISIONAL),
            2 => ::std::option::Option::Some(ConditionVerificationStatusCode_Value::DIFFERENTIAL),
            3 => ::std::option::Option::Some(ConditionVerificationStatusCode_Value::CONFIRMED),
            4 => ::std::option::Option::Some(ConditionVerificationStatusCode_Value::REFUTED),
            5 => ::std::option::Option::Some(ConditionVerificationStatusCode_Value::ENTERED_IN_ERROR),
            6 => ::std::option::Option::Some(ConditionVerificationStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConditionVerificationStatusCode_Value] = &[
            ConditionVerificationStatusCode_Value::INVALID_UNINITIALIZED,
            ConditionVerificationStatusCode_Value::PROVISIONAL,
            ConditionVerificationStatusCode_Value::DIFFERENTIAL,
            ConditionVerificationStatusCode_Value::CONFIRMED,
            ConditionVerificationStatusCode_Value::REFUTED,
            ConditionVerificationStatusCode_Value::ENTERED_IN_ERROR,
            ConditionVerificationStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConditionVerificationStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConditionVerificationStatusCode_Value {
}

impl ::std::default::Default for ConditionVerificationStatusCode_Value {
    fn default() -> Self {
        ConditionVerificationStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConditionVerificationStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConformanceExpectationCode {
    // message fields
    pub value: ConformanceExpectationCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConformanceExpectationCode {
    pub fn new() -> ConformanceExpectationCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConformanceExpectationCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConformanceExpectationCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConformanceExpectationCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConformanceExpectationCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConformanceExpectationCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConformanceExpectationCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConformanceExpectationCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConformanceExpectationCode {
        ConformanceExpectationCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConformanceExpectationCode_Value>>(
                    "value",
                    |m: &ConformanceExpectationCode| { &m.value },
                    |m: &mut ConformanceExpectationCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConformanceExpectationCode| { &m.id },
                    |m: &mut ConformanceExpectationCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConformanceExpectationCode| { &m.extension },
                    |m: &mut ConformanceExpectationCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConformanceExpectationCode>(
                    "ConformanceExpectationCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConformanceExpectationCode {
        static mut instance: ::protobuf::lazy::Lazy<ConformanceExpectationCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConformanceExpectationCode,
        };
        unsafe {
            instance.get(ConformanceExpectationCode::new)
        }
    }
}

impl ::protobuf::Clear for ConformanceExpectationCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConformanceExpectationCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConformanceExpectationCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConformanceExpectationCode_Value {
    INVALID_UNINITIALIZED = 0,
    SHALL = 1,
    SHOULD = 2,
    MAY = 3,
    SHOULD_NOT = 4,
}

impl ::protobuf::ProtobufEnum for ConformanceExpectationCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConformanceExpectationCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConformanceExpectationCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConformanceExpectationCode_Value::SHALL),
            2 => ::std::option::Option::Some(ConformanceExpectationCode_Value::SHOULD),
            3 => ::std::option::Option::Some(ConformanceExpectationCode_Value::MAY),
            4 => ::std::option::Option::Some(ConformanceExpectationCode_Value::SHOULD_NOT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConformanceExpectationCode_Value] = &[
            ConformanceExpectationCode_Value::INVALID_UNINITIALIZED,
            ConformanceExpectationCode_Value::SHALL,
            ConformanceExpectationCode_Value::SHOULD,
            ConformanceExpectationCode_Value::MAY,
            ConformanceExpectationCode_Value::SHOULD_NOT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConformanceExpectationCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConformanceExpectationCode_Value {
}

impl ::std::default::Default for ConformanceExpectationCode_Value {
    fn default() -> Self {
        ConformanceExpectationCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConformanceExpectationCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConsentDataMeaningCode {
    // message fields
    pub value: ConsentDataMeaningCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConsentDataMeaningCode {
    pub fn new() -> ConsentDataMeaningCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConsentDataMeaningCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConsentDataMeaningCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConsentDataMeaningCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConsentDataMeaningCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConsentDataMeaningCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConsentDataMeaningCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConsentDataMeaningCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsentDataMeaningCode {
        ConsentDataMeaningCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConsentDataMeaningCode_Value>>(
                    "value",
                    |m: &ConsentDataMeaningCode| { &m.value },
                    |m: &mut ConsentDataMeaningCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConsentDataMeaningCode| { &m.id },
                    |m: &mut ConsentDataMeaningCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConsentDataMeaningCode| { &m.extension },
                    |m: &mut ConsentDataMeaningCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConsentDataMeaningCode>(
                    "ConsentDataMeaningCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConsentDataMeaningCode {
        static mut instance: ::protobuf::lazy::Lazy<ConsentDataMeaningCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConsentDataMeaningCode,
        };
        unsafe {
            instance.get(ConsentDataMeaningCode::new)
        }
    }
}

impl ::protobuf::Clear for ConsentDataMeaningCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsentDataMeaningCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsentDataMeaningCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConsentDataMeaningCode_Value {
    INVALID_UNINITIALIZED = 0,
    INSTANCE = 1,
    RELATED = 2,
    DEPENDENTS = 3,
    AUTHOREDBY = 4,
}

impl ::protobuf::ProtobufEnum for ConsentDataMeaningCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConsentDataMeaningCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConsentDataMeaningCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConsentDataMeaningCode_Value::INSTANCE),
            2 => ::std::option::Option::Some(ConsentDataMeaningCode_Value::RELATED),
            3 => ::std::option::Option::Some(ConsentDataMeaningCode_Value::DEPENDENTS),
            4 => ::std::option::Option::Some(ConsentDataMeaningCode_Value::AUTHOREDBY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConsentDataMeaningCode_Value] = &[
            ConsentDataMeaningCode_Value::INVALID_UNINITIALIZED,
            ConsentDataMeaningCode_Value::INSTANCE,
            ConsentDataMeaningCode_Value::RELATED,
            ConsentDataMeaningCode_Value::DEPENDENTS,
            ConsentDataMeaningCode_Value::AUTHOREDBY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConsentDataMeaningCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConsentDataMeaningCode_Value {
}

impl ::std::default::Default for ConsentDataMeaningCode_Value {
    fn default() -> Self {
        ConsentDataMeaningCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsentDataMeaningCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConsentExceptTypeCode {
    // message fields
    pub value: ConsentExceptTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConsentExceptTypeCode {
    pub fn new() -> ConsentExceptTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConsentExceptTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConsentExceptTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConsentExceptTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConsentExceptTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConsentExceptTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConsentExceptTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConsentExceptTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsentExceptTypeCode {
        ConsentExceptTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConsentExceptTypeCode_Value>>(
                    "value",
                    |m: &ConsentExceptTypeCode| { &m.value },
                    |m: &mut ConsentExceptTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConsentExceptTypeCode| { &m.id },
                    |m: &mut ConsentExceptTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConsentExceptTypeCode| { &m.extension },
                    |m: &mut ConsentExceptTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConsentExceptTypeCode>(
                    "ConsentExceptTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConsentExceptTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ConsentExceptTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConsentExceptTypeCode,
        };
        unsafe {
            instance.get(ConsentExceptTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ConsentExceptTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsentExceptTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsentExceptTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConsentExceptTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    DENY = 1,
    PERMIT = 2,
}

impl ::protobuf::ProtobufEnum for ConsentExceptTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConsentExceptTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConsentExceptTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConsentExceptTypeCode_Value::DENY),
            2 => ::std::option::Option::Some(ConsentExceptTypeCode_Value::PERMIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConsentExceptTypeCode_Value] = &[
            ConsentExceptTypeCode_Value::INVALID_UNINITIALIZED,
            ConsentExceptTypeCode_Value::DENY,
            ConsentExceptTypeCode_Value::PERMIT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConsentExceptTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConsentExceptTypeCode_Value {
}

impl ::std::default::Default for ConsentExceptTypeCode_Value {
    fn default() -> Self {
        ConsentExceptTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsentExceptTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConsentStateCode {
    // message fields
    pub value: ConsentStateCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConsentStateCode {
    pub fn new() -> ConsentStateCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConsentStateCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConsentStateCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConsentStateCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConsentStateCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConsentStateCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConsentStateCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConsentStateCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsentStateCode {
        ConsentStateCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConsentStateCode_Value>>(
                    "value",
                    |m: &ConsentStateCode| { &m.value },
                    |m: &mut ConsentStateCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConsentStateCode| { &m.id },
                    |m: &mut ConsentStateCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConsentStateCode| { &m.extension },
                    |m: &mut ConsentStateCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConsentStateCode>(
                    "ConsentStateCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConsentStateCode {
        static mut instance: ::protobuf::lazy::Lazy<ConsentStateCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConsentStateCode,
        };
        unsafe {
            instance.get(ConsentStateCode::new)
        }
    }
}

impl ::protobuf::Clear for ConsentStateCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsentStateCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsentStateCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConsentStateCode_Value {
    INVALID_UNINITIALIZED = 0,
    DRAFT = 1,
    PROPOSED = 2,
    ACTIVE = 3,
    REJECTED = 4,
    INACTIVE = 5,
    ENTERED_IN_ERROR = 6,
}

impl ::protobuf::ProtobufEnum for ConsentStateCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConsentStateCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConsentStateCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConsentStateCode_Value::DRAFT),
            2 => ::std::option::Option::Some(ConsentStateCode_Value::PROPOSED),
            3 => ::std::option::Option::Some(ConsentStateCode_Value::ACTIVE),
            4 => ::std::option::Option::Some(ConsentStateCode_Value::REJECTED),
            5 => ::std::option::Option::Some(ConsentStateCode_Value::INACTIVE),
            6 => ::std::option::Option::Some(ConsentStateCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConsentStateCode_Value] = &[
            ConsentStateCode_Value::INVALID_UNINITIALIZED,
            ConsentStateCode_Value::DRAFT,
            ConsentStateCode_Value::PROPOSED,
            ConsentStateCode_Value::ACTIVE,
            ConsentStateCode_Value::REJECTED,
            ConsentStateCode_Value::INACTIVE,
            ConsentStateCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConsentStateCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConsentStateCode_Value {
}

impl ::std::default::Default for ConsentStateCode_Value {
    fn default() -> Self {
        ConsentStateCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsentStateCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContactEntityTypeCode {
    // message fields
    pub value: ContactEntityTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ContactEntityTypeCode {
    pub fn new() -> ContactEntityTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ContactEntityTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ContactEntityTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ContactEntityTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ContactEntityTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ContactEntityTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ContactEntityTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ContactEntityTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContactEntityTypeCode {
        ContactEntityTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContactEntityTypeCode_Value>>(
                    "value",
                    |m: &ContactEntityTypeCode| { &m.value },
                    |m: &mut ContactEntityTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ContactEntityTypeCode| { &m.id },
                    |m: &mut ContactEntityTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ContactEntityTypeCode| { &m.extension },
                    |m: &mut ContactEntityTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContactEntityTypeCode>(
                    "ContactEntityTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContactEntityTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ContactEntityTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContactEntityTypeCode,
        };
        unsafe {
            instance.get(ContactEntityTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ContactEntityTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContactEntityTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactEntityTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContactEntityTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    BILL = 1,
    ADMIN = 2,
    HR = 3,
    PAYOR = 4,
    PATINF = 5,
    PRESS = 6,
}

impl ::protobuf::ProtobufEnum for ContactEntityTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContactEntityTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ContactEntityTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ContactEntityTypeCode_Value::BILL),
            2 => ::std::option::Option::Some(ContactEntityTypeCode_Value::ADMIN),
            3 => ::std::option::Option::Some(ContactEntityTypeCode_Value::HR),
            4 => ::std::option::Option::Some(ContactEntityTypeCode_Value::PAYOR),
            5 => ::std::option::Option::Some(ContactEntityTypeCode_Value::PATINF),
            6 => ::std::option::Option::Some(ContactEntityTypeCode_Value::PRESS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContactEntityTypeCode_Value] = &[
            ContactEntityTypeCode_Value::INVALID_UNINITIALIZED,
            ContactEntityTypeCode_Value::BILL,
            ContactEntityTypeCode_Value::ADMIN,
            ContactEntityTypeCode_Value::HR,
            ContactEntityTypeCode_Value::PAYOR,
            ContactEntityTypeCode_Value::PATINF,
            ContactEntityTypeCode_Value::PRESS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContactEntityTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContactEntityTypeCode_Value {
}

impl ::std::default::Default for ContactEntityTypeCode_Value {
    fn default() -> Self {
        ContactEntityTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactEntityTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContentTypeCode {
    // message fields
    pub value: ContentTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ContentTypeCode {
    pub fn new() -> ContentTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ContentTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ContentTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ContentTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ContentTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ContentTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ContentTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ContentTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentTypeCode {
        ContentTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContentTypeCode_Value>>(
                    "value",
                    |m: &ContentTypeCode| { &m.value },
                    |m: &mut ContentTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ContentTypeCode| { &m.id },
                    |m: &mut ContentTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ContentTypeCode| { &m.extension },
                    |m: &mut ContentTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContentTypeCode>(
                    "ContentTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContentTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ContentTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContentTypeCode,
        };
        unsafe {
            instance.get(ContentTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ContentTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContentTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    XML = 1,
    JSON = 2,
    TTL = 3,
    NONE = 4,
}

impl ::protobuf::ProtobufEnum for ContentTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContentTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ContentTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ContentTypeCode_Value::XML),
            2 => ::std::option::Option::Some(ContentTypeCode_Value::JSON),
            3 => ::std::option::Option::Some(ContentTypeCode_Value::TTL),
            4 => ::std::option::Option::Some(ContentTypeCode_Value::NONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContentTypeCode_Value] = &[
            ContentTypeCode_Value::INVALID_UNINITIALIZED,
            ContentTypeCode_Value::XML,
            ContentTypeCode_Value::JSON,
            ContentTypeCode_Value::TTL,
            ContentTypeCode_Value::NONE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContentTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContentTypeCode_Value {
}

impl ::std::default::Default for ContentTypeCode_Value {
    fn default() -> Self {
        ContentTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContractResourceStatusCode {
    // message fields
    pub value: ContractResourceStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ContractResourceStatusCode {
    pub fn new() -> ContractResourceStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ContractResourceStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ContractResourceStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ContractResourceStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ContractResourceStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ContractResourceStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ContractResourceStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ContractResourceStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractResourceStatusCode {
        ContractResourceStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContractResourceStatusCode_Value>>(
                    "value",
                    |m: &ContractResourceStatusCode| { &m.value },
                    |m: &mut ContractResourceStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ContractResourceStatusCode| { &m.id },
                    |m: &mut ContractResourceStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ContractResourceStatusCode| { &m.extension },
                    |m: &mut ContractResourceStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContractResourceStatusCode>(
                    "ContractResourceStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContractResourceStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ContractResourceStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContractResourceStatusCode,
        };
        unsafe {
            instance.get(ContractResourceStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ContractResourceStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractResourceStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractResourceStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContractResourceStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    AMENDED = 1,
    APPENDED = 2,
    CANCELLED = 3,
    DISPUTED = 4,
    ENTERED_IN_ERROR = 5,
    EXECUTABLE = 6,
    EXECUTED = 7,
    NEGOTIABLE = 8,
    OFFERED = 9,
    POLICY = 10,
    REJECTED = 11,
    RENEWED = 12,
    REVOKED = 13,
    RESOLVED = 14,
    TERMINATED = 15,
}

impl ::protobuf::ProtobufEnum for ContractResourceStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContractResourceStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ContractResourceStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ContractResourceStatusCode_Value::AMENDED),
            2 => ::std::option::Option::Some(ContractResourceStatusCode_Value::APPENDED),
            3 => ::std::option::Option::Some(ContractResourceStatusCode_Value::CANCELLED),
            4 => ::std::option::Option::Some(ContractResourceStatusCode_Value::DISPUTED),
            5 => ::std::option::Option::Some(ContractResourceStatusCode_Value::ENTERED_IN_ERROR),
            6 => ::std::option::Option::Some(ContractResourceStatusCode_Value::EXECUTABLE),
            7 => ::std::option::Option::Some(ContractResourceStatusCode_Value::EXECUTED),
            8 => ::std::option::Option::Some(ContractResourceStatusCode_Value::NEGOTIABLE),
            9 => ::std::option::Option::Some(ContractResourceStatusCode_Value::OFFERED),
            10 => ::std::option::Option::Some(ContractResourceStatusCode_Value::POLICY),
            11 => ::std::option::Option::Some(ContractResourceStatusCode_Value::REJECTED),
            12 => ::std::option::Option::Some(ContractResourceStatusCode_Value::RENEWED),
            13 => ::std::option::Option::Some(ContractResourceStatusCode_Value::REVOKED),
            14 => ::std::option::Option::Some(ContractResourceStatusCode_Value::RESOLVED),
            15 => ::std::option::Option::Some(ContractResourceStatusCode_Value::TERMINATED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContractResourceStatusCode_Value] = &[
            ContractResourceStatusCode_Value::INVALID_UNINITIALIZED,
            ContractResourceStatusCode_Value::AMENDED,
            ContractResourceStatusCode_Value::APPENDED,
            ContractResourceStatusCode_Value::CANCELLED,
            ContractResourceStatusCode_Value::DISPUTED,
            ContractResourceStatusCode_Value::ENTERED_IN_ERROR,
            ContractResourceStatusCode_Value::EXECUTABLE,
            ContractResourceStatusCode_Value::EXECUTED,
            ContractResourceStatusCode_Value::NEGOTIABLE,
            ContractResourceStatusCode_Value::OFFERED,
            ContractResourceStatusCode_Value::POLICY,
            ContractResourceStatusCode_Value::REJECTED,
            ContractResourceStatusCode_Value::RENEWED,
            ContractResourceStatusCode_Value::REVOKED,
            ContractResourceStatusCode_Value::RESOLVED,
            ContractResourceStatusCode_Value::TERMINATED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContractResourceStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContractResourceStatusCode_Value {
}

impl ::std::default::Default for ContractResourceStatusCode_Value {
    fn default() -> Self {
        ContractResourceStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractResourceStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContributorTypeCode {
    // message fields
    pub value: ContributorTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ContributorTypeCode {
    pub fn new() -> ContributorTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ContributorTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ContributorTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ContributorTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ContributorTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ContributorTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ContributorTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ContributorTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContributorTypeCode {
        ContributorTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ContributorTypeCode_Value>>(
                    "value",
                    |m: &ContributorTypeCode| { &m.value },
                    |m: &mut ContributorTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ContributorTypeCode| { &m.id },
                    |m: &mut ContributorTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ContributorTypeCode| { &m.extension },
                    |m: &mut ContributorTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContributorTypeCode>(
                    "ContributorTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContributorTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ContributorTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContributorTypeCode,
        };
        unsafe {
            instance.get(ContributorTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ContributorTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContributorTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContributorTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContributorTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    AUTHOR = 1,
    EDITOR = 2,
    REVIEWER = 3,
    ENDORSER = 4,
}

impl ::protobuf::ProtobufEnum for ContributorTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContributorTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ContributorTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ContributorTypeCode_Value::AUTHOR),
            2 => ::std::option::Option::Some(ContributorTypeCode_Value::EDITOR),
            3 => ::std::option::Option::Some(ContributorTypeCode_Value::REVIEWER),
            4 => ::std::option::Option::Some(ContributorTypeCode_Value::ENDORSER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContributorTypeCode_Value] = &[
            ContributorTypeCode_Value::INVALID_UNINITIALIZED,
            ContributorTypeCode_Value::AUTHOR,
            ContributorTypeCode_Value::EDITOR,
            ContributorTypeCode_Value::REVIEWER,
            ContributorTypeCode_Value::ENDORSER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContributorTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContributorTypeCode_Value {
}

impl ::std::default::Default for ContributorTypeCode_Value {
    fn default() -> Self {
        ContributorTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ContributorTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CopyNumberEventCode {
    // message fields
    pub value: CopyNumberEventCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CopyNumberEventCode {
    pub fn new() -> CopyNumberEventCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.CopyNumberEventCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = CopyNumberEventCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: CopyNumberEventCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> CopyNumberEventCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for CopyNumberEventCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != CopyNumberEventCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != CopyNumberEventCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CopyNumberEventCode {
        CopyNumberEventCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CopyNumberEventCode_Value>>(
                    "value",
                    |m: &CopyNumberEventCode| { &m.value },
                    |m: &mut CopyNumberEventCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &CopyNumberEventCode| { &m.id },
                    |m: &mut CopyNumberEventCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &CopyNumberEventCode| { &m.extension },
                    |m: &mut CopyNumberEventCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CopyNumberEventCode>(
                    "CopyNumberEventCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CopyNumberEventCode {
        static mut instance: ::protobuf::lazy::Lazy<CopyNumberEventCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CopyNumberEventCode,
        };
        unsafe {
            instance.get(CopyNumberEventCode::new)
        }
    }
}

impl ::protobuf::Clear for CopyNumberEventCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CopyNumberEventCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyNumberEventCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CopyNumberEventCode_Value {
    INVALID_UNINITIALIZED = 0,
    AMP = 1,
    DEL = 2,
    LOF = 3,
}

impl ::protobuf::ProtobufEnum for CopyNumberEventCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CopyNumberEventCode_Value> {
        match value {
            0 => ::std::option::Option::Some(CopyNumberEventCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(CopyNumberEventCode_Value::AMP),
            2 => ::std::option::Option::Some(CopyNumberEventCode_Value::DEL),
            3 => ::std::option::Option::Some(CopyNumberEventCode_Value::LOF),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CopyNumberEventCode_Value] = &[
            CopyNumberEventCode_Value::INVALID_UNINITIALIZED,
            CopyNumberEventCode_Value::AMP,
            CopyNumberEventCode_Value::DEL,
            CopyNumberEventCode_Value::LOF,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CopyNumberEventCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CopyNumberEventCode_Value {
}

impl ::std::default::Default for CopyNumberEventCode_Value {
    fn default() -> Self {
        CopyNumberEventCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for CopyNumberEventCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataAbsentReasonCode {
    // message fields
    pub value: DataAbsentReasonCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DataAbsentReasonCode {
    pub fn new() -> DataAbsentReasonCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DataAbsentReasonCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DataAbsentReasonCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DataAbsentReasonCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DataAbsentReasonCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DataAbsentReasonCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DataAbsentReasonCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DataAbsentReasonCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataAbsentReasonCode {
        DataAbsentReasonCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataAbsentReasonCode_Value>>(
                    "value",
                    |m: &DataAbsentReasonCode| { &m.value },
                    |m: &mut DataAbsentReasonCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DataAbsentReasonCode| { &m.id },
                    |m: &mut DataAbsentReasonCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DataAbsentReasonCode| { &m.extension },
                    |m: &mut DataAbsentReasonCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataAbsentReasonCode>(
                    "DataAbsentReasonCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DataAbsentReasonCode {
        static mut instance: ::protobuf::lazy::Lazy<DataAbsentReasonCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataAbsentReasonCode,
        };
        unsafe {
            instance.get(DataAbsentReasonCode::new)
        }
    }
}

impl ::protobuf::Clear for DataAbsentReasonCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataAbsentReasonCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataAbsentReasonCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataAbsentReasonCode_Value {
    INVALID_UNINITIALIZED = 0,
    UNKNOWN = 1,
    ASKED = 2,
    TEMP = 3,
    NOT_ASKED = 4,
    MASKED = 5,
    UNSUPPORTED = 6,
    ASTEXT = 7,
    ERROR = 8,
    NOT_A_NUMBER = 9,
    NOT_PERFORMED = 10,
}

impl ::protobuf::ProtobufEnum for DataAbsentReasonCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataAbsentReasonCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DataAbsentReasonCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DataAbsentReasonCode_Value::UNKNOWN),
            2 => ::std::option::Option::Some(DataAbsentReasonCode_Value::ASKED),
            3 => ::std::option::Option::Some(DataAbsentReasonCode_Value::TEMP),
            4 => ::std::option::Option::Some(DataAbsentReasonCode_Value::NOT_ASKED),
            5 => ::std::option::Option::Some(DataAbsentReasonCode_Value::MASKED),
            6 => ::std::option::Option::Some(DataAbsentReasonCode_Value::UNSUPPORTED),
            7 => ::std::option::Option::Some(DataAbsentReasonCode_Value::ASTEXT),
            8 => ::std::option::Option::Some(DataAbsentReasonCode_Value::ERROR),
            9 => ::std::option::Option::Some(DataAbsentReasonCode_Value::NOT_A_NUMBER),
            10 => ::std::option::Option::Some(DataAbsentReasonCode_Value::NOT_PERFORMED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataAbsentReasonCode_Value] = &[
            DataAbsentReasonCode_Value::INVALID_UNINITIALIZED,
            DataAbsentReasonCode_Value::UNKNOWN,
            DataAbsentReasonCode_Value::ASKED,
            DataAbsentReasonCode_Value::TEMP,
            DataAbsentReasonCode_Value::NOT_ASKED,
            DataAbsentReasonCode_Value::MASKED,
            DataAbsentReasonCode_Value::UNSUPPORTED,
            DataAbsentReasonCode_Value::ASTEXT,
            DataAbsentReasonCode_Value::ERROR,
            DataAbsentReasonCode_Value::NOT_A_NUMBER,
            DataAbsentReasonCode_Value::NOT_PERFORMED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DataAbsentReasonCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DataAbsentReasonCode_Value {
}

impl ::std::default::Default for DataAbsentReasonCode_Value {
    fn default() -> Self {
        DataAbsentReasonCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DataAbsentReasonCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataElementStringencyCode {
    // message fields
    pub value: DataElementStringencyCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DataElementStringencyCode {
    pub fn new() -> DataElementStringencyCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DataElementStringencyCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DataElementStringencyCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DataElementStringencyCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DataElementStringencyCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DataElementStringencyCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DataElementStringencyCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DataElementStringencyCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataElementStringencyCode {
        DataElementStringencyCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataElementStringencyCode_Value>>(
                    "value",
                    |m: &DataElementStringencyCode| { &m.value },
                    |m: &mut DataElementStringencyCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DataElementStringencyCode| { &m.id },
                    |m: &mut DataElementStringencyCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DataElementStringencyCode| { &m.extension },
                    |m: &mut DataElementStringencyCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataElementStringencyCode>(
                    "DataElementStringencyCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DataElementStringencyCode {
        static mut instance: ::protobuf::lazy::Lazy<DataElementStringencyCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataElementStringencyCode,
        };
        unsafe {
            instance.get(DataElementStringencyCode::new)
        }
    }
}

impl ::protobuf::Clear for DataElementStringencyCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataElementStringencyCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataElementStringencyCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataElementStringencyCode_Value {
    INVALID_UNINITIALIZED = 0,
    COMPARABLE = 1,
    FULLY_SPECIFIED = 2,
    EQUIVALENT = 3,
    CONVERTABLE = 4,
    SCALEABLE = 5,
    FLEXIBLE = 6,
}

impl ::protobuf::ProtobufEnum for DataElementStringencyCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataElementStringencyCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DataElementStringencyCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DataElementStringencyCode_Value::COMPARABLE),
            2 => ::std::option::Option::Some(DataElementStringencyCode_Value::FULLY_SPECIFIED),
            3 => ::std::option::Option::Some(DataElementStringencyCode_Value::EQUIVALENT),
            4 => ::std::option::Option::Some(DataElementStringencyCode_Value::CONVERTABLE),
            5 => ::std::option::Option::Some(DataElementStringencyCode_Value::SCALEABLE),
            6 => ::std::option::Option::Some(DataElementStringencyCode_Value::FLEXIBLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataElementStringencyCode_Value] = &[
            DataElementStringencyCode_Value::INVALID_UNINITIALIZED,
            DataElementStringencyCode_Value::COMPARABLE,
            DataElementStringencyCode_Value::FULLY_SPECIFIED,
            DataElementStringencyCode_Value::EQUIVALENT,
            DataElementStringencyCode_Value::CONVERTABLE,
            DataElementStringencyCode_Value::SCALEABLE,
            DataElementStringencyCode_Value::FLEXIBLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DataElementStringencyCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DataElementStringencyCode_Value {
}

impl ::std::default::Default for DataElementStringencyCode_Value {
    fn default() -> Self {
        DataElementStringencyCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DataElementStringencyCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TriggerTypeCode {
    // message fields
    pub value: TriggerTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TriggerTypeCode {
    pub fn new() -> TriggerTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TriggerTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TriggerTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TriggerTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TriggerTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TriggerTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TriggerTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TriggerTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TriggerTypeCode {
        TriggerTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TriggerTypeCode_Value>>(
                    "value",
                    |m: &TriggerTypeCode| { &m.value },
                    |m: &mut TriggerTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TriggerTypeCode| { &m.id },
                    |m: &mut TriggerTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TriggerTypeCode| { &m.extension },
                    |m: &mut TriggerTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TriggerTypeCode>(
                    "TriggerTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TriggerTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<TriggerTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TriggerTypeCode,
        };
        unsafe {
            instance.get(TriggerTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for TriggerTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TriggerTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TriggerTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TriggerTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    NAMED_EVENT = 1,
    PERIODIC = 2,
    DATA_ADDED = 3,
    DATA_MODIFIED = 4,
    DATA_REMOVED = 5,
    DATA_ACCESSED = 6,
    DATA_ACCESS_ENDED = 7,
}

impl ::protobuf::ProtobufEnum for TriggerTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TriggerTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TriggerTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TriggerTypeCode_Value::NAMED_EVENT),
            2 => ::std::option::Option::Some(TriggerTypeCode_Value::PERIODIC),
            3 => ::std::option::Option::Some(TriggerTypeCode_Value::DATA_ADDED),
            4 => ::std::option::Option::Some(TriggerTypeCode_Value::DATA_MODIFIED),
            5 => ::std::option::Option::Some(TriggerTypeCode_Value::DATA_REMOVED),
            6 => ::std::option::Option::Some(TriggerTypeCode_Value::DATA_ACCESSED),
            7 => ::std::option::Option::Some(TriggerTypeCode_Value::DATA_ACCESS_ENDED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TriggerTypeCode_Value] = &[
            TriggerTypeCode_Value::INVALID_UNINITIALIZED,
            TriggerTypeCode_Value::NAMED_EVENT,
            TriggerTypeCode_Value::PERIODIC,
            TriggerTypeCode_Value::DATA_ADDED,
            TriggerTypeCode_Value::DATA_MODIFIED,
            TriggerTypeCode_Value::DATA_REMOVED,
            TriggerTypeCode_Value::DATA_ACCESSED,
            TriggerTypeCode_Value::DATA_ACCESS_ENDED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TriggerTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TriggerTypeCode_Value {
}

impl ::std::default::Default for TriggerTypeCode_Value {
    fn default() -> Self {
        TriggerTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TriggerTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataTypeCode {
    // message fields
    pub value: DataTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DataTypeCode {
    pub fn new() -> DataTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DataTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DataTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DataTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DataTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DataTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DataTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DataTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataTypeCode {
        DataTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataTypeCode_Value>>(
                    "value",
                    |m: &DataTypeCode| { &m.value },
                    |m: &mut DataTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DataTypeCode| { &m.id },
                    |m: &mut DataTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DataTypeCode| { &m.extension },
                    |m: &mut DataTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataTypeCode>(
                    "DataTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DataTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<DataTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataTypeCode,
        };
        unsafe {
            instance.get(DataTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for DataTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    ADDRESS = 1,
    AGE = 2,
    ANNOTATION = 3,
    ATTACHMENT = 4,
    BACKBONE_ELEMENT = 5,
    CODEABLE_CONCEPT = 6,
    CODING = 7,
    CONTACT_DETAIL = 8,
    CONTACT_POINT = 9,
    CONTRIBUTOR = 10,
    COUNT = 11,
    DATA_REQUIREMENT = 12,
    DISTANCE = 13,
    DOSAGE = 14,
    DURATION = 15,
    ELEMENT = 16,
    ELEMENT_DEFINITION = 17,
    EXTENSION = 18,
    HUMAN_NAME = 19,
    IDENTIFIER = 20,
    META = 21,
    MONEY = 22,
    NARRATIVE = 23,
    PARAMETER_DEFINITION = 24,
    PERIOD = 25,
    QUANTITY = 26,
    RANGE = 27,
    RATIO = 28,
    REFERENCE = 29,
    RELATED_ARTIFACT = 30,
    SAMPLED_DATA = 31,
    SIGNATURE = 32,
    SIMPLE_QUANTITY = 33,
    TIMING = 34,
    TRIGGER_DEFINITION = 35,
    USAGE_CONTEXT = 36,
    BASE64_BINARY = 37,
    BOOLEAN = 38,
    CODE = 39,
    DATE = 40,
    DATE_TIME = 41,
    DECIMAL = 42,
    ID = 43,
    INSTANT = 44,
    INTEGER = 45,
    MARKDOWN = 46,
    OID = 47,
    POSITIVE_INT = 48,
    STRING = 49,
    TIME = 50,
    UNSIGNED_INT = 51,
    URI = 52,
    UUID = 53,
    XHTML = 54,
}

impl ::protobuf::ProtobufEnum for DataTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DataTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DataTypeCode_Value::ADDRESS),
            2 => ::std::option::Option::Some(DataTypeCode_Value::AGE),
            3 => ::std::option::Option::Some(DataTypeCode_Value::ANNOTATION),
            4 => ::std::option::Option::Some(DataTypeCode_Value::ATTACHMENT),
            5 => ::std::option::Option::Some(DataTypeCode_Value::BACKBONE_ELEMENT),
            6 => ::std::option::Option::Some(DataTypeCode_Value::CODEABLE_CONCEPT),
            7 => ::std::option::Option::Some(DataTypeCode_Value::CODING),
            8 => ::std::option::Option::Some(DataTypeCode_Value::CONTACT_DETAIL),
            9 => ::std::option::Option::Some(DataTypeCode_Value::CONTACT_POINT),
            10 => ::std::option::Option::Some(DataTypeCode_Value::CONTRIBUTOR),
            11 => ::std::option::Option::Some(DataTypeCode_Value::COUNT),
            12 => ::std::option::Option::Some(DataTypeCode_Value::DATA_REQUIREMENT),
            13 => ::std::option::Option::Some(DataTypeCode_Value::DISTANCE),
            14 => ::std::option::Option::Some(DataTypeCode_Value::DOSAGE),
            15 => ::std::option::Option::Some(DataTypeCode_Value::DURATION),
            16 => ::std::option::Option::Some(DataTypeCode_Value::ELEMENT),
            17 => ::std::option::Option::Some(DataTypeCode_Value::ELEMENT_DEFINITION),
            18 => ::std::option::Option::Some(DataTypeCode_Value::EXTENSION),
            19 => ::std::option::Option::Some(DataTypeCode_Value::HUMAN_NAME),
            20 => ::std::option::Option::Some(DataTypeCode_Value::IDENTIFIER),
            21 => ::std::option::Option::Some(DataTypeCode_Value::META),
            22 => ::std::option::Option::Some(DataTypeCode_Value::MONEY),
            23 => ::std::option::Option::Some(DataTypeCode_Value::NARRATIVE),
            24 => ::std::option::Option::Some(DataTypeCode_Value::PARAMETER_DEFINITION),
            25 => ::std::option::Option::Some(DataTypeCode_Value::PERIOD),
            26 => ::std::option::Option::Some(DataTypeCode_Value::QUANTITY),
            27 => ::std::option::Option::Some(DataTypeCode_Value::RANGE),
            28 => ::std::option::Option::Some(DataTypeCode_Value::RATIO),
            29 => ::std::option::Option::Some(DataTypeCode_Value::REFERENCE),
            30 => ::std::option::Option::Some(DataTypeCode_Value::RELATED_ARTIFACT),
            31 => ::std::option::Option::Some(DataTypeCode_Value::SAMPLED_DATA),
            32 => ::std::option::Option::Some(DataTypeCode_Value::SIGNATURE),
            33 => ::std::option::Option::Some(DataTypeCode_Value::SIMPLE_QUANTITY),
            34 => ::std::option::Option::Some(DataTypeCode_Value::TIMING),
            35 => ::std::option::Option::Some(DataTypeCode_Value::TRIGGER_DEFINITION),
            36 => ::std::option::Option::Some(DataTypeCode_Value::USAGE_CONTEXT),
            37 => ::std::option::Option::Some(DataTypeCode_Value::BASE64_BINARY),
            38 => ::std::option::Option::Some(DataTypeCode_Value::BOOLEAN),
            39 => ::std::option::Option::Some(DataTypeCode_Value::CODE),
            40 => ::std::option::Option::Some(DataTypeCode_Value::DATE),
            41 => ::std::option::Option::Some(DataTypeCode_Value::DATE_TIME),
            42 => ::std::option::Option::Some(DataTypeCode_Value::DECIMAL),
            43 => ::std::option::Option::Some(DataTypeCode_Value::ID),
            44 => ::std::option::Option::Some(DataTypeCode_Value::INSTANT),
            45 => ::std::option::Option::Some(DataTypeCode_Value::INTEGER),
            46 => ::std::option::Option::Some(DataTypeCode_Value::MARKDOWN),
            47 => ::std::option::Option::Some(DataTypeCode_Value::OID),
            48 => ::std::option::Option::Some(DataTypeCode_Value::POSITIVE_INT),
            49 => ::std::option::Option::Some(DataTypeCode_Value::STRING),
            50 => ::std::option::Option::Some(DataTypeCode_Value::TIME),
            51 => ::std::option::Option::Some(DataTypeCode_Value::UNSIGNED_INT),
            52 => ::std::option::Option::Some(DataTypeCode_Value::URI),
            53 => ::std::option::Option::Some(DataTypeCode_Value::UUID),
            54 => ::std::option::Option::Some(DataTypeCode_Value::XHTML),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataTypeCode_Value] = &[
            DataTypeCode_Value::INVALID_UNINITIALIZED,
            DataTypeCode_Value::ADDRESS,
            DataTypeCode_Value::AGE,
            DataTypeCode_Value::ANNOTATION,
            DataTypeCode_Value::ATTACHMENT,
            DataTypeCode_Value::BACKBONE_ELEMENT,
            DataTypeCode_Value::CODEABLE_CONCEPT,
            DataTypeCode_Value::CODING,
            DataTypeCode_Value::CONTACT_DETAIL,
            DataTypeCode_Value::CONTACT_POINT,
            DataTypeCode_Value::CONTRIBUTOR,
            DataTypeCode_Value::COUNT,
            DataTypeCode_Value::DATA_REQUIREMENT,
            DataTypeCode_Value::DISTANCE,
            DataTypeCode_Value::DOSAGE,
            DataTypeCode_Value::DURATION,
            DataTypeCode_Value::ELEMENT,
            DataTypeCode_Value::ELEMENT_DEFINITION,
            DataTypeCode_Value::EXTENSION,
            DataTypeCode_Value::HUMAN_NAME,
            DataTypeCode_Value::IDENTIFIER,
            DataTypeCode_Value::META,
            DataTypeCode_Value::MONEY,
            DataTypeCode_Value::NARRATIVE,
            DataTypeCode_Value::PARAMETER_DEFINITION,
            DataTypeCode_Value::PERIOD,
            DataTypeCode_Value::QUANTITY,
            DataTypeCode_Value::RANGE,
            DataTypeCode_Value::RATIO,
            DataTypeCode_Value::REFERENCE,
            DataTypeCode_Value::RELATED_ARTIFACT,
            DataTypeCode_Value::SAMPLED_DATA,
            DataTypeCode_Value::SIGNATURE,
            DataTypeCode_Value::SIMPLE_QUANTITY,
            DataTypeCode_Value::TIMING,
            DataTypeCode_Value::TRIGGER_DEFINITION,
            DataTypeCode_Value::USAGE_CONTEXT,
            DataTypeCode_Value::BASE64_BINARY,
            DataTypeCode_Value::BOOLEAN,
            DataTypeCode_Value::CODE,
            DataTypeCode_Value::DATE,
            DataTypeCode_Value::DATE_TIME,
            DataTypeCode_Value::DECIMAL,
            DataTypeCode_Value::ID,
            DataTypeCode_Value::INSTANT,
            DataTypeCode_Value::INTEGER,
            DataTypeCode_Value::MARKDOWN,
            DataTypeCode_Value::OID,
            DataTypeCode_Value::POSITIVE_INT,
            DataTypeCode_Value::STRING,
            DataTypeCode_Value::TIME,
            DataTypeCode_Value::UNSIGNED_INT,
            DataTypeCode_Value::URI,
            DataTypeCode_Value::UUID,
            DataTypeCode_Value::XHTML,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DataTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DataTypeCode_Value {
}

impl ::std::default::Default for DataTypeCode_Value {
    fn default() -> Self {
        DataTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DataTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FHIRAllTypesCode {
    // message fields
    pub value: FHIRAllTypesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FHIRAllTypesCode {
    pub fn new() -> FHIRAllTypesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.FHIRAllTypesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = FHIRAllTypesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FHIRAllTypesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> FHIRAllTypesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FHIRAllTypesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != FHIRAllTypesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != FHIRAllTypesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FHIRAllTypesCode {
        FHIRAllTypesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FHIRAllTypesCode_Value>>(
                    "value",
                    |m: &FHIRAllTypesCode| { &m.value },
                    |m: &mut FHIRAllTypesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FHIRAllTypesCode| { &m.id },
                    |m: &mut FHIRAllTypesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FHIRAllTypesCode| { &m.extension },
                    |m: &mut FHIRAllTypesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FHIRAllTypesCode>(
                    "FHIRAllTypesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FHIRAllTypesCode {
        static mut instance: ::protobuf::lazy::Lazy<FHIRAllTypesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FHIRAllTypesCode,
        };
        unsafe {
            instance.get(FHIRAllTypesCode::new)
        }
    }
}

impl ::protobuf::Clear for FHIRAllTypesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FHIRAllTypesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FHIRAllTypesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FHIRAllTypesCode_Value {
    INVALID_UNINITIALIZED = 0,
    ADDRESS = 1,
    AGE = 2,
    ANNOTATION = 3,
    ATTACHMENT = 4,
    BACKBONE_ELEMENT = 5,
    CODEABLE_CONCEPT = 6,
    CODING = 7,
    CONTACT_DETAIL = 8,
    CONTACT_POINT = 9,
    CONTRIBUTOR = 10,
    COUNT = 11,
    DATA_REQUIREMENT = 12,
    DISTANCE = 13,
    DOSAGE = 14,
    DURATION = 15,
    ELEMENT = 16,
    ELEMENT_DEFINITION = 17,
    EXTENSION = 18,
    HUMAN_NAME = 19,
    IDENTIFIER = 20,
    META = 21,
    MONEY = 22,
    NARRATIVE = 23,
    PARAMETER_DEFINITION = 24,
    PERIOD = 25,
    QUANTITY = 26,
    RANGE = 27,
    RATIO = 28,
    REFERENCE = 29,
    RELATED_ARTIFACT = 30,
    SAMPLED_DATA = 31,
    SIGNATURE = 32,
    SIMPLE_QUANTITY = 33,
    TIMING = 34,
    TRIGGER_DEFINITION = 35,
    USAGE_CONTEXT = 36,
    BASE64_BINARY = 37,
    BOOLEAN = 38,
    CODE = 39,
    DATE = 40,
    DATE_TIME = 41,
    DECIMAL = 42,
    ID = 43,
    INSTANT = 44,
    INTEGER = 45,
    MARKDOWN = 46,
    OID = 47,
    POSITIVE_INT = 48,
    STRING = 49,
    TIME = 50,
    UNSIGNED_INT = 51,
    URI = 52,
    UUID = 53,
    XHTML = 54,
    ACCOUNT = 55,
    ACTIVITY_DEFINITION = 56,
    ADVERSE_EVENT = 57,
    ALLERGY_INTOLERANCE = 58,
    APPOINTMENT = 59,
    APPOINTMENT_RESPONSE = 60,
    AUDIT_EVENT = 61,
    BASIC = 62,
    BINARY = 63,
    BODY_SITE = 64,
    BUNDLE = 65,
    CAPABILITY_STATEMENT = 66,
    CARE_PLAN = 67,
    CARE_TEAM = 68,
    CHARGE_ITEM = 69,
    CLAIM = 70,
    CLAIM_RESPONSE = 71,
    CLINICAL_IMPRESSION = 72,
    CODE_SYSTEM = 73,
    COMMUNICATION = 74,
    COMMUNICATION_REQUEST = 75,
    COMPARTMENT_DEFINITION = 76,
    COMPOSITION = 77,
    CONCEPT_MAP = 78,
    CONDITION = 79,
    CONSENT = 80,
    CONTRACT = 81,
    COVERAGE = 82,
    DATA_ELEMENT = 83,
    DETECTED_ISSUE = 84,
    DEVICE = 85,
    DEVICE_COMPONENT = 86,
    DEVICE_METRIC = 87,
    DEVICE_REQUEST = 88,
    DEVICE_USE_STATEMENT = 89,
    DIAGNOSTIC_REPORT = 90,
    DOCUMENT_MANIFEST = 91,
    DOCUMENT_REFERENCE = 92,
    DOMAIN_RESOURCE = 93,
    ELIGIBILITY_REQUEST = 94,
    ELIGIBILITY_RESPONSE = 95,
    ENCOUNTER = 96,
    ENDPOINT = 97,
    ENROLLMENT_REQUEST = 98,
    ENROLLMENT_RESPONSE = 99,
    EPISODE_OF_CARE = 100,
    EXPANSION_PROFILE = 101,
    EXPLANATION_OF_BENEFIT = 102,
    FAMILY_MEMBER_HISTORY = 103,
    FLAG = 104,
    GOAL = 105,
    GRAPH_DEFINITION = 106,
    GROUP = 107,
    GUIDANCE_RESPONSE = 108,
    HEALTHCARE_SERVICE = 109,
    IMAGING_MANIFEST = 110,
    IMAGING_STUDY = 111,
    IMMUNIZATION = 112,
    IMMUNIZATION_RECOMMENDATION = 113,
    IMPLEMENTATION_GUIDE = 114,
    LIBRARY = 115,
    LINKAGE = 116,
    LIST = 117,
    LOCATION = 118,
    MEASURE = 119,
    MEASURE_REPORT = 120,
    MEDIA = 121,
    MEDICATION = 122,
    MEDICATION_ADMINISTRATION = 123,
    MEDICATION_DISPENSE = 124,
    MEDICATION_REQUEST = 125,
    MEDICATION_STATEMENT = 126,
    MESSAGE_DEFINITION = 127,
    MESSAGE_HEADER = 128,
    NAMING_SYSTEM = 129,
    NUTRITION_ORDER = 130,
    OBSERVATION = 131,
    OPERATIONDEFINITION = 132,
    OPERATION_OUTCOME = 133,
    ORGANIZATION = 134,
    PARAMETERS = 135,
    PATIENT = 136,
    PAYMENT_NOTICE = 137,
    PAYMENT_RECONCILIATION = 138,
    PERSON = 139,
    PLAN_DEFINITION = 140,
    PRACTITIONER = 141,
    PRACTITIONER_ROLE = 142,
    PROCEDURE = 143,
    PROCEDURE_REQUEST = 144,
    PROCESS_REQUEST = 145,
    PROCESS_RESPONSE = 146,
    PROVENANCE = 147,
    QUESTIONNAIRE = 148,
    QUESTIONNAIRE_RESPONSE = 149,
    REFERRAL_REQUEST = 150,
    RELATED_PERSON = 151,
    REQUEST_GROUP = 152,
    RESEARCH_STUDY = 153,
    RESEARCH_SUBJECT = 154,
    RESOURCE = 155,
    RISK_ASSESSMENT = 156,
    SCHEDULE = 157,
    SEARCH_PARAMETER = 158,
    SEQUENCE = 159,
    SERVICE_DEFINITION = 160,
    SLOT = 161,
    SPECIMEN = 162,
    STRUCTURE_DEFINITION = 163,
    STRUCTURE_MAP = 164,
    SUBSCRIPTION = 165,
    SUBSTANCE = 166,
    SUPPLY_DELIVERY = 167,
    SUPPLY_REQUEST = 168,
    TASK = 169,
    TEST_REPORT = 170,
    TEST_SCRIPT = 171,
    VALUE_SET = 172,
    VISION_PRESCRIPTION = 173,
    TYPE = 174,
    ANY = 175,
}

impl ::protobuf::ProtobufEnum for FHIRAllTypesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FHIRAllTypesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(FHIRAllTypesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ADDRESS),
            2 => ::std::option::Option::Some(FHIRAllTypesCode_Value::AGE),
            3 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ANNOTATION),
            4 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ATTACHMENT),
            5 => ::std::option::Option::Some(FHIRAllTypesCode_Value::BACKBONE_ELEMENT),
            6 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CODEABLE_CONCEPT),
            7 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CODING),
            8 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CONTACT_DETAIL),
            9 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CONTACT_POINT),
            10 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CONTRIBUTOR),
            11 => ::std::option::Option::Some(FHIRAllTypesCode_Value::COUNT),
            12 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DATA_REQUIREMENT),
            13 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DISTANCE),
            14 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DOSAGE),
            15 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DURATION),
            16 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ELEMENT),
            17 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ELEMENT_DEFINITION),
            18 => ::std::option::Option::Some(FHIRAllTypesCode_Value::EXTENSION),
            19 => ::std::option::Option::Some(FHIRAllTypesCode_Value::HUMAN_NAME),
            20 => ::std::option::Option::Some(FHIRAllTypesCode_Value::IDENTIFIER),
            21 => ::std::option::Option::Some(FHIRAllTypesCode_Value::META),
            22 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MONEY),
            23 => ::std::option::Option::Some(FHIRAllTypesCode_Value::NARRATIVE),
            24 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PARAMETER_DEFINITION),
            25 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PERIOD),
            26 => ::std::option::Option::Some(FHIRAllTypesCode_Value::QUANTITY),
            27 => ::std::option::Option::Some(FHIRAllTypesCode_Value::RANGE),
            28 => ::std::option::Option::Some(FHIRAllTypesCode_Value::RATIO),
            29 => ::std::option::Option::Some(FHIRAllTypesCode_Value::REFERENCE),
            30 => ::std::option::Option::Some(FHIRAllTypesCode_Value::RELATED_ARTIFACT),
            31 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SAMPLED_DATA),
            32 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SIGNATURE),
            33 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SIMPLE_QUANTITY),
            34 => ::std::option::Option::Some(FHIRAllTypesCode_Value::TIMING),
            35 => ::std::option::Option::Some(FHIRAllTypesCode_Value::TRIGGER_DEFINITION),
            36 => ::std::option::Option::Some(FHIRAllTypesCode_Value::USAGE_CONTEXT),
            37 => ::std::option::Option::Some(FHIRAllTypesCode_Value::BASE64_BINARY),
            38 => ::std::option::Option::Some(FHIRAllTypesCode_Value::BOOLEAN),
            39 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CODE),
            40 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DATE),
            41 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DATE_TIME),
            42 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DECIMAL),
            43 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ID),
            44 => ::std::option::Option::Some(FHIRAllTypesCode_Value::INSTANT),
            45 => ::std::option::Option::Some(FHIRAllTypesCode_Value::INTEGER),
            46 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MARKDOWN),
            47 => ::std::option::Option::Some(FHIRAllTypesCode_Value::OID),
            48 => ::std::option::Option::Some(FHIRAllTypesCode_Value::POSITIVE_INT),
            49 => ::std::option::Option::Some(FHIRAllTypesCode_Value::STRING),
            50 => ::std::option::Option::Some(FHIRAllTypesCode_Value::TIME),
            51 => ::std::option::Option::Some(FHIRAllTypesCode_Value::UNSIGNED_INT),
            52 => ::std::option::Option::Some(FHIRAllTypesCode_Value::URI),
            53 => ::std::option::Option::Some(FHIRAllTypesCode_Value::UUID),
            54 => ::std::option::Option::Some(FHIRAllTypesCode_Value::XHTML),
            55 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ACCOUNT),
            56 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ACTIVITY_DEFINITION),
            57 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ADVERSE_EVENT),
            58 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ALLERGY_INTOLERANCE),
            59 => ::std::option::Option::Some(FHIRAllTypesCode_Value::APPOINTMENT),
            60 => ::std::option::Option::Some(FHIRAllTypesCode_Value::APPOINTMENT_RESPONSE),
            61 => ::std::option::Option::Some(FHIRAllTypesCode_Value::AUDIT_EVENT),
            62 => ::std::option::Option::Some(FHIRAllTypesCode_Value::BASIC),
            63 => ::std::option::Option::Some(FHIRAllTypesCode_Value::BINARY),
            64 => ::std::option::Option::Some(FHIRAllTypesCode_Value::BODY_SITE),
            65 => ::std::option::Option::Some(FHIRAllTypesCode_Value::BUNDLE),
            66 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CAPABILITY_STATEMENT),
            67 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CARE_PLAN),
            68 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CARE_TEAM),
            69 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CHARGE_ITEM),
            70 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CLAIM),
            71 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CLAIM_RESPONSE),
            72 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CLINICAL_IMPRESSION),
            73 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CODE_SYSTEM),
            74 => ::std::option::Option::Some(FHIRAllTypesCode_Value::COMMUNICATION),
            75 => ::std::option::Option::Some(FHIRAllTypesCode_Value::COMMUNICATION_REQUEST),
            76 => ::std::option::Option::Some(FHIRAllTypesCode_Value::COMPARTMENT_DEFINITION),
            77 => ::std::option::Option::Some(FHIRAllTypesCode_Value::COMPOSITION),
            78 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CONCEPT_MAP),
            79 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CONDITION),
            80 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CONSENT),
            81 => ::std::option::Option::Some(FHIRAllTypesCode_Value::CONTRACT),
            82 => ::std::option::Option::Some(FHIRAllTypesCode_Value::COVERAGE),
            83 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DATA_ELEMENT),
            84 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DETECTED_ISSUE),
            85 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DEVICE),
            86 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DEVICE_COMPONENT),
            87 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DEVICE_METRIC),
            88 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DEVICE_REQUEST),
            89 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DEVICE_USE_STATEMENT),
            90 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DIAGNOSTIC_REPORT),
            91 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DOCUMENT_MANIFEST),
            92 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DOCUMENT_REFERENCE),
            93 => ::std::option::Option::Some(FHIRAllTypesCode_Value::DOMAIN_RESOURCE),
            94 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ELIGIBILITY_REQUEST),
            95 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ELIGIBILITY_RESPONSE),
            96 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ENCOUNTER),
            97 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ENDPOINT),
            98 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ENROLLMENT_REQUEST),
            99 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ENROLLMENT_RESPONSE),
            100 => ::std::option::Option::Some(FHIRAllTypesCode_Value::EPISODE_OF_CARE),
            101 => ::std::option::Option::Some(FHIRAllTypesCode_Value::EXPANSION_PROFILE),
            102 => ::std::option::Option::Some(FHIRAllTypesCode_Value::EXPLANATION_OF_BENEFIT),
            103 => ::std::option::Option::Some(FHIRAllTypesCode_Value::FAMILY_MEMBER_HISTORY),
            104 => ::std::option::Option::Some(FHIRAllTypesCode_Value::FLAG),
            105 => ::std::option::Option::Some(FHIRAllTypesCode_Value::GOAL),
            106 => ::std::option::Option::Some(FHIRAllTypesCode_Value::GRAPH_DEFINITION),
            107 => ::std::option::Option::Some(FHIRAllTypesCode_Value::GROUP),
            108 => ::std::option::Option::Some(FHIRAllTypesCode_Value::GUIDANCE_RESPONSE),
            109 => ::std::option::Option::Some(FHIRAllTypesCode_Value::HEALTHCARE_SERVICE),
            110 => ::std::option::Option::Some(FHIRAllTypesCode_Value::IMAGING_MANIFEST),
            111 => ::std::option::Option::Some(FHIRAllTypesCode_Value::IMAGING_STUDY),
            112 => ::std::option::Option::Some(FHIRAllTypesCode_Value::IMMUNIZATION),
            113 => ::std::option::Option::Some(FHIRAllTypesCode_Value::IMMUNIZATION_RECOMMENDATION),
            114 => ::std::option::Option::Some(FHIRAllTypesCode_Value::IMPLEMENTATION_GUIDE),
            115 => ::std::option::Option::Some(FHIRAllTypesCode_Value::LIBRARY),
            116 => ::std::option::Option::Some(FHIRAllTypesCode_Value::LINKAGE),
            117 => ::std::option::Option::Some(FHIRAllTypesCode_Value::LIST),
            118 => ::std::option::Option::Some(FHIRAllTypesCode_Value::LOCATION),
            119 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MEASURE),
            120 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MEASURE_REPORT),
            121 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MEDIA),
            122 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MEDICATION),
            123 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MEDICATION_ADMINISTRATION),
            124 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MEDICATION_DISPENSE),
            125 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MEDICATION_REQUEST),
            126 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MEDICATION_STATEMENT),
            127 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MESSAGE_DEFINITION),
            128 => ::std::option::Option::Some(FHIRAllTypesCode_Value::MESSAGE_HEADER),
            129 => ::std::option::Option::Some(FHIRAllTypesCode_Value::NAMING_SYSTEM),
            130 => ::std::option::Option::Some(FHIRAllTypesCode_Value::NUTRITION_ORDER),
            131 => ::std::option::Option::Some(FHIRAllTypesCode_Value::OBSERVATION),
            132 => ::std::option::Option::Some(FHIRAllTypesCode_Value::OPERATIONDEFINITION),
            133 => ::std::option::Option::Some(FHIRAllTypesCode_Value::OPERATION_OUTCOME),
            134 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ORGANIZATION),
            135 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PARAMETERS),
            136 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PATIENT),
            137 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PAYMENT_NOTICE),
            138 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PAYMENT_RECONCILIATION),
            139 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PERSON),
            140 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PLAN_DEFINITION),
            141 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PRACTITIONER),
            142 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PRACTITIONER_ROLE),
            143 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PROCEDURE),
            144 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PROCEDURE_REQUEST),
            145 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PROCESS_REQUEST),
            146 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PROCESS_RESPONSE),
            147 => ::std::option::Option::Some(FHIRAllTypesCode_Value::PROVENANCE),
            148 => ::std::option::Option::Some(FHIRAllTypesCode_Value::QUESTIONNAIRE),
            149 => ::std::option::Option::Some(FHIRAllTypesCode_Value::QUESTIONNAIRE_RESPONSE),
            150 => ::std::option::Option::Some(FHIRAllTypesCode_Value::REFERRAL_REQUEST),
            151 => ::std::option::Option::Some(FHIRAllTypesCode_Value::RELATED_PERSON),
            152 => ::std::option::Option::Some(FHIRAllTypesCode_Value::REQUEST_GROUP),
            153 => ::std::option::Option::Some(FHIRAllTypesCode_Value::RESEARCH_STUDY),
            154 => ::std::option::Option::Some(FHIRAllTypesCode_Value::RESEARCH_SUBJECT),
            155 => ::std::option::Option::Some(FHIRAllTypesCode_Value::RESOURCE),
            156 => ::std::option::Option::Some(FHIRAllTypesCode_Value::RISK_ASSESSMENT),
            157 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SCHEDULE),
            158 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SEARCH_PARAMETER),
            159 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SEQUENCE),
            160 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SERVICE_DEFINITION),
            161 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SLOT),
            162 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SPECIMEN),
            163 => ::std::option::Option::Some(FHIRAllTypesCode_Value::STRUCTURE_DEFINITION),
            164 => ::std::option::Option::Some(FHIRAllTypesCode_Value::STRUCTURE_MAP),
            165 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SUBSCRIPTION),
            166 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SUBSTANCE),
            167 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SUPPLY_DELIVERY),
            168 => ::std::option::Option::Some(FHIRAllTypesCode_Value::SUPPLY_REQUEST),
            169 => ::std::option::Option::Some(FHIRAllTypesCode_Value::TASK),
            170 => ::std::option::Option::Some(FHIRAllTypesCode_Value::TEST_REPORT),
            171 => ::std::option::Option::Some(FHIRAllTypesCode_Value::TEST_SCRIPT),
            172 => ::std::option::Option::Some(FHIRAllTypesCode_Value::VALUE_SET),
            173 => ::std::option::Option::Some(FHIRAllTypesCode_Value::VISION_PRESCRIPTION),
            174 => ::std::option::Option::Some(FHIRAllTypesCode_Value::TYPE),
            175 => ::std::option::Option::Some(FHIRAllTypesCode_Value::ANY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FHIRAllTypesCode_Value] = &[
            FHIRAllTypesCode_Value::INVALID_UNINITIALIZED,
            FHIRAllTypesCode_Value::ADDRESS,
            FHIRAllTypesCode_Value::AGE,
            FHIRAllTypesCode_Value::ANNOTATION,
            FHIRAllTypesCode_Value::ATTACHMENT,
            FHIRAllTypesCode_Value::BACKBONE_ELEMENT,
            FHIRAllTypesCode_Value::CODEABLE_CONCEPT,
            FHIRAllTypesCode_Value::CODING,
            FHIRAllTypesCode_Value::CONTACT_DETAIL,
            FHIRAllTypesCode_Value::CONTACT_POINT,
            FHIRAllTypesCode_Value::CONTRIBUTOR,
            FHIRAllTypesCode_Value::COUNT,
            FHIRAllTypesCode_Value::DATA_REQUIREMENT,
            FHIRAllTypesCode_Value::DISTANCE,
            FHIRAllTypesCode_Value::DOSAGE,
            FHIRAllTypesCode_Value::DURATION,
            FHIRAllTypesCode_Value::ELEMENT,
            FHIRAllTypesCode_Value::ELEMENT_DEFINITION,
            FHIRAllTypesCode_Value::EXTENSION,
            FHIRAllTypesCode_Value::HUMAN_NAME,
            FHIRAllTypesCode_Value::IDENTIFIER,
            FHIRAllTypesCode_Value::META,
            FHIRAllTypesCode_Value::MONEY,
            FHIRAllTypesCode_Value::NARRATIVE,
            FHIRAllTypesCode_Value::PARAMETER_DEFINITION,
            FHIRAllTypesCode_Value::PERIOD,
            FHIRAllTypesCode_Value::QUANTITY,
            FHIRAllTypesCode_Value::RANGE,
            FHIRAllTypesCode_Value::RATIO,
            FHIRAllTypesCode_Value::REFERENCE,
            FHIRAllTypesCode_Value::RELATED_ARTIFACT,
            FHIRAllTypesCode_Value::SAMPLED_DATA,
            FHIRAllTypesCode_Value::SIGNATURE,
            FHIRAllTypesCode_Value::SIMPLE_QUANTITY,
            FHIRAllTypesCode_Value::TIMING,
            FHIRAllTypesCode_Value::TRIGGER_DEFINITION,
            FHIRAllTypesCode_Value::USAGE_CONTEXT,
            FHIRAllTypesCode_Value::BASE64_BINARY,
            FHIRAllTypesCode_Value::BOOLEAN,
            FHIRAllTypesCode_Value::CODE,
            FHIRAllTypesCode_Value::DATE,
            FHIRAllTypesCode_Value::DATE_TIME,
            FHIRAllTypesCode_Value::DECIMAL,
            FHIRAllTypesCode_Value::ID,
            FHIRAllTypesCode_Value::INSTANT,
            FHIRAllTypesCode_Value::INTEGER,
            FHIRAllTypesCode_Value::MARKDOWN,
            FHIRAllTypesCode_Value::OID,
            FHIRAllTypesCode_Value::POSITIVE_INT,
            FHIRAllTypesCode_Value::STRING,
            FHIRAllTypesCode_Value::TIME,
            FHIRAllTypesCode_Value::UNSIGNED_INT,
            FHIRAllTypesCode_Value::URI,
            FHIRAllTypesCode_Value::UUID,
            FHIRAllTypesCode_Value::XHTML,
            FHIRAllTypesCode_Value::ACCOUNT,
            FHIRAllTypesCode_Value::ACTIVITY_DEFINITION,
            FHIRAllTypesCode_Value::ADVERSE_EVENT,
            FHIRAllTypesCode_Value::ALLERGY_INTOLERANCE,
            FHIRAllTypesCode_Value::APPOINTMENT,
            FHIRAllTypesCode_Value::APPOINTMENT_RESPONSE,
            FHIRAllTypesCode_Value::AUDIT_EVENT,
            FHIRAllTypesCode_Value::BASIC,
            FHIRAllTypesCode_Value::BINARY,
            FHIRAllTypesCode_Value::BODY_SITE,
            FHIRAllTypesCode_Value::BUNDLE,
            FHIRAllTypesCode_Value::CAPABILITY_STATEMENT,
            FHIRAllTypesCode_Value::CARE_PLAN,
            FHIRAllTypesCode_Value::CARE_TEAM,
            FHIRAllTypesCode_Value::CHARGE_ITEM,
            FHIRAllTypesCode_Value::CLAIM,
            FHIRAllTypesCode_Value::CLAIM_RESPONSE,
            FHIRAllTypesCode_Value::CLINICAL_IMPRESSION,
            FHIRAllTypesCode_Value::CODE_SYSTEM,
            FHIRAllTypesCode_Value::COMMUNICATION,
            FHIRAllTypesCode_Value::COMMUNICATION_REQUEST,
            FHIRAllTypesCode_Value::COMPARTMENT_DEFINITION,
            FHIRAllTypesCode_Value::COMPOSITION,
            FHIRAllTypesCode_Value::CONCEPT_MAP,
            FHIRAllTypesCode_Value::CONDITION,
            FHIRAllTypesCode_Value::CONSENT,
            FHIRAllTypesCode_Value::CONTRACT,
            FHIRAllTypesCode_Value::COVERAGE,
            FHIRAllTypesCode_Value::DATA_ELEMENT,
            FHIRAllTypesCode_Value::DETECTED_ISSUE,
            FHIRAllTypesCode_Value::DEVICE,
            FHIRAllTypesCode_Value::DEVICE_COMPONENT,
            FHIRAllTypesCode_Value::DEVICE_METRIC,
            FHIRAllTypesCode_Value::DEVICE_REQUEST,
            FHIRAllTypesCode_Value::DEVICE_USE_STATEMENT,
            FHIRAllTypesCode_Value::DIAGNOSTIC_REPORT,
            FHIRAllTypesCode_Value::DOCUMENT_MANIFEST,
            FHIRAllTypesCode_Value::DOCUMENT_REFERENCE,
            FHIRAllTypesCode_Value::DOMAIN_RESOURCE,
            FHIRAllTypesCode_Value::ELIGIBILITY_REQUEST,
            FHIRAllTypesCode_Value::ELIGIBILITY_RESPONSE,
            FHIRAllTypesCode_Value::ENCOUNTER,
            FHIRAllTypesCode_Value::ENDPOINT,
            FHIRAllTypesCode_Value::ENROLLMENT_REQUEST,
            FHIRAllTypesCode_Value::ENROLLMENT_RESPONSE,
            FHIRAllTypesCode_Value::EPISODE_OF_CARE,
            FHIRAllTypesCode_Value::EXPANSION_PROFILE,
            FHIRAllTypesCode_Value::EXPLANATION_OF_BENEFIT,
            FHIRAllTypesCode_Value::FAMILY_MEMBER_HISTORY,
            FHIRAllTypesCode_Value::FLAG,
            FHIRAllTypesCode_Value::GOAL,
            FHIRAllTypesCode_Value::GRAPH_DEFINITION,
            FHIRAllTypesCode_Value::GROUP,
            FHIRAllTypesCode_Value::GUIDANCE_RESPONSE,
            FHIRAllTypesCode_Value::HEALTHCARE_SERVICE,
            FHIRAllTypesCode_Value::IMAGING_MANIFEST,
            FHIRAllTypesCode_Value::IMAGING_STUDY,
            FHIRAllTypesCode_Value::IMMUNIZATION,
            FHIRAllTypesCode_Value::IMMUNIZATION_RECOMMENDATION,
            FHIRAllTypesCode_Value::IMPLEMENTATION_GUIDE,
            FHIRAllTypesCode_Value::LIBRARY,
            FHIRAllTypesCode_Value::LINKAGE,
            FHIRAllTypesCode_Value::LIST,
            FHIRAllTypesCode_Value::LOCATION,
            FHIRAllTypesCode_Value::MEASURE,
            FHIRAllTypesCode_Value::MEASURE_REPORT,
            FHIRAllTypesCode_Value::MEDIA,
            FHIRAllTypesCode_Value::MEDICATION,
            FHIRAllTypesCode_Value::MEDICATION_ADMINISTRATION,
            FHIRAllTypesCode_Value::MEDICATION_DISPENSE,
            FHIRAllTypesCode_Value::MEDICATION_REQUEST,
            FHIRAllTypesCode_Value::MEDICATION_STATEMENT,
            FHIRAllTypesCode_Value::MESSAGE_DEFINITION,
            FHIRAllTypesCode_Value::MESSAGE_HEADER,
            FHIRAllTypesCode_Value::NAMING_SYSTEM,
            FHIRAllTypesCode_Value::NUTRITION_ORDER,
            FHIRAllTypesCode_Value::OBSERVATION,
            FHIRAllTypesCode_Value::OPERATIONDEFINITION,
            FHIRAllTypesCode_Value::OPERATION_OUTCOME,
            FHIRAllTypesCode_Value::ORGANIZATION,
            FHIRAllTypesCode_Value::PARAMETERS,
            FHIRAllTypesCode_Value::PATIENT,
            FHIRAllTypesCode_Value::PAYMENT_NOTICE,
            FHIRAllTypesCode_Value::PAYMENT_RECONCILIATION,
            FHIRAllTypesCode_Value::PERSON,
            FHIRAllTypesCode_Value::PLAN_DEFINITION,
            FHIRAllTypesCode_Value::PRACTITIONER,
            FHIRAllTypesCode_Value::PRACTITIONER_ROLE,
            FHIRAllTypesCode_Value::PROCEDURE,
            FHIRAllTypesCode_Value::PROCEDURE_REQUEST,
            FHIRAllTypesCode_Value::PROCESS_REQUEST,
            FHIRAllTypesCode_Value::PROCESS_RESPONSE,
            FHIRAllTypesCode_Value::PROVENANCE,
            FHIRAllTypesCode_Value::QUESTIONNAIRE,
            FHIRAllTypesCode_Value::QUESTIONNAIRE_RESPONSE,
            FHIRAllTypesCode_Value::REFERRAL_REQUEST,
            FHIRAllTypesCode_Value::RELATED_PERSON,
            FHIRAllTypesCode_Value::REQUEST_GROUP,
            FHIRAllTypesCode_Value::RESEARCH_STUDY,
            FHIRAllTypesCode_Value::RESEARCH_SUBJECT,
            FHIRAllTypesCode_Value::RESOURCE,
            FHIRAllTypesCode_Value::RISK_ASSESSMENT,
            FHIRAllTypesCode_Value::SCHEDULE,
            FHIRAllTypesCode_Value::SEARCH_PARAMETER,
            FHIRAllTypesCode_Value::SEQUENCE,
            FHIRAllTypesCode_Value::SERVICE_DEFINITION,
            FHIRAllTypesCode_Value::SLOT,
            FHIRAllTypesCode_Value::SPECIMEN,
            FHIRAllTypesCode_Value::STRUCTURE_DEFINITION,
            FHIRAllTypesCode_Value::STRUCTURE_MAP,
            FHIRAllTypesCode_Value::SUBSCRIPTION,
            FHIRAllTypesCode_Value::SUBSTANCE,
            FHIRAllTypesCode_Value::SUPPLY_DELIVERY,
            FHIRAllTypesCode_Value::SUPPLY_REQUEST,
            FHIRAllTypesCode_Value::TASK,
            FHIRAllTypesCode_Value::TEST_REPORT,
            FHIRAllTypesCode_Value::TEST_SCRIPT,
            FHIRAllTypesCode_Value::VALUE_SET,
            FHIRAllTypesCode_Value::VISION_PRESCRIPTION,
            FHIRAllTypesCode_Value::TYPE,
            FHIRAllTypesCode_Value::ANY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FHIRAllTypesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FHIRAllTypesCode_Value {
}

impl ::std::default::Default for FHIRAllTypesCode_Value {
    fn default() -> Self {
        FHIRAllTypesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for FHIRAllTypesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FHIRDefinedTypeCode {
    // message fields
    pub value: FHIRDefinedTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FHIRDefinedTypeCode {
    pub fn new() -> FHIRDefinedTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.FHIRDefinedTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = FHIRDefinedTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FHIRDefinedTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> FHIRDefinedTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FHIRDefinedTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != FHIRDefinedTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != FHIRDefinedTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FHIRDefinedTypeCode {
        FHIRDefinedTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FHIRDefinedTypeCode_Value>>(
                    "value",
                    |m: &FHIRDefinedTypeCode| { &m.value },
                    |m: &mut FHIRDefinedTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FHIRDefinedTypeCode| { &m.id },
                    |m: &mut FHIRDefinedTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FHIRDefinedTypeCode| { &m.extension },
                    |m: &mut FHIRDefinedTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FHIRDefinedTypeCode>(
                    "FHIRDefinedTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FHIRDefinedTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<FHIRDefinedTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FHIRDefinedTypeCode,
        };
        unsafe {
            instance.get(FHIRDefinedTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for FHIRDefinedTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FHIRDefinedTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FHIRDefinedTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FHIRDefinedTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    ADDRESS = 1,
    AGE = 2,
    ANNOTATION = 3,
    ATTACHMENT = 4,
    BACKBONE_ELEMENT = 5,
    CODEABLE_CONCEPT = 6,
    CODING = 7,
    CONTACT_DETAIL = 8,
    CONTACT_POINT = 9,
    CONTRIBUTOR = 10,
    COUNT = 11,
    DATA_REQUIREMENT = 12,
    DISTANCE = 13,
    DOSAGE = 14,
    DURATION = 15,
    ELEMENT = 16,
    ELEMENT_DEFINITION = 17,
    EXTENSION = 18,
    HUMAN_NAME = 19,
    IDENTIFIER = 20,
    META = 21,
    MONEY = 22,
    NARRATIVE = 23,
    PARAMETER_DEFINITION = 24,
    PERIOD = 25,
    QUANTITY = 26,
    RANGE = 27,
    RATIO = 28,
    REFERENCE = 29,
    RELATED_ARTIFACT = 30,
    SAMPLED_DATA = 31,
    SIGNATURE = 32,
    SIMPLE_QUANTITY = 33,
    TIMING = 34,
    TRIGGER_DEFINITION = 35,
    USAGE_CONTEXT = 36,
    BASE64_BINARY = 37,
    BOOLEAN = 38,
    CODE = 39,
    DATE = 40,
    DATE_TIME = 41,
    DECIMAL = 42,
    ID = 43,
    INSTANT = 44,
    INTEGER = 45,
    MARKDOWN = 46,
    OID = 47,
    POSITIVE_INT = 48,
    STRING = 49,
    TIME = 50,
    UNSIGNED_INT = 51,
    URI = 52,
    UUID = 53,
    XHTML = 54,
    ACCOUNT = 55,
    ACTIVITY_DEFINITION = 56,
    ADVERSE_EVENT = 57,
    ALLERGY_INTOLERANCE = 58,
    APPOINTMENT = 59,
    APPOINTMENT_RESPONSE = 60,
    AUDIT_EVENT = 61,
    BASIC = 62,
    BINARY = 63,
    BODY_SITE = 64,
    BUNDLE = 65,
    CAPABILITY_STATEMENT = 66,
    CARE_PLAN = 67,
    CARE_TEAM = 68,
    CHARGE_ITEM = 69,
    CLAIM = 70,
    CLAIM_RESPONSE = 71,
    CLINICAL_IMPRESSION = 72,
    CODE_SYSTEM = 73,
    COMMUNICATION = 74,
    COMMUNICATION_REQUEST = 75,
    COMPARTMENT_DEFINITION = 76,
    COMPOSITION = 77,
    CONCEPT_MAP = 78,
    CONDITION = 79,
    CONSENT = 80,
    CONTRACT = 81,
    COVERAGE = 82,
    DATA_ELEMENT = 83,
    DETECTED_ISSUE = 84,
    DEVICE = 85,
    DEVICE_COMPONENT = 86,
    DEVICE_METRIC = 87,
    DEVICE_REQUEST = 88,
    DEVICE_USE_STATEMENT = 89,
    DIAGNOSTIC_REPORT = 90,
    DOCUMENT_MANIFEST = 91,
    DOCUMENT_REFERENCE = 92,
    DOMAIN_RESOURCE = 93,
    ELIGIBILITY_REQUEST = 94,
    ELIGIBILITY_RESPONSE = 95,
    ENCOUNTER = 96,
    ENDPOINT = 97,
    ENROLLMENT_REQUEST = 98,
    ENROLLMENT_RESPONSE = 99,
    EPISODE_OF_CARE = 100,
    EXPANSION_PROFILE = 101,
    EXPLANATION_OF_BENEFIT = 102,
    FAMILY_MEMBER_HISTORY = 103,
    FLAG = 104,
    GOAL = 105,
    GRAPH_DEFINITION = 106,
    GROUP = 107,
    GUIDANCE_RESPONSE = 108,
    HEALTHCARE_SERVICE = 109,
    IMAGING_MANIFEST = 110,
    IMAGING_STUDY = 111,
    IMMUNIZATION = 112,
    IMMUNIZATION_RECOMMENDATION = 113,
    IMPLEMENTATION_GUIDE = 114,
    LIBRARY = 115,
    LINKAGE = 116,
    LIST = 117,
    LOCATION = 118,
    MEASURE = 119,
    MEASURE_REPORT = 120,
    MEDIA = 121,
    MEDICATION = 122,
    MEDICATION_ADMINISTRATION = 123,
    MEDICATION_DISPENSE = 124,
    MEDICATION_REQUEST = 125,
    MEDICATION_STATEMENT = 126,
    MESSAGE_DEFINITION = 127,
    MESSAGE_HEADER = 128,
    NAMING_SYSTEM = 129,
    NUTRITION_ORDER = 130,
    OBSERVATION = 131,
    OPERATIONDEFINITION = 132,
    OPERATION_OUTCOME = 133,
    ORGANIZATION = 134,
    PARAMETERS = 135,
    PATIENT = 136,
    PAYMENT_NOTICE = 137,
    PAYMENT_RECONCILIATION = 138,
    PERSON = 139,
    PLAN_DEFINITION = 140,
    PRACTITIONER = 141,
    PRACTITIONER_ROLE = 142,
    PROCEDURE = 143,
    PROCEDURE_REQUEST = 144,
    PROCESS_REQUEST = 145,
    PROCESS_RESPONSE = 146,
    PROVENANCE = 147,
    QUESTIONNAIRE = 148,
    QUESTIONNAIRE_RESPONSE = 149,
    REFERRAL_REQUEST = 150,
    RELATED_PERSON = 151,
    REQUEST_GROUP = 152,
    RESEARCH_STUDY = 153,
    RESEARCH_SUBJECT = 154,
    RESOURCE = 155,
    RISK_ASSESSMENT = 156,
    SCHEDULE = 157,
    SEARCH_PARAMETER = 158,
    SEQUENCE = 159,
    SERVICE_DEFINITION = 160,
    SLOT = 161,
    SPECIMEN = 162,
    STRUCTURE_DEFINITION = 163,
    STRUCTURE_MAP = 164,
    SUBSCRIPTION = 165,
    SUBSTANCE = 166,
    SUPPLY_DELIVERY = 167,
    SUPPLY_REQUEST = 168,
    TASK = 169,
    TEST_REPORT = 170,
    TEST_SCRIPT = 171,
    VALUE_SET = 172,
    VISION_PRESCRIPTION = 173,
}

impl ::protobuf::ProtobufEnum for FHIRDefinedTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FHIRDefinedTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ADDRESS),
            2 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::AGE),
            3 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ANNOTATION),
            4 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ATTACHMENT),
            5 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::BACKBONE_ELEMENT),
            6 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CODEABLE_CONCEPT),
            7 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CODING),
            8 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CONTACT_DETAIL),
            9 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CONTACT_POINT),
            10 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CONTRIBUTOR),
            11 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::COUNT),
            12 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DATA_REQUIREMENT),
            13 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DISTANCE),
            14 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DOSAGE),
            15 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DURATION),
            16 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ELEMENT),
            17 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ELEMENT_DEFINITION),
            18 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::EXTENSION),
            19 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::HUMAN_NAME),
            20 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::IDENTIFIER),
            21 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::META),
            22 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MONEY),
            23 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::NARRATIVE),
            24 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PARAMETER_DEFINITION),
            25 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PERIOD),
            26 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::QUANTITY),
            27 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::RANGE),
            28 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::RATIO),
            29 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::REFERENCE),
            30 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::RELATED_ARTIFACT),
            31 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SAMPLED_DATA),
            32 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SIGNATURE),
            33 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SIMPLE_QUANTITY),
            34 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::TIMING),
            35 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::TRIGGER_DEFINITION),
            36 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::USAGE_CONTEXT),
            37 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::BASE64_BINARY),
            38 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::BOOLEAN),
            39 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CODE),
            40 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DATE),
            41 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DATE_TIME),
            42 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DECIMAL),
            43 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ID),
            44 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::INSTANT),
            45 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::INTEGER),
            46 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MARKDOWN),
            47 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::OID),
            48 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::POSITIVE_INT),
            49 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::STRING),
            50 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::TIME),
            51 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::UNSIGNED_INT),
            52 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::URI),
            53 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::UUID),
            54 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::XHTML),
            55 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ACCOUNT),
            56 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ACTIVITY_DEFINITION),
            57 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ADVERSE_EVENT),
            58 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ALLERGY_INTOLERANCE),
            59 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::APPOINTMENT),
            60 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::APPOINTMENT_RESPONSE),
            61 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::AUDIT_EVENT),
            62 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::BASIC),
            63 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::BINARY),
            64 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::BODY_SITE),
            65 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::BUNDLE),
            66 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CAPABILITY_STATEMENT),
            67 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CARE_PLAN),
            68 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CARE_TEAM),
            69 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CHARGE_ITEM),
            70 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CLAIM),
            71 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CLAIM_RESPONSE),
            72 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CLINICAL_IMPRESSION),
            73 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CODE_SYSTEM),
            74 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::COMMUNICATION),
            75 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::COMMUNICATION_REQUEST),
            76 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::COMPARTMENT_DEFINITION),
            77 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::COMPOSITION),
            78 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CONCEPT_MAP),
            79 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CONDITION),
            80 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CONSENT),
            81 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::CONTRACT),
            82 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::COVERAGE),
            83 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DATA_ELEMENT),
            84 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DETECTED_ISSUE),
            85 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DEVICE),
            86 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DEVICE_COMPONENT),
            87 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DEVICE_METRIC),
            88 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DEVICE_REQUEST),
            89 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DEVICE_USE_STATEMENT),
            90 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DIAGNOSTIC_REPORT),
            91 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DOCUMENT_MANIFEST),
            92 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DOCUMENT_REFERENCE),
            93 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::DOMAIN_RESOURCE),
            94 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ELIGIBILITY_REQUEST),
            95 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ELIGIBILITY_RESPONSE),
            96 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ENCOUNTER),
            97 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ENDPOINT),
            98 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ENROLLMENT_REQUEST),
            99 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ENROLLMENT_RESPONSE),
            100 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::EPISODE_OF_CARE),
            101 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::EXPANSION_PROFILE),
            102 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::EXPLANATION_OF_BENEFIT),
            103 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::FAMILY_MEMBER_HISTORY),
            104 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::FLAG),
            105 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::GOAL),
            106 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::GRAPH_DEFINITION),
            107 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::GROUP),
            108 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::GUIDANCE_RESPONSE),
            109 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::HEALTHCARE_SERVICE),
            110 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::IMAGING_MANIFEST),
            111 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::IMAGING_STUDY),
            112 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::IMMUNIZATION),
            113 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::IMMUNIZATION_RECOMMENDATION),
            114 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::IMPLEMENTATION_GUIDE),
            115 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::LIBRARY),
            116 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::LINKAGE),
            117 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::LIST),
            118 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::LOCATION),
            119 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MEASURE),
            120 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MEASURE_REPORT),
            121 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MEDIA),
            122 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MEDICATION),
            123 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MEDICATION_ADMINISTRATION),
            124 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MEDICATION_DISPENSE),
            125 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MEDICATION_REQUEST),
            126 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MEDICATION_STATEMENT),
            127 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MESSAGE_DEFINITION),
            128 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::MESSAGE_HEADER),
            129 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::NAMING_SYSTEM),
            130 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::NUTRITION_ORDER),
            131 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::OBSERVATION),
            132 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::OPERATIONDEFINITION),
            133 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::OPERATION_OUTCOME),
            134 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::ORGANIZATION),
            135 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PARAMETERS),
            136 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PATIENT),
            137 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PAYMENT_NOTICE),
            138 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PAYMENT_RECONCILIATION),
            139 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PERSON),
            140 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PLAN_DEFINITION),
            141 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PRACTITIONER),
            142 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PRACTITIONER_ROLE),
            143 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PROCEDURE),
            144 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PROCEDURE_REQUEST),
            145 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PROCESS_REQUEST),
            146 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PROCESS_RESPONSE),
            147 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::PROVENANCE),
            148 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::QUESTIONNAIRE),
            149 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::QUESTIONNAIRE_RESPONSE),
            150 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::REFERRAL_REQUEST),
            151 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::RELATED_PERSON),
            152 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::REQUEST_GROUP),
            153 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::RESEARCH_STUDY),
            154 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::RESEARCH_SUBJECT),
            155 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::RESOURCE),
            156 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::RISK_ASSESSMENT),
            157 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SCHEDULE),
            158 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SEARCH_PARAMETER),
            159 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SEQUENCE),
            160 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SERVICE_DEFINITION),
            161 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SLOT),
            162 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SPECIMEN),
            163 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::STRUCTURE_DEFINITION),
            164 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::STRUCTURE_MAP),
            165 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SUBSCRIPTION),
            166 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SUBSTANCE),
            167 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SUPPLY_DELIVERY),
            168 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::SUPPLY_REQUEST),
            169 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::TASK),
            170 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::TEST_REPORT),
            171 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::TEST_SCRIPT),
            172 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::VALUE_SET),
            173 => ::std::option::Option::Some(FHIRDefinedTypeCode_Value::VISION_PRESCRIPTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FHIRDefinedTypeCode_Value] = &[
            FHIRDefinedTypeCode_Value::INVALID_UNINITIALIZED,
            FHIRDefinedTypeCode_Value::ADDRESS,
            FHIRDefinedTypeCode_Value::AGE,
            FHIRDefinedTypeCode_Value::ANNOTATION,
            FHIRDefinedTypeCode_Value::ATTACHMENT,
            FHIRDefinedTypeCode_Value::BACKBONE_ELEMENT,
            FHIRDefinedTypeCode_Value::CODEABLE_CONCEPT,
            FHIRDefinedTypeCode_Value::CODING,
            FHIRDefinedTypeCode_Value::CONTACT_DETAIL,
            FHIRDefinedTypeCode_Value::CONTACT_POINT,
            FHIRDefinedTypeCode_Value::CONTRIBUTOR,
            FHIRDefinedTypeCode_Value::COUNT,
            FHIRDefinedTypeCode_Value::DATA_REQUIREMENT,
            FHIRDefinedTypeCode_Value::DISTANCE,
            FHIRDefinedTypeCode_Value::DOSAGE,
            FHIRDefinedTypeCode_Value::DURATION,
            FHIRDefinedTypeCode_Value::ELEMENT,
            FHIRDefinedTypeCode_Value::ELEMENT_DEFINITION,
            FHIRDefinedTypeCode_Value::EXTENSION,
            FHIRDefinedTypeCode_Value::HUMAN_NAME,
            FHIRDefinedTypeCode_Value::IDENTIFIER,
            FHIRDefinedTypeCode_Value::META,
            FHIRDefinedTypeCode_Value::MONEY,
            FHIRDefinedTypeCode_Value::NARRATIVE,
            FHIRDefinedTypeCode_Value::PARAMETER_DEFINITION,
            FHIRDefinedTypeCode_Value::PERIOD,
            FHIRDefinedTypeCode_Value::QUANTITY,
            FHIRDefinedTypeCode_Value::RANGE,
            FHIRDefinedTypeCode_Value::RATIO,
            FHIRDefinedTypeCode_Value::REFERENCE,
            FHIRDefinedTypeCode_Value::RELATED_ARTIFACT,
            FHIRDefinedTypeCode_Value::SAMPLED_DATA,
            FHIRDefinedTypeCode_Value::SIGNATURE,
            FHIRDefinedTypeCode_Value::SIMPLE_QUANTITY,
            FHIRDefinedTypeCode_Value::TIMING,
            FHIRDefinedTypeCode_Value::TRIGGER_DEFINITION,
            FHIRDefinedTypeCode_Value::USAGE_CONTEXT,
            FHIRDefinedTypeCode_Value::BASE64_BINARY,
            FHIRDefinedTypeCode_Value::BOOLEAN,
            FHIRDefinedTypeCode_Value::CODE,
            FHIRDefinedTypeCode_Value::DATE,
            FHIRDefinedTypeCode_Value::DATE_TIME,
            FHIRDefinedTypeCode_Value::DECIMAL,
            FHIRDefinedTypeCode_Value::ID,
            FHIRDefinedTypeCode_Value::INSTANT,
            FHIRDefinedTypeCode_Value::INTEGER,
            FHIRDefinedTypeCode_Value::MARKDOWN,
            FHIRDefinedTypeCode_Value::OID,
            FHIRDefinedTypeCode_Value::POSITIVE_INT,
            FHIRDefinedTypeCode_Value::STRING,
            FHIRDefinedTypeCode_Value::TIME,
            FHIRDefinedTypeCode_Value::UNSIGNED_INT,
            FHIRDefinedTypeCode_Value::URI,
            FHIRDefinedTypeCode_Value::UUID,
            FHIRDefinedTypeCode_Value::XHTML,
            FHIRDefinedTypeCode_Value::ACCOUNT,
            FHIRDefinedTypeCode_Value::ACTIVITY_DEFINITION,
            FHIRDefinedTypeCode_Value::ADVERSE_EVENT,
            FHIRDefinedTypeCode_Value::ALLERGY_INTOLERANCE,
            FHIRDefinedTypeCode_Value::APPOINTMENT,
            FHIRDefinedTypeCode_Value::APPOINTMENT_RESPONSE,
            FHIRDefinedTypeCode_Value::AUDIT_EVENT,
            FHIRDefinedTypeCode_Value::BASIC,
            FHIRDefinedTypeCode_Value::BINARY,
            FHIRDefinedTypeCode_Value::BODY_SITE,
            FHIRDefinedTypeCode_Value::BUNDLE,
            FHIRDefinedTypeCode_Value::CAPABILITY_STATEMENT,
            FHIRDefinedTypeCode_Value::CARE_PLAN,
            FHIRDefinedTypeCode_Value::CARE_TEAM,
            FHIRDefinedTypeCode_Value::CHARGE_ITEM,
            FHIRDefinedTypeCode_Value::CLAIM,
            FHIRDefinedTypeCode_Value::CLAIM_RESPONSE,
            FHIRDefinedTypeCode_Value::CLINICAL_IMPRESSION,
            FHIRDefinedTypeCode_Value::CODE_SYSTEM,
            FHIRDefinedTypeCode_Value::COMMUNICATION,
            FHIRDefinedTypeCode_Value::COMMUNICATION_REQUEST,
            FHIRDefinedTypeCode_Value::COMPARTMENT_DEFINITION,
            FHIRDefinedTypeCode_Value::COMPOSITION,
            FHIRDefinedTypeCode_Value::CONCEPT_MAP,
            FHIRDefinedTypeCode_Value::CONDITION,
            FHIRDefinedTypeCode_Value::CONSENT,
            FHIRDefinedTypeCode_Value::CONTRACT,
            FHIRDefinedTypeCode_Value::COVERAGE,
            FHIRDefinedTypeCode_Value::DATA_ELEMENT,
            FHIRDefinedTypeCode_Value::DETECTED_ISSUE,
            FHIRDefinedTypeCode_Value::DEVICE,
            FHIRDefinedTypeCode_Value::DEVICE_COMPONENT,
            FHIRDefinedTypeCode_Value::DEVICE_METRIC,
            FHIRDefinedTypeCode_Value::DEVICE_REQUEST,
            FHIRDefinedTypeCode_Value::DEVICE_USE_STATEMENT,
            FHIRDefinedTypeCode_Value::DIAGNOSTIC_REPORT,
            FHIRDefinedTypeCode_Value::DOCUMENT_MANIFEST,
            FHIRDefinedTypeCode_Value::DOCUMENT_REFERENCE,
            FHIRDefinedTypeCode_Value::DOMAIN_RESOURCE,
            FHIRDefinedTypeCode_Value::ELIGIBILITY_REQUEST,
            FHIRDefinedTypeCode_Value::ELIGIBILITY_RESPONSE,
            FHIRDefinedTypeCode_Value::ENCOUNTER,
            FHIRDefinedTypeCode_Value::ENDPOINT,
            FHIRDefinedTypeCode_Value::ENROLLMENT_REQUEST,
            FHIRDefinedTypeCode_Value::ENROLLMENT_RESPONSE,
            FHIRDefinedTypeCode_Value::EPISODE_OF_CARE,
            FHIRDefinedTypeCode_Value::EXPANSION_PROFILE,
            FHIRDefinedTypeCode_Value::EXPLANATION_OF_BENEFIT,
            FHIRDefinedTypeCode_Value::FAMILY_MEMBER_HISTORY,
            FHIRDefinedTypeCode_Value::FLAG,
            FHIRDefinedTypeCode_Value::GOAL,
            FHIRDefinedTypeCode_Value::GRAPH_DEFINITION,
            FHIRDefinedTypeCode_Value::GROUP,
            FHIRDefinedTypeCode_Value::GUIDANCE_RESPONSE,
            FHIRDefinedTypeCode_Value::HEALTHCARE_SERVICE,
            FHIRDefinedTypeCode_Value::IMAGING_MANIFEST,
            FHIRDefinedTypeCode_Value::IMAGING_STUDY,
            FHIRDefinedTypeCode_Value::IMMUNIZATION,
            FHIRDefinedTypeCode_Value::IMMUNIZATION_RECOMMENDATION,
            FHIRDefinedTypeCode_Value::IMPLEMENTATION_GUIDE,
            FHIRDefinedTypeCode_Value::LIBRARY,
            FHIRDefinedTypeCode_Value::LINKAGE,
            FHIRDefinedTypeCode_Value::LIST,
            FHIRDefinedTypeCode_Value::LOCATION,
            FHIRDefinedTypeCode_Value::MEASURE,
            FHIRDefinedTypeCode_Value::MEASURE_REPORT,
            FHIRDefinedTypeCode_Value::MEDIA,
            FHIRDefinedTypeCode_Value::MEDICATION,
            FHIRDefinedTypeCode_Value::MEDICATION_ADMINISTRATION,
            FHIRDefinedTypeCode_Value::MEDICATION_DISPENSE,
            FHIRDefinedTypeCode_Value::MEDICATION_REQUEST,
            FHIRDefinedTypeCode_Value::MEDICATION_STATEMENT,
            FHIRDefinedTypeCode_Value::MESSAGE_DEFINITION,
            FHIRDefinedTypeCode_Value::MESSAGE_HEADER,
            FHIRDefinedTypeCode_Value::NAMING_SYSTEM,
            FHIRDefinedTypeCode_Value::NUTRITION_ORDER,
            FHIRDefinedTypeCode_Value::OBSERVATION,
            FHIRDefinedTypeCode_Value::OPERATIONDEFINITION,
            FHIRDefinedTypeCode_Value::OPERATION_OUTCOME,
            FHIRDefinedTypeCode_Value::ORGANIZATION,
            FHIRDefinedTypeCode_Value::PARAMETERS,
            FHIRDefinedTypeCode_Value::PATIENT,
            FHIRDefinedTypeCode_Value::PAYMENT_NOTICE,
            FHIRDefinedTypeCode_Value::PAYMENT_RECONCILIATION,
            FHIRDefinedTypeCode_Value::PERSON,
            FHIRDefinedTypeCode_Value::PLAN_DEFINITION,
            FHIRDefinedTypeCode_Value::PRACTITIONER,
            FHIRDefinedTypeCode_Value::PRACTITIONER_ROLE,
            FHIRDefinedTypeCode_Value::PROCEDURE,
            FHIRDefinedTypeCode_Value::PROCEDURE_REQUEST,
            FHIRDefinedTypeCode_Value::PROCESS_REQUEST,
            FHIRDefinedTypeCode_Value::PROCESS_RESPONSE,
            FHIRDefinedTypeCode_Value::PROVENANCE,
            FHIRDefinedTypeCode_Value::QUESTIONNAIRE,
            FHIRDefinedTypeCode_Value::QUESTIONNAIRE_RESPONSE,
            FHIRDefinedTypeCode_Value::REFERRAL_REQUEST,
            FHIRDefinedTypeCode_Value::RELATED_PERSON,
            FHIRDefinedTypeCode_Value::REQUEST_GROUP,
            FHIRDefinedTypeCode_Value::RESEARCH_STUDY,
            FHIRDefinedTypeCode_Value::RESEARCH_SUBJECT,
            FHIRDefinedTypeCode_Value::RESOURCE,
            FHIRDefinedTypeCode_Value::RISK_ASSESSMENT,
            FHIRDefinedTypeCode_Value::SCHEDULE,
            FHIRDefinedTypeCode_Value::SEARCH_PARAMETER,
            FHIRDefinedTypeCode_Value::SEQUENCE,
            FHIRDefinedTypeCode_Value::SERVICE_DEFINITION,
            FHIRDefinedTypeCode_Value::SLOT,
            FHIRDefinedTypeCode_Value::SPECIMEN,
            FHIRDefinedTypeCode_Value::STRUCTURE_DEFINITION,
            FHIRDefinedTypeCode_Value::STRUCTURE_MAP,
            FHIRDefinedTypeCode_Value::SUBSCRIPTION,
            FHIRDefinedTypeCode_Value::SUBSTANCE,
            FHIRDefinedTypeCode_Value::SUPPLY_DELIVERY,
            FHIRDefinedTypeCode_Value::SUPPLY_REQUEST,
            FHIRDefinedTypeCode_Value::TASK,
            FHIRDefinedTypeCode_Value::TEST_REPORT,
            FHIRDefinedTypeCode_Value::TEST_SCRIPT,
            FHIRDefinedTypeCode_Value::VALUE_SET,
            FHIRDefinedTypeCode_Value::VISION_PRESCRIPTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FHIRDefinedTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FHIRDefinedTypeCode_Value {
}

impl ::std::default::Default for FHIRDefinedTypeCode_Value {
    fn default() -> Self {
        FHIRDefinedTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for FHIRDefinedTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FHIRDefinedTypeExtCode {
    // message fields
    pub value: ::std::string::String,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FHIRDefinedTypeExtCode {
    pub fn new() -> FHIRDefinedTypeExtCode {
        ::std::default::Default::default()
    }

    // string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        &self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FHIRDefinedTypeExtCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FHIRDefinedTypeExtCode {
        FHIRDefinedTypeExtCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &FHIRDefinedTypeExtCode| { &m.value },
                    |m: &mut FHIRDefinedTypeExtCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FHIRDefinedTypeExtCode| { &m.id },
                    |m: &mut FHIRDefinedTypeExtCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FHIRDefinedTypeExtCode| { &m.extension },
                    |m: &mut FHIRDefinedTypeExtCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FHIRDefinedTypeExtCode>(
                    "FHIRDefinedTypeExtCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FHIRDefinedTypeExtCode {
        static mut instance: ::protobuf::lazy::Lazy<FHIRDefinedTypeExtCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FHIRDefinedTypeExtCode,
        };
        unsafe {
            instance.get(FHIRDefinedTypeExtCode::new)
        }
    }
}

impl ::protobuf::Clear for FHIRDefinedTypeExtCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FHIRDefinedTypeExtCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FHIRDefinedTypeExtCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefinitionStatusCode {
    // message fields
    pub value: DefinitionStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DefinitionStatusCode {
    pub fn new() -> DefinitionStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DefinitionStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DefinitionStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DefinitionStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DefinitionStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DefinitionStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DefinitionStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DefinitionStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefinitionStatusCode {
        DefinitionStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DefinitionStatusCode_Value>>(
                    "value",
                    |m: &DefinitionStatusCode| { &m.value },
                    |m: &mut DefinitionStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DefinitionStatusCode| { &m.id },
                    |m: &mut DefinitionStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DefinitionStatusCode| { &m.extension },
                    |m: &mut DefinitionStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DefinitionStatusCode>(
                    "DefinitionStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefinitionStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<DefinitionStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DefinitionStatusCode,
        };
        unsafe {
            instance.get(DefinitionStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for DefinitionStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefinitionStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefinitionStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DefinitionStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    DRAFT = 1,
    ACTIVE = 2,
    WITHDRAWN = 3,
    UNKNOWN = 4,
}

impl ::protobuf::ProtobufEnum for DefinitionStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DefinitionStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DefinitionStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DefinitionStatusCode_Value::DRAFT),
            2 => ::std::option::Option::Some(DefinitionStatusCode_Value::ACTIVE),
            3 => ::std::option::Option::Some(DefinitionStatusCode_Value::WITHDRAWN),
            4 => ::std::option::Option::Some(DefinitionStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DefinitionStatusCode_Value] = &[
            DefinitionStatusCode_Value::INVALID_UNINITIALIZED,
            DefinitionStatusCode_Value::DRAFT,
            DefinitionStatusCode_Value::ACTIVE,
            DefinitionStatusCode_Value::WITHDRAWN,
            DefinitionStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DefinitionStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DefinitionStatusCode_Value {
}

impl ::std::default::Default for DefinitionStatusCode_Value {
    fn default() -> Self {
        DefinitionStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DefinitionStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefinitionTopicCode {
    // message fields
    pub value: DefinitionTopicCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DefinitionTopicCode {
    pub fn new() -> DefinitionTopicCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DefinitionTopicCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DefinitionTopicCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DefinitionTopicCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DefinitionTopicCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DefinitionTopicCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DefinitionTopicCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DefinitionTopicCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefinitionTopicCode {
        DefinitionTopicCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DefinitionTopicCode_Value>>(
                    "value",
                    |m: &DefinitionTopicCode| { &m.value },
                    |m: &mut DefinitionTopicCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DefinitionTopicCode| { &m.id },
                    |m: &mut DefinitionTopicCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DefinitionTopicCode| { &m.extension },
                    |m: &mut DefinitionTopicCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DefinitionTopicCode>(
                    "DefinitionTopicCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DefinitionTopicCode {
        static mut instance: ::protobuf::lazy::Lazy<DefinitionTopicCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DefinitionTopicCode,
        };
        unsafe {
            instance.get(DefinitionTopicCode::new)
        }
    }
}

impl ::protobuf::Clear for DefinitionTopicCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefinitionTopicCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefinitionTopicCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DefinitionTopicCode_Value {
    INVALID_UNINITIALIZED = 0,
    TREATMENT = 1,
    EDUCATION = 2,
    ASSESSMENT = 3,
}

impl ::protobuf::ProtobufEnum for DefinitionTopicCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DefinitionTopicCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DefinitionTopicCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DefinitionTopicCode_Value::TREATMENT),
            2 => ::std::option::Option::Some(DefinitionTopicCode_Value::EDUCATION),
            3 => ::std::option::Option::Some(DefinitionTopicCode_Value::ASSESSMENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DefinitionTopicCode_Value] = &[
            DefinitionTopicCode_Value::INVALID_UNINITIALIZED,
            DefinitionTopicCode_Value::TREATMENT,
            DefinitionTopicCode_Value::EDUCATION,
            DefinitionTopicCode_Value::ASSESSMENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DefinitionTopicCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DefinitionTopicCode_Value {
}

impl ::std::default::Default for DefinitionTopicCode_Value {
    fn default() -> Self {
        DefinitionTopicCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DefinitionTopicCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DetectedIssueSeverityCode {
    // message fields
    pub value: DetectedIssueSeverityCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DetectedIssueSeverityCode {
    pub fn new() -> DetectedIssueSeverityCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DetectedIssueSeverityCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DetectedIssueSeverityCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DetectedIssueSeverityCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DetectedIssueSeverityCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DetectedIssueSeverityCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DetectedIssueSeverityCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DetectedIssueSeverityCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DetectedIssueSeverityCode {
        DetectedIssueSeverityCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DetectedIssueSeverityCode_Value>>(
                    "value",
                    |m: &DetectedIssueSeverityCode| { &m.value },
                    |m: &mut DetectedIssueSeverityCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DetectedIssueSeverityCode| { &m.id },
                    |m: &mut DetectedIssueSeverityCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DetectedIssueSeverityCode| { &m.extension },
                    |m: &mut DetectedIssueSeverityCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DetectedIssueSeverityCode>(
                    "DetectedIssueSeverityCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DetectedIssueSeverityCode {
        static mut instance: ::protobuf::lazy::Lazy<DetectedIssueSeverityCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DetectedIssueSeverityCode,
        };
        unsafe {
            instance.get(DetectedIssueSeverityCode::new)
        }
    }
}

impl ::protobuf::Clear for DetectedIssueSeverityCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DetectedIssueSeverityCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetectedIssueSeverityCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DetectedIssueSeverityCode_Value {
    INVALID_UNINITIALIZED = 0,
    HIGH = 1,
    MODERATE = 2,
    LOW = 3,
}

impl ::protobuf::ProtobufEnum for DetectedIssueSeverityCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DetectedIssueSeverityCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DetectedIssueSeverityCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DetectedIssueSeverityCode_Value::HIGH),
            2 => ::std::option::Option::Some(DetectedIssueSeverityCode_Value::MODERATE),
            3 => ::std::option::Option::Some(DetectedIssueSeverityCode_Value::LOW),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DetectedIssueSeverityCode_Value] = &[
            DetectedIssueSeverityCode_Value::INVALID_UNINITIALIZED,
            DetectedIssueSeverityCode_Value::HIGH,
            DetectedIssueSeverityCode_Value::MODERATE,
            DetectedIssueSeverityCode_Value::LOW,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DetectedIssueSeverityCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DetectedIssueSeverityCode_Value {
}

impl ::std::default::Default for DetectedIssueSeverityCode_Value {
    fn default() -> Self {
        DetectedIssueSeverityCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DetectedIssueSeverityCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceUseStatementStatusCode {
    // message fields
    pub value: DeviceUseStatementStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeviceUseStatementStatusCode {
    pub fn new() -> DeviceUseStatementStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DeviceUseStatementStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DeviceUseStatementStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DeviceUseStatementStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DeviceUseStatementStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DeviceUseStatementStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DeviceUseStatementStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DeviceUseStatementStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceUseStatementStatusCode {
        DeviceUseStatementStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DeviceUseStatementStatusCode_Value>>(
                    "value",
                    |m: &DeviceUseStatementStatusCode| { &m.value },
                    |m: &mut DeviceUseStatementStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DeviceUseStatementStatusCode| { &m.id },
                    |m: &mut DeviceUseStatementStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DeviceUseStatementStatusCode| { &m.extension },
                    |m: &mut DeviceUseStatementStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceUseStatementStatusCode>(
                    "DeviceUseStatementStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceUseStatementStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<DeviceUseStatementStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceUseStatementStatusCode,
        };
        unsafe {
            instance.get(DeviceUseStatementStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for DeviceUseStatementStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceUseStatementStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceUseStatementStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeviceUseStatementStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    COMPLETED = 2,
    ENTERED_IN_ERROR = 3,
    INTENDED = 4,
    STOPPED = 5,
    ON_HOLD = 6,
}

impl ::protobuf::ProtobufEnum for DeviceUseStatementStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceUseStatementStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DeviceUseStatementStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DeviceUseStatementStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(DeviceUseStatementStatusCode_Value::COMPLETED),
            3 => ::std::option::Option::Some(DeviceUseStatementStatusCode_Value::ENTERED_IN_ERROR),
            4 => ::std::option::Option::Some(DeviceUseStatementStatusCode_Value::INTENDED),
            5 => ::std::option::Option::Some(DeviceUseStatementStatusCode_Value::STOPPED),
            6 => ::std::option::Option::Some(DeviceUseStatementStatusCode_Value::ON_HOLD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeviceUseStatementStatusCode_Value] = &[
            DeviceUseStatementStatusCode_Value::INVALID_UNINITIALIZED,
            DeviceUseStatementStatusCode_Value::ACTIVE,
            DeviceUseStatementStatusCode_Value::COMPLETED,
            DeviceUseStatementStatusCode_Value::ENTERED_IN_ERROR,
            DeviceUseStatementStatusCode_Value::INTENDED,
            DeviceUseStatementStatusCode_Value::STOPPED,
            DeviceUseStatementStatusCode_Value::ON_HOLD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DeviceUseStatementStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DeviceUseStatementStatusCode_Value {
}

impl ::std::default::Default for DeviceUseStatementStatusCode_Value {
    fn default() -> Self {
        DeviceUseStatementStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceUseStatementStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FHIRDeviceStatusCode {
    // message fields
    pub value: FHIRDeviceStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FHIRDeviceStatusCode {
    pub fn new() -> FHIRDeviceStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.FHIRDeviceStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = FHIRDeviceStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FHIRDeviceStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> FHIRDeviceStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FHIRDeviceStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != FHIRDeviceStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != FHIRDeviceStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FHIRDeviceStatusCode {
        FHIRDeviceStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FHIRDeviceStatusCode_Value>>(
                    "value",
                    |m: &FHIRDeviceStatusCode| { &m.value },
                    |m: &mut FHIRDeviceStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FHIRDeviceStatusCode| { &m.id },
                    |m: &mut FHIRDeviceStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FHIRDeviceStatusCode| { &m.extension },
                    |m: &mut FHIRDeviceStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FHIRDeviceStatusCode>(
                    "FHIRDeviceStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FHIRDeviceStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<FHIRDeviceStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FHIRDeviceStatusCode,
        };
        unsafe {
            instance.get(FHIRDeviceStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for FHIRDeviceStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FHIRDeviceStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FHIRDeviceStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FHIRDeviceStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    INACTIVE = 2,
    ENTERED_IN_ERROR = 3,
    UNKNOWN = 4,
}

impl ::protobuf::ProtobufEnum for FHIRDeviceStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FHIRDeviceStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(FHIRDeviceStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(FHIRDeviceStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(FHIRDeviceStatusCode_Value::INACTIVE),
            3 => ::std::option::Option::Some(FHIRDeviceStatusCode_Value::ENTERED_IN_ERROR),
            4 => ::std::option::Option::Some(FHIRDeviceStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FHIRDeviceStatusCode_Value] = &[
            FHIRDeviceStatusCode_Value::INVALID_UNINITIALIZED,
            FHIRDeviceStatusCode_Value::ACTIVE,
            FHIRDeviceStatusCode_Value::INACTIVE,
            FHIRDeviceStatusCode_Value::ENTERED_IN_ERROR,
            FHIRDeviceStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FHIRDeviceStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FHIRDeviceStatusCode_Value {
}

impl ::std::default::Default for FHIRDeviceStatusCode_Value {
    fn default() -> Self {
        FHIRDeviceStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for FHIRDeviceStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiagnosisRoleCode {
    // message fields
    pub value: DiagnosisRoleCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DiagnosisRoleCode {
    pub fn new() -> DiagnosisRoleCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DiagnosisRoleCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DiagnosisRoleCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DiagnosisRoleCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DiagnosisRoleCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DiagnosisRoleCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DiagnosisRoleCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DiagnosisRoleCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiagnosisRoleCode {
        DiagnosisRoleCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DiagnosisRoleCode_Value>>(
                    "value",
                    |m: &DiagnosisRoleCode| { &m.value },
                    |m: &mut DiagnosisRoleCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DiagnosisRoleCode| { &m.id },
                    |m: &mut DiagnosisRoleCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DiagnosisRoleCode| { &m.extension },
                    |m: &mut DiagnosisRoleCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DiagnosisRoleCode>(
                    "DiagnosisRoleCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DiagnosisRoleCode {
        static mut instance: ::protobuf::lazy::Lazy<DiagnosisRoleCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DiagnosisRoleCode,
        };
        unsafe {
            instance.get(DiagnosisRoleCode::new)
        }
    }
}

impl ::protobuf::Clear for DiagnosisRoleCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiagnosisRoleCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiagnosisRoleCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DiagnosisRoleCode_Value {
    INVALID_UNINITIALIZED = 0,
    AD = 1,
    DD = 2,
    CC = 3,
    CM = 4,
    PRE_OP = 5,
    POST_OP = 6,
    BILLING = 7,
}

impl ::protobuf::ProtobufEnum for DiagnosisRoleCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DiagnosisRoleCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DiagnosisRoleCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DiagnosisRoleCode_Value::AD),
            2 => ::std::option::Option::Some(DiagnosisRoleCode_Value::DD),
            3 => ::std::option::Option::Some(DiagnosisRoleCode_Value::CC),
            4 => ::std::option::Option::Some(DiagnosisRoleCode_Value::CM),
            5 => ::std::option::Option::Some(DiagnosisRoleCode_Value::PRE_OP),
            6 => ::std::option::Option::Some(DiagnosisRoleCode_Value::POST_OP),
            7 => ::std::option::Option::Some(DiagnosisRoleCode_Value::BILLING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DiagnosisRoleCode_Value] = &[
            DiagnosisRoleCode_Value::INVALID_UNINITIALIZED,
            DiagnosisRoleCode_Value::AD,
            DiagnosisRoleCode_Value::DD,
            DiagnosisRoleCode_Value::CC,
            DiagnosisRoleCode_Value::CM,
            DiagnosisRoleCode_Value::PRE_OP,
            DiagnosisRoleCode_Value::POST_OP,
            DiagnosisRoleCode_Value::BILLING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DiagnosisRoleCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DiagnosisRoleCode_Value {
}

impl ::std::default::Default for DiagnosisRoleCode_Value {
    fn default() -> Self {
        DiagnosisRoleCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DiagnosisRoleCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DiagnosticReportStatusCode {
    // message fields
    pub value: DiagnosticReportStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DiagnosticReportStatusCode {
    pub fn new() -> DiagnosticReportStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DiagnosticReportStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DiagnosticReportStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DiagnosticReportStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DiagnosticReportStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DiagnosticReportStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DiagnosticReportStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DiagnosticReportStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DiagnosticReportStatusCode {
        DiagnosticReportStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DiagnosticReportStatusCode_Value>>(
                    "value",
                    |m: &DiagnosticReportStatusCode| { &m.value },
                    |m: &mut DiagnosticReportStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DiagnosticReportStatusCode| { &m.id },
                    |m: &mut DiagnosticReportStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DiagnosticReportStatusCode| { &m.extension },
                    |m: &mut DiagnosticReportStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DiagnosticReportStatusCode>(
                    "DiagnosticReportStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DiagnosticReportStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<DiagnosticReportStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DiagnosticReportStatusCode,
        };
        unsafe {
            instance.get(DiagnosticReportStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for DiagnosticReportStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DiagnosticReportStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DiagnosticReportStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DiagnosticReportStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    REGISTERED = 1,
    PARTIAL = 2,
    PRELIMINARY = 3,
    FINAL = 4,
    AMENDED = 5,
    CORRECTED = 6,
    APPENDED = 7,
    CANCELLED = 8,
    ENTERED_IN_ERROR = 9,
    UNKNOWN = 10,
}

impl ::protobuf::ProtobufEnum for DiagnosticReportStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DiagnosticReportStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DiagnosticReportStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DiagnosticReportStatusCode_Value::REGISTERED),
            2 => ::std::option::Option::Some(DiagnosticReportStatusCode_Value::PARTIAL),
            3 => ::std::option::Option::Some(DiagnosticReportStatusCode_Value::PRELIMINARY),
            4 => ::std::option::Option::Some(DiagnosticReportStatusCode_Value::FINAL),
            5 => ::std::option::Option::Some(DiagnosticReportStatusCode_Value::AMENDED),
            6 => ::std::option::Option::Some(DiagnosticReportStatusCode_Value::CORRECTED),
            7 => ::std::option::Option::Some(DiagnosticReportStatusCode_Value::APPENDED),
            8 => ::std::option::Option::Some(DiagnosticReportStatusCode_Value::CANCELLED),
            9 => ::std::option::Option::Some(DiagnosticReportStatusCode_Value::ENTERED_IN_ERROR),
            10 => ::std::option::Option::Some(DiagnosticReportStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DiagnosticReportStatusCode_Value] = &[
            DiagnosticReportStatusCode_Value::INVALID_UNINITIALIZED,
            DiagnosticReportStatusCode_Value::REGISTERED,
            DiagnosticReportStatusCode_Value::PARTIAL,
            DiagnosticReportStatusCode_Value::PRELIMINARY,
            DiagnosticReportStatusCode_Value::FINAL,
            DiagnosticReportStatusCode_Value::AMENDED,
            DiagnosticReportStatusCode_Value::CORRECTED,
            DiagnosticReportStatusCode_Value::APPENDED,
            DiagnosticReportStatusCode_Value::CANCELLED,
            DiagnosticReportStatusCode_Value::ENTERED_IN_ERROR,
            DiagnosticReportStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DiagnosticReportStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DiagnosticReportStatusCode_Value {
}

impl ::std::default::Default for DiagnosticReportStatusCode_Value {
    fn default() -> Self {
        DiagnosticReportStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DiagnosticReportStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DigitalMediaTypeCode {
    // message fields
    pub value: DigitalMediaTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DigitalMediaTypeCode {
    pub fn new() -> DigitalMediaTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DigitalMediaTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DigitalMediaTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DigitalMediaTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DigitalMediaTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DigitalMediaTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DigitalMediaTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DigitalMediaTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DigitalMediaTypeCode {
        DigitalMediaTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DigitalMediaTypeCode_Value>>(
                    "value",
                    |m: &DigitalMediaTypeCode| { &m.value },
                    |m: &mut DigitalMediaTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DigitalMediaTypeCode| { &m.id },
                    |m: &mut DigitalMediaTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DigitalMediaTypeCode| { &m.extension },
                    |m: &mut DigitalMediaTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DigitalMediaTypeCode>(
                    "DigitalMediaTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DigitalMediaTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<DigitalMediaTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DigitalMediaTypeCode,
        };
        unsafe {
            instance.get(DigitalMediaTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for DigitalMediaTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DigitalMediaTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DigitalMediaTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DigitalMediaTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    PHOTO = 1,
    VIDEO = 2,
    AUDIO = 3,
}

impl ::protobuf::ProtobufEnum for DigitalMediaTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DigitalMediaTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DigitalMediaTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DigitalMediaTypeCode_Value::PHOTO),
            2 => ::std::option::Option::Some(DigitalMediaTypeCode_Value::VIDEO),
            3 => ::std::option::Option::Some(DigitalMediaTypeCode_Value::AUDIO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DigitalMediaTypeCode_Value] = &[
            DigitalMediaTypeCode_Value::INVALID_UNINITIALIZED,
            DigitalMediaTypeCode_Value::PHOTO,
            DigitalMediaTypeCode_Value::VIDEO,
            DigitalMediaTypeCode_Value::AUDIO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DigitalMediaTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DigitalMediaTypeCode_Value {
}

impl ::std::default::Default for DigitalMediaTypeCode_Value {
    fn default() -> Self {
        DigitalMediaTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DigitalMediaTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DocumentModeCode {
    // message fields
    pub value: DocumentModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DocumentModeCode {
    pub fn new() -> DocumentModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DocumentModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DocumentModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DocumentModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DocumentModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DocumentModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DocumentModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DocumentModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentModeCode {
        DocumentModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DocumentModeCode_Value>>(
                    "value",
                    |m: &DocumentModeCode| { &m.value },
                    |m: &mut DocumentModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DocumentModeCode| { &m.id },
                    |m: &mut DocumentModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DocumentModeCode| { &m.extension },
                    |m: &mut DocumentModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DocumentModeCode>(
                    "DocumentModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DocumentModeCode {
        static mut instance: ::protobuf::lazy::Lazy<DocumentModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DocumentModeCode,
        };
        unsafe {
            instance.get(DocumentModeCode::new)
        }
    }
}

impl ::protobuf::Clear for DocumentModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DocumentModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    PRODUCER = 1,
    CONSUMER = 2,
}

impl ::protobuf::ProtobufEnum for DocumentModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DocumentModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DocumentModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DocumentModeCode_Value::PRODUCER),
            2 => ::std::option::Option::Some(DocumentModeCode_Value::CONSUMER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DocumentModeCode_Value] = &[
            DocumentModeCode_Value::INVALID_UNINITIALIZED,
            DocumentModeCode_Value::PRODUCER,
            DocumentModeCode_Value::CONSUMER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DocumentModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DocumentModeCode_Value {
}

impl ::std::default::Default for DocumentModeCode_Value {
    fn default() -> Self {
        DocumentModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DocumentReferenceStatusCode {
    // message fields
    pub value: DocumentReferenceStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DocumentReferenceStatusCode {
    pub fn new() -> DocumentReferenceStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DocumentReferenceStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DocumentReferenceStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DocumentReferenceStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DocumentReferenceStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DocumentReferenceStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DocumentReferenceStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DocumentReferenceStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentReferenceStatusCode {
        DocumentReferenceStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DocumentReferenceStatusCode_Value>>(
                    "value",
                    |m: &DocumentReferenceStatusCode| { &m.value },
                    |m: &mut DocumentReferenceStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DocumentReferenceStatusCode| { &m.id },
                    |m: &mut DocumentReferenceStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DocumentReferenceStatusCode| { &m.extension },
                    |m: &mut DocumentReferenceStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DocumentReferenceStatusCode>(
                    "DocumentReferenceStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DocumentReferenceStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<DocumentReferenceStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DocumentReferenceStatusCode,
        };
        unsafe {
            instance.get(DocumentReferenceStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for DocumentReferenceStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentReferenceStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentReferenceStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DocumentReferenceStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    CURRENT = 1,
    SUPERSEDED = 2,
    ENTERED_IN_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for DocumentReferenceStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DocumentReferenceStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DocumentReferenceStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DocumentReferenceStatusCode_Value::CURRENT),
            2 => ::std::option::Option::Some(DocumentReferenceStatusCode_Value::SUPERSEDED),
            3 => ::std::option::Option::Some(DocumentReferenceStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DocumentReferenceStatusCode_Value] = &[
            DocumentReferenceStatusCode_Value::INVALID_UNINITIALIZED,
            DocumentReferenceStatusCode_Value::CURRENT,
            DocumentReferenceStatusCode_Value::SUPERSEDED,
            DocumentReferenceStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DocumentReferenceStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DocumentReferenceStatusCode_Value {
}

impl ::std::default::Default for DocumentReferenceStatusCode_Value {
    fn default() -> Self {
        DocumentReferenceStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentReferenceStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DocumentRelationshipTypeCode {
    // message fields
    pub value: DocumentRelationshipTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DocumentRelationshipTypeCode {
    pub fn new() -> DocumentRelationshipTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DocumentRelationshipTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DocumentRelationshipTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DocumentRelationshipTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DocumentRelationshipTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DocumentRelationshipTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DocumentRelationshipTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DocumentRelationshipTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentRelationshipTypeCode {
        DocumentRelationshipTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DocumentRelationshipTypeCode_Value>>(
                    "value",
                    |m: &DocumentRelationshipTypeCode| { &m.value },
                    |m: &mut DocumentRelationshipTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DocumentRelationshipTypeCode| { &m.id },
                    |m: &mut DocumentRelationshipTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DocumentRelationshipTypeCode| { &m.extension },
                    |m: &mut DocumentRelationshipTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DocumentRelationshipTypeCode>(
                    "DocumentRelationshipTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DocumentRelationshipTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<DocumentRelationshipTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DocumentRelationshipTypeCode,
        };
        unsafe {
            instance.get(DocumentRelationshipTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for DocumentRelationshipTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentRelationshipTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentRelationshipTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DocumentRelationshipTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    REPLACES = 1,
    TRANSFORMS = 2,
    SIGNS = 3,
    APPENDS = 4,
}

impl ::protobuf::ProtobufEnum for DocumentRelationshipTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DocumentRelationshipTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DocumentRelationshipTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DocumentRelationshipTypeCode_Value::REPLACES),
            2 => ::std::option::Option::Some(DocumentRelationshipTypeCode_Value::TRANSFORMS),
            3 => ::std::option::Option::Some(DocumentRelationshipTypeCode_Value::SIGNS),
            4 => ::std::option::Option::Some(DocumentRelationshipTypeCode_Value::APPENDS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DocumentRelationshipTypeCode_Value] = &[
            DocumentRelationshipTypeCode_Value::INVALID_UNINITIALIZED,
            DocumentRelationshipTypeCode_Value::REPLACES,
            DocumentRelationshipTypeCode_Value::TRANSFORMS,
            DocumentRelationshipTypeCode_Value::SIGNS,
            DocumentRelationshipTypeCode_Value::APPENDS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DocumentRelationshipTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DocumentRelationshipTypeCode_Value {
}

impl ::std::default::Default for DocumentRelationshipTypeCode_Value {
    fn default() -> Self {
        DocumentRelationshipTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentRelationshipTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdmitSourceCode {
    // message fields
    pub value: AdmitSourceCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AdmitSourceCode {
    pub fn new() -> AdmitSourceCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AdmitSourceCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AdmitSourceCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AdmitSourceCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AdmitSourceCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AdmitSourceCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AdmitSourceCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AdmitSourceCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdmitSourceCode {
        AdmitSourceCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AdmitSourceCode_Value>>(
                    "value",
                    |m: &AdmitSourceCode| { &m.value },
                    |m: &mut AdmitSourceCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AdmitSourceCode| { &m.id },
                    |m: &mut AdmitSourceCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AdmitSourceCode| { &m.extension },
                    |m: &mut AdmitSourceCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AdmitSourceCode>(
                    "AdmitSourceCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AdmitSourceCode {
        static mut instance: ::protobuf::lazy::Lazy<AdmitSourceCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AdmitSourceCode,
        };
        unsafe {
            instance.get(AdmitSourceCode::new)
        }
    }
}

impl ::protobuf::Clear for AdmitSourceCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdmitSourceCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdmitSourceCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AdmitSourceCode_Value {
    INVALID_UNINITIALIZED = 0,
    HOSP_TRANS = 1,
    EMD = 2,
    OUTP = 3,
    BORN = 4,
    GP = 5,
    MP = 6,
    NURSING = 7,
    PSYCH = 8,
    REHAB = 9,
    OTHER = 10,
}

impl ::protobuf::ProtobufEnum for AdmitSourceCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AdmitSourceCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AdmitSourceCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AdmitSourceCode_Value::HOSP_TRANS),
            2 => ::std::option::Option::Some(AdmitSourceCode_Value::EMD),
            3 => ::std::option::Option::Some(AdmitSourceCode_Value::OUTP),
            4 => ::std::option::Option::Some(AdmitSourceCode_Value::BORN),
            5 => ::std::option::Option::Some(AdmitSourceCode_Value::GP),
            6 => ::std::option::Option::Some(AdmitSourceCode_Value::MP),
            7 => ::std::option::Option::Some(AdmitSourceCode_Value::NURSING),
            8 => ::std::option::Option::Some(AdmitSourceCode_Value::PSYCH),
            9 => ::std::option::Option::Some(AdmitSourceCode_Value::REHAB),
            10 => ::std::option::Option::Some(AdmitSourceCode_Value::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AdmitSourceCode_Value] = &[
            AdmitSourceCode_Value::INVALID_UNINITIALIZED,
            AdmitSourceCode_Value::HOSP_TRANS,
            AdmitSourceCode_Value::EMD,
            AdmitSourceCode_Value::OUTP,
            AdmitSourceCode_Value::BORN,
            AdmitSourceCode_Value::GP,
            AdmitSourceCode_Value::MP,
            AdmitSourceCode_Value::NURSING,
            AdmitSourceCode_Value::PSYCH,
            AdmitSourceCode_Value::REHAB,
            AdmitSourceCode_Value::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AdmitSourceCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AdmitSourceCode_Value {
}

impl ::std::default::Default for AdmitSourceCode_Value {
    fn default() -> Self {
        AdmitSourceCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AdmitSourceCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DietCode {
    // message fields
    pub value: DietCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DietCode {
    pub fn new() -> DietCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DietCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DietCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DietCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DietCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DietCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DietCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DietCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DietCode {
        DietCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DietCode_Value>>(
                    "value",
                    |m: &DietCode| { &m.value },
                    |m: &mut DietCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DietCode| { &m.id },
                    |m: &mut DietCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DietCode| { &m.extension },
                    |m: &mut DietCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DietCode>(
                    "DietCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DietCode {
        static mut instance: ::protobuf::lazy::Lazy<DietCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DietCode,
        };
        unsafe {
            instance.get(DietCode::new)
        }
    }
}

impl ::protobuf::Clear for DietCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DietCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DietCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DietCode_Value {
    INVALID_UNINITIALIZED = 0,
    VEGETARIAN = 1,
    DAIRY_FREE = 2,
    NUT_FREE = 3,
    GLUTEN_FREE = 4,
    VEGAN = 5,
    HALAL = 6,
    KOSHER = 7,
}

impl ::protobuf::ProtobufEnum for DietCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DietCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DietCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DietCode_Value::VEGETARIAN),
            2 => ::std::option::Option::Some(DietCode_Value::DAIRY_FREE),
            3 => ::std::option::Option::Some(DietCode_Value::NUT_FREE),
            4 => ::std::option::Option::Some(DietCode_Value::GLUTEN_FREE),
            5 => ::std::option::Option::Some(DietCode_Value::VEGAN),
            6 => ::std::option::Option::Some(DietCode_Value::HALAL),
            7 => ::std::option::Option::Some(DietCode_Value::KOSHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DietCode_Value] = &[
            DietCode_Value::INVALID_UNINITIALIZED,
            DietCode_Value::VEGETARIAN,
            DietCode_Value::DAIRY_FREE,
            DietCode_Value::NUT_FREE,
            DietCode_Value::GLUTEN_FREE,
            DietCode_Value::VEGAN,
            DietCode_Value::HALAL,
            DietCode_Value::KOSHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DietCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DietCode_Value {
}

impl ::std::default::Default for DietCode_Value {
    fn default() -> Self {
        DietCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DietCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DischargeDispositionCode {
    // message fields
    pub value: DischargeDispositionCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DischargeDispositionCode {
    pub fn new() -> DischargeDispositionCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DischargeDispositionCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DischargeDispositionCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DischargeDispositionCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DischargeDispositionCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DischargeDispositionCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DischargeDispositionCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DischargeDispositionCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DischargeDispositionCode {
        DischargeDispositionCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DischargeDispositionCode_Value>>(
                    "value",
                    |m: &DischargeDispositionCode| { &m.value },
                    |m: &mut DischargeDispositionCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DischargeDispositionCode| { &m.id },
                    |m: &mut DischargeDispositionCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DischargeDispositionCode| { &m.extension },
                    |m: &mut DischargeDispositionCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DischargeDispositionCode>(
                    "DischargeDispositionCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DischargeDispositionCode {
        static mut instance: ::protobuf::lazy::Lazy<DischargeDispositionCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DischargeDispositionCode,
        };
        unsafe {
            instance.get(DischargeDispositionCode::new)
        }
    }
}

impl ::protobuf::Clear for DischargeDispositionCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DischargeDispositionCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DischargeDispositionCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DischargeDispositionCode_Value {
    INVALID_UNINITIALIZED = 0,
    HOME = 1,
    OTHER_HCF = 2,
    HOSP = 3,
    LONG = 4,
    AADVICE = 5,
    EXP = 6,
    PSY = 7,
    REHAB = 8,
    SNF = 9,
    OTH = 10,
}

impl ::protobuf::ProtobufEnum for DischargeDispositionCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DischargeDispositionCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DischargeDispositionCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DischargeDispositionCode_Value::HOME),
            2 => ::std::option::Option::Some(DischargeDispositionCode_Value::OTHER_HCF),
            3 => ::std::option::Option::Some(DischargeDispositionCode_Value::HOSP),
            4 => ::std::option::Option::Some(DischargeDispositionCode_Value::LONG),
            5 => ::std::option::Option::Some(DischargeDispositionCode_Value::AADVICE),
            6 => ::std::option::Option::Some(DischargeDispositionCode_Value::EXP),
            7 => ::std::option::Option::Some(DischargeDispositionCode_Value::PSY),
            8 => ::std::option::Option::Some(DischargeDispositionCode_Value::REHAB),
            9 => ::std::option::Option::Some(DischargeDispositionCode_Value::SNF),
            10 => ::std::option::Option::Some(DischargeDispositionCode_Value::OTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DischargeDispositionCode_Value] = &[
            DischargeDispositionCode_Value::INVALID_UNINITIALIZED,
            DischargeDispositionCode_Value::HOME,
            DischargeDispositionCode_Value::OTHER_HCF,
            DischargeDispositionCode_Value::HOSP,
            DischargeDispositionCode_Value::LONG,
            DischargeDispositionCode_Value::AADVICE,
            DischargeDispositionCode_Value::EXP,
            DischargeDispositionCode_Value::PSY,
            DischargeDispositionCode_Value::REHAB,
            DischargeDispositionCode_Value::SNF,
            DischargeDispositionCode_Value::OTH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DischargeDispositionCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DischargeDispositionCode_Value {
}

impl ::std::default::Default for DischargeDispositionCode_Value {
    fn default() -> Self {
        DischargeDispositionCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DischargeDispositionCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncounterLocationStatusCode {
    // message fields
    pub value: EncounterLocationStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EncounterLocationStatusCode {
    pub fn new() -> EncounterLocationStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.EncounterLocationStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = EncounterLocationStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: EncounterLocationStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> EncounterLocationStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for EncounterLocationStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != EncounterLocationStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != EncounterLocationStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncounterLocationStatusCode {
        EncounterLocationStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncounterLocationStatusCode_Value>>(
                    "value",
                    |m: &EncounterLocationStatusCode| { &m.value },
                    |m: &mut EncounterLocationStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &EncounterLocationStatusCode| { &m.id },
                    |m: &mut EncounterLocationStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &EncounterLocationStatusCode| { &m.extension },
                    |m: &mut EncounterLocationStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EncounterLocationStatusCode>(
                    "EncounterLocationStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncounterLocationStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<EncounterLocationStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EncounterLocationStatusCode,
        };
        unsafe {
            instance.get(EncounterLocationStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for EncounterLocationStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncounterLocationStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncounterLocationStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EncounterLocationStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PLANNED = 1,
    ACTIVE = 2,
    RESERVED = 3,
    COMPLETED = 4,
}

impl ::protobuf::ProtobufEnum for EncounterLocationStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncounterLocationStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(EncounterLocationStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(EncounterLocationStatusCode_Value::PLANNED),
            2 => ::std::option::Option::Some(EncounterLocationStatusCode_Value::ACTIVE),
            3 => ::std::option::Option::Some(EncounterLocationStatusCode_Value::RESERVED),
            4 => ::std::option::Option::Some(EncounterLocationStatusCode_Value::COMPLETED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EncounterLocationStatusCode_Value] = &[
            EncounterLocationStatusCode_Value::INVALID_UNINITIALIZED,
            EncounterLocationStatusCode_Value::PLANNED,
            EncounterLocationStatusCode_Value::ACTIVE,
            EncounterLocationStatusCode_Value::RESERVED,
            EncounterLocationStatusCode_Value::COMPLETED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EncounterLocationStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EncounterLocationStatusCode_Value {
}

impl ::std::default::Default for EncounterLocationStatusCode_Value {
    fn default() -> Self {
        EncounterLocationStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for EncounterLocationStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SpecialArrangementsCode {
    // message fields
    pub value: SpecialArrangementsCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SpecialArrangementsCode {
    pub fn new() -> SpecialArrangementsCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SpecialArrangementsCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SpecialArrangementsCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SpecialArrangementsCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SpecialArrangementsCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SpecialArrangementsCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SpecialArrangementsCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SpecialArrangementsCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpecialArrangementsCode {
        SpecialArrangementsCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SpecialArrangementsCode_Value>>(
                    "value",
                    |m: &SpecialArrangementsCode| { &m.value },
                    |m: &mut SpecialArrangementsCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SpecialArrangementsCode| { &m.id },
                    |m: &mut SpecialArrangementsCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SpecialArrangementsCode| { &m.extension },
                    |m: &mut SpecialArrangementsCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SpecialArrangementsCode>(
                    "SpecialArrangementsCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SpecialArrangementsCode {
        static mut instance: ::protobuf::lazy::Lazy<SpecialArrangementsCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SpecialArrangementsCode,
        };
        unsafe {
            instance.get(SpecialArrangementsCode::new)
        }
    }
}

impl ::protobuf::Clear for SpecialArrangementsCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpecialArrangementsCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpecialArrangementsCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SpecialArrangementsCode_Value {
    INVALID_UNINITIALIZED = 0,
    WHEEL = 1,
    ADD_BED = 2,
    INT = 3,
    ATT = 4,
    DOG = 5,
}

impl ::protobuf::ProtobufEnum for SpecialArrangementsCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SpecialArrangementsCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SpecialArrangementsCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SpecialArrangementsCode_Value::WHEEL),
            2 => ::std::option::Option::Some(SpecialArrangementsCode_Value::ADD_BED),
            3 => ::std::option::Option::Some(SpecialArrangementsCode_Value::INT),
            4 => ::std::option::Option::Some(SpecialArrangementsCode_Value::ATT),
            5 => ::std::option::Option::Some(SpecialArrangementsCode_Value::DOG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SpecialArrangementsCode_Value] = &[
            SpecialArrangementsCode_Value::INVALID_UNINITIALIZED,
            SpecialArrangementsCode_Value::WHEEL,
            SpecialArrangementsCode_Value::ADD_BED,
            SpecialArrangementsCode_Value::INT,
            SpecialArrangementsCode_Value::ATT,
            SpecialArrangementsCode_Value::DOG,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SpecialArrangementsCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SpecialArrangementsCode_Value {
}

impl ::std::default::Default for SpecialArrangementsCode_Value {
    fn default() -> Self {
        SpecialArrangementsCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SpecialArrangementsCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncounterStatusCode {
    // message fields
    pub value: EncounterStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EncounterStatusCode {
    pub fn new() -> EncounterStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.EncounterStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = EncounterStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: EncounterStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> EncounterStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for EncounterStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != EncounterStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != EncounterStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncounterStatusCode {
        EncounterStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncounterStatusCode_Value>>(
                    "value",
                    |m: &EncounterStatusCode| { &m.value },
                    |m: &mut EncounterStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &EncounterStatusCode| { &m.id },
                    |m: &mut EncounterStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &EncounterStatusCode| { &m.extension },
                    |m: &mut EncounterStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EncounterStatusCode>(
                    "EncounterStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncounterStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<EncounterStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EncounterStatusCode,
        };
        unsafe {
            instance.get(EncounterStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for EncounterStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncounterStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncounterStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EncounterStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PLANNED = 1,
    ARRIVED = 2,
    TRIAGED = 3,
    IN_PROGRESS = 4,
    ONLEAVE = 5,
    FINISHED = 6,
    CANCELLED = 7,
    ENTERED_IN_ERROR = 8,
    UNKNOWN = 9,
}

impl ::protobuf::ProtobufEnum for EncounterStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncounterStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(EncounterStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(EncounterStatusCode_Value::PLANNED),
            2 => ::std::option::Option::Some(EncounterStatusCode_Value::ARRIVED),
            3 => ::std::option::Option::Some(EncounterStatusCode_Value::TRIAGED),
            4 => ::std::option::Option::Some(EncounterStatusCode_Value::IN_PROGRESS),
            5 => ::std::option::Option::Some(EncounterStatusCode_Value::ONLEAVE),
            6 => ::std::option::Option::Some(EncounterStatusCode_Value::FINISHED),
            7 => ::std::option::Option::Some(EncounterStatusCode_Value::CANCELLED),
            8 => ::std::option::Option::Some(EncounterStatusCode_Value::ENTERED_IN_ERROR),
            9 => ::std::option::Option::Some(EncounterStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EncounterStatusCode_Value] = &[
            EncounterStatusCode_Value::INVALID_UNINITIALIZED,
            EncounterStatusCode_Value::PLANNED,
            EncounterStatusCode_Value::ARRIVED,
            EncounterStatusCode_Value::TRIAGED,
            EncounterStatusCode_Value::IN_PROGRESS,
            EncounterStatusCode_Value::ONLEAVE,
            EncounterStatusCode_Value::FINISHED,
            EncounterStatusCode_Value::CANCELLED,
            EncounterStatusCode_Value::ENTERED_IN_ERROR,
            EncounterStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EncounterStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EncounterStatusCode_Value {
}

impl ::std::default::Default for EncounterStatusCode_Value {
    fn default() -> Self {
        EncounterStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for EncounterStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncounterTypeCode {
    // message fields
    pub value: EncounterTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EncounterTypeCode {
    pub fn new() -> EncounterTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.EncounterTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = EncounterTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: EncounterTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> EncounterTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for EncounterTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != EncounterTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != EncounterTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncounterTypeCode {
        EncounterTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncounterTypeCode_Value>>(
                    "value",
                    |m: &EncounterTypeCode| { &m.value },
                    |m: &mut EncounterTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &EncounterTypeCode| { &m.id },
                    |m: &mut EncounterTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &EncounterTypeCode| { &m.extension },
                    |m: &mut EncounterTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EncounterTypeCode>(
                    "EncounterTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncounterTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<EncounterTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EncounterTypeCode,
        };
        unsafe {
            instance.get(EncounterTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for EncounterTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncounterTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncounterTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EncounterTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    ADMS = 1,
    BD_BM_CLIN = 2,
    CCS60 = 3,
    OKI = 4,
}

impl ::protobuf::ProtobufEnum for EncounterTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncounterTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(EncounterTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(EncounterTypeCode_Value::ADMS),
            2 => ::std::option::Option::Some(EncounterTypeCode_Value::BD_BM_CLIN),
            3 => ::std::option::Option::Some(EncounterTypeCode_Value::CCS60),
            4 => ::std::option::Option::Some(EncounterTypeCode_Value::OKI),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EncounterTypeCode_Value] = &[
            EncounterTypeCode_Value::INVALID_UNINITIALIZED,
            EncounterTypeCode_Value::ADMS,
            EncounterTypeCode_Value::BD_BM_CLIN,
            EncounterTypeCode_Value::CCS60,
            EncounterTypeCode_Value::OKI,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EncounterTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EncounterTypeCode_Value {
}

impl ::std::default::Default for EncounterTypeCode_Value {
    fn default() -> Self {
        EncounterTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for EncounterTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndpointStatusCode {
    // message fields
    pub value: EndpointStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EndpointStatusCode {
    pub fn new() -> EndpointStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.EndpointStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = EndpointStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: EndpointStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> EndpointStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for EndpointStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != EndpointStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != EndpointStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndpointStatusCode {
        EndpointStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EndpointStatusCode_Value>>(
                    "value",
                    |m: &EndpointStatusCode| { &m.value },
                    |m: &mut EndpointStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &EndpointStatusCode| { &m.id },
                    |m: &mut EndpointStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &EndpointStatusCode| { &m.extension },
                    |m: &mut EndpointStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EndpointStatusCode>(
                    "EndpointStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EndpointStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<EndpointStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EndpointStatusCode,
        };
        unsafe {
            instance.get(EndpointStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for EndpointStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndpointStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EndpointStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    SUSPENDED = 2,
    ERROR = 3,
    OFF = 4,
    ENTERED_IN_ERROR = 5,
    TEST = 6,
}

impl ::protobuf::ProtobufEnum for EndpointStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EndpointStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(EndpointStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(EndpointStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(EndpointStatusCode_Value::SUSPENDED),
            3 => ::std::option::Option::Some(EndpointStatusCode_Value::ERROR),
            4 => ::std::option::Option::Some(EndpointStatusCode_Value::OFF),
            5 => ::std::option::Option::Some(EndpointStatusCode_Value::ENTERED_IN_ERROR),
            6 => ::std::option::Option::Some(EndpointStatusCode_Value::TEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EndpointStatusCode_Value] = &[
            EndpointStatusCode_Value::INVALID_UNINITIALIZED,
            EndpointStatusCode_Value::ACTIVE,
            EndpointStatusCode_Value::SUSPENDED,
            EndpointStatusCode_Value::ERROR,
            EndpointStatusCode_Value::OFF,
            EndpointStatusCode_Value::ENTERED_IN_ERROR,
            EndpointStatusCode_Value::TEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EndpointStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EndpointStatusCode_Value {
}

impl ::std::default::Default for EndpointStatusCode_Value {
    fn default() -> Self {
        EndpointStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntityNamePartQualifierCode {
    // message fields
    pub value: EntityNamePartQualifierCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EntityNamePartQualifierCode {
    pub fn new() -> EntityNamePartQualifierCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.EntityNamePartQualifierCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = EntityNamePartQualifierCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: EntityNamePartQualifierCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> EntityNamePartQualifierCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for EntityNamePartQualifierCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != EntityNamePartQualifierCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != EntityNamePartQualifierCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntityNamePartQualifierCode {
        EntityNamePartQualifierCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityNamePartQualifierCode_Value>>(
                    "value",
                    |m: &EntityNamePartQualifierCode| { &m.value },
                    |m: &mut EntityNamePartQualifierCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &EntityNamePartQualifierCode| { &m.id },
                    |m: &mut EntityNamePartQualifierCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &EntityNamePartQualifierCode| { &m.extension },
                    |m: &mut EntityNamePartQualifierCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EntityNamePartQualifierCode>(
                    "EntityNamePartQualifierCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EntityNamePartQualifierCode {
        static mut instance: ::protobuf::lazy::Lazy<EntityNamePartQualifierCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EntityNamePartQualifierCode,
        };
        unsafe {
            instance.get(EntityNamePartQualifierCode::new)
        }
    }
}

impl ::protobuf::Clear for EntityNamePartQualifierCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntityNamePartQualifierCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityNamePartQualifierCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EntityNamePartQualifierCode_Value {
    INVALID_UNINITIALIZED = 0,
    LS = 1,
    AC = 2,
    NB = 3,
    PR = 4,
    HON = 5,
    BR = 6,
    AD = 7,
    SP = 8,
    MID = 9,
    CL = 10,
    IN = 11,
}

impl ::protobuf::ProtobufEnum for EntityNamePartQualifierCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EntityNamePartQualifierCode_Value> {
        match value {
            0 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::LS),
            2 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::AC),
            3 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::NB),
            4 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::PR),
            5 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::HON),
            6 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::BR),
            7 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::AD),
            8 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::SP),
            9 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::MID),
            10 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::CL),
            11 => ::std::option::Option::Some(EntityNamePartQualifierCode_Value::IN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EntityNamePartQualifierCode_Value] = &[
            EntityNamePartQualifierCode_Value::INVALID_UNINITIALIZED,
            EntityNamePartQualifierCode_Value::LS,
            EntityNamePartQualifierCode_Value::AC,
            EntityNamePartQualifierCode_Value::NB,
            EntityNamePartQualifierCode_Value::PR,
            EntityNamePartQualifierCode_Value::HON,
            EntityNamePartQualifierCode_Value::BR,
            EntityNamePartQualifierCode_Value::AD,
            EntityNamePartQualifierCode_Value::SP,
            EntityNamePartQualifierCode_Value::MID,
            EntityNamePartQualifierCode_Value::CL,
            EntityNamePartQualifierCode_Value::IN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EntityNamePartQualifierCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EntityNamePartQualifierCode_Value {
}

impl ::std::default::Default for EntityNamePartQualifierCode_Value {
    fn default() -> Self {
        EntityNamePartQualifierCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityNamePartQualifierCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnteralFormulaAdditiveTypeCodeCode {
    // message fields
    pub value: EnteralFormulaAdditiveTypeCodeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EnteralFormulaAdditiveTypeCodeCode {
    pub fn new() -> EnteralFormulaAdditiveTypeCodeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.EnteralFormulaAdditiveTypeCodeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = EnteralFormulaAdditiveTypeCodeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: EnteralFormulaAdditiveTypeCodeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> EnteralFormulaAdditiveTypeCodeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for EnteralFormulaAdditiveTypeCodeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != EnteralFormulaAdditiveTypeCodeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != EnteralFormulaAdditiveTypeCodeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnteralFormulaAdditiveTypeCodeCode {
        EnteralFormulaAdditiveTypeCodeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EnteralFormulaAdditiveTypeCodeCode_Value>>(
                    "value",
                    |m: &EnteralFormulaAdditiveTypeCodeCode| { &m.value },
                    |m: &mut EnteralFormulaAdditiveTypeCodeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &EnteralFormulaAdditiveTypeCodeCode| { &m.id },
                    |m: &mut EnteralFormulaAdditiveTypeCodeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &EnteralFormulaAdditiveTypeCodeCode| { &m.extension },
                    |m: &mut EnteralFormulaAdditiveTypeCodeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EnteralFormulaAdditiveTypeCodeCode>(
                    "EnteralFormulaAdditiveTypeCodeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnteralFormulaAdditiveTypeCodeCode {
        static mut instance: ::protobuf::lazy::Lazy<EnteralFormulaAdditiveTypeCodeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EnteralFormulaAdditiveTypeCodeCode,
        };
        unsafe {
            instance.get(EnteralFormulaAdditiveTypeCodeCode::new)
        }
    }
}

impl ::protobuf::Clear for EnteralFormulaAdditiveTypeCodeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnteralFormulaAdditiveTypeCodeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnteralFormulaAdditiveTypeCodeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EnteralFormulaAdditiveTypeCodeCode_Value {
    INVALID_UNINITIALIZED = 0,
    LIPID = 1,
    PROTEIN = 2,
    CARBOHYDRATE = 3,
    FIBER = 4,
    WATER = 5,
}

impl ::protobuf::ProtobufEnum for EnteralFormulaAdditiveTypeCodeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EnteralFormulaAdditiveTypeCodeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(EnteralFormulaAdditiveTypeCodeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(EnteralFormulaAdditiveTypeCodeCode_Value::LIPID),
            2 => ::std::option::Option::Some(EnteralFormulaAdditiveTypeCodeCode_Value::PROTEIN),
            3 => ::std::option::Option::Some(EnteralFormulaAdditiveTypeCodeCode_Value::CARBOHYDRATE),
            4 => ::std::option::Option::Some(EnteralFormulaAdditiveTypeCodeCode_Value::FIBER),
            5 => ::std::option::Option::Some(EnteralFormulaAdditiveTypeCodeCode_Value::WATER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EnteralFormulaAdditiveTypeCodeCode_Value] = &[
            EnteralFormulaAdditiveTypeCodeCode_Value::INVALID_UNINITIALIZED,
            EnteralFormulaAdditiveTypeCodeCode_Value::LIPID,
            EnteralFormulaAdditiveTypeCodeCode_Value::PROTEIN,
            EnteralFormulaAdditiveTypeCodeCode_Value::CARBOHYDRATE,
            EnteralFormulaAdditiveTypeCodeCode_Value::FIBER,
            EnteralFormulaAdditiveTypeCodeCode_Value::WATER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EnteralFormulaAdditiveTypeCodeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EnteralFormulaAdditiveTypeCodeCode_Value {
}

impl ::std::default::Default for EnteralFormulaAdditiveTypeCodeCode_Value {
    fn default() -> Self {
        EnteralFormulaAdditiveTypeCodeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for EnteralFormulaAdditiveTypeCodeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpisodeOfCareStatusCode {
    // message fields
    pub value: EpisodeOfCareStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EpisodeOfCareStatusCode {
    pub fn new() -> EpisodeOfCareStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.EpisodeOfCareStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = EpisodeOfCareStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: EpisodeOfCareStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> EpisodeOfCareStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for EpisodeOfCareStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != EpisodeOfCareStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != EpisodeOfCareStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpisodeOfCareStatusCode {
        EpisodeOfCareStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EpisodeOfCareStatusCode_Value>>(
                    "value",
                    |m: &EpisodeOfCareStatusCode| { &m.value },
                    |m: &mut EpisodeOfCareStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &EpisodeOfCareStatusCode| { &m.id },
                    |m: &mut EpisodeOfCareStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &EpisodeOfCareStatusCode| { &m.extension },
                    |m: &mut EpisodeOfCareStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EpisodeOfCareStatusCode>(
                    "EpisodeOfCareStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpisodeOfCareStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<EpisodeOfCareStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EpisodeOfCareStatusCode,
        };
        unsafe {
            instance.get(EpisodeOfCareStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for EpisodeOfCareStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpisodeOfCareStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpisodeOfCareStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EpisodeOfCareStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PLANNED = 1,
    WAITLIST = 2,
    ACTIVE = 3,
    ONHOLD = 4,
    FINISHED = 5,
    CANCELLED = 6,
    ENTERED_IN_ERROR = 7,
}

impl ::protobuf::ProtobufEnum for EpisodeOfCareStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EpisodeOfCareStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(EpisodeOfCareStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(EpisodeOfCareStatusCode_Value::PLANNED),
            2 => ::std::option::Option::Some(EpisodeOfCareStatusCode_Value::WAITLIST),
            3 => ::std::option::Option::Some(EpisodeOfCareStatusCode_Value::ACTIVE),
            4 => ::std::option::Option::Some(EpisodeOfCareStatusCode_Value::ONHOLD),
            5 => ::std::option::Option::Some(EpisodeOfCareStatusCode_Value::FINISHED),
            6 => ::std::option::Option::Some(EpisodeOfCareStatusCode_Value::CANCELLED),
            7 => ::std::option::Option::Some(EpisodeOfCareStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EpisodeOfCareStatusCode_Value] = &[
            EpisodeOfCareStatusCode_Value::INVALID_UNINITIALIZED,
            EpisodeOfCareStatusCode_Value::PLANNED,
            EpisodeOfCareStatusCode_Value::WAITLIST,
            EpisodeOfCareStatusCode_Value::ACTIVE,
            EpisodeOfCareStatusCode_Value::ONHOLD,
            EpisodeOfCareStatusCode_Value::FINISHED,
            EpisodeOfCareStatusCode_Value::CANCELLED,
            EpisodeOfCareStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EpisodeOfCareStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EpisodeOfCareStatusCode_Value {
}

impl ::std::default::Default for EpisodeOfCareStatusCode_Value {
    fn default() -> Self {
        EpisodeOfCareStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for EpisodeOfCareStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EpisodeOfCareTypeCode {
    // message fields
    pub value: EpisodeOfCareTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EpisodeOfCareTypeCode {
    pub fn new() -> EpisodeOfCareTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.EpisodeOfCareTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = EpisodeOfCareTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: EpisodeOfCareTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> EpisodeOfCareTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for EpisodeOfCareTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != EpisodeOfCareTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != EpisodeOfCareTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EpisodeOfCareTypeCode {
        EpisodeOfCareTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EpisodeOfCareTypeCode_Value>>(
                    "value",
                    |m: &EpisodeOfCareTypeCode| { &m.value },
                    |m: &mut EpisodeOfCareTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &EpisodeOfCareTypeCode| { &m.id },
                    |m: &mut EpisodeOfCareTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &EpisodeOfCareTypeCode| { &m.extension },
                    |m: &mut EpisodeOfCareTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EpisodeOfCareTypeCode>(
                    "EpisodeOfCareTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EpisodeOfCareTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<EpisodeOfCareTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EpisodeOfCareTypeCode,
        };
        unsafe {
            instance.get(EpisodeOfCareTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for EpisodeOfCareTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EpisodeOfCareTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EpisodeOfCareTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EpisodeOfCareTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    HACC = 1,
    PAC = 2,
    DIAB = 3,
    DA = 4,
    CACP = 5,
}

impl ::protobuf::ProtobufEnum for EpisodeOfCareTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EpisodeOfCareTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(EpisodeOfCareTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(EpisodeOfCareTypeCode_Value::HACC),
            2 => ::std::option::Option::Some(EpisodeOfCareTypeCode_Value::PAC),
            3 => ::std::option::Option::Some(EpisodeOfCareTypeCode_Value::DIAB),
            4 => ::std::option::Option::Some(EpisodeOfCareTypeCode_Value::DA),
            5 => ::std::option::Option::Some(EpisodeOfCareTypeCode_Value::CACP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EpisodeOfCareTypeCode_Value] = &[
            EpisodeOfCareTypeCode_Value::INVALID_UNINITIALIZED,
            EpisodeOfCareTypeCode_Value::HACC,
            EpisodeOfCareTypeCode_Value::PAC,
            EpisodeOfCareTypeCode_Value::DIAB,
            EpisodeOfCareTypeCode_Value::DA,
            EpisodeOfCareTypeCode_Value::CACP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EpisodeOfCareTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EpisodeOfCareTypeCode_Value {
}

impl ::std::default::Default for EpisodeOfCareTypeCode_Value {
    fn default() -> Self {
        EpisodeOfCareTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for EpisodeOfCareTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventCapabilityModeCode {
    // message fields
    pub value: EventCapabilityModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EventCapabilityModeCode {
    pub fn new() -> EventCapabilityModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.EventCapabilityModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = EventCapabilityModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: EventCapabilityModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> EventCapabilityModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for EventCapabilityModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != EventCapabilityModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != EventCapabilityModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventCapabilityModeCode {
        EventCapabilityModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EventCapabilityModeCode_Value>>(
                    "value",
                    |m: &EventCapabilityModeCode| { &m.value },
                    |m: &mut EventCapabilityModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &EventCapabilityModeCode| { &m.id },
                    |m: &mut EventCapabilityModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &EventCapabilityModeCode| { &m.extension },
                    |m: &mut EventCapabilityModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EventCapabilityModeCode>(
                    "EventCapabilityModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EventCapabilityModeCode {
        static mut instance: ::protobuf::lazy::Lazy<EventCapabilityModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventCapabilityModeCode,
        };
        unsafe {
            instance.get(EventCapabilityModeCode::new)
        }
    }
}

impl ::protobuf::Clear for EventCapabilityModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventCapabilityModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventCapabilityModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EventCapabilityModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    SENDER = 1,
    RECEIVER = 2,
}

impl ::protobuf::ProtobufEnum for EventCapabilityModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EventCapabilityModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(EventCapabilityModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(EventCapabilityModeCode_Value::SENDER),
            2 => ::std::option::Option::Some(EventCapabilityModeCode_Value::RECEIVER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EventCapabilityModeCode_Value] = &[
            EventCapabilityModeCode_Value::INVALID_UNINITIALIZED,
            EventCapabilityModeCode_Value::SENDER,
            EventCapabilityModeCode_Value::RECEIVER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EventCapabilityModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EventCapabilityModeCode_Value {
}

impl ::std::default::Default for EventCapabilityModeCode_Value {
    fn default() -> Self {
        EventCapabilityModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for EventCapabilityModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventStatusCode {
    // message fields
    pub value: EventStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EventStatusCode {
    pub fn new() -> EventStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.EventStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = EventStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: EventStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> EventStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for EventStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != EventStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != EventStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventStatusCode {
        EventStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EventStatusCode_Value>>(
                    "value",
                    |m: &EventStatusCode| { &m.value },
                    |m: &mut EventStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &EventStatusCode| { &m.id },
                    |m: &mut EventStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &EventStatusCode| { &m.extension },
                    |m: &mut EventStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EventStatusCode>(
                    "EventStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EventStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<EventStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventStatusCode,
        };
        unsafe {
            instance.get(EventStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for EventStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EventStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PREPARATION = 1,
    IN_PROGRESS = 2,
    SUSPENDED = 3,
    ABORTED = 4,
    COMPLETED = 5,
    ENTERED_IN_ERROR = 6,
    UNKNOWN = 7,
}

impl ::protobuf::ProtobufEnum for EventStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EventStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(EventStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(EventStatusCode_Value::PREPARATION),
            2 => ::std::option::Option::Some(EventStatusCode_Value::IN_PROGRESS),
            3 => ::std::option::Option::Some(EventStatusCode_Value::SUSPENDED),
            4 => ::std::option::Option::Some(EventStatusCode_Value::ABORTED),
            5 => ::std::option::Option::Some(EventStatusCode_Value::COMPLETED),
            6 => ::std::option::Option::Some(EventStatusCode_Value::ENTERED_IN_ERROR),
            7 => ::std::option::Option::Some(EventStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EventStatusCode_Value] = &[
            EventStatusCode_Value::INVALID_UNINITIALIZED,
            EventStatusCode_Value::PREPARATION,
            EventStatusCode_Value::IN_PROGRESS,
            EventStatusCode_Value::SUSPENDED,
            EventStatusCode_Value::ABORTED,
            EventStatusCode_Value::COMPLETED,
            EventStatusCode_Value::ENTERED_IN_ERROR,
            EventStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EventStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EventStatusCode_Value {
}

impl ::std::default::Default for EventStatusCode_Value {
    fn default() -> Self {
        EventStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for EventStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClaimPayeeResourceTypeCode {
    // message fields
    pub value: ClaimPayeeResourceTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ClaimPayeeResourceTypeCode {
    pub fn new() -> ClaimPayeeResourceTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ClaimPayeeResourceTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ClaimPayeeResourceTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ClaimPayeeResourceTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ClaimPayeeResourceTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ClaimPayeeResourceTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ClaimPayeeResourceTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ClaimPayeeResourceTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClaimPayeeResourceTypeCode {
        ClaimPayeeResourceTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClaimPayeeResourceTypeCode_Value>>(
                    "value",
                    |m: &ClaimPayeeResourceTypeCode| { &m.value },
                    |m: &mut ClaimPayeeResourceTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ClaimPayeeResourceTypeCode| { &m.id },
                    |m: &mut ClaimPayeeResourceTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ClaimPayeeResourceTypeCode| { &m.extension },
                    |m: &mut ClaimPayeeResourceTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClaimPayeeResourceTypeCode>(
                    "ClaimPayeeResourceTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClaimPayeeResourceTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ClaimPayeeResourceTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClaimPayeeResourceTypeCode,
        };
        unsafe {
            instance.get(ClaimPayeeResourceTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ClaimPayeeResourceTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClaimPayeeResourceTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClaimPayeeResourceTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClaimPayeeResourceTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    ORGANIZATION = 1,
    PATIENT = 2,
    PRACTITIONER = 3,
    RELATEDPERSON = 4,
}

impl ::protobuf::ProtobufEnum for ClaimPayeeResourceTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClaimPayeeResourceTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ClaimPayeeResourceTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ClaimPayeeResourceTypeCode_Value::ORGANIZATION),
            2 => ::std::option::Option::Some(ClaimPayeeResourceTypeCode_Value::PATIENT),
            3 => ::std::option::Option::Some(ClaimPayeeResourceTypeCode_Value::PRACTITIONER),
            4 => ::std::option::Option::Some(ClaimPayeeResourceTypeCode_Value::RELATEDPERSON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClaimPayeeResourceTypeCode_Value] = &[
            ClaimPayeeResourceTypeCode_Value::INVALID_UNINITIALIZED,
            ClaimPayeeResourceTypeCode_Value::ORGANIZATION,
            ClaimPayeeResourceTypeCode_Value::PATIENT,
            ClaimPayeeResourceTypeCode_Value::PRACTITIONER,
            ClaimPayeeResourceTypeCode_Value::RELATEDPERSON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ClaimPayeeResourceTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ClaimPayeeResourceTypeCode_Value {
}

impl ::std::default::Default for ClaimPayeeResourceTypeCode_Value {
    fn default() -> Self {
        ClaimPayeeResourceTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ClaimPayeeResourceTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExplanationOfBenefitStatusCode {
    // message fields
    pub value: ExplanationOfBenefitStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ExplanationOfBenefitStatusCode {
    pub fn new() -> ExplanationOfBenefitStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ExplanationOfBenefitStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ExplanationOfBenefitStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ExplanationOfBenefitStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ExplanationOfBenefitStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ExplanationOfBenefitStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ExplanationOfBenefitStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ExplanationOfBenefitStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExplanationOfBenefitStatusCode {
        ExplanationOfBenefitStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExplanationOfBenefitStatusCode_Value>>(
                    "value",
                    |m: &ExplanationOfBenefitStatusCode| { &m.value },
                    |m: &mut ExplanationOfBenefitStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ExplanationOfBenefitStatusCode| { &m.id },
                    |m: &mut ExplanationOfBenefitStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ExplanationOfBenefitStatusCode| { &m.extension },
                    |m: &mut ExplanationOfBenefitStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExplanationOfBenefitStatusCode>(
                    "ExplanationOfBenefitStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExplanationOfBenefitStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ExplanationOfBenefitStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExplanationOfBenefitStatusCode,
        };
        unsafe {
            instance.get(ExplanationOfBenefitStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ExplanationOfBenefitStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExplanationOfBenefitStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExplanationOfBenefitStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExplanationOfBenefitStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    CANCELLED = 2,
    DRAFT = 3,
    ENTERED_IN_ERROR = 4,
}

impl ::protobuf::ProtobufEnum for ExplanationOfBenefitStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExplanationOfBenefitStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ExplanationOfBenefitStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ExplanationOfBenefitStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(ExplanationOfBenefitStatusCode_Value::CANCELLED),
            3 => ::std::option::Option::Some(ExplanationOfBenefitStatusCode_Value::DRAFT),
            4 => ::std::option::Option::Some(ExplanationOfBenefitStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExplanationOfBenefitStatusCode_Value] = &[
            ExplanationOfBenefitStatusCode_Value::INVALID_UNINITIALIZED,
            ExplanationOfBenefitStatusCode_Value::ACTIVE,
            ExplanationOfBenefitStatusCode_Value::CANCELLED,
            ExplanationOfBenefitStatusCode_Value::DRAFT,
            ExplanationOfBenefitStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ExplanationOfBenefitStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ExplanationOfBenefitStatusCode_Value {
}

impl ::std::default::Default for ExplanationOfBenefitStatusCode_Value {
    fn default() -> Self {
        ExplanationOfBenefitStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ExplanationOfBenefitStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtensionContextCode {
    // message fields
    pub value: ExtensionContextCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ExtensionContextCode {
    pub fn new() -> ExtensionContextCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ExtensionContextCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ExtensionContextCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ExtensionContextCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ExtensionContextCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ExtensionContextCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ExtensionContextCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ExtensionContextCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtensionContextCode {
        ExtensionContextCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExtensionContextCode_Value>>(
                    "value",
                    |m: &ExtensionContextCode| { &m.value },
                    |m: &mut ExtensionContextCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ExtensionContextCode| { &m.id },
                    |m: &mut ExtensionContextCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ExtensionContextCode| { &m.extension },
                    |m: &mut ExtensionContextCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExtensionContextCode>(
                    "ExtensionContextCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExtensionContextCode {
        static mut instance: ::protobuf::lazy::Lazy<ExtensionContextCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExtensionContextCode,
        };
        unsafe {
            instance.get(ExtensionContextCode::new)
        }
    }
}

impl ::protobuf::Clear for ExtensionContextCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtensionContextCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtensionContextCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExtensionContextCode_Value {
    INVALID_UNINITIALIZED = 0,
    RESOURCE = 1,
    DATATYPE = 2,
    EXTENSION = 3,
}

impl ::protobuf::ProtobufEnum for ExtensionContextCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExtensionContextCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ExtensionContextCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ExtensionContextCode_Value::RESOURCE),
            2 => ::std::option::Option::Some(ExtensionContextCode_Value::DATATYPE),
            3 => ::std::option::Option::Some(ExtensionContextCode_Value::EXTENSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExtensionContextCode_Value] = &[
            ExtensionContextCode_Value::INVALID_UNINITIALIZED,
            ExtensionContextCode_Value::RESOURCE,
            ExtensionContextCode_Value::DATATYPE,
            ExtensionContextCode_Value::EXTENSION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ExtensionContextCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ExtensionContextCode_Value {
}

impl ::std::default::Default for ExtensionContextCode_Value {
    fn default() -> Self {
        ExtensionContextCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtensionContextCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FilterOperatorCode {
    // message fields
    pub value: FilterOperatorCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FilterOperatorCode {
    pub fn new() -> FilterOperatorCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.FilterOperatorCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = FilterOperatorCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FilterOperatorCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> FilterOperatorCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FilterOperatorCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != FilterOperatorCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != FilterOperatorCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilterOperatorCode {
        FilterOperatorCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FilterOperatorCode_Value>>(
                    "value",
                    |m: &FilterOperatorCode| { &m.value },
                    |m: &mut FilterOperatorCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FilterOperatorCode| { &m.id },
                    |m: &mut FilterOperatorCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FilterOperatorCode| { &m.extension },
                    |m: &mut FilterOperatorCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FilterOperatorCode>(
                    "FilterOperatorCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FilterOperatorCode {
        static mut instance: ::protobuf::lazy::Lazy<FilterOperatorCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FilterOperatorCode,
        };
        unsafe {
            instance.get(FilterOperatorCode::new)
        }
    }
}

impl ::protobuf::Clear for FilterOperatorCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilterOperatorCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilterOperatorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FilterOperatorCode_Value {
    INVALID_UNINITIALIZED = 0,
    EQUALS = 1,
    IS_A = 2,
    DESCENDENT_OF = 3,
    IS_NOT_A = 4,
    REGEX = 5,
    IN = 6,
    NOT_IN = 7,
    GENERALIZES = 8,
    EXISTS = 9,
}

impl ::protobuf::ProtobufEnum for FilterOperatorCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FilterOperatorCode_Value> {
        match value {
            0 => ::std::option::Option::Some(FilterOperatorCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(FilterOperatorCode_Value::EQUALS),
            2 => ::std::option::Option::Some(FilterOperatorCode_Value::IS_A),
            3 => ::std::option::Option::Some(FilterOperatorCode_Value::DESCENDENT_OF),
            4 => ::std::option::Option::Some(FilterOperatorCode_Value::IS_NOT_A),
            5 => ::std::option::Option::Some(FilterOperatorCode_Value::REGEX),
            6 => ::std::option::Option::Some(FilterOperatorCode_Value::IN),
            7 => ::std::option::Option::Some(FilterOperatorCode_Value::NOT_IN),
            8 => ::std::option::Option::Some(FilterOperatorCode_Value::GENERALIZES),
            9 => ::std::option::Option::Some(FilterOperatorCode_Value::EXISTS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FilterOperatorCode_Value] = &[
            FilterOperatorCode_Value::INVALID_UNINITIALIZED,
            FilterOperatorCode_Value::EQUALS,
            FilterOperatorCode_Value::IS_A,
            FilterOperatorCode_Value::DESCENDENT_OF,
            FilterOperatorCode_Value::IS_NOT_A,
            FilterOperatorCode_Value::REGEX,
            FilterOperatorCode_Value::IN,
            FilterOperatorCode_Value::NOT_IN,
            FilterOperatorCode_Value::GENERALIZES,
            FilterOperatorCode_Value::EXISTS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FilterOperatorCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FilterOperatorCode_Value {
}

impl ::std::default::Default for FilterOperatorCode_Value {
    fn default() -> Self {
        FilterOperatorCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for FilterOperatorCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlagCategoryCode {
    // message fields
    pub value: FlagCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FlagCategoryCode {
    pub fn new() -> FlagCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.FlagCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = FlagCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FlagCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> FlagCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FlagCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != FlagCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != FlagCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlagCategoryCode {
        FlagCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlagCategoryCode_Value>>(
                    "value",
                    |m: &FlagCategoryCode| { &m.value },
                    |m: &mut FlagCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FlagCategoryCode| { &m.id },
                    |m: &mut FlagCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FlagCategoryCode| { &m.extension },
                    |m: &mut FlagCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlagCategoryCode>(
                    "FlagCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FlagCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<FlagCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlagCategoryCode,
        };
        unsafe {
            instance.get(FlagCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for FlagCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlagCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlagCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlagCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    DIET = 1,
    DRUG = 2,
    LAB = 3,
    ADMIN = 4,
    CONTACT = 5,
}

impl ::protobuf::ProtobufEnum for FlagCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlagCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(FlagCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(FlagCategoryCode_Value::DIET),
            2 => ::std::option::Option::Some(FlagCategoryCode_Value::DRUG),
            3 => ::std::option::Option::Some(FlagCategoryCode_Value::LAB),
            4 => ::std::option::Option::Some(FlagCategoryCode_Value::ADMIN),
            5 => ::std::option::Option::Some(FlagCategoryCode_Value::CONTACT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlagCategoryCode_Value] = &[
            FlagCategoryCode_Value::INVALID_UNINITIALIZED,
            FlagCategoryCode_Value::DIET,
            FlagCategoryCode_Value::DRUG,
            FlagCategoryCode_Value::LAB,
            FlagCategoryCode_Value::ADMIN,
            FlagCategoryCode_Value::CONTACT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FlagCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FlagCategoryCode_Value {
}

impl ::std::default::Default for FlagCategoryCode_Value {
    fn default() -> Self {
        FlagCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for FlagCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlagPriorityCodesCode {
    // message fields
    pub value: FlagPriorityCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FlagPriorityCodesCode {
    pub fn new() -> FlagPriorityCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.FlagPriorityCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = FlagPriorityCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FlagPriorityCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> FlagPriorityCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FlagPriorityCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != FlagPriorityCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != FlagPriorityCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlagPriorityCodesCode {
        FlagPriorityCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlagPriorityCodesCode_Value>>(
                    "value",
                    |m: &FlagPriorityCodesCode| { &m.value },
                    |m: &mut FlagPriorityCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FlagPriorityCodesCode| { &m.id },
                    |m: &mut FlagPriorityCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FlagPriorityCodesCode| { &m.extension },
                    |m: &mut FlagPriorityCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlagPriorityCodesCode>(
                    "FlagPriorityCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FlagPriorityCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<FlagPriorityCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlagPriorityCodesCode,
        };
        unsafe {
            instance.get(FlagPriorityCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for FlagPriorityCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlagPriorityCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlagPriorityCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlagPriorityCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    PN = 1,
    PL = 2,
    PM = 3,
    PH = 4,
}

impl ::protobuf::ProtobufEnum for FlagPriorityCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlagPriorityCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(FlagPriorityCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(FlagPriorityCodesCode_Value::PN),
            2 => ::std::option::Option::Some(FlagPriorityCodesCode_Value::PL),
            3 => ::std::option::Option::Some(FlagPriorityCodesCode_Value::PM),
            4 => ::std::option::Option::Some(FlagPriorityCodesCode_Value::PH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlagPriorityCodesCode_Value] = &[
            FlagPriorityCodesCode_Value::INVALID_UNINITIALIZED,
            FlagPriorityCodesCode_Value::PN,
            FlagPriorityCodesCode_Value::PL,
            FlagPriorityCodesCode_Value::PM,
            FlagPriorityCodesCode_Value::PH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FlagPriorityCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FlagPriorityCodesCode_Value {
}

impl ::std::default::Default for FlagPriorityCodesCode_Value {
    fn default() -> Self {
        FlagPriorityCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for FlagPriorityCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlagStatusCode {
    // message fields
    pub value: FlagStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FlagStatusCode {
    pub fn new() -> FlagStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.FlagStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = FlagStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FlagStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> FlagStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FlagStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != FlagStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != FlagStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlagStatusCode {
        FlagStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlagStatusCode_Value>>(
                    "value",
                    |m: &FlagStatusCode| { &m.value },
                    |m: &mut FlagStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FlagStatusCode| { &m.id },
                    |m: &mut FlagStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FlagStatusCode| { &m.extension },
                    |m: &mut FlagStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlagStatusCode>(
                    "FlagStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FlagStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<FlagStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlagStatusCode,
        };
        unsafe {
            instance.get(FlagStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for FlagStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlagStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlagStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlagStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    INACTIVE = 2,
    ENTERED_IN_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for FlagStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlagStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(FlagStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(FlagStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(FlagStatusCode_Value::INACTIVE),
            3 => ::std::option::Option::Some(FlagStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlagStatusCode_Value] = &[
            FlagStatusCode_Value::INVALID_UNINITIALIZED,
            FlagStatusCode_Value::ACTIVE,
            FlagStatusCode_Value::INACTIVE,
            FlagStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FlagStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FlagStatusCode_Value {
}

impl ::std::default::Default for FlagStatusCode_Value {
    fn default() -> Self {
        FlagStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for FlagStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinancialResourceStatusCode {
    // message fields
    pub value: FinancialResourceStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FinancialResourceStatusCode {
    pub fn new() -> FinancialResourceStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.FinancialResourceStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = FinancialResourceStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FinancialResourceStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> FinancialResourceStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FinancialResourceStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != FinancialResourceStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != FinancialResourceStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinancialResourceStatusCode {
        FinancialResourceStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FinancialResourceStatusCode_Value>>(
                    "value",
                    |m: &FinancialResourceStatusCode| { &m.value },
                    |m: &mut FinancialResourceStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FinancialResourceStatusCode| { &m.id },
                    |m: &mut FinancialResourceStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FinancialResourceStatusCode| { &m.extension },
                    |m: &mut FinancialResourceStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FinancialResourceStatusCode>(
                    "FinancialResourceStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FinancialResourceStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<FinancialResourceStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FinancialResourceStatusCode,
        };
        unsafe {
            instance.get(FinancialResourceStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for FinancialResourceStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinancialResourceStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinancialResourceStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FinancialResourceStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    CANCELLED = 2,
    DRAFT = 3,
    ENTERED_IN_ERROR = 4,
}

impl ::protobuf::ProtobufEnum for FinancialResourceStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FinancialResourceStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(FinancialResourceStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(FinancialResourceStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(FinancialResourceStatusCode_Value::CANCELLED),
            3 => ::std::option::Option::Some(FinancialResourceStatusCode_Value::DRAFT),
            4 => ::std::option::Option::Some(FinancialResourceStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FinancialResourceStatusCode_Value] = &[
            FinancialResourceStatusCode_Value::INVALID_UNINITIALIZED,
            FinancialResourceStatusCode_Value::ACTIVE,
            FinancialResourceStatusCode_Value::CANCELLED,
            FinancialResourceStatusCode_Value::DRAFT,
            FinancialResourceStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FinancialResourceStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FinancialResourceStatusCode_Value {
}

impl ::std::default::Default for FinancialResourceStatusCode_Value {
    fn default() -> Self {
        FinancialResourceStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for FinancialResourceStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GoalAcceptanceStatusCode {
    // message fields
    pub value: GoalAcceptanceStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GoalAcceptanceStatusCode {
    pub fn new() -> GoalAcceptanceStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GoalAcceptanceStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GoalAcceptanceStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GoalAcceptanceStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GoalAcceptanceStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GoalAcceptanceStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GoalAcceptanceStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GoalAcceptanceStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GoalAcceptanceStatusCode {
        GoalAcceptanceStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GoalAcceptanceStatusCode_Value>>(
                    "value",
                    |m: &GoalAcceptanceStatusCode| { &m.value },
                    |m: &mut GoalAcceptanceStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GoalAcceptanceStatusCode| { &m.id },
                    |m: &mut GoalAcceptanceStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GoalAcceptanceStatusCode| { &m.extension },
                    |m: &mut GoalAcceptanceStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GoalAcceptanceStatusCode>(
                    "GoalAcceptanceStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GoalAcceptanceStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<GoalAcceptanceStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GoalAcceptanceStatusCode,
        };
        unsafe {
            instance.get(GoalAcceptanceStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for GoalAcceptanceStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GoalAcceptanceStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalAcceptanceStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GoalAcceptanceStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    AGREE = 1,
    DISAGREE = 2,
    PENDING = 3,
}

impl ::protobuf::ProtobufEnum for GoalAcceptanceStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GoalAcceptanceStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GoalAcceptanceStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GoalAcceptanceStatusCode_Value::AGREE),
            2 => ::std::option::Option::Some(GoalAcceptanceStatusCode_Value::DISAGREE),
            3 => ::std::option::Option::Some(GoalAcceptanceStatusCode_Value::PENDING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GoalAcceptanceStatusCode_Value] = &[
            GoalAcceptanceStatusCode_Value::INVALID_UNINITIALIZED,
            GoalAcceptanceStatusCode_Value::AGREE,
            GoalAcceptanceStatusCode_Value::DISAGREE,
            GoalAcceptanceStatusCode_Value::PENDING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GoalAcceptanceStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GoalAcceptanceStatusCode_Value {
}

impl ::std::default::Default for GoalAcceptanceStatusCode_Value {
    fn default() -> Self {
        GoalAcceptanceStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalAcceptanceStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GoalCategoryCode {
    // message fields
    pub value: GoalCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GoalCategoryCode {
    pub fn new() -> GoalCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GoalCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GoalCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GoalCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GoalCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GoalCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GoalCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GoalCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GoalCategoryCode {
        GoalCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GoalCategoryCode_Value>>(
                    "value",
                    |m: &GoalCategoryCode| { &m.value },
                    |m: &mut GoalCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GoalCategoryCode| { &m.id },
                    |m: &mut GoalCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GoalCategoryCode| { &m.extension },
                    |m: &mut GoalCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GoalCategoryCode>(
                    "GoalCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GoalCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<GoalCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GoalCategoryCode,
        };
        unsafe {
            instance.get(GoalCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for GoalCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GoalCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GoalCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    DIETARY = 1,
    SAFETY = 2,
    BEHAVIORAL = 3,
    NURSING = 4,
    PHYSIOTHERAPY = 5,
}

impl ::protobuf::ProtobufEnum for GoalCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GoalCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GoalCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GoalCategoryCode_Value::DIETARY),
            2 => ::std::option::Option::Some(GoalCategoryCode_Value::SAFETY),
            3 => ::std::option::Option::Some(GoalCategoryCode_Value::BEHAVIORAL),
            4 => ::std::option::Option::Some(GoalCategoryCode_Value::NURSING),
            5 => ::std::option::Option::Some(GoalCategoryCode_Value::PHYSIOTHERAPY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GoalCategoryCode_Value] = &[
            GoalCategoryCode_Value::INVALID_UNINITIALIZED,
            GoalCategoryCode_Value::DIETARY,
            GoalCategoryCode_Value::SAFETY,
            GoalCategoryCode_Value::BEHAVIORAL,
            GoalCategoryCode_Value::NURSING,
            GoalCategoryCode_Value::PHYSIOTHERAPY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GoalCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GoalCategoryCode_Value {
}

impl ::std::default::Default for GoalCategoryCode_Value {
    fn default() -> Self {
        GoalCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GoalPriorityCode {
    // message fields
    pub value: GoalPriorityCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GoalPriorityCode {
    pub fn new() -> GoalPriorityCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GoalPriorityCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GoalPriorityCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GoalPriorityCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GoalPriorityCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GoalPriorityCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GoalPriorityCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GoalPriorityCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GoalPriorityCode {
        GoalPriorityCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GoalPriorityCode_Value>>(
                    "value",
                    |m: &GoalPriorityCode| { &m.value },
                    |m: &mut GoalPriorityCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GoalPriorityCode| { &m.id },
                    |m: &mut GoalPriorityCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GoalPriorityCode| { &m.extension },
                    |m: &mut GoalPriorityCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GoalPriorityCode>(
                    "GoalPriorityCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GoalPriorityCode {
        static mut instance: ::protobuf::lazy::Lazy<GoalPriorityCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GoalPriorityCode,
        };
        unsafe {
            instance.get(GoalPriorityCode::new)
        }
    }
}

impl ::protobuf::Clear for GoalPriorityCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GoalPriorityCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalPriorityCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GoalPriorityCode_Value {
    INVALID_UNINITIALIZED = 0,
    HIGH_PRIORITY = 1,
    MEDIUM_PRIORITY = 2,
    LOW_PRIORITY = 3,
}

impl ::protobuf::ProtobufEnum for GoalPriorityCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GoalPriorityCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GoalPriorityCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GoalPriorityCode_Value::HIGH_PRIORITY),
            2 => ::std::option::Option::Some(GoalPriorityCode_Value::MEDIUM_PRIORITY),
            3 => ::std::option::Option::Some(GoalPriorityCode_Value::LOW_PRIORITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GoalPriorityCode_Value] = &[
            GoalPriorityCode_Value::INVALID_UNINITIALIZED,
            GoalPriorityCode_Value::HIGH_PRIORITY,
            GoalPriorityCode_Value::MEDIUM_PRIORITY,
            GoalPriorityCode_Value::LOW_PRIORITY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GoalPriorityCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GoalPriorityCode_Value {
}

impl ::std::default::Default for GoalPriorityCode_Value {
    fn default() -> Self {
        GoalPriorityCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalPriorityCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GoalRelationshipTypeCode {
    // message fields
    pub value: GoalRelationshipTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GoalRelationshipTypeCode {
    pub fn new() -> GoalRelationshipTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GoalRelationshipTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GoalRelationshipTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GoalRelationshipTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GoalRelationshipTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GoalRelationshipTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GoalRelationshipTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GoalRelationshipTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GoalRelationshipTypeCode {
        GoalRelationshipTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GoalRelationshipTypeCode_Value>>(
                    "value",
                    |m: &GoalRelationshipTypeCode| { &m.value },
                    |m: &mut GoalRelationshipTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GoalRelationshipTypeCode| { &m.id },
                    |m: &mut GoalRelationshipTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GoalRelationshipTypeCode| { &m.extension },
                    |m: &mut GoalRelationshipTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GoalRelationshipTypeCode>(
                    "GoalRelationshipTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GoalRelationshipTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<GoalRelationshipTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GoalRelationshipTypeCode,
        };
        unsafe {
            instance.get(GoalRelationshipTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for GoalRelationshipTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GoalRelationshipTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalRelationshipTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GoalRelationshipTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    PREDECESSOR = 1,
    SUCCESSOR = 2,
    REPLACEMENT = 3,
    MILESTONE = 4,
    OTHER = 5,
}

impl ::protobuf::ProtobufEnum for GoalRelationshipTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GoalRelationshipTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GoalRelationshipTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GoalRelationshipTypeCode_Value::PREDECESSOR),
            2 => ::std::option::Option::Some(GoalRelationshipTypeCode_Value::SUCCESSOR),
            3 => ::std::option::Option::Some(GoalRelationshipTypeCode_Value::REPLACEMENT),
            4 => ::std::option::Option::Some(GoalRelationshipTypeCode_Value::MILESTONE),
            5 => ::std::option::Option::Some(GoalRelationshipTypeCode_Value::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GoalRelationshipTypeCode_Value] = &[
            GoalRelationshipTypeCode_Value::INVALID_UNINITIALIZED,
            GoalRelationshipTypeCode_Value::PREDECESSOR,
            GoalRelationshipTypeCode_Value::SUCCESSOR,
            GoalRelationshipTypeCode_Value::REPLACEMENT,
            GoalRelationshipTypeCode_Value::MILESTONE,
            GoalRelationshipTypeCode_Value::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GoalRelationshipTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GoalRelationshipTypeCode_Value {
}

impl ::std::default::Default for GoalRelationshipTypeCode_Value {
    fn default() -> Self {
        GoalRelationshipTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalRelationshipTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GoalStatusCode {
    // message fields
    pub value: GoalStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GoalStatusCode {
    pub fn new() -> GoalStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GoalStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GoalStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GoalStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GoalStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GoalStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GoalStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GoalStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GoalStatusCode {
        GoalStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GoalStatusCode_Value>>(
                    "value",
                    |m: &GoalStatusCode| { &m.value },
                    |m: &mut GoalStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GoalStatusCode| { &m.id },
                    |m: &mut GoalStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GoalStatusCode| { &m.extension },
                    |m: &mut GoalStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GoalStatusCode>(
                    "GoalStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GoalStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<GoalStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GoalStatusCode,
        };
        unsafe {
            instance.get(GoalStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for GoalStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GoalStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GoalStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROPOSED = 1,
    ACCEPTED = 2,
    PLANNED = 3,
    IN_PROGRESS = 4,
    ON_TARGET = 5,
    AHEAD_OF_TARGET = 6,
    BEHIND_TARGET = 7,
    SUSTAINING = 8,
    ACHIEVED = 9,
    ON_HOLD = 10,
    CANCELLED = 11,
    ENTERED_IN_ERROR = 12,
    REJECTED = 13,
}

impl ::protobuf::ProtobufEnum for GoalStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GoalStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GoalStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GoalStatusCode_Value::PROPOSED),
            2 => ::std::option::Option::Some(GoalStatusCode_Value::ACCEPTED),
            3 => ::std::option::Option::Some(GoalStatusCode_Value::PLANNED),
            4 => ::std::option::Option::Some(GoalStatusCode_Value::IN_PROGRESS),
            5 => ::std::option::Option::Some(GoalStatusCode_Value::ON_TARGET),
            6 => ::std::option::Option::Some(GoalStatusCode_Value::AHEAD_OF_TARGET),
            7 => ::std::option::Option::Some(GoalStatusCode_Value::BEHIND_TARGET),
            8 => ::std::option::Option::Some(GoalStatusCode_Value::SUSTAINING),
            9 => ::std::option::Option::Some(GoalStatusCode_Value::ACHIEVED),
            10 => ::std::option::Option::Some(GoalStatusCode_Value::ON_HOLD),
            11 => ::std::option::Option::Some(GoalStatusCode_Value::CANCELLED),
            12 => ::std::option::Option::Some(GoalStatusCode_Value::ENTERED_IN_ERROR),
            13 => ::std::option::Option::Some(GoalStatusCode_Value::REJECTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GoalStatusCode_Value] = &[
            GoalStatusCode_Value::INVALID_UNINITIALIZED,
            GoalStatusCode_Value::PROPOSED,
            GoalStatusCode_Value::ACCEPTED,
            GoalStatusCode_Value::PLANNED,
            GoalStatusCode_Value::IN_PROGRESS,
            GoalStatusCode_Value::ON_TARGET,
            GoalStatusCode_Value::AHEAD_OF_TARGET,
            GoalStatusCode_Value::BEHIND_TARGET,
            GoalStatusCode_Value::SUSTAINING,
            GoalStatusCode_Value::ACHIEVED,
            GoalStatusCode_Value::ON_HOLD,
            GoalStatusCode_Value::CANCELLED,
            GoalStatusCode_Value::ENTERED_IN_ERROR,
            GoalStatusCode_Value::REJECTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GoalStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GoalStatusCode_Value {
}

impl ::std::default::Default for GoalStatusCode_Value {
    fn default() -> Self {
        GoalStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GoalStatusReasonCode {
    // message fields
    pub value: GoalStatusReasonCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GoalStatusReasonCode {
    pub fn new() -> GoalStatusReasonCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GoalStatusReasonCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GoalStatusReasonCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GoalStatusReasonCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GoalStatusReasonCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GoalStatusReasonCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GoalStatusReasonCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GoalStatusReasonCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GoalStatusReasonCode {
        GoalStatusReasonCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GoalStatusReasonCode_Value>>(
                    "value",
                    |m: &GoalStatusReasonCode| { &m.value },
                    |m: &mut GoalStatusReasonCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GoalStatusReasonCode| { &m.id },
                    |m: &mut GoalStatusReasonCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GoalStatusReasonCode| { &m.extension },
                    |m: &mut GoalStatusReasonCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GoalStatusReasonCode>(
                    "GoalStatusReasonCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GoalStatusReasonCode {
        static mut instance: ::protobuf::lazy::Lazy<GoalStatusReasonCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GoalStatusReasonCode,
        };
        unsafe {
            instance.get(GoalStatusReasonCode::new)
        }
    }
}

impl ::protobuf::Clear for GoalStatusReasonCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GoalStatusReasonCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalStatusReasonCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GoalStatusReasonCode_Value {
    INVALID_UNINITIALIZED = 0,
    SURGERY = 1,
    LIFE_EVENT = 2,
    REPLACED = 3,
    PATIENT_REQUEST = 4,
    TEMP_NOT_ATTAINABLE = 5,
    PERMANENT_NOT_ATTAINABLE = 6,
    FINANCIAL_BARRIER = 7,
    LACK_OF_TRANSPORTATION = 8,
    LACK_OF_SOCIAL_SUPPORT = 9,
}

impl ::protobuf::ProtobufEnum for GoalStatusReasonCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GoalStatusReasonCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GoalStatusReasonCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GoalStatusReasonCode_Value::SURGERY),
            2 => ::std::option::Option::Some(GoalStatusReasonCode_Value::LIFE_EVENT),
            3 => ::std::option::Option::Some(GoalStatusReasonCode_Value::REPLACED),
            4 => ::std::option::Option::Some(GoalStatusReasonCode_Value::PATIENT_REQUEST),
            5 => ::std::option::Option::Some(GoalStatusReasonCode_Value::TEMP_NOT_ATTAINABLE),
            6 => ::std::option::Option::Some(GoalStatusReasonCode_Value::PERMANENT_NOT_ATTAINABLE),
            7 => ::std::option::Option::Some(GoalStatusReasonCode_Value::FINANCIAL_BARRIER),
            8 => ::std::option::Option::Some(GoalStatusReasonCode_Value::LACK_OF_TRANSPORTATION),
            9 => ::std::option::Option::Some(GoalStatusReasonCode_Value::LACK_OF_SOCIAL_SUPPORT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GoalStatusReasonCode_Value] = &[
            GoalStatusReasonCode_Value::INVALID_UNINITIALIZED,
            GoalStatusReasonCode_Value::SURGERY,
            GoalStatusReasonCode_Value::LIFE_EVENT,
            GoalStatusReasonCode_Value::REPLACED,
            GoalStatusReasonCode_Value::PATIENT_REQUEST,
            GoalStatusReasonCode_Value::TEMP_NOT_ATTAINABLE,
            GoalStatusReasonCode_Value::PERMANENT_NOT_ATTAINABLE,
            GoalStatusReasonCode_Value::FINANCIAL_BARRIER,
            GoalStatusReasonCode_Value::LACK_OF_TRANSPORTATION,
            GoalStatusReasonCode_Value::LACK_OF_SOCIAL_SUPPORT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GoalStatusReasonCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GoalStatusReasonCode_Value {
}

impl ::std::default::Default for GoalStatusReasonCode_Value {
    fn default() -> Self {
        GoalStatusReasonCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GoalStatusReasonCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphCompartmentRuleCode {
    // message fields
    pub value: GraphCompartmentRuleCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GraphCompartmentRuleCode {
    pub fn new() -> GraphCompartmentRuleCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GraphCompartmentRuleCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GraphCompartmentRuleCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GraphCompartmentRuleCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GraphCompartmentRuleCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GraphCompartmentRuleCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GraphCompartmentRuleCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GraphCompartmentRuleCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphCompartmentRuleCode {
        GraphCompartmentRuleCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GraphCompartmentRuleCode_Value>>(
                    "value",
                    |m: &GraphCompartmentRuleCode| { &m.value },
                    |m: &mut GraphCompartmentRuleCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GraphCompartmentRuleCode| { &m.id },
                    |m: &mut GraphCompartmentRuleCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GraphCompartmentRuleCode| { &m.extension },
                    |m: &mut GraphCompartmentRuleCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GraphCompartmentRuleCode>(
                    "GraphCompartmentRuleCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphCompartmentRuleCode {
        static mut instance: ::protobuf::lazy::Lazy<GraphCompartmentRuleCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphCompartmentRuleCode,
        };
        unsafe {
            instance.get(GraphCompartmentRuleCode::new)
        }
    }
}

impl ::protobuf::Clear for GraphCompartmentRuleCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphCompartmentRuleCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphCompartmentRuleCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GraphCompartmentRuleCode_Value {
    INVALID_UNINITIALIZED = 0,
    IDENTICAL = 1,
    MATCHING = 2,
    DIFFERENT = 3,
    CUSTOM = 4,
}

impl ::protobuf::ProtobufEnum for GraphCompartmentRuleCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GraphCompartmentRuleCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GraphCompartmentRuleCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GraphCompartmentRuleCode_Value::IDENTICAL),
            2 => ::std::option::Option::Some(GraphCompartmentRuleCode_Value::MATCHING),
            3 => ::std::option::Option::Some(GraphCompartmentRuleCode_Value::DIFFERENT),
            4 => ::std::option::Option::Some(GraphCompartmentRuleCode_Value::CUSTOM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GraphCompartmentRuleCode_Value] = &[
            GraphCompartmentRuleCode_Value::INVALID_UNINITIALIZED,
            GraphCompartmentRuleCode_Value::IDENTICAL,
            GraphCompartmentRuleCode_Value::MATCHING,
            GraphCompartmentRuleCode_Value::DIFFERENT,
            GraphCompartmentRuleCode_Value::CUSTOM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GraphCompartmentRuleCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GraphCompartmentRuleCode_Value {
}

impl ::std::default::Default for GraphCompartmentRuleCode_Value {
    fn default() -> Self {
        GraphCompartmentRuleCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphCompartmentRuleCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GroupTypeCode {
    // message fields
    pub value: GroupTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GroupTypeCode {
    pub fn new() -> GroupTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GroupTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GroupTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GroupTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GroupTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GroupTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GroupTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GroupTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupTypeCode {
        GroupTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GroupTypeCode_Value>>(
                    "value",
                    |m: &GroupTypeCode| { &m.value },
                    |m: &mut GroupTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GroupTypeCode| { &m.id },
                    |m: &mut GroupTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GroupTypeCode| { &m.extension },
                    |m: &mut GroupTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GroupTypeCode>(
                    "GroupTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GroupTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<GroupTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GroupTypeCode,
        };
        unsafe {
            instance.get(GroupTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for GroupTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GroupTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    PERSON = 1,
    ANIMAL = 2,
    PRACTITIONER = 3,
    DEVICE = 4,
    MEDICATION = 5,
    SUBSTANCE = 6,
}

impl ::protobuf::ProtobufEnum for GroupTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GroupTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GroupTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GroupTypeCode_Value::PERSON),
            2 => ::std::option::Option::Some(GroupTypeCode_Value::ANIMAL),
            3 => ::std::option::Option::Some(GroupTypeCode_Value::PRACTITIONER),
            4 => ::std::option::Option::Some(GroupTypeCode_Value::DEVICE),
            5 => ::std::option::Option::Some(GroupTypeCode_Value::MEDICATION),
            6 => ::std::option::Option::Some(GroupTypeCode_Value::SUBSTANCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GroupTypeCode_Value] = &[
            GroupTypeCode_Value::INVALID_UNINITIALIZED,
            GroupTypeCode_Value::PERSON,
            GroupTypeCode_Value::ANIMAL,
            GroupTypeCode_Value::PRACTITIONER,
            GroupTypeCode_Value::DEVICE,
            GroupTypeCode_Value::MEDICATION,
            GroupTypeCode_Value::SUBSTANCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GroupTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GroupTypeCode_Value {
}

impl ::std::default::Default for GroupTypeCode_Value {
    fn default() -> Self {
        GroupTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuidanceResponseStatusCode {
    // message fields
    pub value: GuidanceResponseStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GuidanceResponseStatusCode {
    pub fn new() -> GuidanceResponseStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GuidanceResponseStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GuidanceResponseStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GuidanceResponseStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GuidanceResponseStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GuidanceResponseStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GuidanceResponseStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GuidanceResponseStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuidanceResponseStatusCode {
        GuidanceResponseStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GuidanceResponseStatusCode_Value>>(
                    "value",
                    |m: &GuidanceResponseStatusCode| { &m.value },
                    |m: &mut GuidanceResponseStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GuidanceResponseStatusCode| { &m.id },
                    |m: &mut GuidanceResponseStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GuidanceResponseStatusCode| { &m.extension },
                    |m: &mut GuidanceResponseStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GuidanceResponseStatusCode>(
                    "GuidanceResponseStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GuidanceResponseStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<GuidanceResponseStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GuidanceResponseStatusCode,
        };
        unsafe {
            instance.get(GuidanceResponseStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for GuidanceResponseStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuidanceResponseStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuidanceResponseStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GuidanceResponseStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    SUCCESS = 1,
    DATA_REQUESTED = 2,
    DATA_REQUIRED = 3,
    IN_PROGRESS = 4,
    FAILURE = 5,
    ENTERED_IN_ERROR = 6,
}

impl ::protobuf::ProtobufEnum for GuidanceResponseStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GuidanceResponseStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GuidanceResponseStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GuidanceResponseStatusCode_Value::SUCCESS),
            2 => ::std::option::Option::Some(GuidanceResponseStatusCode_Value::DATA_REQUESTED),
            3 => ::std::option::Option::Some(GuidanceResponseStatusCode_Value::DATA_REQUIRED),
            4 => ::std::option::Option::Some(GuidanceResponseStatusCode_Value::IN_PROGRESS),
            5 => ::std::option::Option::Some(GuidanceResponseStatusCode_Value::FAILURE),
            6 => ::std::option::Option::Some(GuidanceResponseStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GuidanceResponseStatusCode_Value] = &[
            GuidanceResponseStatusCode_Value::INVALID_UNINITIALIZED,
            GuidanceResponseStatusCode_Value::SUCCESS,
            GuidanceResponseStatusCode_Value::DATA_REQUESTED,
            GuidanceResponseStatusCode_Value::DATA_REQUIRED,
            GuidanceResponseStatusCode_Value::IN_PROGRESS,
            GuidanceResponseStatusCode_Value::FAILURE,
            GuidanceResponseStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GuidanceResponseStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GuidanceResponseStatusCode_Value {
}

impl ::std::default::Default for GuidanceResponseStatusCode_Value {
    fn default() -> Self {
        GuidanceResponseStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GuidanceResponseStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuideDependencyTypeCode {
    // message fields
    pub value: GuideDependencyTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GuideDependencyTypeCode {
    pub fn new() -> GuideDependencyTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GuideDependencyTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GuideDependencyTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GuideDependencyTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GuideDependencyTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GuideDependencyTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GuideDependencyTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GuideDependencyTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuideDependencyTypeCode {
        GuideDependencyTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GuideDependencyTypeCode_Value>>(
                    "value",
                    |m: &GuideDependencyTypeCode| { &m.value },
                    |m: &mut GuideDependencyTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GuideDependencyTypeCode| { &m.id },
                    |m: &mut GuideDependencyTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GuideDependencyTypeCode| { &m.extension },
                    |m: &mut GuideDependencyTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GuideDependencyTypeCode>(
                    "GuideDependencyTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GuideDependencyTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<GuideDependencyTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GuideDependencyTypeCode,
        };
        unsafe {
            instance.get(GuideDependencyTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for GuideDependencyTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuideDependencyTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuideDependencyTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GuideDependencyTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    REFERENCE = 1,
    INCLUSION = 2,
}

impl ::protobuf::ProtobufEnum for GuideDependencyTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GuideDependencyTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GuideDependencyTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GuideDependencyTypeCode_Value::REFERENCE),
            2 => ::std::option::Option::Some(GuideDependencyTypeCode_Value::INCLUSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GuideDependencyTypeCode_Value] = &[
            GuideDependencyTypeCode_Value::INVALID_UNINITIALIZED,
            GuideDependencyTypeCode_Value::REFERENCE,
            GuideDependencyTypeCode_Value::INCLUSION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GuideDependencyTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GuideDependencyTypeCode_Value {
}

impl ::std::default::Default for GuideDependencyTypeCode_Value {
    fn default() -> Self {
        GuideDependencyTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GuideDependencyTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GuidePageKindCode {
    // message fields
    pub value: GuidePageKindCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl GuidePageKindCode {
    pub fn new() -> GuidePageKindCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.GuidePageKindCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = GuidePageKindCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: GuidePageKindCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> GuidePageKindCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for GuidePageKindCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != GuidePageKindCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != GuidePageKindCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GuidePageKindCode {
        GuidePageKindCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GuidePageKindCode_Value>>(
                    "value",
                    |m: &GuidePageKindCode| { &m.value },
                    |m: &mut GuidePageKindCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &GuidePageKindCode| { &m.id },
                    |m: &mut GuidePageKindCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &GuidePageKindCode| { &m.extension },
                    |m: &mut GuidePageKindCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GuidePageKindCode>(
                    "GuidePageKindCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GuidePageKindCode {
        static mut instance: ::protobuf::lazy::Lazy<GuidePageKindCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GuidePageKindCode,
        };
        unsafe {
            instance.get(GuidePageKindCode::new)
        }
    }
}

impl ::protobuf::Clear for GuidePageKindCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GuidePageKindCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GuidePageKindCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GuidePageKindCode_Value {
    INVALID_UNINITIALIZED = 0,
    PAGE = 1,
    EXAMPLE = 2,
    LIST = 3,
    INCLUDE = 4,
    DIRECTORY = 5,
    DICTIONARY = 6,
    TOC = 7,
    RESOURCE = 8,
}

impl ::protobuf::ProtobufEnum for GuidePageKindCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GuidePageKindCode_Value> {
        match value {
            0 => ::std::option::Option::Some(GuidePageKindCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(GuidePageKindCode_Value::PAGE),
            2 => ::std::option::Option::Some(GuidePageKindCode_Value::EXAMPLE),
            3 => ::std::option::Option::Some(GuidePageKindCode_Value::LIST),
            4 => ::std::option::Option::Some(GuidePageKindCode_Value::INCLUDE),
            5 => ::std::option::Option::Some(GuidePageKindCode_Value::DIRECTORY),
            6 => ::std::option::Option::Some(GuidePageKindCode_Value::DICTIONARY),
            7 => ::std::option::Option::Some(GuidePageKindCode_Value::TOC),
            8 => ::std::option::Option::Some(GuidePageKindCode_Value::RESOURCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GuidePageKindCode_Value] = &[
            GuidePageKindCode_Value::INVALID_UNINITIALIZED,
            GuidePageKindCode_Value::PAGE,
            GuidePageKindCode_Value::EXAMPLE,
            GuidePageKindCode_Value::LIST,
            GuidePageKindCode_Value::INCLUDE,
            GuidePageKindCode_Value::DIRECTORY,
            GuidePageKindCode_Value::DICTIONARY,
            GuidePageKindCode_Value::TOC,
            GuidePageKindCode_Value::RESOURCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("GuidePageKindCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for GuidePageKindCode_Value {
}

impl ::std::default::Default for GuidePageKindCode_Value {
    fn default() -> Self {
        GuidePageKindCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for GuidePageKindCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FamilyHistoryNotDoneReasonCode {
    // message fields
    pub value: FamilyHistoryNotDoneReasonCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FamilyHistoryNotDoneReasonCode {
    pub fn new() -> FamilyHistoryNotDoneReasonCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.FamilyHistoryNotDoneReasonCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = FamilyHistoryNotDoneReasonCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FamilyHistoryNotDoneReasonCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> FamilyHistoryNotDoneReasonCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FamilyHistoryNotDoneReasonCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != FamilyHistoryNotDoneReasonCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != FamilyHistoryNotDoneReasonCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FamilyHistoryNotDoneReasonCode {
        FamilyHistoryNotDoneReasonCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FamilyHistoryNotDoneReasonCode_Value>>(
                    "value",
                    |m: &FamilyHistoryNotDoneReasonCode| { &m.value },
                    |m: &mut FamilyHistoryNotDoneReasonCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FamilyHistoryNotDoneReasonCode| { &m.id },
                    |m: &mut FamilyHistoryNotDoneReasonCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FamilyHistoryNotDoneReasonCode| { &m.extension },
                    |m: &mut FamilyHistoryNotDoneReasonCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FamilyHistoryNotDoneReasonCode>(
                    "FamilyHistoryNotDoneReasonCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FamilyHistoryNotDoneReasonCode {
        static mut instance: ::protobuf::lazy::Lazy<FamilyHistoryNotDoneReasonCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FamilyHistoryNotDoneReasonCode,
        };
        unsafe {
            instance.get(FamilyHistoryNotDoneReasonCode::new)
        }
    }
}

impl ::protobuf::Clear for FamilyHistoryNotDoneReasonCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FamilyHistoryNotDoneReasonCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FamilyHistoryNotDoneReasonCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FamilyHistoryNotDoneReasonCode_Value {
    INVALID_UNINITIALIZED = 0,
    SUBJECT_UNKNOWN = 1,
    WITHHELD = 2,
    UNABLE_TO_OBTAIN = 3,
    DEFERRED = 4,
}

impl ::protobuf::ProtobufEnum for FamilyHistoryNotDoneReasonCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FamilyHistoryNotDoneReasonCode_Value> {
        match value {
            0 => ::std::option::Option::Some(FamilyHistoryNotDoneReasonCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(FamilyHistoryNotDoneReasonCode_Value::SUBJECT_UNKNOWN),
            2 => ::std::option::Option::Some(FamilyHistoryNotDoneReasonCode_Value::WITHHELD),
            3 => ::std::option::Option::Some(FamilyHistoryNotDoneReasonCode_Value::UNABLE_TO_OBTAIN),
            4 => ::std::option::Option::Some(FamilyHistoryNotDoneReasonCode_Value::DEFERRED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FamilyHistoryNotDoneReasonCode_Value] = &[
            FamilyHistoryNotDoneReasonCode_Value::INVALID_UNINITIALIZED,
            FamilyHistoryNotDoneReasonCode_Value::SUBJECT_UNKNOWN,
            FamilyHistoryNotDoneReasonCode_Value::WITHHELD,
            FamilyHistoryNotDoneReasonCode_Value::UNABLE_TO_OBTAIN,
            FamilyHistoryNotDoneReasonCode_Value::DEFERRED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FamilyHistoryNotDoneReasonCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FamilyHistoryNotDoneReasonCode_Value {
}

impl ::std::default::Default for FamilyHistoryNotDoneReasonCode_Value {
    fn default() -> Self {
        FamilyHistoryNotDoneReasonCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for FamilyHistoryNotDoneReasonCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FamilyHistoryStatusCode {
    // message fields
    pub value: FamilyHistoryStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FamilyHistoryStatusCode {
    pub fn new() -> FamilyHistoryStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.FamilyHistoryStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = FamilyHistoryStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FamilyHistoryStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> FamilyHistoryStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FamilyHistoryStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != FamilyHistoryStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != FamilyHistoryStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FamilyHistoryStatusCode {
        FamilyHistoryStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FamilyHistoryStatusCode_Value>>(
                    "value",
                    |m: &FamilyHistoryStatusCode| { &m.value },
                    |m: &mut FamilyHistoryStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FamilyHistoryStatusCode| { &m.id },
                    |m: &mut FamilyHistoryStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FamilyHistoryStatusCode| { &m.extension },
                    |m: &mut FamilyHistoryStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FamilyHistoryStatusCode>(
                    "FamilyHistoryStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FamilyHistoryStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<FamilyHistoryStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FamilyHistoryStatusCode,
        };
        unsafe {
            instance.get(FamilyHistoryStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for FamilyHistoryStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FamilyHistoryStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FamilyHistoryStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FamilyHistoryStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PARTIAL = 1,
    COMPLETED = 2,
    ENTERED_IN_ERROR = 3,
    HEALTH_UNKNOWN = 4,
}

impl ::protobuf::ProtobufEnum for FamilyHistoryStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FamilyHistoryStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(FamilyHistoryStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(FamilyHistoryStatusCode_Value::PARTIAL),
            2 => ::std::option::Option::Some(FamilyHistoryStatusCode_Value::COMPLETED),
            3 => ::std::option::Option::Some(FamilyHistoryStatusCode_Value::ENTERED_IN_ERROR),
            4 => ::std::option::Option::Some(FamilyHistoryStatusCode_Value::HEALTH_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FamilyHistoryStatusCode_Value] = &[
            FamilyHistoryStatusCode_Value::INVALID_UNINITIALIZED,
            FamilyHistoryStatusCode_Value::PARTIAL,
            FamilyHistoryStatusCode_Value::COMPLETED,
            FamilyHistoryStatusCode_Value::ENTERED_IN_ERROR,
            FamilyHistoryStatusCode_Value::HEALTH_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FamilyHistoryStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FamilyHistoryStatusCode_Value {
}

impl ::std::default::Default for FamilyHistoryStatusCode_Value {
    fn default() -> Self {
        FamilyHistoryStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for FamilyHistoryStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HL7WorkgroupCode {
    // message fields
    pub value: HL7WorkgroupCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl HL7WorkgroupCode {
    pub fn new() -> HL7WorkgroupCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.HL7WorkgroupCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = HL7WorkgroupCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: HL7WorkgroupCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> HL7WorkgroupCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for HL7WorkgroupCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != HL7WorkgroupCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != HL7WorkgroupCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HL7WorkgroupCode {
        HL7WorkgroupCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HL7WorkgroupCode_Value>>(
                    "value",
                    |m: &HL7WorkgroupCode| { &m.value },
                    |m: &mut HL7WorkgroupCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &HL7WorkgroupCode| { &m.id },
                    |m: &mut HL7WorkgroupCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &HL7WorkgroupCode| { &m.extension },
                    |m: &mut HL7WorkgroupCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HL7WorkgroupCode>(
                    "HL7WorkgroupCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HL7WorkgroupCode {
        static mut instance: ::protobuf::lazy::Lazy<HL7WorkgroupCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HL7WorkgroupCode,
        };
        unsafe {
            instance.get(HL7WorkgroupCode::new)
        }
    }
}

impl ::protobuf::Clear for HL7WorkgroupCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HL7WorkgroupCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HL7WorkgroupCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HL7WorkgroupCode_Value {
    INVALID_UNINITIALIZED = 0,
    CBCC = 1,
    CDS = 2,
    CQI = 3,
    CG = 4,
    DEV = 5,
    EHR = 6,
    FHIR = 7,
    FM = 8,
    HSI = 9,
    II = 10,
    INM = 11,
    ITS = 12,
    OO = 13,
    PA = 14,
    PC = 15,
    PHER = 16,
    PHX = 17,
    RCRIM = 18,
    SD = 19,
    SEC = 20,
    US = 21,
    VOCAB = 22,
    AID = 23,
}

impl ::protobuf::ProtobufEnum for HL7WorkgroupCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HL7WorkgroupCode_Value> {
        match value {
            0 => ::std::option::Option::Some(HL7WorkgroupCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(HL7WorkgroupCode_Value::CBCC),
            2 => ::std::option::Option::Some(HL7WorkgroupCode_Value::CDS),
            3 => ::std::option::Option::Some(HL7WorkgroupCode_Value::CQI),
            4 => ::std::option::Option::Some(HL7WorkgroupCode_Value::CG),
            5 => ::std::option::Option::Some(HL7WorkgroupCode_Value::DEV),
            6 => ::std::option::Option::Some(HL7WorkgroupCode_Value::EHR),
            7 => ::std::option::Option::Some(HL7WorkgroupCode_Value::FHIR),
            8 => ::std::option::Option::Some(HL7WorkgroupCode_Value::FM),
            9 => ::std::option::Option::Some(HL7WorkgroupCode_Value::HSI),
            10 => ::std::option::Option::Some(HL7WorkgroupCode_Value::II),
            11 => ::std::option::Option::Some(HL7WorkgroupCode_Value::INM),
            12 => ::std::option::Option::Some(HL7WorkgroupCode_Value::ITS),
            13 => ::std::option::Option::Some(HL7WorkgroupCode_Value::OO),
            14 => ::std::option::Option::Some(HL7WorkgroupCode_Value::PA),
            15 => ::std::option::Option::Some(HL7WorkgroupCode_Value::PC),
            16 => ::std::option::Option::Some(HL7WorkgroupCode_Value::PHER),
            17 => ::std::option::Option::Some(HL7WorkgroupCode_Value::PHX),
            18 => ::std::option::Option::Some(HL7WorkgroupCode_Value::RCRIM),
            19 => ::std::option::Option::Some(HL7WorkgroupCode_Value::SD),
            20 => ::std::option::Option::Some(HL7WorkgroupCode_Value::SEC),
            21 => ::std::option::Option::Some(HL7WorkgroupCode_Value::US),
            22 => ::std::option::Option::Some(HL7WorkgroupCode_Value::VOCAB),
            23 => ::std::option::Option::Some(HL7WorkgroupCode_Value::AID),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HL7WorkgroupCode_Value] = &[
            HL7WorkgroupCode_Value::INVALID_UNINITIALIZED,
            HL7WorkgroupCode_Value::CBCC,
            HL7WorkgroupCode_Value::CDS,
            HL7WorkgroupCode_Value::CQI,
            HL7WorkgroupCode_Value::CG,
            HL7WorkgroupCode_Value::DEV,
            HL7WorkgroupCode_Value::EHR,
            HL7WorkgroupCode_Value::FHIR,
            HL7WorkgroupCode_Value::FM,
            HL7WorkgroupCode_Value::HSI,
            HL7WorkgroupCode_Value::II,
            HL7WorkgroupCode_Value::INM,
            HL7WorkgroupCode_Value::ITS,
            HL7WorkgroupCode_Value::OO,
            HL7WorkgroupCode_Value::PA,
            HL7WorkgroupCode_Value::PC,
            HL7WorkgroupCode_Value::PHER,
            HL7WorkgroupCode_Value::PHX,
            HL7WorkgroupCode_Value::RCRIM,
            HL7WorkgroupCode_Value::SD,
            HL7WorkgroupCode_Value::SEC,
            HL7WorkgroupCode_Value::US,
            HL7WorkgroupCode_Value::VOCAB,
            HL7WorkgroupCode_Value::AID,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("HL7WorkgroupCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for HL7WorkgroupCode_Value {
}

impl ::std::default::Default for HL7WorkgroupCode_Value {
    fn default() -> Self {
        HL7WorkgroupCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for HL7WorkgroupCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestScriptRequestMethodCodeCode {
    // message fields
    pub value: TestScriptRequestMethodCodeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestScriptRequestMethodCodeCode {
    pub fn new() -> TestScriptRequestMethodCodeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TestScriptRequestMethodCodeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TestScriptRequestMethodCodeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TestScriptRequestMethodCodeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TestScriptRequestMethodCodeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TestScriptRequestMethodCodeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TestScriptRequestMethodCodeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TestScriptRequestMethodCodeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestScriptRequestMethodCodeCode {
        TestScriptRequestMethodCodeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestScriptRequestMethodCodeCode_Value>>(
                    "value",
                    |m: &TestScriptRequestMethodCodeCode| { &m.value },
                    |m: &mut TestScriptRequestMethodCodeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TestScriptRequestMethodCodeCode| { &m.id },
                    |m: &mut TestScriptRequestMethodCodeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TestScriptRequestMethodCodeCode| { &m.extension },
                    |m: &mut TestScriptRequestMethodCodeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestScriptRequestMethodCodeCode>(
                    "TestScriptRequestMethodCodeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestScriptRequestMethodCodeCode {
        static mut instance: ::protobuf::lazy::Lazy<TestScriptRequestMethodCodeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestScriptRequestMethodCodeCode,
        };
        unsafe {
            instance.get(TestScriptRequestMethodCodeCode::new)
        }
    }
}

impl ::protobuf::Clear for TestScriptRequestMethodCodeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestScriptRequestMethodCodeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestScriptRequestMethodCodeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestScriptRequestMethodCodeCode_Value {
    INVALID_UNINITIALIZED = 0,
    DELETE = 1,
    GET = 2,
    OPTIONS = 3,
    PATCH = 4,
    POST = 5,
    PUT = 6,
}

impl ::protobuf::ProtobufEnum for TestScriptRequestMethodCodeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestScriptRequestMethodCodeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TestScriptRequestMethodCodeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TestScriptRequestMethodCodeCode_Value::DELETE),
            2 => ::std::option::Option::Some(TestScriptRequestMethodCodeCode_Value::GET),
            3 => ::std::option::Option::Some(TestScriptRequestMethodCodeCode_Value::OPTIONS),
            4 => ::std::option::Option::Some(TestScriptRequestMethodCodeCode_Value::PATCH),
            5 => ::std::option::Option::Some(TestScriptRequestMethodCodeCode_Value::POST),
            6 => ::std::option::Option::Some(TestScriptRequestMethodCodeCode_Value::PUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestScriptRequestMethodCodeCode_Value] = &[
            TestScriptRequestMethodCodeCode_Value::INVALID_UNINITIALIZED,
            TestScriptRequestMethodCodeCode_Value::DELETE,
            TestScriptRequestMethodCodeCode_Value::GET,
            TestScriptRequestMethodCodeCode_Value::OPTIONS,
            TestScriptRequestMethodCodeCode_Value::PATCH,
            TestScriptRequestMethodCodeCode_Value::POST,
            TestScriptRequestMethodCodeCode_Value::PUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestScriptRequestMethodCodeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestScriptRequestMethodCodeCode_Value {
}

impl ::std::default::Default for TestScriptRequestMethodCodeCode_Value {
    fn default() -> Self {
        TestScriptRequestMethodCodeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TestScriptRequestMethodCodeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPVerbCode {
    // message fields
    pub value: HTTPVerbCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl HTTPVerbCode {
    pub fn new() -> HTTPVerbCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.HTTPVerbCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = HTTPVerbCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: HTTPVerbCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> HTTPVerbCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for HTTPVerbCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != HTTPVerbCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != HTTPVerbCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPVerbCode {
        HTTPVerbCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HTTPVerbCode_Value>>(
                    "value",
                    |m: &HTTPVerbCode| { &m.value },
                    |m: &mut HTTPVerbCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &HTTPVerbCode| { &m.id },
                    |m: &mut HTTPVerbCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &HTTPVerbCode| { &m.extension },
                    |m: &mut HTTPVerbCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HTTPVerbCode>(
                    "HTTPVerbCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HTTPVerbCode {
        static mut instance: ::protobuf::lazy::Lazy<HTTPVerbCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HTTPVerbCode,
        };
        unsafe {
            instance.get(HTTPVerbCode::new)
        }
    }
}

impl ::protobuf::Clear for HTTPVerbCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPVerbCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPVerbCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HTTPVerbCode_Value {
    INVALID_UNINITIALIZED = 0,
    GET = 1,
    POST = 2,
    PUT = 3,
    DELETE = 4,
}

impl ::protobuf::ProtobufEnum for HTTPVerbCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HTTPVerbCode_Value> {
        match value {
            0 => ::std::option::Option::Some(HTTPVerbCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(HTTPVerbCode_Value::GET),
            2 => ::std::option::Option::Some(HTTPVerbCode_Value::POST),
            3 => ::std::option::Option::Some(HTTPVerbCode_Value::PUT),
            4 => ::std::option::Option::Some(HTTPVerbCode_Value::DELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HTTPVerbCode_Value] = &[
            HTTPVerbCode_Value::INVALID_UNINITIALIZED,
            HTTPVerbCode_Value::GET,
            HTTPVerbCode_Value::POST,
            HTTPVerbCode_Value::PUT,
            HTTPVerbCode_Value::DELETE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("HTTPVerbCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for HTTPVerbCode_Value {
}

impl ::std::default::Default for HTTPVerbCode_Value {
    fn default() -> Self {
        HTTPVerbCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPVerbCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IdentityAssuranceLevelCode {
    // message fields
    pub value: IdentityAssuranceLevelCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl IdentityAssuranceLevelCode {
    pub fn new() -> IdentityAssuranceLevelCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.IdentityAssuranceLevelCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = IdentityAssuranceLevelCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: IdentityAssuranceLevelCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> IdentityAssuranceLevelCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for IdentityAssuranceLevelCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != IdentityAssuranceLevelCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != IdentityAssuranceLevelCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdentityAssuranceLevelCode {
        IdentityAssuranceLevelCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IdentityAssuranceLevelCode_Value>>(
                    "value",
                    |m: &IdentityAssuranceLevelCode| { &m.value },
                    |m: &mut IdentityAssuranceLevelCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &IdentityAssuranceLevelCode| { &m.id },
                    |m: &mut IdentityAssuranceLevelCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &IdentityAssuranceLevelCode| { &m.extension },
                    |m: &mut IdentityAssuranceLevelCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IdentityAssuranceLevelCode>(
                    "IdentityAssuranceLevelCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IdentityAssuranceLevelCode {
        static mut instance: ::protobuf::lazy::Lazy<IdentityAssuranceLevelCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IdentityAssuranceLevelCode,
        };
        unsafe {
            instance.get(IdentityAssuranceLevelCode::new)
        }
    }
}

impl ::protobuf::Clear for IdentityAssuranceLevelCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdentityAssuranceLevelCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentityAssuranceLevelCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IdentityAssuranceLevelCode_Value {
    INVALID_UNINITIALIZED = 0,
    LEVEL1 = 1,
    LEVEL2 = 2,
    LEVEL3 = 3,
    LEVEL4 = 4,
}

impl ::protobuf::ProtobufEnum for IdentityAssuranceLevelCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IdentityAssuranceLevelCode_Value> {
        match value {
            0 => ::std::option::Option::Some(IdentityAssuranceLevelCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(IdentityAssuranceLevelCode_Value::LEVEL1),
            2 => ::std::option::Option::Some(IdentityAssuranceLevelCode_Value::LEVEL2),
            3 => ::std::option::Option::Some(IdentityAssuranceLevelCode_Value::LEVEL3),
            4 => ::std::option::Option::Some(IdentityAssuranceLevelCode_Value::LEVEL4),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IdentityAssuranceLevelCode_Value] = &[
            IdentityAssuranceLevelCode_Value::INVALID_UNINITIALIZED,
            IdentityAssuranceLevelCode_Value::LEVEL1,
            IdentityAssuranceLevelCode_Value::LEVEL2,
            IdentityAssuranceLevelCode_Value::LEVEL3,
            IdentityAssuranceLevelCode_Value::LEVEL4,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("IdentityAssuranceLevelCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for IdentityAssuranceLevelCode_Value {
}

impl ::std::default::Default for IdentityAssuranceLevelCode_Value {
    fn default() -> Self {
        IdentityAssuranceLevelCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentityAssuranceLevelCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImmunizationOriginCodesCode {
    // message fields
    pub value: ImmunizationOriginCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ImmunizationOriginCodesCode {
    pub fn new() -> ImmunizationOriginCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ImmunizationOriginCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ImmunizationOriginCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ImmunizationOriginCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ImmunizationOriginCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ImmunizationOriginCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ImmunizationOriginCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ImmunizationOriginCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImmunizationOriginCodesCode {
        ImmunizationOriginCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ImmunizationOriginCodesCode_Value>>(
                    "value",
                    |m: &ImmunizationOriginCodesCode| { &m.value },
                    |m: &mut ImmunizationOriginCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ImmunizationOriginCodesCode| { &m.id },
                    |m: &mut ImmunizationOriginCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ImmunizationOriginCodesCode| { &m.extension },
                    |m: &mut ImmunizationOriginCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ImmunizationOriginCodesCode>(
                    "ImmunizationOriginCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ImmunizationOriginCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ImmunizationOriginCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ImmunizationOriginCodesCode,
        };
        unsafe {
            instance.get(ImmunizationOriginCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ImmunizationOriginCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImmunizationOriginCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImmunizationOriginCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ImmunizationOriginCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROVIDER = 1,
    RECORD = 2,
    RECALL = 3,
    SCHOOL = 4,
}

impl ::protobuf::ProtobufEnum for ImmunizationOriginCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImmunizationOriginCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ImmunizationOriginCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ImmunizationOriginCodesCode_Value::PROVIDER),
            2 => ::std::option::Option::Some(ImmunizationOriginCodesCode_Value::RECORD),
            3 => ::std::option::Option::Some(ImmunizationOriginCodesCode_Value::RECALL),
            4 => ::std::option::Option::Some(ImmunizationOriginCodesCode_Value::SCHOOL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ImmunizationOriginCodesCode_Value] = &[
            ImmunizationOriginCodesCode_Value::INVALID_UNINITIALIZED,
            ImmunizationOriginCodesCode_Value::PROVIDER,
            ImmunizationOriginCodesCode_Value::RECORD,
            ImmunizationOriginCodesCode_Value::RECALL,
            ImmunizationOriginCodesCode_Value::SCHOOL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ImmunizationOriginCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ImmunizationOriginCodesCode_Value {
}

impl ::std::default::Default for ImmunizationOriginCodesCode_Value {
    fn default() -> Self {
        ImmunizationOriginCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ImmunizationOriginCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImmunizationRecommendationDateCriterionCodesCode {
    // message fields
    pub value: ImmunizationRecommendationDateCriterionCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ImmunizationRecommendationDateCriterionCodesCode {
    pub fn new() -> ImmunizationRecommendationDateCriterionCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ImmunizationRecommendationDateCriterionCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ImmunizationRecommendationDateCriterionCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ImmunizationRecommendationDateCriterionCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ImmunizationRecommendationDateCriterionCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ImmunizationRecommendationDateCriterionCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ImmunizationRecommendationDateCriterionCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ImmunizationRecommendationDateCriterionCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImmunizationRecommendationDateCriterionCodesCode {
        ImmunizationRecommendationDateCriterionCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ImmunizationRecommendationDateCriterionCodesCode_Value>>(
                    "value",
                    |m: &ImmunizationRecommendationDateCriterionCodesCode| { &m.value },
                    |m: &mut ImmunizationRecommendationDateCriterionCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ImmunizationRecommendationDateCriterionCodesCode| { &m.id },
                    |m: &mut ImmunizationRecommendationDateCriterionCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ImmunizationRecommendationDateCriterionCodesCode| { &m.extension },
                    |m: &mut ImmunizationRecommendationDateCriterionCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ImmunizationRecommendationDateCriterionCodesCode>(
                    "ImmunizationRecommendationDateCriterionCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ImmunizationRecommendationDateCriterionCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ImmunizationRecommendationDateCriterionCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ImmunizationRecommendationDateCriterionCodesCode,
        };
        unsafe {
            instance.get(ImmunizationRecommendationDateCriterionCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ImmunizationRecommendationDateCriterionCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImmunizationRecommendationDateCriterionCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImmunizationRecommendationDateCriterionCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ImmunizationRecommendationDateCriterionCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    DUE = 1,
    RECOMMENDED = 2,
    EARLIEST = 3,
    OVERDUE = 4,
    LATEST = 5,
}

impl ::protobuf::ProtobufEnum for ImmunizationRecommendationDateCriterionCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImmunizationRecommendationDateCriterionCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ImmunizationRecommendationDateCriterionCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ImmunizationRecommendationDateCriterionCodesCode_Value::DUE),
            2 => ::std::option::Option::Some(ImmunizationRecommendationDateCriterionCodesCode_Value::RECOMMENDED),
            3 => ::std::option::Option::Some(ImmunizationRecommendationDateCriterionCodesCode_Value::EARLIEST),
            4 => ::std::option::Option::Some(ImmunizationRecommendationDateCriterionCodesCode_Value::OVERDUE),
            5 => ::std::option::Option::Some(ImmunizationRecommendationDateCriterionCodesCode_Value::LATEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ImmunizationRecommendationDateCriterionCodesCode_Value] = &[
            ImmunizationRecommendationDateCriterionCodesCode_Value::INVALID_UNINITIALIZED,
            ImmunizationRecommendationDateCriterionCodesCode_Value::DUE,
            ImmunizationRecommendationDateCriterionCodesCode_Value::RECOMMENDED,
            ImmunizationRecommendationDateCriterionCodesCode_Value::EARLIEST,
            ImmunizationRecommendationDateCriterionCodesCode_Value::OVERDUE,
            ImmunizationRecommendationDateCriterionCodesCode_Value::LATEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ImmunizationRecommendationDateCriterionCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ImmunizationRecommendationDateCriterionCodesCode_Value {
}

impl ::std::default::Default for ImmunizationRecommendationDateCriterionCodesCode_Value {
    fn default() -> Self {
        ImmunizationRecommendationDateCriterionCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ImmunizationRecommendationDateCriterionCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImmunizationRecommendationStatusCodesCode {
    // message fields
    pub value: ImmunizationRecommendationStatusCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ImmunizationRecommendationStatusCodesCode {
    pub fn new() -> ImmunizationRecommendationStatusCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ImmunizationRecommendationStatusCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ImmunizationRecommendationStatusCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ImmunizationRecommendationStatusCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ImmunizationRecommendationStatusCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ImmunizationRecommendationStatusCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ImmunizationRecommendationStatusCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ImmunizationRecommendationStatusCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImmunizationRecommendationStatusCodesCode {
        ImmunizationRecommendationStatusCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ImmunizationRecommendationStatusCodesCode_Value>>(
                    "value",
                    |m: &ImmunizationRecommendationStatusCodesCode| { &m.value },
                    |m: &mut ImmunizationRecommendationStatusCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ImmunizationRecommendationStatusCodesCode| { &m.id },
                    |m: &mut ImmunizationRecommendationStatusCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ImmunizationRecommendationStatusCodesCode| { &m.extension },
                    |m: &mut ImmunizationRecommendationStatusCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ImmunizationRecommendationStatusCodesCode>(
                    "ImmunizationRecommendationStatusCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ImmunizationRecommendationStatusCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ImmunizationRecommendationStatusCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ImmunizationRecommendationStatusCodesCode,
        };
        unsafe {
            instance.get(ImmunizationRecommendationStatusCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ImmunizationRecommendationStatusCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImmunizationRecommendationStatusCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImmunizationRecommendationStatusCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ImmunizationRecommendationStatusCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    DUE = 1,
    OVERDUE = 2,
}

impl ::protobuf::ProtobufEnum for ImmunizationRecommendationStatusCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImmunizationRecommendationStatusCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ImmunizationRecommendationStatusCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ImmunizationRecommendationStatusCodesCode_Value::DUE),
            2 => ::std::option::Option::Some(ImmunizationRecommendationStatusCodesCode_Value::OVERDUE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ImmunizationRecommendationStatusCodesCode_Value] = &[
            ImmunizationRecommendationStatusCodesCode_Value::INVALID_UNINITIALIZED,
            ImmunizationRecommendationStatusCodesCode_Value::DUE,
            ImmunizationRecommendationStatusCodesCode_Value::OVERDUE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ImmunizationRecommendationStatusCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ImmunizationRecommendationStatusCodesCode_Value {
}

impl ::std::default::Default for ImmunizationRecommendationStatusCodesCode_Value {
    fn default() -> Self {
        ImmunizationRecommendationStatusCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ImmunizationRecommendationStatusCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImmunizationStatusCodesCode {
    // message fields
    pub value: ImmunizationStatusCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ImmunizationStatusCodesCode {
    pub fn new() -> ImmunizationStatusCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ImmunizationStatusCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ImmunizationStatusCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ImmunizationStatusCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ImmunizationStatusCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ImmunizationStatusCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ImmunizationStatusCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ImmunizationStatusCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImmunizationStatusCodesCode {
        ImmunizationStatusCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ImmunizationStatusCodesCode_Value>>(
                    "value",
                    |m: &ImmunizationStatusCodesCode| { &m.value },
                    |m: &mut ImmunizationStatusCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ImmunizationStatusCodesCode| { &m.id },
                    |m: &mut ImmunizationStatusCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ImmunizationStatusCodesCode| { &m.extension },
                    |m: &mut ImmunizationStatusCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ImmunizationStatusCodesCode>(
                    "ImmunizationStatusCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ImmunizationStatusCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ImmunizationStatusCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ImmunizationStatusCodesCode,
        };
        unsafe {
            instance.get(ImmunizationStatusCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ImmunizationStatusCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImmunizationStatusCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImmunizationStatusCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ImmunizationStatusCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    COMPLETED = 1,
    ENTERED_IN_ERROR = 2,
}

impl ::protobuf::ProtobufEnum for ImmunizationStatusCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImmunizationStatusCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ImmunizationStatusCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ImmunizationStatusCodesCode_Value::COMPLETED),
            2 => ::std::option::Option::Some(ImmunizationStatusCodesCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ImmunizationStatusCodesCode_Value] = &[
            ImmunizationStatusCodesCode_Value::INVALID_UNINITIALIZED,
            ImmunizationStatusCodesCode_Value::COMPLETED,
            ImmunizationStatusCodesCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ImmunizationStatusCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ImmunizationStatusCodesCode_Value {
}

impl ::std::default::Default for ImmunizationStatusCodesCode_Value {
    fn default() -> Self {
        ImmunizationStatusCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ImmunizationStatusCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImplantStatusCode {
    // message fields
    pub value: ImplantStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ImplantStatusCode {
    pub fn new() -> ImplantStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ImplantStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ImplantStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ImplantStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ImplantStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ImplantStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ImplantStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ImplantStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImplantStatusCode {
        ImplantStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ImplantStatusCode_Value>>(
                    "value",
                    |m: &ImplantStatusCode| { &m.value },
                    |m: &mut ImplantStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ImplantStatusCode| { &m.id },
                    |m: &mut ImplantStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ImplantStatusCode| { &m.extension },
                    |m: &mut ImplantStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ImplantStatusCode>(
                    "ImplantStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ImplantStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ImplantStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ImplantStatusCode,
        };
        unsafe {
            instance.get(ImplantStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ImplantStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImplantStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImplantStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ImplantStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    FUNCTIONAL = 1,
    NON_FUNCTIONAL = 2,
    DISABLED = 3,
    UNKNOWN = 4,
}

impl ::protobuf::ProtobufEnum for ImplantStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImplantStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ImplantStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ImplantStatusCode_Value::FUNCTIONAL),
            2 => ::std::option::Option::Some(ImplantStatusCode_Value::NON_FUNCTIONAL),
            3 => ::std::option::Option::Some(ImplantStatusCode_Value::DISABLED),
            4 => ::std::option::Option::Some(ImplantStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ImplantStatusCode_Value] = &[
            ImplantStatusCode_Value::INVALID_UNINITIALIZED,
            ImplantStatusCode_Value::FUNCTIONAL,
            ImplantStatusCode_Value::NON_FUNCTIONAL,
            ImplantStatusCode_Value::DISABLED,
            ImplantStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ImplantStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ImplantStatusCode_Value {
}

impl ::std::default::Default for ImplantStatusCode_Value {
    fn default() -> Self {
        ImplantStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ImplantStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstanceAvailabilityCode {
    // message fields
    pub value: InstanceAvailabilityCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl InstanceAvailabilityCode {
    pub fn new() -> InstanceAvailabilityCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.InstanceAvailabilityCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = InstanceAvailabilityCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: InstanceAvailabilityCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> InstanceAvailabilityCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for InstanceAvailabilityCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != InstanceAvailabilityCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != InstanceAvailabilityCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstanceAvailabilityCode {
        InstanceAvailabilityCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<InstanceAvailabilityCode_Value>>(
                    "value",
                    |m: &InstanceAvailabilityCode| { &m.value },
                    |m: &mut InstanceAvailabilityCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &InstanceAvailabilityCode| { &m.id },
                    |m: &mut InstanceAvailabilityCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &InstanceAvailabilityCode| { &m.extension },
                    |m: &mut InstanceAvailabilityCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InstanceAvailabilityCode>(
                    "InstanceAvailabilityCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InstanceAvailabilityCode {
        static mut instance: ::protobuf::lazy::Lazy<InstanceAvailabilityCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InstanceAvailabilityCode,
        };
        unsafe {
            instance.get(InstanceAvailabilityCode::new)
        }
    }
}

impl ::protobuf::Clear for InstanceAvailabilityCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstanceAvailabilityCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstanceAvailabilityCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum InstanceAvailabilityCode_Value {
    INVALID_UNINITIALIZED = 0,
    ONLINE = 1,
    OFFLINE = 2,
    NEARLINE = 3,
    UNAVAILABLE = 4,
}

impl ::protobuf::ProtobufEnum for InstanceAvailabilityCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InstanceAvailabilityCode_Value> {
        match value {
            0 => ::std::option::Option::Some(InstanceAvailabilityCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(InstanceAvailabilityCode_Value::ONLINE),
            2 => ::std::option::Option::Some(InstanceAvailabilityCode_Value::OFFLINE),
            3 => ::std::option::Option::Some(InstanceAvailabilityCode_Value::NEARLINE),
            4 => ::std::option::Option::Some(InstanceAvailabilityCode_Value::UNAVAILABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [InstanceAvailabilityCode_Value] = &[
            InstanceAvailabilityCode_Value::INVALID_UNINITIALIZED,
            InstanceAvailabilityCode_Value::ONLINE,
            InstanceAvailabilityCode_Value::OFFLINE,
            InstanceAvailabilityCode_Value::NEARLINE,
            InstanceAvailabilityCode_Value::UNAVAILABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("InstanceAvailabilityCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for InstanceAvailabilityCode_Value {
}

impl ::std::default::Default for InstanceAvailabilityCode_Value {
    fn default() -> Self {
        InstanceAvailabilityCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for InstanceAvailabilityCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IssueSeverityCode {
    // message fields
    pub value: IssueSeverityCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl IssueSeverityCode {
    pub fn new() -> IssueSeverityCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.IssueSeverityCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = IssueSeverityCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: IssueSeverityCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> IssueSeverityCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for IssueSeverityCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != IssueSeverityCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != IssueSeverityCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IssueSeverityCode {
        IssueSeverityCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IssueSeverityCode_Value>>(
                    "value",
                    |m: &IssueSeverityCode| { &m.value },
                    |m: &mut IssueSeverityCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &IssueSeverityCode| { &m.id },
                    |m: &mut IssueSeverityCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &IssueSeverityCode| { &m.extension },
                    |m: &mut IssueSeverityCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IssueSeverityCode>(
                    "IssueSeverityCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IssueSeverityCode {
        static mut instance: ::protobuf::lazy::Lazy<IssueSeverityCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IssueSeverityCode,
        };
        unsafe {
            instance.get(IssueSeverityCode::new)
        }
    }
}

impl ::protobuf::Clear for IssueSeverityCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IssueSeverityCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IssueSeverityCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IssueSeverityCode_Value {
    INVALID_UNINITIALIZED = 0,
    FATAL = 1,
    ERROR = 2,
    WARNING = 3,
    INFORMATION = 4,
}

impl ::protobuf::ProtobufEnum for IssueSeverityCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IssueSeverityCode_Value> {
        match value {
            0 => ::std::option::Option::Some(IssueSeverityCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(IssueSeverityCode_Value::FATAL),
            2 => ::std::option::Option::Some(IssueSeverityCode_Value::ERROR),
            3 => ::std::option::Option::Some(IssueSeverityCode_Value::WARNING),
            4 => ::std::option::Option::Some(IssueSeverityCode_Value::INFORMATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IssueSeverityCode_Value] = &[
            IssueSeverityCode_Value::INVALID_UNINITIALIZED,
            IssueSeverityCode_Value::FATAL,
            IssueSeverityCode_Value::ERROR,
            IssueSeverityCode_Value::WARNING,
            IssueSeverityCode_Value::INFORMATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("IssueSeverityCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for IssueSeverityCode_Value {
}

impl ::std::default::Default for IssueSeverityCode_Value {
    fn default() -> Self {
        IssueSeverityCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for IssueSeverityCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IssueTypeCode {
    // message fields
    pub value: IssueTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl IssueTypeCode {
    pub fn new() -> IssueTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.IssueTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = IssueTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: IssueTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> IssueTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for IssueTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != IssueTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != IssueTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IssueTypeCode {
        IssueTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IssueTypeCode_Value>>(
                    "value",
                    |m: &IssueTypeCode| { &m.value },
                    |m: &mut IssueTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &IssueTypeCode| { &m.id },
                    |m: &mut IssueTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &IssueTypeCode| { &m.extension },
                    |m: &mut IssueTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IssueTypeCode>(
                    "IssueTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IssueTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<IssueTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IssueTypeCode,
        };
        unsafe {
            instance.get(IssueTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for IssueTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IssueTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IssueTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IssueTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    INVALID = 1,
    STRUCTURE = 2,
    REQUIRED = 3,
    VALUE = 4,
    INVARIANT = 5,
    SECURITY = 6,
    LOGIN = 7,
    UNKNOWN = 8,
    EXPIRED = 9,
    FORBIDDEN = 10,
    SUPPRESSED = 11,
    PROCESSING = 12,
    NOT_SUPPORTED = 13,
    DUPLICATE = 14,
    NOT_FOUND = 15,
    TOO_LONG = 16,
    CODE_INVALID = 17,
    EXTENSION = 18,
    TOO_COSTLY = 19,
    BUSINESS_RULE = 20,
    CONFLICT = 21,
    INCOMPLETE = 22,
    TRANSIENT = 23,
    LOCK_ERROR = 24,
    NO_STORE = 25,
    EXCEPTION = 26,
    TIMEOUT = 27,
    THROTTLED = 28,
    INFORMATIONAL = 29,
}

impl ::protobuf::ProtobufEnum for IssueTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IssueTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(IssueTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(IssueTypeCode_Value::INVALID),
            2 => ::std::option::Option::Some(IssueTypeCode_Value::STRUCTURE),
            3 => ::std::option::Option::Some(IssueTypeCode_Value::REQUIRED),
            4 => ::std::option::Option::Some(IssueTypeCode_Value::VALUE),
            5 => ::std::option::Option::Some(IssueTypeCode_Value::INVARIANT),
            6 => ::std::option::Option::Some(IssueTypeCode_Value::SECURITY),
            7 => ::std::option::Option::Some(IssueTypeCode_Value::LOGIN),
            8 => ::std::option::Option::Some(IssueTypeCode_Value::UNKNOWN),
            9 => ::std::option::Option::Some(IssueTypeCode_Value::EXPIRED),
            10 => ::std::option::Option::Some(IssueTypeCode_Value::FORBIDDEN),
            11 => ::std::option::Option::Some(IssueTypeCode_Value::SUPPRESSED),
            12 => ::std::option::Option::Some(IssueTypeCode_Value::PROCESSING),
            13 => ::std::option::Option::Some(IssueTypeCode_Value::NOT_SUPPORTED),
            14 => ::std::option::Option::Some(IssueTypeCode_Value::DUPLICATE),
            15 => ::std::option::Option::Some(IssueTypeCode_Value::NOT_FOUND),
            16 => ::std::option::Option::Some(IssueTypeCode_Value::TOO_LONG),
            17 => ::std::option::Option::Some(IssueTypeCode_Value::CODE_INVALID),
            18 => ::std::option::Option::Some(IssueTypeCode_Value::EXTENSION),
            19 => ::std::option::Option::Some(IssueTypeCode_Value::TOO_COSTLY),
            20 => ::std::option::Option::Some(IssueTypeCode_Value::BUSINESS_RULE),
            21 => ::std::option::Option::Some(IssueTypeCode_Value::CONFLICT),
            22 => ::std::option::Option::Some(IssueTypeCode_Value::INCOMPLETE),
            23 => ::std::option::Option::Some(IssueTypeCode_Value::TRANSIENT),
            24 => ::std::option::Option::Some(IssueTypeCode_Value::LOCK_ERROR),
            25 => ::std::option::Option::Some(IssueTypeCode_Value::NO_STORE),
            26 => ::std::option::Option::Some(IssueTypeCode_Value::EXCEPTION),
            27 => ::std::option::Option::Some(IssueTypeCode_Value::TIMEOUT),
            28 => ::std::option::Option::Some(IssueTypeCode_Value::THROTTLED),
            29 => ::std::option::Option::Some(IssueTypeCode_Value::INFORMATIONAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IssueTypeCode_Value] = &[
            IssueTypeCode_Value::INVALID_UNINITIALIZED,
            IssueTypeCode_Value::INVALID,
            IssueTypeCode_Value::STRUCTURE,
            IssueTypeCode_Value::REQUIRED,
            IssueTypeCode_Value::VALUE,
            IssueTypeCode_Value::INVARIANT,
            IssueTypeCode_Value::SECURITY,
            IssueTypeCode_Value::LOGIN,
            IssueTypeCode_Value::UNKNOWN,
            IssueTypeCode_Value::EXPIRED,
            IssueTypeCode_Value::FORBIDDEN,
            IssueTypeCode_Value::SUPPRESSED,
            IssueTypeCode_Value::PROCESSING,
            IssueTypeCode_Value::NOT_SUPPORTED,
            IssueTypeCode_Value::DUPLICATE,
            IssueTypeCode_Value::NOT_FOUND,
            IssueTypeCode_Value::TOO_LONG,
            IssueTypeCode_Value::CODE_INVALID,
            IssueTypeCode_Value::EXTENSION,
            IssueTypeCode_Value::TOO_COSTLY,
            IssueTypeCode_Value::BUSINESS_RULE,
            IssueTypeCode_Value::CONFLICT,
            IssueTypeCode_Value::INCOMPLETE,
            IssueTypeCode_Value::TRANSIENT,
            IssueTypeCode_Value::LOCK_ERROR,
            IssueTypeCode_Value::NO_STORE,
            IssueTypeCode_Value::EXCEPTION,
            IssueTypeCode_Value::TIMEOUT,
            IssueTypeCode_Value::THROTTLED,
            IssueTypeCode_Value::INFORMATIONAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("IssueTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for IssueTypeCode_Value {
}

impl ::std::default::Default for IssueTypeCode_Value {
    fn default() -> Self {
        IssueTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for IssueTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuestionnaireItemTypeCode {
    // message fields
    pub value: QuestionnaireItemTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl QuestionnaireItemTypeCode {
    pub fn new() -> QuestionnaireItemTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.QuestionnaireItemTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = QuestionnaireItemTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: QuestionnaireItemTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> QuestionnaireItemTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for QuestionnaireItemTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != QuestionnaireItemTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != QuestionnaireItemTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuestionnaireItemTypeCode {
        QuestionnaireItemTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<QuestionnaireItemTypeCode_Value>>(
                    "value",
                    |m: &QuestionnaireItemTypeCode| { &m.value },
                    |m: &mut QuestionnaireItemTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &QuestionnaireItemTypeCode| { &m.id },
                    |m: &mut QuestionnaireItemTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &QuestionnaireItemTypeCode| { &m.extension },
                    |m: &mut QuestionnaireItemTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QuestionnaireItemTypeCode>(
                    "QuestionnaireItemTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QuestionnaireItemTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<QuestionnaireItemTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QuestionnaireItemTypeCode,
        };
        unsafe {
            instance.get(QuestionnaireItemTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for QuestionnaireItemTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuestionnaireItemTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuestionnaireItemTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum QuestionnaireItemTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    GROUP = 1,
    DISPLAY = 2,
    QUESTION = 3,
    BOOLEAN = 4,
    DECIMAL = 5,
    INTEGER = 6,
    DATE = 7,
    DATE_TIME = 8,
    TIME = 9,
    STRING = 10,
    TEXT = 11,
    URL = 12,
    CHOICE = 13,
    OPEN_CHOICE = 14,
    ATTACHMENT = 15,
    REFERENCE = 16,
    QUANTITY = 17,
}

impl ::protobuf::ProtobufEnum for QuestionnaireItemTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<QuestionnaireItemTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::GROUP),
            2 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::DISPLAY),
            3 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::QUESTION),
            4 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::BOOLEAN),
            5 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::DECIMAL),
            6 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::INTEGER),
            7 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::DATE),
            8 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::DATE_TIME),
            9 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::TIME),
            10 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::STRING),
            11 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::TEXT),
            12 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::URL),
            13 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::CHOICE),
            14 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::OPEN_CHOICE),
            15 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::ATTACHMENT),
            16 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::REFERENCE),
            17 => ::std::option::Option::Some(QuestionnaireItemTypeCode_Value::QUANTITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [QuestionnaireItemTypeCode_Value] = &[
            QuestionnaireItemTypeCode_Value::INVALID_UNINITIALIZED,
            QuestionnaireItemTypeCode_Value::GROUP,
            QuestionnaireItemTypeCode_Value::DISPLAY,
            QuestionnaireItemTypeCode_Value::QUESTION,
            QuestionnaireItemTypeCode_Value::BOOLEAN,
            QuestionnaireItemTypeCode_Value::DECIMAL,
            QuestionnaireItemTypeCode_Value::INTEGER,
            QuestionnaireItemTypeCode_Value::DATE,
            QuestionnaireItemTypeCode_Value::DATE_TIME,
            QuestionnaireItemTypeCode_Value::TIME,
            QuestionnaireItemTypeCode_Value::STRING,
            QuestionnaireItemTypeCode_Value::TEXT,
            QuestionnaireItemTypeCode_Value::URL,
            QuestionnaireItemTypeCode_Value::CHOICE,
            QuestionnaireItemTypeCode_Value::OPEN_CHOICE,
            QuestionnaireItemTypeCode_Value::ATTACHMENT,
            QuestionnaireItemTypeCode_Value::REFERENCE,
            QuestionnaireItemTypeCode_Value::QUANTITY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("QuestionnaireItemTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for QuestionnaireItemTypeCode_Value {
}

impl ::std::default::Default for QuestionnaireItemTypeCode_Value {
    fn default() -> Self {
        QuestionnaireItemTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for QuestionnaireItemTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LibraryTypeCode {
    // message fields
    pub value: LibraryTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LibraryTypeCode {
    pub fn new() -> LibraryTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.LibraryTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = LibraryTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: LibraryTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> LibraryTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for LibraryTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != LibraryTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != LibraryTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LibraryTypeCode {
        LibraryTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LibraryTypeCode_Value>>(
                    "value",
                    |m: &LibraryTypeCode| { &m.value },
                    |m: &mut LibraryTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &LibraryTypeCode| { &m.id },
                    |m: &mut LibraryTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &LibraryTypeCode| { &m.extension },
                    |m: &mut LibraryTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LibraryTypeCode>(
                    "LibraryTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LibraryTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<LibraryTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LibraryTypeCode,
        };
        unsafe {
            instance.get(LibraryTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for LibraryTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LibraryTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LibraryTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    LOGIC_LIBRARY = 1,
    MODEL_DEFINITION = 2,
    ASSET_COLLECTION = 3,
    MODULE_DEFINITION = 4,
}

impl ::protobuf::ProtobufEnum for LibraryTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LibraryTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(LibraryTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(LibraryTypeCode_Value::LOGIC_LIBRARY),
            2 => ::std::option::Option::Some(LibraryTypeCode_Value::MODEL_DEFINITION),
            3 => ::std::option::Option::Some(LibraryTypeCode_Value::ASSET_COLLECTION),
            4 => ::std::option::Option::Some(LibraryTypeCode_Value::MODULE_DEFINITION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LibraryTypeCode_Value] = &[
            LibraryTypeCode_Value::INVALID_UNINITIALIZED,
            LibraryTypeCode_Value::LOGIC_LIBRARY,
            LibraryTypeCode_Value::MODEL_DEFINITION,
            LibraryTypeCode_Value::ASSET_COLLECTION,
            LibraryTypeCode_Value::MODULE_DEFINITION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LibraryTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LibraryTypeCode_Value {
}

impl ::std::default::Default for LibraryTypeCode_Value {
    fn default() -> Self {
        LibraryTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for LibraryTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinkageTypeCode {
    // message fields
    pub value: LinkageTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LinkageTypeCode {
    pub fn new() -> LinkageTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.LinkageTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = LinkageTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: LinkageTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> LinkageTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for LinkageTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != LinkageTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != LinkageTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinkageTypeCode {
        LinkageTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LinkageTypeCode_Value>>(
                    "value",
                    |m: &LinkageTypeCode| { &m.value },
                    |m: &mut LinkageTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &LinkageTypeCode| { &m.id },
                    |m: &mut LinkageTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &LinkageTypeCode| { &m.extension },
                    |m: &mut LinkageTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LinkageTypeCode>(
                    "LinkageTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinkageTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<LinkageTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LinkageTypeCode,
        };
        unsafe {
            instance.get(LinkageTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for LinkageTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinkageTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkageTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LinkageTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    SOURCE = 1,
    ALTERNATE = 2,
    HISTORICAL = 3,
}

impl ::protobuf::ProtobufEnum for LinkageTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LinkageTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(LinkageTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(LinkageTypeCode_Value::SOURCE),
            2 => ::std::option::Option::Some(LinkageTypeCode_Value::ALTERNATE),
            3 => ::std::option::Option::Some(LinkageTypeCode_Value::HISTORICAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LinkageTypeCode_Value] = &[
            LinkageTypeCode_Value::INVALID_UNINITIALIZED,
            LinkageTypeCode_Value::SOURCE,
            LinkageTypeCode_Value::ALTERNATE,
            LinkageTypeCode_Value::HISTORICAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LinkageTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LinkageTypeCode_Value {
}

impl ::std::default::Default for LinkageTypeCode_Value {
    fn default() -> Self {
        LinkageTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkageTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinkTypeCode {
    // message fields
    pub value: LinkTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LinkTypeCode {
    pub fn new() -> LinkTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.LinkTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = LinkTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: LinkTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> LinkTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for LinkTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != LinkTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != LinkTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinkTypeCode {
        LinkTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LinkTypeCode_Value>>(
                    "value",
                    |m: &LinkTypeCode| { &m.value },
                    |m: &mut LinkTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &LinkTypeCode| { &m.id },
                    |m: &mut LinkTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &LinkTypeCode| { &m.extension },
                    |m: &mut LinkTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LinkTypeCode>(
                    "LinkTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LinkTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<LinkTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LinkTypeCode,
        };
        unsafe {
            instance.get(LinkTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for LinkTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinkTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LinkTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    REPLACED_BY = 1,
    REPLACES = 2,
    REFER = 3,
    SEEALSO = 4,
}

impl ::protobuf::ProtobufEnum for LinkTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LinkTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(LinkTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(LinkTypeCode_Value::REPLACED_BY),
            2 => ::std::option::Option::Some(LinkTypeCode_Value::REPLACES),
            3 => ::std::option::Option::Some(LinkTypeCode_Value::REFER),
            4 => ::std::option::Option::Some(LinkTypeCode_Value::SEEALSO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LinkTypeCode_Value] = &[
            LinkTypeCode_Value::INVALID_UNINITIALIZED,
            LinkTypeCode_Value::REPLACED_BY,
            LinkTypeCode_Value::REPLACES,
            LinkTypeCode_Value::REFER,
            LinkTypeCode_Value::SEEALSO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LinkTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LinkTypeCode_Value {
}

impl ::std::default::Default for LinkTypeCode_Value {
    fn default() -> Self {
        LinkTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEmptyReasonsCode {
    // message fields
    pub value: ListEmptyReasonsCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListEmptyReasonsCode {
    pub fn new() -> ListEmptyReasonsCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ListEmptyReasonsCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ListEmptyReasonsCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ListEmptyReasonsCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ListEmptyReasonsCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ListEmptyReasonsCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ListEmptyReasonsCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ListEmptyReasonsCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEmptyReasonsCode {
        ListEmptyReasonsCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ListEmptyReasonsCode_Value>>(
                    "value",
                    |m: &ListEmptyReasonsCode| { &m.value },
                    |m: &mut ListEmptyReasonsCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ListEmptyReasonsCode| { &m.id },
                    |m: &mut ListEmptyReasonsCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ListEmptyReasonsCode| { &m.extension },
                    |m: &mut ListEmptyReasonsCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListEmptyReasonsCode>(
                    "ListEmptyReasonsCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListEmptyReasonsCode {
        static mut instance: ::protobuf::lazy::Lazy<ListEmptyReasonsCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListEmptyReasonsCode,
        };
        unsafe {
            instance.get(ListEmptyReasonsCode::new)
        }
    }
}

impl ::protobuf::Clear for ListEmptyReasonsCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEmptyReasonsCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEmptyReasonsCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ListEmptyReasonsCode_Value {
    INVALID_UNINITIALIZED = 0,
    NILKNOWN = 1,
    NOTASKED = 2,
    WITHHELD = 3,
    UNAVAILABLE = 4,
    NOTSTARTED = 5,
    CLOSED = 6,
}

impl ::protobuf::ProtobufEnum for ListEmptyReasonsCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ListEmptyReasonsCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ListEmptyReasonsCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ListEmptyReasonsCode_Value::NILKNOWN),
            2 => ::std::option::Option::Some(ListEmptyReasonsCode_Value::NOTASKED),
            3 => ::std::option::Option::Some(ListEmptyReasonsCode_Value::WITHHELD),
            4 => ::std::option::Option::Some(ListEmptyReasonsCode_Value::UNAVAILABLE),
            5 => ::std::option::Option::Some(ListEmptyReasonsCode_Value::NOTSTARTED),
            6 => ::std::option::Option::Some(ListEmptyReasonsCode_Value::CLOSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ListEmptyReasonsCode_Value] = &[
            ListEmptyReasonsCode_Value::INVALID_UNINITIALIZED,
            ListEmptyReasonsCode_Value::NILKNOWN,
            ListEmptyReasonsCode_Value::NOTASKED,
            ListEmptyReasonsCode_Value::WITHHELD,
            ListEmptyReasonsCode_Value::UNAVAILABLE,
            ListEmptyReasonsCode_Value::NOTSTARTED,
            ListEmptyReasonsCode_Value::CLOSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ListEmptyReasonsCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ListEmptyReasonsCode_Value {
}

impl ::std::default::Default for ListEmptyReasonsCode_Value {
    fn default() -> Self {
        ListEmptyReasonsCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEmptyReasonsCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExampleUseCodesforListCode {
    // message fields
    pub value: ExampleUseCodesforListCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ExampleUseCodesforListCode {
    pub fn new() -> ExampleUseCodesforListCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ExampleUseCodesforListCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ExampleUseCodesforListCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ExampleUseCodesforListCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ExampleUseCodesforListCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ExampleUseCodesforListCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ExampleUseCodesforListCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ExampleUseCodesforListCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExampleUseCodesforListCode {
        ExampleUseCodesforListCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExampleUseCodesforListCode_Value>>(
                    "value",
                    |m: &ExampleUseCodesforListCode| { &m.value },
                    |m: &mut ExampleUseCodesforListCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ExampleUseCodesforListCode| { &m.id },
                    |m: &mut ExampleUseCodesforListCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ExampleUseCodesforListCode| { &m.extension },
                    |m: &mut ExampleUseCodesforListCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExampleUseCodesforListCode>(
                    "ExampleUseCodesforListCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExampleUseCodesforListCode {
        static mut instance: ::protobuf::lazy::Lazy<ExampleUseCodesforListCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExampleUseCodesforListCode,
        };
        unsafe {
            instance.get(ExampleUseCodesforListCode::new)
        }
    }
}

impl ::protobuf::Clear for ExampleUseCodesforListCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExampleUseCodesforListCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExampleUseCodesforListCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExampleUseCodesforListCode_Value {
    INVALID_UNINITIALIZED = 0,
    ALERTS = 1,
    ADVERSERXNS = 2,
    ALLERGIES = 3,
    MEDICATIONS = 4,
    PROBLEMS = 5,
    WORKLIST = 6,
    WAITING = 7,
    PROTOCOLS = 8,
    PLANS = 9,
}

impl ::protobuf::ProtobufEnum for ExampleUseCodesforListCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExampleUseCodesforListCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ExampleUseCodesforListCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ExampleUseCodesforListCode_Value::ALERTS),
            2 => ::std::option::Option::Some(ExampleUseCodesforListCode_Value::ADVERSERXNS),
            3 => ::std::option::Option::Some(ExampleUseCodesforListCode_Value::ALLERGIES),
            4 => ::std::option::Option::Some(ExampleUseCodesforListCode_Value::MEDICATIONS),
            5 => ::std::option::Option::Some(ExampleUseCodesforListCode_Value::PROBLEMS),
            6 => ::std::option::Option::Some(ExampleUseCodesforListCode_Value::WORKLIST),
            7 => ::std::option::Option::Some(ExampleUseCodesforListCode_Value::WAITING),
            8 => ::std::option::Option::Some(ExampleUseCodesforListCode_Value::PROTOCOLS),
            9 => ::std::option::Option::Some(ExampleUseCodesforListCode_Value::PLANS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExampleUseCodesforListCode_Value] = &[
            ExampleUseCodesforListCode_Value::INVALID_UNINITIALIZED,
            ExampleUseCodesforListCode_Value::ALERTS,
            ExampleUseCodesforListCode_Value::ADVERSERXNS,
            ExampleUseCodesforListCode_Value::ALLERGIES,
            ExampleUseCodesforListCode_Value::MEDICATIONS,
            ExampleUseCodesforListCode_Value::PROBLEMS,
            ExampleUseCodesforListCode_Value::WORKLIST,
            ExampleUseCodesforListCode_Value::WAITING,
            ExampleUseCodesforListCode_Value::PROTOCOLS,
            ExampleUseCodesforListCode_Value::PLANS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ExampleUseCodesforListCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ExampleUseCodesforListCode_Value {
}

impl ::std::default::Default for ExampleUseCodesforListCode_Value {
    fn default() -> Self {
        ExampleUseCodesforListCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ExampleUseCodesforListCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModeCode {
    // message fields
    pub value: ListModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListModeCode {
    pub fn new() -> ListModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ListModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ListModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ListModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ListModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ListModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ListModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ListModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModeCode {
        ListModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ListModeCode_Value>>(
                    "value",
                    |m: &ListModeCode| { &m.value },
                    |m: &mut ListModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ListModeCode| { &m.id },
                    |m: &mut ListModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ListModeCode| { &m.extension },
                    |m: &mut ListModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListModeCode>(
                    "ListModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListModeCode {
        static mut instance: ::protobuf::lazy::Lazy<ListModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListModeCode,
        };
        unsafe {
            instance.get(ListModeCode::new)
        }
    }
}

impl ::protobuf::Clear for ListModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ListModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    WORKING = 1,
    SNAPSHOT = 2,
    CHANGES = 3,
}

impl ::protobuf::ProtobufEnum for ListModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ListModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ListModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ListModeCode_Value::WORKING),
            2 => ::std::option::Option::Some(ListModeCode_Value::SNAPSHOT),
            3 => ::std::option::Option::Some(ListModeCode_Value::CHANGES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ListModeCode_Value] = &[
            ListModeCode_Value::INVALID_UNINITIALIZED,
            ListModeCode_Value::WORKING,
            ListModeCode_Value::SNAPSHOT,
            ListModeCode_Value::CHANGES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ListModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ListModeCode_Value {
}

impl ::std::default::Default for ListModeCode_Value {
    fn default() -> Self {
        ListModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOrderCodesCode {
    // message fields
    pub value: ListOrderCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListOrderCodesCode {
    pub fn new() -> ListOrderCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ListOrderCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ListOrderCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ListOrderCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ListOrderCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ListOrderCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ListOrderCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ListOrderCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOrderCodesCode {
        ListOrderCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ListOrderCodesCode_Value>>(
                    "value",
                    |m: &ListOrderCodesCode| { &m.value },
                    |m: &mut ListOrderCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ListOrderCodesCode| { &m.id },
                    |m: &mut ListOrderCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ListOrderCodesCode| { &m.extension },
                    |m: &mut ListOrderCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListOrderCodesCode>(
                    "ListOrderCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListOrderCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ListOrderCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListOrderCodesCode,
        };
        unsafe {
            instance.get(ListOrderCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ListOrderCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOrderCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOrderCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ListOrderCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    USER = 1,
    SYSTEM = 2,
    EVENT_DATE = 3,
    ENTRY_DATE = 4,
    PRIORITY = 5,
    ALPHABETIC = 6,
    CATEGORY = 7,
    PATIENT = 8,
}

impl ::protobuf::ProtobufEnum for ListOrderCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ListOrderCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ListOrderCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ListOrderCodesCode_Value::USER),
            2 => ::std::option::Option::Some(ListOrderCodesCode_Value::SYSTEM),
            3 => ::std::option::Option::Some(ListOrderCodesCode_Value::EVENT_DATE),
            4 => ::std::option::Option::Some(ListOrderCodesCode_Value::ENTRY_DATE),
            5 => ::std::option::Option::Some(ListOrderCodesCode_Value::PRIORITY),
            6 => ::std::option::Option::Some(ListOrderCodesCode_Value::ALPHABETIC),
            7 => ::std::option::Option::Some(ListOrderCodesCode_Value::CATEGORY),
            8 => ::std::option::Option::Some(ListOrderCodesCode_Value::PATIENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ListOrderCodesCode_Value] = &[
            ListOrderCodesCode_Value::INVALID_UNINITIALIZED,
            ListOrderCodesCode_Value::USER,
            ListOrderCodesCode_Value::SYSTEM,
            ListOrderCodesCode_Value::EVENT_DATE,
            ListOrderCodesCode_Value::ENTRY_DATE,
            ListOrderCodesCode_Value::PRIORITY,
            ListOrderCodesCode_Value::ALPHABETIC,
            ListOrderCodesCode_Value::CATEGORY,
            ListOrderCodesCode_Value::PATIENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ListOrderCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ListOrderCodesCode_Value {
}

impl ::std::default::Default for ListOrderCodesCode_Value {
    fn default() -> Self {
        ListOrderCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOrderCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListStatusCode {
    // message fields
    pub value: ListStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ListStatusCode {
    pub fn new() -> ListStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ListStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ListStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ListStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ListStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ListStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ListStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ListStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListStatusCode {
        ListStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ListStatusCode_Value>>(
                    "value",
                    |m: &ListStatusCode| { &m.value },
                    |m: &mut ListStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ListStatusCode| { &m.id },
                    |m: &mut ListStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ListStatusCode| { &m.extension },
                    |m: &mut ListStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListStatusCode>(
                    "ListStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ListStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListStatusCode,
        };
        unsafe {
            instance.get(ListStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ListStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ListStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    CURRENT = 1,
    RETIRED = 2,
    ENTERED_IN_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for ListStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ListStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ListStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ListStatusCode_Value::CURRENT),
            2 => ::std::option::Option::Some(ListStatusCode_Value::RETIRED),
            3 => ::std::option::Option::Some(ListStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ListStatusCode_Value] = &[
            ListStatusCode_Value::INVALID_UNINITIALIZED,
            ListStatusCode_Value::CURRENT,
            ListStatusCode_Value::RETIRED,
            ListStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ListStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ListStatusCode_Value {
}

impl ::std::default::Default for ListStatusCode_Value {
    fn default() -> Self {
        ListStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocationModeCode {
    // message fields
    pub value: LocationModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LocationModeCode {
    pub fn new() -> LocationModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.LocationModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = LocationModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: LocationModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> LocationModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for LocationModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != LocationModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != LocationModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocationModeCode {
        LocationModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LocationModeCode_Value>>(
                    "value",
                    |m: &LocationModeCode| { &m.value },
                    |m: &mut LocationModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &LocationModeCode| { &m.id },
                    |m: &mut LocationModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &LocationModeCode| { &m.extension },
                    |m: &mut LocationModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocationModeCode>(
                    "LocationModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocationModeCode {
        static mut instance: ::protobuf::lazy::Lazy<LocationModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocationModeCode,
        };
        unsafe {
            instance.get(LocationModeCode::new)
        }
    }
}

impl ::protobuf::Clear for LocationModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocationModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LocationModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    INSTANCE = 1,
    KIND = 2,
}

impl ::protobuf::ProtobufEnum for LocationModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LocationModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(LocationModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(LocationModeCode_Value::INSTANCE),
            2 => ::std::option::Option::Some(LocationModeCode_Value::KIND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LocationModeCode_Value] = &[
            LocationModeCode_Value::INVALID_UNINITIALIZED,
            LocationModeCode_Value::INSTANCE,
            LocationModeCode_Value::KIND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LocationModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LocationModeCode_Value {
}

impl ::std::default::Default for LocationModeCode_Value {
    fn default() -> Self {
        LocationModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocationTypeCode {
    // message fields
    pub value: LocationTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LocationTypeCode {
    pub fn new() -> LocationTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.LocationTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = LocationTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: LocationTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> LocationTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for LocationTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != LocationTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != LocationTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocationTypeCode {
        LocationTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LocationTypeCode_Value>>(
                    "value",
                    |m: &LocationTypeCode| { &m.value },
                    |m: &mut LocationTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &LocationTypeCode| { &m.id },
                    |m: &mut LocationTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &LocationTypeCode| { &m.extension },
                    |m: &mut LocationTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocationTypeCode>(
                    "LocationTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocationTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<LocationTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocationTypeCode,
        };
        unsafe {
            instance.get(LocationTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for LocationTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocationTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LocationTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    SI = 1,
    BU = 2,
    WI = 3,
    WA = 4,
    LVL = 5,
    CO = 6,
    RO = 7,
    BD = 8,
    VE = 9,
    HO = 10,
    CA = 11,
    RD = 12,
    AREA = 13,
    JDN = 14,
}

impl ::protobuf::ProtobufEnum for LocationTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LocationTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(LocationTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(LocationTypeCode_Value::SI),
            2 => ::std::option::Option::Some(LocationTypeCode_Value::BU),
            3 => ::std::option::Option::Some(LocationTypeCode_Value::WI),
            4 => ::std::option::Option::Some(LocationTypeCode_Value::WA),
            5 => ::std::option::Option::Some(LocationTypeCode_Value::LVL),
            6 => ::std::option::Option::Some(LocationTypeCode_Value::CO),
            7 => ::std::option::Option::Some(LocationTypeCode_Value::RO),
            8 => ::std::option::Option::Some(LocationTypeCode_Value::BD),
            9 => ::std::option::Option::Some(LocationTypeCode_Value::VE),
            10 => ::std::option::Option::Some(LocationTypeCode_Value::HO),
            11 => ::std::option::Option::Some(LocationTypeCode_Value::CA),
            12 => ::std::option::Option::Some(LocationTypeCode_Value::RD),
            13 => ::std::option::Option::Some(LocationTypeCode_Value::AREA),
            14 => ::std::option::Option::Some(LocationTypeCode_Value::JDN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LocationTypeCode_Value] = &[
            LocationTypeCode_Value::INVALID_UNINITIALIZED,
            LocationTypeCode_Value::SI,
            LocationTypeCode_Value::BU,
            LocationTypeCode_Value::WI,
            LocationTypeCode_Value::WA,
            LocationTypeCode_Value::LVL,
            LocationTypeCode_Value::CO,
            LocationTypeCode_Value::RO,
            LocationTypeCode_Value::BD,
            LocationTypeCode_Value::VE,
            LocationTypeCode_Value::HO,
            LocationTypeCode_Value::CA,
            LocationTypeCode_Value::RD,
            LocationTypeCode_Value::AREA,
            LocationTypeCode_Value::JDN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LocationTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LocationTypeCode_Value {
}

impl ::std::default::Default for LocationTypeCode_Value {
    fn default() -> Self {
        LocationTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocationStatusCode {
    // message fields
    pub value: LocationStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LocationStatusCode {
    pub fn new() -> LocationStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.LocationStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = LocationStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: LocationStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> LocationStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for LocationStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != LocationStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != LocationStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocationStatusCode {
        LocationStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LocationStatusCode_Value>>(
                    "value",
                    |m: &LocationStatusCode| { &m.value },
                    |m: &mut LocationStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &LocationStatusCode| { &m.id },
                    |m: &mut LocationStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &LocationStatusCode| { &m.extension },
                    |m: &mut LocationStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocationStatusCode>(
                    "LocationStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocationStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<LocationStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocationStatusCode,
        };
        unsafe {
            instance.get(LocationStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for LocationStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocationStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LocationStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    SUSPENDED = 2,
    INACTIVE = 3,
}

impl ::protobuf::ProtobufEnum for LocationStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LocationStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(LocationStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(LocationStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(LocationStatusCode_Value::SUSPENDED),
            3 => ::std::option::Option::Some(LocationStatusCode_Value::INACTIVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LocationStatusCode_Value] = &[
            LocationStatusCode_Value::INVALID_UNINITIALIZED,
            LocationStatusCode_Value::ACTIVE,
            LocationStatusCode_Value::SUSPENDED,
            LocationStatusCode_Value::INACTIVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LocationStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LocationStatusCode_Value {
}

impl ::std::default::Default for LocationStatusCode_Value {
    fn default() -> Self {
        LocationStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for LocationStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProbabilityDistributionTypeCode {
    // message fields
    pub value: ProbabilityDistributionTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ProbabilityDistributionTypeCode {
    pub fn new() -> ProbabilityDistributionTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ProbabilityDistributionTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ProbabilityDistributionTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ProbabilityDistributionTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ProbabilityDistributionTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ProbabilityDistributionTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ProbabilityDistributionTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ProbabilityDistributionTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProbabilityDistributionTypeCode {
        ProbabilityDistributionTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ProbabilityDistributionTypeCode_Value>>(
                    "value",
                    |m: &ProbabilityDistributionTypeCode| { &m.value },
                    |m: &mut ProbabilityDistributionTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ProbabilityDistributionTypeCode| { &m.id },
                    |m: &mut ProbabilityDistributionTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ProbabilityDistributionTypeCode| { &m.extension },
                    |m: &mut ProbabilityDistributionTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProbabilityDistributionTypeCode>(
                    "ProbabilityDistributionTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProbabilityDistributionTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ProbabilityDistributionTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProbabilityDistributionTypeCode,
        };
        unsafe {
            instance.get(ProbabilityDistributionTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ProbabilityDistributionTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProbabilityDistributionTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProbabilityDistributionTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProbabilityDistributionTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    B = 1,
    E = 2,
    F = 3,
    G = 4,
    LN = 5,
    N = 6,
    T = 7,
    U = 8,
    X2 = 9,
}

impl ::protobuf::ProtobufEnum for ProbabilityDistributionTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProbabilityDistributionTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ProbabilityDistributionTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ProbabilityDistributionTypeCode_Value::B),
            2 => ::std::option::Option::Some(ProbabilityDistributionTypeCode_Value::E),
            3 => ::std::option::Option::Some(ProbabilityDistributionTypeCode_Value::F),
            4 => ::std::option::Option::Some(ProbabilityDistributionTypeCode_Value::G),
            5 => ::std::option::Option::Some(ProbabilityDistributionTypeCode_Value::LN),
            6 => ::std::option::Option::Some(ProbabilityDistributionTypeCode_Value::N),
            7 => ::std::option::Option::Some(ProbabilityDistributionTypeCode_Value::T),
            8 => ::std::option::Option::Some(ProbabilityDistributionTypeCode_Value::U),
            9 => ::std::option::Option::Some(ProbabilityDistributionTypeCode_Value::X2),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProbabilityDistributionTypeCode_Value] = &[
            ProbabilityDistributionTypeCode_Value::INVALID_UNINITIALIZED,
            ProbabilityDistributionTypeCode_Value::B,
            ProbabilityDistributionTypeCode_Value::E,
            ProbabilityDistributionTypeCode_Value::F,
            ProbabilityDistributionTypeCode_Value::G,
            ProbabilityDistributionTypeCode_Value::LN,
            ProbabilityDistributionTypeCode_Value::N,
            ProbabilityDistributionTypeCode_Value::T,
            ProbabilityDistributionTypeCode_Value::U,
            ProbabilityDistributionTypeCode_Value::X2,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ProbabilityDistributionTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ProbabilityDistributionTypeCode_Value {
}

impl ::std::default::Default for ProbabilityDistributionTypeCode_Value {
    fn default() -> Self {
        ProbabilityDistributionTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ProbabilityDistributionTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructureMapContextTypeCode {
    // message fields
    pub value: StructureMapContextTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StructureMapContextTypeCode {
    pub fn new() -> StructureMapContextTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.StructureMapContextTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = StructureMapContextTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: StructureMapContextTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> StructureMapContextTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for StructureMapContextTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != StructureMapContextTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != StructureMapContextTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructureMapContextTypeCode {
        StructureMapContextTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructureMapContextTypeCode_Value>>(
                    "value",
                    |m: &StructureMapContextTypeCode| { &m.value },
                    |m: &mut StructureMapContextTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &StructureMapContextTypeCode| { &m.id },
                    |m: &mut StructureMapContextTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &StructureMapContextTypeCode| { &m.extension },
                    |m: &mut StructureMapContextTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructureMapContextTypeCode>(
                    "StructureMapContextTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructureMapContextTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<StructureMapContextTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructureMapContextTypeCode,
        };
        unsafe {
            instance.get(StructureMapContextTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for StructureMapContextTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructureMapContextTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapContextTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructureMapContextTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    TYPE = 1,
    VARIABLE = 2,
}

impl ::protobuf::ProtobufEnum for StructureMapContextTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructureMapContextTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(StructureMapContextTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(StructureMapContextTypeCode_Value::TYPE),
            2 => ::std::option::Option::Some(StructureMapContextTypeCode_Value::VARIABLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructureMapContextTypeCode_Value] = &[
            StructureMapContextTypeCode_Value::INVALID_UNINITIALIZED,
            StructureMapContextTypeCode_Value::TYPE,
            StructureMapContextTypeCode_Value::VARIABLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructureMapContextTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructureMapContextTypeCode_Value {
}

impl ::std::default::Default for StructureMapContextTypeCode_Value {
    fn default() -> Self {
        StructureMapContextTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapContextTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructureMapGroupTypeModeCode {
    // message fields
    pub value: StructureMapGroupTypeModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StructureMapGroupTypeModeCode {
    pub fn new() -> StructureMapGroupTypeModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.StructureMapGroupTypeModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = StructureMapGroupTypeModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: StructureMapGroupTypeModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> StructureMapGroupTypeModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for StructureMapGroupTypeModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != StructureMapGroupTypeModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != StructureMapGroupTypeModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructureMapGroupTypeModeCode {
        StructureMapGroupTypeModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructureMapGroupTypeModeCode_Value>>(
                    "value",
                    |m: &StructureMapGroupTypeModeCode| { &m.value },
                    |m: &mut StructureMapGroupTypeModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &StructureMapGroupTypeModeCode| { &m.id },
                    |m: &mut StructureMapGroupTypeModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &StructureMapGroupTypeModeCode| { &m.extension },
                    |m: &mut StructureMapGroupTypeModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructureMapGroupTypeModeCode>(
                    "StructureMapGroupTypeModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructureMapGroupTypeModeCode {
        static mut instance: ::protobuf::lazy::Lazy<StructureMapGroupTypeModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructureMapGroupTypeModeCode,
        };
        unsafe {
            instance.get(StructureMapGroupTypeModeCode::new)
        }
    }
}

impl ::protobuf::Clear for StructureMapGroupTypeModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructureMapGroupTypeModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapGroupTypeModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructureMapGroupTypeModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    NONE = 1,
    TYPES = 2,
    TYPE_AND_TYPES = 3,
}

impl ::protobuf::ProtobufEnum for StructureMapGroupTypeModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructureMapGroupTypeModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(StructureMapGroupTypeModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(StructureMapGroupTypeModeCode_Value::NONE),
            2 => ::std::option::Option::Some(StructureMapGroupTypeModeCode_Value::TYPES),
            3 => ::std::option::Option::Some(StructureMapGroupTypeModeCode_Value::TYPE_AND_TYPES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructureMapGroupTypeModeCode_Value] = &[
            StructureMapGroupTypeModeCode_Value::INVALID_UNINITIALIZED,
            StructureMapGroupTypeModeCode_Value::NONE,
            StructureMapGroupTypeModeCode_Value::TYPES,
            StructureMapGroupTypeModeCode_Value::TYPE_AND_TYPES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructureMapGroupTypeModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructureMapGroupTypeModeCode_Value {
}

impl ::std::default::Default for StructureMapGroupTypeModeCode_Value {
    fn default() -> Self {
        StructureMapGroupTypeModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapGroupTypeModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructureMapInputModeCode {
    // message fields
    pub value: StructureMapInputModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StructureMapInputModeCode {
    pub fn new() -> StructureMapInputModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.StructureMapInputModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = StructureMapInputModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: StructureMapInputModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> StructureMapInputModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for StructureMapInputModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != StructureMapInputModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != StructureMapInputModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructureMapInputModeCode {
        StructureMapInputModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructureMapInputModeCode_Value>>(
                    "value",
                    |m: &StructureMapInputModeCode| { &m.value },
                    |m: &mut StructureMapInputModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &StructureMapInputModeCode| { &m.id },
                    |m: &mut StructureMapInputModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &StructureMapInputModeCode| { &m.extension },
                    |m: &mut StructureMapInputModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructureMapInputModeCode>(
                    "StructureMapInputModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructureMapInputModeCode {
        static mut instance: ::protobuf::lazy::Lazy<StructureMapInputModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructureMapInputModeCode,
        };
        unsafe {
            instance.get(StructureMapInputModeCode::new)
        }
    }
}

impl ::protobuf::Clear for StructureMapInputModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructureMapInputModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapInputModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructureMapInputModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    SOURCE = 1,
    TARGET = 2,
}

impl ::protobuf::ProtobufEnum for StructureMapInputModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructureMapInputModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(StructureMapInputModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(StructureMapInputModeCode_Value::SOURCE),
            2 => ::std::option::Option::Some(StructureMapInputModeCode_Value::TARGET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructureMapInputModeCode_Value] = &[
            StructureMapInputModeCode_Value::INVALID_UNINITIALIZED,
            StructureMapInputModeCode_Value::SOURCE,
            StructureMapInputModeCode_Value::TARGET,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructureMapInputModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructureMapInputModeCode_Value {
}

impl ::std::default::Default for StructureMapInputModeCode_Value {
    fn default() -> Self {
        StructureMapInputModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapInputModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructureMapModelModeCode {
    // message fields
    pub value: StructureMapModelModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StructureMapModelModeCode {
    pub fn new() -> StructureMapModelModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.StructureMapModelModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = StructureMapModelModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: StructureMapModelModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> StructureMapModelModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for StructureMapModelModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != StructureMapModelModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != StructureMapModelModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructureMapModelModeCode {
        StructureMapModelModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructureMapModelModeCode_Value>>(
                    "value",
                    |m: &StructureMapModelModeCode| { &m.value },
                    |m: &mut StructureMapModelModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &StructureMapModelModeCode| { &m.id },
                    |m: &mut StructureMapModelModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &StructureMapModelModeCode| { &m.extension },
                    |m: &mut StructureMapModelModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructureMapModelModeCode>(
                    "StructureMapModelModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructureMapModelModeCode {
        static mut instance: ::protobuf::lazy::Lazy<StructureMapModelModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructureMapModelModeCode,
        };
        unsafe {
            instance.get(StructureMapModelModeCode::new)
        }
    }
}

impl ::protobuf::Clear for StructureMapModelModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructureMapModelModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapModelModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructureMapModelModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    SOURCE = 1,
    QUERIED = 2,
    TARGET = 3,
    PRODUCED = 4,
}

impl ::protobuf::ProtobufEnum for StructureMapModelModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructureMapModelModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(StructureMapModelModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(StructureMapModelModeCode_Value::SOURCE),
            2 => ::std::option::Option::Some(StructureMapModelModeCode_Value::QUERIED),
            3 => ::std::option::Option::Some(StructureMapModelModeCode_Value::TARGET),
            4 => ::std::option::Option::Some(StructureMapModelModeCode_Value::PRODUCED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructureMapModelModeCode_Value] = &[
            StructureMapModelModeCode_Value::INVALID_UNINITIALIZED,
            StructureMapModelModeCode_Value::SOURCE,
            StructureMapModelModeCode_Value::QUERIED,
            StructureMapModelModeCode_Value::TARGET,
            StructureMapModelModeCode_Value::PRODUCED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructureMapModelModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructureMapModelModeCode_Value {
}

impl ::std::default::Default for StructureMapModelModeCode_Value {
    fn default() -> Self {
        StructureMapModelModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapModelModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructureMapSourceListModeCode {
    // message fields
    pub value: StructureMapSourceListModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StructureMapSourceListModeCode {
    pub fn new() -> StructureMapSourceListModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.StructureMapSourceListModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = StructureMapSourceListModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: StructureMapSourceListModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> StructureMapSourceListModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for StructureMapSourceListModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != StructureMapSourceListModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != StructureMapSourceListModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructureMapSourceListModeCode {
        StructureMapSourceListModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructureMapSourceListModeCode_Value>>(
                    "value",
                    |m: &StructureMapSourceListModeCode| { &m.value },
                    |m: &mut StructureMapSourceListModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &StructureMapSourceListModeCode| { &m.id },
                    |m: &mut StructureMapSourceListModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &StructureMapSourceListModeCode| { &m.extension },
                    |m: &mut StructureMapSourceListModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructureMapSourceListModeCode>(
                    "StructureMapSourceListModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructureMapSourceListModeCode {
        static mut instance: ::protobuf::lazy::Lazy<StructureMapSourceListModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructureMapSourceListModeCode,
        };
        unsafe {
            instance.get(StructureMapSourceListModeCode::new)
        }
    }
}

impl ::protobuf::Clear for StructureMapSourceListModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructureMapSourceListModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapSourceListModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructureMapSourceListModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    FIRST = 1,
    NOT_FIRST = 2,
    LAST = 3,
    NOT_LAST = 4,
    ONLY_ONE = 5,
}

impl ::protobuf::ProtobufEnum for StructureMapSourceListModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructureMapSourceListModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(StructureMapSourceListModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(StructureMapSourceListModeCode_Value::FIRST),
            2 => ::std::option::Option::Some(StructureMapSourceListModeCode_Value::NOT_FIRST),
            3 => ::std::option::Option::Some(StructureMapSourceListModeCode_Value::LAST),
            4 => ::std::option::Option::Some(StructureMapSourceListModeCode_Value::NOT_LAST),
            5 => ::std::option::Option::Some(StructureMapSourceListModeCode_Value::ONLY_ONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructureMapSourceListModeCode_Value] = &[
            StructureMapSourceListModeCode_Value::INVALID_UNINITIALIZED,
            StructureMapSourceListModeCode_Value::FIRST,
            StructureMapSourceListModeCode_Value::NOT_FIRST,
            StructureMapSourceListModeCode_Value::LAST,
            StructureMapSourceListModeCode_Value::NOT_LAST,
            StructureMapSourceListModeCode_Value::ONLY_ONE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructureMapSourceListModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructureMapSourceListModeCode_Value {
}

impl ::std::default::Default for StructureMapSourceListModeCode_Value {
    fn default() -> Self {
        StructureMapSourceListModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapSourceListModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructureMapTargetListModeCode {
    // message fields
    pub value: StructureMapTargetListModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StructureMapTargetListModeCode {
    pub fn new() -> StructureMapTargetListModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.StructureMapTargetListModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = StructureMapTargetListModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: StructureMapTargetListModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> StructureMapTargetListModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for StructureMapTargetListModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != StructureMapTargetListModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != StructureMapTargetListModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructureMapTargetListModeCode {
        StructureMapTargetListModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructureMapTargetListModeCode_Value>>(
                    "value",
                    |m: &StructureMapTargetListModeCode| { &m.value },
                    |m: &mut StructureMapTargetListModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &StructureMapTargetListModeCode| { &m.id },
                    |m: &mut StructureMapTargetListModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &StructureMapTargetListModeCode| { &m.extension },
                    |m: &mut StructureMapTargetListModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructureMapTargetListModeCode>(
                    "StructureMapTargetListModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructureMapTargetListModeCode {
        static mut instance: ::protobuf::lazy::Lazy<StructureMapTargetListModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructureMapTargetListModeCode,
        };
        unsafe {
            instance.get(StructureMapTargetListModeCode::new)
        }
    }
}

impl ::protobuf::Clear for StructureMapTargetListModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructureMapTargetListModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapTargetListModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructureMapTargetListModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    FIRST = 1,
    SHARE = 2,
    LAST = 3,
    COLLATE = 4,
}

impl ::protobuf::ProtobufEnum for StructureMapTargetListModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructureMapTargetListModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(StructureMapTargetListModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(StructureMapTargetListModeCode_Value::FIRST),
            2 => ::std::option::Option::Some(StructureMapTargetListModeCode_Value::SHARE),
            3 => ::std::option::Option::Some(StructureMapTargetListModeCode_Value::LAST),
            4 => ::std::option::Option::Some(StructureMapTargetListModeCode_Value::COLLATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructureMapTargetListModeCode_Value] = &[
            StructureMapTargetListModeCode_Value::INVALID_UNINITIALIZED,
            StructureMapTargetListModeCode_Value::FIRST,
            StructureMapTargetListModeCode_Value::SHARE,
            StructureMapTargetListModeCode_Value::LAST,
            StructureMapTargetListModeCode_Value::COLLATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructureMapTargetListModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructureMapTargetListModeCode_Value {
}

impl ::std::default::Default for StructureMapTargetListModeCode_Value {
    fn default() -> Self {
        StructureMapTargetListModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapTargetListModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructureMapTransformCode {
    // message fields
    pub value: StructureMapTransformCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StructureMapTransformCode {
    pub fn new() -> StructureMapTransformCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.StructureMapTransformCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = StructureMapTransformCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: StructureMapTransformCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> StructureMapTransformCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for StructureMapTransformCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != StructureMapTransformCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != StructureMapTransformCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructureMapTransformCode {
        StructureMapTransformCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructureMapTransformCode_Value>>(
                    "value",
                    |m: &StructureMapTransformCode| { &m.value },
                    |m: &mut StructureMapTransformCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &StructureMapTransformCode| { &m.id },
                    |m: &mut StructureMapTransformCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &StructureMapTransformCode| { &m.extension },
                    |m: &mut StructureMapTransformCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructureMapTransformCode>(
                    "StructureMapTransformCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructureMapTransformCode {
        static mut instance: ::protobuf::lazy::Lazy<StructureMapTransformCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructureMapTransformCode,
        };
        unsafe {
            instance.get(StructureMapTransformCode::new)
        }
    }
}

impl ::protobuf::Clear for StructureMapTransformCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructureMapTransformCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapTransformCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructureMapTransformCode_Value {
    INVALID_UNINITIALIZED = 0,
    CREATE = 1,
    COPY = 2,
    TRUNCATE = 3,
    ESCAPE = 4,
    CAST = 5,
    APPEND = 6,
    TRANSLATE = 7,
    REFERENCE = 8,
    DATE_OP = 9,
    UUID = 10,
    POINTER = 11,
    EVALUATE = 12,
    CC = 13,
    C = 14,
    QTY = 15,
    ID = 16,
    CP = 17,
}

impl ::protobuf::ProtobufEnum for StructureMapTransformCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructureMapTransformCode_Value> {
        match value {
            0 => ::std::option::Option::Some(StructureMapTransformCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(StructureMapTransformCode_Value::CREATE),
            2 => ::std::option::Option::Some(StructureMapTransformCode_Value::COPY),
            3 => ::std::option::Option::Some(StructureMapTransformCode_Value::TRUNCATE),
            4 => ::std::option::Option::Some(StructureMapTransformCode_Value::ESCAPE),
            5 => ::std::option::Option::Some(StructureMapTransformCode_Value::CAST),
            6 => ::std::option::Option::Some(StructureMapTransformCode_Value::APPEND),
            7 => ::std::option::Option::Some(StructureMapTransformCode_Value::TRANSLATE),
            8 => ::std::option::Option::Some(StructureMapTransformCode_Value::REFERENCE),
            9 => ::std::option::Option::Some(StructureMapTransformCode_Value::DATE_OP),
            10 => ::std::option::Option::Some(StructureMapTransformCode_Value::UUID),
            11 => ::std::option::Option::Some(StructureMapTransformCode_Value::POINTER),
            12 => ::std::option::Option::Some(StructureMapTransformCode_Value::EVALUATE),
            13 => ::std::option::Option::Some(StructureMapTransformCode_Value::CC),
            14 => ::std::option::Option::Some(StructureMapTransformCode_Value::C),
            15 => ::std::option::Option::Some(StructureMapTransformCode_Value::QTY),
            16 => ::std::option::Option::Some(StructureMapTransformCode_Value::ID),
            17 => ::std::option::Option::Some(StructureMapTransformCode_Value::CP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructureMapTransformCode_Value] = &[
            StructureMapTransformCode_Value::INVALID_UNINITIALIZED,
            StructureMapTransformCode_Value::CREATE,
            StructureMapTransformCode_Value::COPY,
            StructureMapTransformCode_Value::TRUNCATE,
            StructureMapTransformCode_Value::ESCAPE,
            StructureMapTransformCode_Value::CAST,
            StructureMapTransformCode_Value::APPEND,
            StructureMapTransformCode_Value::TRANSLATE,
            StructureMapTransformCode_Value::REFERENCE,
            StructureMapTransformCode_Value::DATE_OP,
            StructureMapTransformCode_Value::UUID,
            StructureMapTransformCode_Value::POINTER,
            StructureMapTransformCode_Value::EVALUATE,
            StructureMapTransformCode_Value::CC,
            StructureMapTransformCode_Value::C,
            StructureMapTransformCode_Value::QTY,
            StructureMapTransformCode_Value::ID,
            StructureMapTransformCode_Value::CP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructureMapTransformCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructureMapTransformCode_Value {
}

impl ::std::default::Default for StructureMapTransformCode_Value {
    fn default() -> Self {
        StructureMapTransformCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureMapTransformCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MatchGradeCode {
    // message fields
    pub value: MatchGradeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MatchGradeCode {
    pub fn new() -> MatchGradeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MatchGradeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MatchGradeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MatchGradeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MatchGradeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MatchGradeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MatchGradeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MatchGradeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MatchGradeCode {
        MatchGradeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MatchGradeCode_Value>>(
                    "value",
                    |m: &MatchGradeCode| { &m.value },
                    |m: &mut MatchGradeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MatchGradeCode| { &m.id },
                    |m: &mut MatchGradeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MatchGradeCode| { &m.extension },
                    |m: &mut MatchGradeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MatchGradeCode>(
                    "MatchGradeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MatchGradeCode {
        static mut instance: ::protobuf::lazy::Lazy<MatchGradeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MatchGradeCode,
        };
        unsafe {
            instance.get(MatchGradeCode::new)
        }
    }
}

impl ::protobuf::Clear for MatchGradeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MatchGradeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchGradeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MatchGradeCode_Value {
    INVALID_UNINITIALIZED = 0,
    CERTAIN = 1,
    PROBABLE = 2,
    POSSIBLE = 3,
    CERTAINLY_NOT = 4,
}

impl ::protobuf::ProtobufEnum for MatchGradeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MatchGradeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MatchGradeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MatchGradeCode_Value::CERTAIN),
            2 => ::std::option::Option::Some(MatchGradeCode_Value::PROBABLE),
            3 => ::std::option::Option::Some(MatchGradeCode_Value::POSSIBLE),
            4 => ::std::option::Option::Some(MatchGradeCode_Value::CERTAINLY_NOT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MatchGradeCode_Value] = &[
            MatchGradeCode_Value::INVALID_UNINITIALIZED,
            MatchGradeCode_Value::CERTAIN,
            MatchGradeCode_Value::PROBABLE,
            MatchGradeCode_Value::POSSIBLE,
            MatchGradeCode_Value::CERTAINLY_NOT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MatchGradeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MatchGradeCode_Value {
}

impl ::std::default::Default for MatchGradeCode_Value {
    fn default() -> Self {
        MatchGradeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchGradeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MeasureDataUsageCode {
    // message fields
    pub value: MeasureDataUsageCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MeasureDataUsageCode {
    pub fn new() -> MeasureDataUsageCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MeasureDataUsageCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MeasureDataUsageCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MeasureDataUsageCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MeasureDataUsageCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MeasureDataUsageCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MeasureDataUsageCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MeasureDataUsageCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasureDataUsageCode {
        MeasureDataUsageCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MeasureDataUsageCode_Value>>(
                    "value",
                    |m: &MeasureDataUsageCode| { &m.value },
                    |m: &mut MeasureDataUsageCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MeasureDataUsageCode| { &m.id },
                    |m: &mut MeasureDataUsageCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MeasureDataUsageCode| { &m.extension },
                    |m: &mut MeasureDataUsageCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MeasureDataUsageCode>(
                    "MeasureDataUsageCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MeasureDataUsageCode {
        static mut instance: ::protobuf::lazy::Lazy<MeasureDataUsageCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MeasureDataUsageCode,
        };
        unsafe {
            instance.get(MeasureDataUsageCode::new)
        }
    }
}

impl ::protobuf::Clear for MeasureDataUsageCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasureDataUsageCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureDataUsageCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MeasureDataUsageCode_Value {
    INVALID_UNINITIALIZED = 0,
    SUPPLEMENTAL_DATA = 1,
    RISK_ADJUSTMENT_FACTOR = 2,
}

impl ::protobuf::ProtobufEnum for MeasureDataUsageCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MeasureDataUsageCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MeasureDataUsageCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MeasureDataUsageCode_Value::SUPPLEMENTAL_DATA),
            2 => ::std::option::Option::Some(MeasureDataUsageCode_Value::RISK_ADJUSTMENT_FACTOR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MeasureDataUsageCode_Value] = &[
            MeasureDataUsageCode_Value::INVALID_UNINITIALIZED,
            MeasureDataUsageCode_Value::SUPPLEMENTAL_DATA,
            MeasureDataUsageCode_Value::RISK_ADJUSTMENT_FACTOR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MeasureDataUsageCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MeasureDataUsageCode_Value {
}

impl ::std::default::Default for MeasureDataUsageCode_Value {
    fn default() -> Self {
        MeasureDataUsageCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureDataUsageCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MeasmntPrincipleCode {
    // message fields
    pub value: MeasmntPrincipleCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MeasmntPrincipleCode {
    pub fn new() -> MeasmntPrincipleCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MeasmntPrincipleCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MeasmntPrincipleCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MeasmntPrincipleCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MeasmntPrincipleCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MeasmntPrincipleCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MeasmntPrincipleCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MeasmntPrincipleCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasmntPrincipleCode {
        MeasmntPrincipleCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MeasmntPrincipleCode_Value>>(
                    "value",
                    |m: &MeasmntPrincipleCode| { &m.value },
                    |m: &mut MeasmntPrincipleCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MeasmntPrincipleCode| { &m.id },
                    |m: &mut MeasmntPrincipleCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MeasmntPrincipleCode| { &m.extension },
                    |m: &mut MeasmntPrincipleCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MeasmntPrincipleCode>(
                    "MeasmntPrincipleCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MeasmntPrincipleCode {
        static mut instance: ::protobuf::lazy::Lazy<MeasmntPrincipleCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MeasmntPrincipleCode,
        };
        unsafe {
            instance.get(MeasmntPrincipleCode::new)
        }
    }
}

impl ::protobuf::Clear for MeasmntPrincipleCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasmntPrincipleCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasmntPrincipleCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MeasmntPrincipleCode_Value {
    INVALID_UNINITIALIZED = 0,
    OTHER = 1,
    CHEMICAL = 2,
    ELECTRICAL = 3,
    IMPEDANCE = 4,
    NUCLEAR = 5,
    OPTICAL = 6,
    THERMAL = 7,
    BIOLOGICAL = 8,
    MECHANICAL = 9,
    ACOUSTICAL = 10,
    MANUAL = 11,
}

impl ::protobuf::ProtobufEnum for MeasmntPrincipleCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MeasmntPrincipleCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::OTHER),
            2 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::CHEMICAL),
            3 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::ELECTRICAL),
            4 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::IMPEDANCE),
            5 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::NUCLEAR),
            6 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::OPTICAL),
            7 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::THERMAL),
            8 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::BIOLOGICAL),
            9 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::MECHANICAL),
            10 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::ACOUSTICAL),
            11 => ::std::option::Option::Some(MeasmntPrincipleCode_Value::MANUAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MeasmntPrincipleCode_Value] = &[
            MeasmntPrincipleCode_Value::INVALID_UNINITIALIZED,
            MeasmntPrincipleCode_Value::OTHER,
            MeasmntPrincipleCode_Value::CHEMICAL,
            MeasmntPrincipleCode_Value::ELECTRICAL,
            MeasmntPrincipleCode_Value::IMPEDANCE,
            MeasmntPrincipleCode_Value::NUCLEAR,
            MeasmntPrincipleCode_Value::OPTICAL,
            MeasmntPrincipleCode_Value::THERMAL,
            MeasmntPrincipleCode_Value::BIOLOGICAL,
            MeasmntPrincipleCode_Value::MECHANICAL,
            MeasmntPrincipleCode_Value::ACOUSTICAL,
            MeasmntPrincipleCode_Value::MANUAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MeasmntPrincipleCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MeasmntPrincipleCode_Value {
}

impl ::std::default::Default for MeasmntPrincipleCode_Value {
    fn default() -> Self {
        MeasmntPrincipleCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasmntPrincipleCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MeasurePopulationTypeCode {
    // message fields
    pub value: MeasurePopulationTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MeasurePopulationTypeCode {
    pub fn new() -> MeasurePopulationTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MeasurePopulationTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MeasurePopulationTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MeasurePopulationTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MeasurePopulationTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MeasurePopulationTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MeasurePopulationTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MeasurePopulationTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasurePopulationTypeCode {
        MeasurePopulationTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MeasurePopulationTypeCode_Value>>(
                    "value",
                    |m: &MeasurePopulationTypeCode| { &m.value },
                    |m: &mut MeasurePopulationTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MeasurePopulationTypeCode| { &m.id },
                    |m: &mut MeasurePopulationTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MeasurePopulationTypeCode| { &m.extension },
                    |m: &mut MeasurePopulationTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MeasurePopulationTypeCode>(
                    "MeasurePopulationTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MeasurePopulationTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<MeasurePopulationTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MeasurePopulationTypeCode,
        };
        unsafe {
            instance.get(MeasurePopulationTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for MeasurePopulationTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasurePopulationTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasurePopulationTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MeasurePopulationTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    INITIAL_POPULATION = 1,
    NUMERATOR = 2,
    NUMERATOR_EXCLUSION = 3,
    DENOMINATOR = 4,
    DENOMINATOR_EXCLUSION = 5,
    DENOMINATOR_EXCEPTION = 6,
    MEASURE_POPULATION = 7,
    MEASURE_POPULATION_EXCLUSION = 8,
    MEASURE_OBSERVATION = 9,
}

impl ::protobuf::ProtobufEnum for MeasurePopulationTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MeasurePopulationTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MeasurePopulationTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MeasurePopulationTypeCode_Value::INITIAL_POPULATION),
            2 => ::std::option::Option::Some(MeasurePopulationTypeCode_Value::NUMERATOR),
            3 => ::std::option::Option::Some(MeasurePopulationTypeCode_Value::NUMERATOR_EXCLUSION),
            4 => ::std::option::Option::Some(MeasurePopulationTypeCode_Value::DENOMINATOR),
            5 => ::std::option::Option::Some(MeasurePopulationTypeCode_Value::DENOMINATOR_EXCLUSION),
            6 => ::std::option::Option::Some(MeasurePopulationTypeCode_Value::DENOMINATOR_EXCEPTION),
            7 => ::std::option::Option::Some(MeasurePopulationTypeCode_Value::MEASURE_POPULATION),
            8 => ::std::option::Option::Some(MeasurePopulationTypeCode_Value::MEASURE_POPULATION_EXCLUSION),
            9 => ::std::option::Option::Some(MeasurePopulationTypeCode_Value::MEASURE_OBSERVATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MeasurePopulationTypeCode_Value] = &[
            MeasurePopulationTypeCode_Value::INVALID_UNINITIALIZED,
            MeasurePopulationTypeCode_Value::INITIAL_POPULATION,
            MeasurePopulationTypeCode_Value::NUMERATOR,
            MeasurePopulationTypeCode_Value::NUMERATOR_EXCLUSION,
            MeasurePopulationTypeCode_Value::DENOMINATOR,
            MeasurePopulationTypeCode_Value::DENOMINATOR_EXCLUSION,
            MeasurePopulationTypeCode_Value::DENOMINATOR_EXCEPTION,
            MeasurePopulationTypeCode_Value::MEASURE_POPULATION,
            MeasurePopulationTypeCode_Value::MEASURE_POPULATION_EXCLUSION,
            MeasurePopulationTypeCode_Value::MEASURE_OBSERVATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MeasurePopulationTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MeasurePopulationTypeCode_Value {
}

impl ::std::default::Default for MeasurePopulationTypeCode_Value {
    fn default() -> Self {
        MeasurePopulationTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasurePopulationTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MeasureReportStatusCode {
    // message fields
    pub value: MeasureReportStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MeasureReportStatusCode {
    pub fn new() -> MeasureReportStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MeasureReportStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MeasureReportStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MeasureReportStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MeasureReportStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MeasureReportStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MeasureReportStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MeasureReportStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasureReportStatusCode {
        MeasureReportStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MeasureReportStatusCode_Value>>(
                    "value",
                    |m: &MeasureReportStatusCode| { &m.value },
                    |m: &mut MeasureReportStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MeasureReportStatusCode| { &m.id },
                    |m: &mut MeasureReportStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MeasureReportStatusCode| { &m.extension },
                    |m: &mut MeasureReportStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MeasureReportStatusCode>(
                    "MeasureReportStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MeasureReportStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<MeasureReportStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MeasureReportStatusCode,
        };
        unsafe {
            instance.get(MeasureReportStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for MeasureReportStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasureReportStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureReportStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MeasureReportStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    COMPLETE = 1,
    PENDING = 2,
    ERROR = 3,
}

impl ::protobuf::ProtobufEnum for MeasureReportStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MeasureReportStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MeasureReportStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MeasureReportStatusCode_Value::COMPLETE),
            2 => ::std::option::Option::Some(MeasureReportStatusCode_Value::PENDING),
            3 => ::std::option::Option::Some(MeasureReportStatusCode_Value::ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MeasureReportStatusCode_Value] = &[
            MeasureReportStatusCode_Value::INVALID_UNINITIALIZED,
            MeasureReportStatusCode_Value::COMPLETE,
            MeasureReportStatusCode_Value::PENDING,
            MeasureReportStatusCode_Value::ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MeasureReportStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MeasureReportStatusCode_Value {
}

impl ::std::default::Default for MeasureReportStatusCode_Value {
    fn default() -> Self {
        MeasureReportStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureReportStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MeasureReportTypeCode {
    // message fields
    pub value: MeasureReportTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MeasureReportTypeCode {
    pub fn new() -> MeasureReportTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MeasureReportTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MeasureReportTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MeasureReportTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MeasureReportTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MeasureReportTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MeasureReportTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MeasureReportTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasureReportTypeCode {
        MeasureReportTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MeasureReportTypeCode_Value>>(
                    "value",
                    |m: &MeasureReportTypeCode| { &m.value },
                    |m: &mut MeasureReportTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MeasureReportTypeCode| { &m.id },
                    |m: &mut MeasureReportTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MeasureReportTypeCode| { &m.extension },
                    |m: &mut MeasureReportTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MeasureReportTypeCode>(
                    "MeasureReportTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MeasureReportTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<MeasureReportTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MeasureReportTypeCode,
        };
        unsafe {
            instance.get(MeasureReportTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for MeasureReportTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasureReportTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureReportTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MeasureReportTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    INDIVIDUAL = 1,
    PATIENT_LIST = 2,
    SUMMARY = 3,
}

impl ::protobuf::ProtobufEnum for MeasureReportTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MeasureReportTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MeasureReportTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MeasureReportTypeCode_Value::INDIVIDUAL),
            2 => ::std::option::Option::Some(MeasureReportTypeCode_Value::PATIENT_LIST),
            3 => ::std::option::Option::Some(MeasureReportTypeCode_Value::SUMMARY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MeasureReportTypeCode_Value] = &[
            MeasureReportTypeCode_Value::INVALID_UNINITIALIZED,
            MeasureReportTypeCode_Value::INDIVIDUAL,
            MeasureReportTypeCode_Value::PATIENT_LIST,
            MeasureReportTypeCode_Value::SUMMARY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MeasureReportTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MeasureReportTypeCode_Value {
}

impl ::std::default::Default for MeasureReportTypeCode_Value {
    fn default() -> Self {
        MeasureReportTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureReportTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MeasureScoringCode {
    // message fields
    pub value: MeasureScoringCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MeasureScoringCode {
    pub fn new() -> MeasureScoringCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MeasureScoringCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MeasureScoringCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MeasureScoringCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MeasureScoringCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MeasureScoringCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MeasureScoringCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MeasureScoringCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasureScoringCode {
        MeasureScoringCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MeasureScoringCode_Value>>(
                    "value",
                    |m: &MeasureScoringCode| { &m.value },
                    |m: &mut MeasureScoringCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MeasureScoringCode| { &m.id },
                    |m: &mut MeasureScoringCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MeasureScoringCode| { &m.extension },
                    |m: &mut MeasureScoringCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MeasureScoringCode>(
                    "MeasureScoringCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MeasureScoringCode {
        static mut instance: ::protobuf::lazy::Lazy<MeasureScoringCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MeasureScoringCode,
        };
        unsafe {
            instance.get(MeasureScoringCode::new)
        }
    }
}

impl ::protobuf::Clear for MeasureScoringCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasureScoringCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureScoringCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MeasureScoringCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROPORTION = 1,
    RATIO = 2,
    CONTINUOUS_VARIABLE = 3,
    COHORT = 4,
}

impl ::protobuf::ProtobufEnum for MeasureScoringCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MeasureScoringCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MeasureScoringCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MeasureScoringCode_Value::PROPORTION),
            2 => ::std::option::Option::Some(MeasureScoringCode_Value::RATIO),
            3 => ::std::option::Option::Some(MeasureScoringCode_Value::CONTINUOUS_VARIABLE),
            4 => ::std::option::Option::Some(MeasureScoringCode_Value::COHORT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MeasureScoringCode_Value] = &[
            MeasureScoringCode_Value::INVALID_UNINITIALIZED,
            MeasureScoringCode_Value::PROPORTION,
            MeasureScoringCode_Value::RATIO,
            MeasureScoringCode_Value::CONTINUOUS_VARIABLE,
            MeasureScoringCode_Value::COHORT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MeasureScoringCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MeasureScoringCode_Value {
}

impl ::std::default::Default for MeasureScoringCode_Value {
    fn default() -> Self {
        MeasureScoringCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureScoringCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MeasureTypeCode {
    // message fields
    pub value: MeasureTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MeasureTypeCode {
    pub fn new() -> MeasureTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MeasureTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MeasureTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MeasureTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MeasureTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MeasureTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MeasureTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MeasureTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MeasureTypeCode {
        MeasureTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MeasureTypeCode_Value>>(
                    "value",
                    |m: &MeasureTypeCode| { &m.value },
                    |m: &mut MeasureTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MeasureTypeCode| { &m.id },
                    |m: &mut MeasureTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MeasureTypeCode| { &m.extension },
                    |m: &mut MeasureTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MeasureTypeCode>(
                    "MeasureTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MeasureTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<MeasureTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MeasureTypeCode,
        };
        unsafe {
            instance.get(MeasureTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for MeasureTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MeasureTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MeasureTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROCESS = 1,
    OUTCOME = 2,
    STRUCTURE = 3,
    PATIENT_REPORTED_OUTCOME = 4,
    COMPOSITE = 5,
}

impl ::protobuf::ProtobufEnum for MeasureTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MeasureTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MeasureTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MeasureTypeCode_Value::PROCESS),
            2 => ::std::option::Option::Some(MeasureTypeCode_Value::OUTCOME),
            3 => ::std::option::Option::Some(MeasureTypeCode_Value::STRUCTURE),
            4 => ::std::option::Option::Some(MeasureTypeCode_Value::PATIENT_REPORTED_OUTCOME),
            5 => ::std::option::Option::Some(MeasureTypeCode_Value::COMPOSITE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MeasureTypeCode_Value] = &[
            MeasureTypeCode_Value::INVALID_UNINITIALIZED,
            MeasureTypeCode_Value::PROCESS,
            MeasureTypeCode_Value::OUTCOME,
            MeasureTypeCode_Value::STRUCTURE,
            MeasureTypeCode_Value::PATIENT_REPORTED_OUTCOME,
            MeasureTypeCode_Value::COMPOSITE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MeasureTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MeasureTypeCode_Value {
}

impl ::std::default::Default for MeasureTypeCode_Value {
    fn default() -> Self {
        MeasureTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MeasureTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationAdministrationCategoryCode {
    // message fields
    pub value: MedicationAdministrationCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationAdministrationCategoryCode {
    pub fn new() -> MedicationAdministrationCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationAdministrationCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationAdministrationCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationAdministrationCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationAdministrationCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationAdministrationCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationAdministrationCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationAdministrationCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationAdministrationCategoryCode {
        MedicationAdministrationCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationAdministrationCategoryCode_Value>>(
                    "value",
                    |m: &MedicationAdministrationCategoryCode| { &m.value },
                    |m: &mut MedicationAdministrationCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationAdministrationCategoryCode| { &m.id },
                    |m: &mut MedicationAdministrationCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationAdministrationCategoryCode| { &m.extension },
                    |m: &mut MedicationAdministrationCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationAdministrationCategoryCode>(
                    "MedicationAdministrationCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationAdministrationCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationAdministrationCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationAdministrationCategoryCode,
        };
        unsafe {
            instance.get(MedicationAdministrationCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationAdministrationCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationAdministrationCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationAdministrationCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationAdministrationCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    INPATIENT = 1,
    OUTPATIENT = 2,
    COMMUNITY = 3,
}

impl ::protobuf::ProtobufEnum for MedicationAdministrationCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationAdministrationCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationAdministrationCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationAdministrationCategoryCode_Value::INPATIENT),
            2 => ::std::option::Option::Some(MedicationAdministrationCategoryCode_Value::OUTPATIENT),
            3 => ::std::option::Option::Some(MedicationAdministrationCategoryCode_Value::COMMUNITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationAdministrationCategoryCode_Value] = &[
            MedicationAdministrationCategoryCode_Value::INVALID_UNINITIALIZED,
            MedicationAdministrationCategoryCode_Value::INPATIENT,
            MedicationAdministrationCategoryCode_Value::OUTPATIENT,
            MedicationAdministrationCategoryCode_Value::COMMUNITY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationAdministrationCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationAdministrationCategoryCode_Value {
}

impl ::std::default::Default for MedicationAdministrationCategoryCode_Value {
    fn default() -> Self {
        MedicationAdministrationCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationAdministrationCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationAdministrationStatusCode {
    // message fields
    pub value: MedicationAdministrationStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationAdministrationStatusCode {
    pub fn new() -> MedicationAdministrationStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationAdministrationStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationAdministrationStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationAdministrationStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationAdministrationStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationAdministrationStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationAdministrationStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationAdministrationStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationAdministrationStatusCode {
        MedicationAdministrationStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationAdministrationStatusCode_Value>>(
                    "value",
                    |m: &MedicationAdministrationStatusCode| { &m.value },
                    |m: &mut MedicationAdministrationStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationAdministrationStatusCode| { &m.id },
                    |m: &mut MedicationAdministrationStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationAdministrationStatusCode| { &m.extension },
                    |m: &mut MedicationAdministrationStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationAdministrationStatusCode>(
                    "MedicationAdministrationStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationAdministrationStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationAdministrationStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationAdministrationStatusCode,
        };
        unsafe {
            instance.get(MedicationAdministrationStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationAdministrationStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationAdministrationStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationAdministrationStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationAdministrationStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    IN_PROGRESS = 1,
    ON_HOLD = 2,
    COMPLETED = 3,
    ENTERED_IN_ERROR = 4,
    STOPPED = 5,
    UNKNOWN = 6,
}

impl ::protobuf::ProtobufEnum for MedicationAdministrationStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationAdministrationStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationAdministrationStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationAdministrationStatusCode_Value::IN_PROGRESS),
            2 => ::std::option::Option::Some(MedicationAdministrationStatusCode_Value::ON_HOLD),
            3 => ::std::option::Option::Some(MedicationAdministrationStatusCode_Value::COMPLETED),
            4 => ::std::option::Option::Some(MedicationAdministrationStatusCode_Value::ENTERED_IN_ERROR),
            5 => ::std::option::Option::Some(MedicationAdministrationStatusCode_Value::STOPPED),
            6 => ::std::option::Option::Some(MedicationAdministrationStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationAdministrationStatusCode_Value] = &[
            MedicationAdministrationStatusCode_Value::INVALID_UNINITIALIZED,
            MedicationAdministrationStatusCode_Value::IN_PROGRESS,
            MedicationAdministrationStatusCode_Value::ON_HOLD,
            MedicationAdministrationStatusCode_Value::COMPLETED,
            MedicationAdministrationStatusCode_Value::ENTERED_IN_ERROR,
            MedicationAdministrationStatusCode_Value::STOPPED,
            MedicationAdministrationStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationAdministrationStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationAdministrationStatusCode_Value {
}

impl ::std::default::Default for MedicationAdministrationStatusCode_Value {
    fn default() -> Self {
        MedicationAdministrationStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationAdministrationStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationDispenseCategoryCode {
    // message fields
    pub value: MedicationDispenseCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationDispenseCategoryCode {
    pub fn new() -> MedicationDispenseCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationDispenseCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationDispenseCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationDispenseCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationDispenseCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationDispenseCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationDispenseCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationDispenseCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationDispenseCategoryCode {
        MedicationDispenseCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationDispenseCategoryCode_Value>>(
                    "value",
                    |m: &MedicationDispenseCategoryCode| { &m.value },
                    |m: &mut MedicationDispenseCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationDispenseCategoryCode| { &m.id },
                    |m: &mut MedicationDispenseCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationDispenseCategoryCode| { &m.extension },
                    |m: &mut MedicationDispenseCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationDispenseCategoryCode>(
                    "MedicationDispenseCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationDispenseCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationDispenseCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationDispenseCategoryCode,
        };
        unsafe {
            instance.get(MedicationDispenseCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationDispenseCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationDispenseCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationDispenseCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationDispenseCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    INPATIENT = 1,
    OUTPATIENT = 2,
    COMMUNITY = 3,
}

impl ::protobuf::ProtobufEnum for MedicationDispenseCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationDispenseCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationDispenseCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationDispenseCategoryCode_Value::INPATIENT),
            2 => ::std::option::Option::Some(MedicationDispenseCategoryCode_Value::OUTPATIENT),
            3 => ::std::option::Option::Some(MedicationDispenseCategoryCode_Value::COMMUNITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationDispenseCategoryCode_Value] = &[
            MedicationDispenseCategoryCode_Value::INVALID_UNINITIALIZED,
            MedicationDispenseCategoryCode_Value::INPATIENT,
            MedicationDispenseCategoryCode_Value::OUTPATIENT,
            MedicationDispenseCategoryCode_Value::COMMUNITY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationDispenseCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationDispenseCategoryCode_Value {
}

impl ::std::default::Default for MedicationDispenseCategoryCode_Value {
    fn default() -> Self {
        MedicationDispenseCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationDispenseCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationDispenseStatusCode {
    // message fields
    pub value: MedicationDispenseStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationDispenseStatusCode {
    pub fn new() -> MedicationDispenseStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationDispenseStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationDispenseStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationDispenseStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationDispenseStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationDispenseStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationDispenseStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationDispenseStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationDispenseStatusCode {
        MedicationDispenseStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationDispenseStatusCode_Value>>(
                    "value",
                    |m: &MedicationDispenseStatusCode| { &m.value },
                    |m: &mut MedicationDispenseStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationDispenseStatusCode| { &m.id },
                    |m: &mut MedicationDispenseStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationDispenseStatusCode| { &m.extension },
                    |m: &mut MedicationDispenseStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationDispenseStatusCode>(
                    "MedicationDispenseStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationDispenseStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationDispenseStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationDispenseStatusCode,
        };
        unsafe {
            instance.get(MedicationDispenseStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationDispenseStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationDispenseStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationDispenseStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationDispenseStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PREPARATION = 1,
    IN_PROGRESS = 2,
    ON_HOLD = 3,
    COMPLETED = 4,
    ENTERED_IN_ERROR = 5,
    STOPPED = 6,
}

impl ::protobuf::ProtobufEnum for MedicationDispenseStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationDispenseStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationDispenseStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationDispenseStatusCode_Value::PREPARATION),
            2 => ::std::option::Option::Some(MedicationDispenseStatusCode_Value::IN_PROGRESS),
            3 => ::std::option::Option::Some(MedicationDispenseStatusCode_Value::ON_HOLD),
            4 => ::std::option::Option::Some(MedicationDispenseStatusCode_Value::COMPLETED),
            5 => ::std::option::Option::Some(MedicationDispenseStatusCode_Value::ENTERED_IN_ERROR),
            6 => ::std::option::Option::Some(MedicationDispenseStatusCode_Value::STOPPED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationDispenseStatusCode_Value] = &[
            MedicationDispenseStatusCode_Value::INVALID_UNINITIALIZED,
            MedicationDispenseStatusCode_Value::PREPARATION,
            MedicationDispenseStatusCode_Value::IN_PROGRESS,
            MedicationDispenseStatusCode_Value::ON_HOLD,
            MedicationDispenseStatusCode_Value::COMPLETED,
            MedicationDispenseStatusCode_Value::ENTERED_IN_ERROR,
            MedicationDispenseStatusCode_Value::STOPPED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationDispenseStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationDispenseStatusCode_Value {
}

impl ::std::default::Default for MedicationDispenseStatusCode_Value {
    fn default() -> Self {
        MedicationDispenseStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationDispenseStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationContainerCode {
    // message fields
    pub value: MedicationContainerCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationContainerCode {
    pub fn new() -> MedicationContainerCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationContainerCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationContainerCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationContainerCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationContainerCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationContainerCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationContainerCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationContainerCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationContainerCode {
        MedicationContainerCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationContainerCode_Value>>(
                    "value",
                    |m: &MedicationContainerCode| { &m.value },
                    |m: &mut MedicationContainerCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationContainerCode| { &m.id },
                    |m: &mut MedicationContainerCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationContainerCode| { &m.extension },
                    |m: &mut MedicationContainerCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationContainerCode>(
                    "MedicationContainerCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationContainerCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationContainerCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationContainerCode,
        };
        unsafe {
            instance.get(MedicationContainerCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationContainerCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationContainerCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationContainerCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationContainerCode_Value {
    INVALID_UNINITIALIZED = 0,
    AMPOULE = 1,
    BOTTLE = 2,
    BOX = 3,
    CARTRIDGE = 4,
    CONTAINER = 5,
    TUBE = 6,
    UNITDOSE = 7,
    VIAL = 8,
}

impl ::protobuf::ProtobufEnum for MedicationContainerCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationContainerCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationContainerCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationContainerCode_Value::AMPOULE),
            2 => ::std::option::Option::Some(MedicationContainerCode_Value::BOTTLE),
            3 => ::std::option::Option::Some(MedicationContainerCode_Value::BOX),
            4 => ::std::option::Option::Some(MedicationContainerCode_Value::CARTRIDGE),
            5 => ::std::option::Option::Some(MedicationContainerCode_Value::CONTAINER),
            6 => ::std::option::Option::Some(MedicationContainerCode_Value::TUBE),
            7 => ::std::option::Option::Some(MedicationContainerCode_Value::UNITDOSE),
            8 => ::std::option::Option::Some(MedicationContainerCode_Value::VIAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationContainerCode_Value] = &[
            MedicationContainerCode_Value::INVALID_UNINITIALIZED,
            MedicationContainerCode_Value::AMPOULE,
            MedicationContainerCode_Value::BOTTLE,
            MedicationContainerCode_Value::BOX,
            MedicationContainerCode_Value::CARTRIDGE,
            MedicationContainerCode_Value::CONTAINER,
            MedicationContainerCode_Value::TUBE,
            MedicationContainerCode_Value::UNITDOSE,
            MedicationContainerCode_Value::VIAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationContainerCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationContainerCode_Value {
}

impl ::std::default::Default for MedicationContainerCode_Value {
    fn default() -> Self {
        MedicationContainerCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationContainerCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationRequestCategoryCode {
    // message fields
    pub value: MedicationRequestCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationRequestCategoryCode {
    pub fn new() -> MedicationRequestCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationRequestCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationRequestCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationRequestCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationRequestCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationRequestCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationRequestCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationRequestCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationRequestCategoryCode {
        MedicationRequestCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationRequestCategoryCode_Value>>(
                    "value",
                    |m: &MedicationRequestCategoryCode| { &m.value },
                    |m: &mut MedicationRequestCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationRequestCategoryCode| { &m.id },
                    |m: &mut MedicationRequestCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationRequestCategoryCode| { &m.extension },
                    |m: &mut MedicationRequestCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationRequestCategoryCode>(
                    "MedicationRequestCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationRequestCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationRequestCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationRequestCategoryCode,
        };
        unsafe {
            instance.get(MedicationRequestCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationRequestCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationRequestCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationRequestCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationRequestCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    INPATIENT = 1,
    OUTPATIENT = 2,
    COMMUNITY = 3,
}

impl ::protobuf::ProtobufEnum for MedicationRequestCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationRequestCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationRequestCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationRequestCategoryCode_Value::INPATIENT),
            2 => ::std::option::Option::Some(MedicationRequestCategoryCode_Value::OUTPATIENT),
            3 => ::std::option::Option::Some(MedicationRequestCategoryCode_Value::COMMUNITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationRequestCategoryCode_Value] = &[
            MedicationRequestCategoryCode_Value::INVALID_UNINITIALIZED,
            MedicationRequestCategoryCode_Value::INPATIENT,
            MedicationRequestCategoryCode_Value::OUTPATIENT,
            MedicationRequestCategoryCode_Value::COMMUNITY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationRequestCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationRequestCategoryCode_Value {
}

impl ::std::default::Default for MedicationRequestCategoryCode_Value {
    fn default() -> Self {
        MedicationRequestCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationRequestCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationRequestIntentCode {
    // message fields
    pub value: MedicationRequestIntentCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationRequestIntentCode {
    pub fn new() -> MedicationRequestIntentCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationRequestIntentCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationRequestIntentCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationRequestIntentCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationRequestIntentCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationRequestIntentCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationRequestIntentCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationRequestIntentCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationRequestIntentCode {
        MedicationRequestIntentCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationRequestIntentCode_Value>>(
                    "value",
                    |m: &MedicationRequestIntentCode| { &m.value },
                    |m: &mut MedicationRequestIntentCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationRequestIntentCode| { &m.id },
                    |m: &mut MedicationRequestIntentCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationRequestIntentCode| { &m.extension },
                    |m: &mut MedicationRequestIntentCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationRequestIntentCode>(
                    "MedicationRequestIntentCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationRequestIntentCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationRequestIntentCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationRequestIntentCode,
        };
        unsafe {
            instance.get(MedicationRequestIntentCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationRequestIntentCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationRequestIntentCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationRequestIntentCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationRequestIntentCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROPOSAL = 1,
    PLAN = 2,
    ORDER = 3,
    INSTANCE_ORDER = 4,
}

impl ::protobuf::ProtobufEnum for MedicationRequestIntentCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationRequestIntentCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationRequestIntentCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationRequestIntentCode_Value::PROPOSAL),
            2 => ::std::option::Option::Some(MedicationRequestIntentCode_Value::PLAN),
            3 => ::std::option::Option::Some(MedicationRequestIntentCode_Value::ORDER),
            4 => ::std::option::Option::Some(MedicationRequestIntentCode_Value::INSTANCE_ORDER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationRequestIntentCode_Value] = &[
            MedicationRequestIntentCode_Value::INVALID_UNINITIALIZED,
            MedicationRequestIntentCode_Value::PROPOSAL,
            MedicationRequestIntentCode_Value::PLAN,
            MedicationRequestIntentCode_Value::ORDER,
            MedicationRequestIntentCode_Value::INSTANCE_ORDER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationRequestIntentCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationRequestIntentCode_Value {
}

impl ::std::default::Default for MedicationRequestIntentCode_Value {
    fn default() -> Self {
        MedicationRequestIntentCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationRequestIntentCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationRequestPriorityCode {
    // message fields
    pub value: MedicationRequestPriorityCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationRequestPriorityCode {
    pub fn new() -> MedicationRequestPriorityCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationRequestPriorityCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationRequestPriorityCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationRequestPriorityCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationRequestPriorityCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationRequestPriorityCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationRequestPriorityCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationRequestPriorityCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationRequestPriorityCode {
        MedicationRequestPriorityCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationRequestPriorityCode_Value>>(
                    "value",
                    |m: &MedicationRequestPriorityCode| { &m.value },
                    |m: &mut MedicationRequestPriorityCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationRequestPriorityCode| { &m.id },
                    |m: &mut MedicationRequestPriorityCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationRequestPriorityCode| { &m.extension },
                    |m: &mut MedicationRequestPriorityCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationRequestPriorityCode>(
                    "MedicationRequestPriorityCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationRequestPriorityCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationRequestPriorityCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationRequestPriorityCode,
        };
        unsafe {
            instance.get(MedicationRequestPriorityCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationRequestPriorityCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationRequestPriorityCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationRequestPriorityCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationRequestPriorityCode_Value {
    INVALID_UNINITIALIZED = 0,
    ROUTINE = 1,
    URGENT = 2,
    STAT = 3,
    ASAP = 4,
}

impl ::protobuf::ProtobufEnum for MedicationRequestPriorityCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationRequestPriorityCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationRequestPriorityCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationRequestPriorityCode_Value::ROUTINE),
            2 => ::std::option::Option::Some(MedicationRequestPriorityCode_Value::URGENT),
            3 => ::std::option::Option::Some(MedicationRequestPriorityCode_Value::STAT),
            4 => ::std::option::Option::Some(MedicationRequestPriorityCode_Value::ASAP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationRequestPriorityCode_Value] = &[
            MedicationRequestPriorityCode_Value::INVALID_UNINITIALIZED,
            MedicationRequestPriorityCode_Value::ROUTINE,
            MedicationRequestPriorityCode_Value::URGENT,
            MedicationRequestPriorityCode_Value::STAT,
            MedicationRequestPriorityCode_Value::ASAP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationRequestPriorityCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationRequestPriorityCode_Value {
}

impl ::std::default::Default for MedicationRequestPriorityCode_Value {
    fn default() -> Self {
        MedicationRequestPriorityCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationRequestPriorityCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationRequestStatusCode {
    // message fields
    pub value: MedicationRequestStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationRequestStatusCode {
    pub fn new() -> MedicationRequestStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationRequestStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationRequestStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationRequestStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationRequestStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationRequestStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationRequestStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationRequestStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationRequestStatusCode {
        MedicationRequestStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationRequestStatusCode_Value>>(
                    "value",
                    |m: &MedicationRequestStatusCode| { &m.value },
                    |m: &mut MedicationRequestStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationRequestStatusCode| { &m.id },
                    |m: &mut MedicationRequestStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationRequestStatusCode| { &m.extension },
                    |m: &mut MedicationRequestStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationRequestStatusCode>(
                    "MedicationRequestStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationRequestStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationRequestStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationRequestStatusCode,
        };
        unsafe {
            instance.get(MedicationRequestStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationRequestStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationRequestStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationRequestStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationRequestStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    ON_HOLD = 2,
    CANCELLED = 3,
    COMPLETED = 4,
    ENTERED_IN_ERROR = 5,
    STOPPED = 6,
    DRAFT = 7,
    UNKNOWN = 8,
}

impl ::protobuf::ProtobufEnum for MedicationRequestStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationRequestStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationRequestStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationRequestStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(MedicationRequestStatusCode_Value::ON_HOLD),
            3 => ::std::option::Option::Some(MedicationRequestStatusCode_Value::CANCELLED),
            4 => ::std::option::Option::Some(MedicationRequestStatusCode_Value::COMPLETED),
            5 => ::std::option::Option::Some(MedicationRequestStatusCode_Value::ENTERED_IN_ERROR),
            6 => ::std::option::Option::Some(MedicationRequestStatusCode_Value::STOPPED),
            7 => ::std::option::Option::Some(MedicationRequestStatusCode_Value::DRAFT),
            8 => ::std::option::Option::Some(MedicationRequestStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationRequestStatusCode_Value] = &[
            MedicationRequestStatusCode_Value::INVALID_UNINITIALIZED,
            MedicationRequestStatusCode_Value::ACTIVE,
            MedicationRequestStatusCode_Value::ON_HOLD,
            MedicationRequestStatusCode_Value::CANCELLED,
            MedicationRequestStatusCode_Value::COMPLETED,
            MedicationRequestStatusCode_Value::ENTERED_IN_ERROR,
            MedicationRequestStatusCode_Value::STOPPED,
            MedicationRequestStatusCode_Value::DRAFT,
            MedicationRequestStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationRequestStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationRequestStatusCode_Value {
}

impl ::std::default::Default for MedicationRequestStatusCode_Value {
    fn default() -> Self {
        MedicationRequestStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationRequestStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationStatementCategoryCode {
    // message fields
    pub value: MedicationStatementCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationStatementCategoryCode {
    pub fn new() -> MedicationStatementCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationStatementCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationStatementCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationStatementCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationStatementCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationStatementCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationStatementCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationStatementCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationStatementCategoryCode {
        MedicationStatementCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationStatementCategoryCode_Value>>(
                    "value",
                    |m: &MedicationStatementCategoryCode| { &m.value },
                    |m: &mut MedicationStatementCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationStatementCategoryCode| { &m.id },
                    |m: &mut MedicationStatementCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationStatementCategoryCode| { &m.extension },
                    |m: &mut MedicationStatementCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationStatementCategoryCode>(
                    "MedicationStatementCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationStatementCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationStatementCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationStatementCategoryCode,
        };
        unsafe {
            instance.get(MedicationStatementCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationStatementCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationStatementCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationStatementCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationStatementCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    INPATIENT = 1,
    OUTPATIENT = 2,
    COMMUNITY = 3,
    PATIENTSPECIFIED = 4,
}

impl ::protobuf::ProtobufEnum for MedicationStatementCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationStatementCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationStatementCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationStatementCategoryCode_Value::INPATIENT),
            2 => ::std::option::Option::Some(MedicationStatementCategoryCode_Value::OUTPATIENT),
            3 => ::std::option::Option::Some(MedicationStatementCategoryCode_Value::COMMUNITY),
            4 => ::std::option::Option::Some(MedicationStatementCategoryCode_Value::PATIENTSPECIFIED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationStatementCategoryCode_Value] = &[
            MedicationStatementCategoryCode_Value::INVALID_UNINITIALIZED,
            MedicationStatementCategoryCode_Value::INPATIENT,
            MedicationStatementCategoryCode_Value::OUTPATIENT,
            MedicationStatementCategoryCode_Value::COMMUNITY,
            MedicationStatementCategoryCode_Value::PATIENTSPECIFIED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationStatementCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationStatementCategoryCode_Value {
}

impl ::std::default::Default for MedicationStatementCategoryCode_Value {
    fn default() -> Self {
        MedicationStatementCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationStatementCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationStatementStatusCode {
    // message fields
    pub value: MedicationStatementStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationStatementStatusCode {
    pub fn new() -> MedicationStatementStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationStatementStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationStatementStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationStatementStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationStatementStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationStatementStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationStatementStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationStatementStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationStatementStatusCode {
        MedicationStatementStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationStatementStatusCode_Value>>(
                    "value",
                    |m: &MedicationStatementStatusCode| { &m.value },
                    |m: &mut MedicationStatementStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationStatementStatusCode| { &m.id },
                    |m: &mut MedicationStatementStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationStatementStatusCode| { &m.extension },
                    |m: &mut MedicationStatementStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationStatementStatusCode>(
                    "MedicationStatementStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationStatementStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationStatementStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationStatementStatusCode,
        };
        unsafe {
            instance.get(MedicationStatementStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationStatementStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationStatementStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationStatementStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationStatementStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    COMPLETED = 2,
    ENTERED_IN_ERROR = 3,
    INTENDED = 4,
    STOPPED = 5,
    ON_HOLD = 6,
}

impl ::protobuf::ProtobufEnum for MedicationStatementStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationStatementStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationStatementStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationStatementStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(MedicationStatementStatusCode_Value::COMPLETED),
            3 => ::std::option::Option::Some(MedicationStatementStatusCode_Value::ENTERED_IN_ERROR),
            4 => ::std::option::Option::Some(MedicationStatementStatusCode_Value::INTENDED),
            5 => ::std::option::Option::Some(MedicationStatementStatusCode_Value::STOPPED),
            6 => ::std::option::Option::Some(MedicationStatementStatusCode_Value::ON_HOLD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationStatementStatusCode_Value] = &[
            MedicationStatementStatusCode_Value::INVALID_UNINITIALIZED,
            MedicationStatementStatusCode_Value::ACTIVE,
            MedicationStatementStatusCode_Value::COMPLETED,
            MedicationStatementStatusCode_Value::ENTERED_IN_ERROR,
            MedicationStatementStatusCode_Value::INTENDED,
            MedicationStatementStatusCode_Value::STOPPED,
            MedicationStatementStatusCode_Value::ON_HOLD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationStatementStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationStatementStatusCode_Value {
}

impl ::std::default::Default for MedicationStatementStatusCode_Value {
    fn default() -> Self {
        MedicationStatementStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationStatementStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationStatementTakenCode {
    // message fields
    pub value: MedicationStatementTakenCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationStatementTakenCode {
    pub fn new() -> MedicationStatementTakenCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationStatementTakenCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationStatementTakenCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationStatementTakenCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationStatementTakenCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationStatementTakenCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationStatementTakenCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationStatementTakenCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationStatementTakenCode {
        MedicationStatementTakenCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationStatementTakenCode_Value>>(
                    "value",
                    |m: &MedicationStatementTakenCode| { &m.value },
                    |m: &mut MedicationStatementTakenCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationStatementTakenCode| { &m.id },
                    |m: &mut MedicationStatementTakenCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationStatementTakenCode| { &m.extension },
                    |m: &mut MedicationStatementTakenCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationStatementTakenCode>(
                    "MedicationStatementTakenCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationStatementTakenCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationStatementTakenCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationStatementTakenCode,
        };
        unsafe {
            instance.get(MedicationStatementTakenCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationStatementTakenCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationStatementTakenCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationStatementTakenCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationStatementTakenCode_Value {
    INVALID_UNINITIALIZED = 0,
    Y = 1,
    N = 2,
    UNK = 3,
    NA = 4,
}

impl ::protobuf::ProtobufEnum for MedicationStatementTakenCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationStatementTakenCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationStatementTakenCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationStatementTakenCode_Value::Y),
            2 => ::std::option::Option::Some(MedicationStatementTakenCode_Value::N),
            3 => ::std::option::Option::Some(MedicationStatementTakenCode_Value::UNK),
            4 => ::std::option::Option::Some(MedicationStatementTakenCode_Value::NA),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationStatementTakenCode_Value] = &[
            MedicationStatementTakenCode_Value::INVALID_UNINITIALIZED,
            MedicationStatementTakenCode_Value::Y,
            MedicationStatementTakenCode_Value::N,
            MedicationStatementTakenCode_Value::UNK,
            MedicationStatementTakenCode_Value::NA,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationStatementTakenCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationStatementTakenCode_Value {
}

impl ::std::default::Default for MedicationStatementTakenCode_Value {
    fn default() -> Self {
        MedicationStatementTakenCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationStatementTakenCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MedicationStatusCode {
    // message fields
    pub value: MedicationStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MedicationStatusCode {
    pub fn new() -> MedicationStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MedicationStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MedicationStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MedicationStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MedicationStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MedicationStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MedicationStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MedicationStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MedicationStatusCode {
        MedicationStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MedicationStatusCode_Value>>(
                    "value",
                    |m: &MedicationStatusCode| { &m.value },
                    |m: &mut MedicationStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MedicationStatusCode| { &m.id },
                    |m: &mut MedicationStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MedicationStatusCode| { &m.extension },
                    |m: &mut MedicationStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MedicationStatusCode>(
                    "MedicationStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MedicationStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<MedicationStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MedicationStatusCode,
        };
        unsafe {
            instance.get(MedicationStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for MedicationStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MedicationStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MedicationStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    INACTIVE = 2,
    ENTERED_IN_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for MedicationStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MedicationStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MedicationStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MedicationStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(MedicationStatusCode_Value::INACTIVE),
            3 => ::std::option::Option::Some(MedicationStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MedicationStatusCode_Value] = &[
            MedicationStatusCode_Value::INVALID_UNINITIALIZED,
            MedicationStatusCode_Value::ACTIVE,
            MedicationStatusCode_Value::INACTIVE,
            MedicationStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MedicationStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MedicationStatusCode_Value {
}

impl ::std::default::Default for MedicationStatusCode_Value {
    fn default() -> Self {
        MedicationStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MedicationStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageEventCode {
    // message fields
    pub value: MessageEventCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MessageEventCode {
    pub fn new() -> MessageEventCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MessageEventCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MessageEventCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MessageEventCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MessageEventCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MessageEventCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MessageEventCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MessageEventCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageEventCode {
        MessageEventCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MessageEventCode_Value>>(
                    "value",
                    |m: &MessageEventCode| { &m.value },
                    |m: &mut MessageEventCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MessageEventCode| { &m.id },
                    |m: &mut MessageEventCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MessageEventCode| { &m.extension },
                    |m: &mut MessageEventCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageEventCode>(
                    "MessageEventCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageEventCode {
        static mut instance: ::protobuf::lazy::Lazy<MessageEventCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageEventCode,
        };
        unsafe {
            instance.get(MessageEventCode::new)
        }
    }
}

impl ::protobuf::Clear for MessageEventCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageEventCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageEventCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MessageEventCode_Value {
    INVALID_UNINITIALIZED = 0,
    CODE_SYSTEM_EXPAND = 1,
    MEDICATION_ADMINISTRATION_COMPLETE = 2,
    MEDICATION_ADMINISTRATION_NULLIFICATION = 3,
    MEDICATION_ADMINISTRATION_RECORDING = 4,
    MEDICATION_ADMINISTRATION_UPDATE = 5,
    ADMIN_NOTIFY = 6,
    COMMUNICATION_REQUEST = 7,
    DIAGNOSTICREPORT_PROVIDE = 8,
    OBSERVATION_PROVIDE = 9,
    PATIENT_LINK = 10,
    PATIENT_UNLINK = 11,
    VALUESET_EXPAND = 12,
}

impl ::protobuf::ProtobufEnum for MessageEventCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageEventCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MessageEventCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MessageEventCode_Value::CODE_SYSTEM_EXPAND),
            2 => ::std::option::Option::Some(MessageEventCode_Value::MEDICATION_ADMINISTRATION_COMPLETE),
            3 => ::std::option::Option::Some(MessageEventCode_Value::MEDICATION_ADMINISTRATION_NULLIFICATION),
            4 => ::std::option::Option::Some(MessageEventCode_Value::MEDICATION_ADMINISTRATION_RECORDING),
            5 => ::std::option::Option::Some(MessageEventCode_Value::MEDICATION_ADMINISTRATION_UPDATE),
            6 => ::std::option::Option::Some(MessageEventCode_Value::ADMIN_NOTIFY),
            7 => ::std::option::Option::Some(MessageEventCode_Value::COMMUNICATION_REQUEST),
            8 => ::std::option::Option::Some(MessageEventCode_Value::DIAGNOSTICREPORT_PROVIDE),
            9 => ::std::option::Option::Some(MessageEventCode_Value::OBSERVATION_PROVIDE),
            10 => ::std::option::Option::Some(MessageEventCode_Value::PATIENT_LINK),
            11 => ::std::option::Option::Some(MessageEventCode_Value::PATIENT_UNLINK),
            12 => ::std::option::Option::Some(MessageEventCode_Value::VALUESET_EXPAND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MessageEventCode_Value] = &[
            MessageEventCode_Value::INVALID_UNINITIALIZED,
            MessageEventCode_Value::CODE_SYSTEM_EXPAND,
            MessageEventCode_Value::MEDICATION_ADMINISTRATION_COMPLETE,
            MessageEventCode_Value::MEDICATION_ADMINISTRATION_NULLIFICATION,
            MessageEventCode_Value::MEDICATION_ADMINISTRATION_RECORDING,
            MessageEventCode_Value::MEDICATION_ADMINISTRATION_UPDATE,
            MessageEventCode_Value::ADMIN_NOTIFY,
            MessageEventCode_Value::COMMUNICATION_REQUEST,
            MessageEventCode_Value::DIAGNOSTICREPORT_PROVIDE,
            MessageEventCode_Value::OBSERVATION_PROVIDE,
            MessageEventCode_Value::PATIENT_LINK,
            MessageEventCode_Value::PATIENT_UNLINK,
            MessageEventCode_Value::VALUESET_EXPAND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MessageEventCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MessageEventCode_Value {
}

impl ::std::default::Default for MessageEventCode_Value {
    fn default() -> Self {
        MessageEventCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageEventCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageHeaderResponseRequestCode {
    // message fields
    pub value: MessageHeaderResponseRequestCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MessageHeaderResponseRequestCode {
    pub fn new() -> MessageHeaderResponseRequestCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MessageHeaderResponseRequestCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MessageHeaderResponseRequestCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MessageHeaderResponseRequestCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MessageHeaderResponseRequestCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MessageHeaderResponseRequestCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MessageHeaderResponseRequestCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MessageHeaderResponseRequestCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageHeaderResponseRequestCode {
        MessageHeaderResponseRequestCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MessageHeaderResponseRequestCode_Value>>(
                    "value",
                    |m: &MessageHeaderResponseRequestCode| { &m.value },
                    |m: &mut MessageHeaderResponseRequestCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MessageHeaderResponseRequestCode| { &m.id },
                    |m: &mut MessageHeaderResponseRequestCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MessageHeaderResponseRequestCode| { &m.extension },
                    |m: &mut MessageHeaderResponseRequestCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageHeaderResponseRequestCode>(
                    "MessageHeaderResponseRequestCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageHeaderResponseRequestCode {
        static mut instance: ::protobuf::lazy::Lazy<MessageHeaderResponseRequestCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageHeaderResponseRequestCode,
        };
        unsafe {
            instance.get(MessageHeaderResponseRequestCode::new)
        }
    }
}

impl ::protobuf::Clear for MessageHeaderResponseRequestCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageHeaderResponseRequestCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageHeaderResponseRequestCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MessageHeaderResponseRequestCode_Value {
    INVALID_UNINITIALIZED = 0,
    ALWAYS = 1,
    ON_ERROR = 2,
    NEVER = 3,
    ON_SUCCESS = 4,
}

impl ::protobuf::ProtobufEnum for MessageHeaderResponseRequestCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageHeaderResponseRequestCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MessageHeaderResponseRequestCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MessageHeaderResponseRequestCode_Value::ALWAYS),
            2 => ::std::option::Option::Some(MessageHeaderResponseRequestCode_Value::ON_ERROR),
            3 => ::std::option::Option::Some(MessageHeaderResponseRequestCode_Value::NEVER),
            4 => ::std::option::Option::Some(MessageHeaderResponseRequestCode_Value::ON_SUCCESS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MessageHeaderResponseRequestCode_Value] = &[
            MessageHeaderResponseRequestCode_Value::INVALID_UNINITIALIZED,
            MessageHeaderResponseRequestCode_Value::ALWAYS,
            MessageHeaderResponseRequestCode_Value::ON_ERROR,
            MessageHeaderResponseRequestCode_Value::NEVER,
            MessageHeaderResponseRequestCode_Value::ON_SUCCESS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MessageHeaderResponseRequestCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MessageHeaderResponseRequestCode_Value {
}

impl ::std::default::Default for MessageHeaderResponseRequestCode_Value {
    fn default() -> Self {
        MessageHeaderResponseRequestCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageHeaderResponseRequestCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExampleMessageReasonCodesCode {
    // message fields
    pub value: ExampleMessageReasonCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ExampleMessageReasonCodesCode {
    pub fn new() -> ExampleMessageReasonCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ExampleMessageReasonCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ExampleMessageReasonCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ExampleMessageReasonCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ExampleMessageReasonCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ExampleMessageReasonCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ExampleMessageReasonCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ExampleMessageReasonCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExampleMessageReasonCodesCode {
        ExampleMessageReasonCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExampleMessageReasonCodesCode_Value>>(
                    "value",
                    |m: &ExampleMessageReasonCodesCode| { &m.value },
                    |m: &mut ExampleMessageReasonCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ExampleMessageReasonCodesCode| { &m.id },
                    |m: &mut ExampleMessageReasonCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ExampleMessageReasonCodesCode| { &m.extension },
                    |m: &mut ExampleMessageReasonCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExampleMessageReasonCodesCode>(
                    "ExampleMessageReasonCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExampleMessageReasonCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ExampleMessageReasonCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExampleMessageReasonCodesCode,
        };
        unsafe {
            instance.get(ExampleMessageReasonCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ExampleMessageReasonCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExampleMessageReasonCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExampleMessageReasonCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExampleMessageReasonCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    ADMIT = 1,
    DISCHARGE = 2,
    ABSENT = 3,
    RETURN = 4,
    MOVED = 5,
    EDIT = 6,
}

impl ::protobuf::ProtobufEnum for ExampleMessageReasonCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExampleMessageReasonCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ExampleMessageReasonCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ExampleMessageReasonCodesCode_Value::ADMIT),
            2 => ::std::option::Option::Some(ExampleMessageReasonCodesCode_Value::DISCHARGE),
            3 => ::std::option::Option::Some(ExampleMessageReasonCodesCode_Value::ABSENT),
            4 => ::std::option::Option::Some(ExampleMessageReasonCodesCode_Value::RETURN),
            5 => ::std::option::Option::Some(ExampleMessageReasonCodesCode_Value::MOVED),
            6 => ::std::option::Option::Some(ExampleMessageReasonCodesCode_Value::EDIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExampleMessageReasonCodesCode_Value] = &[
            ExampleMessageReasonCodesCode_Value::INVALID_UNINITIALIZED,
            ExampleMessageReasonCodesCode_Value::ADMIT,
            ExampleMessageReasonCodesCode_Value::DISCHARGE,
            ExampleMessageReasonCodesCode_Value::ABSENT,
            ExampleMessageReasonCodesCode_Value::RETURN,
            ExampleMessageReasonCodesCode_Value::MOVED,
            ExampleMessageReasonCodesCode_Value::EDIT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ExampleMessageReasonCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ExampleMessageReasonCodesCode_Value {
}

impl ::std::default::Default for ExampleMessageReasonCodesCode_Value {
    fn default() -> Self {
        ExampleMessageReasonCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ExampleMessageReasonCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageSignificanceCategoryCode {
    // message fields
    pub value: MessageSignificanceCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MessageSignificanceCategoryCode {
    pub fn new() -> MessageSignificanceCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MessageSignificanceCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MessageSignificanceCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MessageSignificanceCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MessageSignificanceCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MessageSignificanceCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MessageSignificanceCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MessageSignificanceCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageSignificanceCategoryCode {
        MessageSignificanceCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MessageSignificanceCategoryCode_Value>>(
                    "value",
                    |m: &MessageSignificanceCategoryCode| { &m.value },
                    |m: &mut MessageSignificanceCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MessageSignificanceCategoryCode| { &m.id },
                    |m: &mut MessageSignificanceCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MessageSignificanceCategoryCode| { &m.extension },
                    |m: &mut MessageSignificanceCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageSignificanceCategoryCode>(
                    "MessageSignificanceCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageSignificanceCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<MessageSignificanceCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageSignificanceCategoryCode,
        };
        unsafe {
            instance.get(MessageSignificanceCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for MessageSignificanceCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageSignificanceCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageSignificanceCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MessageSignificanceCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    CONSEQUENCE = 1,
    CURRENCY = 2,
    NOTIFICATION = 3,
}

impl ::protobuf::ProtobufEnum for MessageSignificanceCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageSignificanceCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MessageSignificanceCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MessageSignificanceCategoryCode_Value::CONSEQUENCE),
            2 => ::std::option::Option::Some(MessageSignificanceCategoryCode_Value::CURRENCY),
            3 => ::std::option::Option::Some(MessageSignificanceCategoryCode_Value::NOTIFICATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MessageSignificanceCategoryCode_Value] = &[
            MessageSignificanceCategoryCode_Value::INVALID_UNINITIALIZED,
            MessageSignificanceCategoryCode_Value::CONSEQUENCE,
            MessageSignificanceCategoryCode_Value::CURRENCY,
            MessageSignificanceCategoryCode_Value::NOTIFICATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MessageSignificanceCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MessageSignificanceCategoryCode_Value {
}

impl ::std::default::Default for MessageSignificanceCategoryCode_Value {
    fn default() -> Self {
        MessageSignificanceCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageSignificanceCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageTransportCode {
    // message fields
    pub value: MessageTransportCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MessageTransportCode {
    pub fn new() -> MessageTransportCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MessageTransportCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MessageTransportCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MessageTransportCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MessageTransportCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MessageTransportCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MessageTransportCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MessageTransportCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageTransportCode {
        MessageTransportCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MessageTransportCode_Value>>(
                    "value",
                    |m: &MessageTransportCode| { &m.value },
                    |m: &mut MessageTransportCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MessageTransportCode| { &m.id },
                    |m: &mut MessageTransportCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MessageTransportCode| { &m.extension },
                    |m: &mut MessageTransportCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MessageTransportCode>(
                    "MessageTransportCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MessageTransportCode {
        static mut instance: ::protobuf::lazy::Lazy<MessageTransportCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MessageTransportCode,
        };
        unsafe {
            instance.get(MessageTransportCode::new)
        }
    }
}

impl ::protobuf::Clear for MessageTransportCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageTransportCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageTransportCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MessageTransportCode_Value {
    INVALID_UNINITIALIZED = 0,
    HTTP = 1,
    FTP = 2,
    MLLP = 3,
}

impl ::protobuf::ProtobufEnum for MessageTransportCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageTransportCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MessageTransportCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MessageTransportCode_Value::HTTP),
            2 => ::std::option::Option::Some(MessageTransportCode_Value::FTP),
            3 => ::std::option::Option::Some(MessageTransportCode_Value::MLLP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MessageTransportCode_Value] = &[
            MessageTransportCode_Value::INVALID_UNINITIALIZED,
            MessageTransportCode_Value::HTTP,
            MessageTransportCode_Value::FTP,
            MessageTransportCode_Value::MLLP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MessageTransportCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MessageTransportCode_Value {
}

impl ::std::default::Default for MessageTransportCode_Value {
    fn default() -> Self {
        MessageTransportCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageTransportCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceMetricCalibrationStateCode {
    // message fields
    pub value: DeviceMetricCalibrationStateCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeviceMetricCalibrationStateCode {
    pub fn new() -> DeviceMetricCalibrationStateCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DeviceMetricCalibrationStateCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DeviceMetricCalibrationStateCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DeviceMetricCalibrationStateCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DeviceMetricCalibrationStateCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DeviceMetricCalibrationStateCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DeviceMetricCalibrationStateCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DeviceMetricCalibrationStateCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceMetricCalibrationStateCode {
        DeviceMetricCalibrationStateCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DeviceMetricCalibrationStateCode_Value>>(
                    "value",
                    |m: &DeviceMetricCalibrationStateCode| { &m.value },
                    |m: &mut DeviceMetricCalibrationStateCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DeviceMetricCalibrationStateCode| { &m.id },
                    |m: &mut DeviceMetricCalibrationStateCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DeviceMetricCalibrationStateCode| { &m.extension },
                    |m: &mut DeviceMetricCalibrationStateCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceMetricCalibrationStateCode>(
                    "DeviceMetricCalibrationStateCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceMetricCalibrationStateCode {
        static mut instance: ::protobuf::lazy::Lazy<DeviceMetricCalibrationStateCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceMetricCalibrationStateCode,
        };
        unsafe {
            instance.get(DeviceMetricCalibrationStateCode::new)
        }
    }
}

impl ::protobuf::Clear for DeviceMetricCalibrationStateCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceMetricCalibrationStateCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceMetricCalibrationStateCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeviceMetricCalibrationStateCode_Value {
    INVALID_UNINITIALIZED = 0,
    NOT_CALIBRATED = 1,
    CALIBRATION_REQUIRED = 2,
    CALIBRATED = 3,
    UNSPECIFIED = 4,
}

impl ::protobuf::ProtobufEnum for DeviceMetricCalibrationStateCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceMetricCalibrationStateCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DeviceMetricCalibrationStateCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DeviceMetricCalibrationStateCode_Value::NOT_CALIBRATED),
            2 => ::std::option::Option::Some(DeviceMetricCalibrationStateCode_Value::CALIBRATION_REQUIRED),
            3 => ::std::option::Option::Some(DeviceMetricCalibrationStateCode_Value::CALIBRATED),
            4 => ::std::option::Option::Some(DeviceMetricCalibrationStateCode_Value::UNSPECIFIED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeviceMetricCalibrationStateCode_Value] = &[
            DeviceMetricCalibrationStateCode_Value::INVALID_UNINITIALIZED,
            DeviceMetricCalibrationStateCode_Value::NOT_CALIBRATED,
            DeviceMetricCalibrationStateCode_Value::CALIBRATION_REQUIRED,
            DeviceMetricCalibrationStateCode_Value::CALIBRATED,
            DeviceMetricCalibrationStateCode_Value::UNSPECIFIED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DeviceMetricCalibrationStateCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DeviceMetricCalibrationStateCode_Value {
}

impl ::std::default::Default for DeviceMetricCalibrationStateCode_Value {
    fn default() -> Self {
        DeviceMetricCalibrationStateCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceMetricCalibrationStateCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceMetricCalibrationTypeCode {
    // message fields
    pub value: DeviceMetricCalibrationTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeviceMetricCalibrationTypeCode {
    pub fn new() -> DeviceMetricCalibrationTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DeviceMetricCalibrationTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DeviceMetricCalibrationTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DeviceMetricCalibrationTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DeviceMetricCalibrationTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DeviceMetricCalibrationTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DeviceMetricCalibrationTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DeviceMetricCalibrationTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceMetricCalibrationTypeCode {
        DeviceMetricCalibrationTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DeviceMetricCalibrationTypeCode_Value>>(
                    "value",
                    |m: &DeviceMetricCalibrationTypeCode| { &m.value },
                    |m: &mut DeviceMetricCalibrationTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DeviceMetricCalibrationTypeCode| { &m.id },
                    |m: &mut DeviceMetricCalibrationTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DeviceMetricCalibrationTypeCode| { &m.extension },
                    |m: &mut DeviceMetricCalibrationTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceMetricCalibrationTypeCode>(
                    "DeviceMetricCalibrationTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceMetricCalibrationTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<DeviceMetricCalibrationTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceMetricCalibrationTypeCode,
        };
        unsafe {
            instance.get(DeviceMetricCalibrationTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for DeviceMetricCalibrationTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceMetricCalibrationTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceMetricCalibrationTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeviceMetricCalibrationTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    UNSPECIFIED = 1,
    OFFSET = 2,
    GAIN = 3,
    TWO_POINT = 4,
}

impl ::protobuf::ProtobufEnum for DeviceMetricCalibrationTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceMetricCalibrationTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DeviceMetricCalibrationTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DeviceMetricCalibrationTypeCode_Value::UNSPECIFIED),
            2 => ::std::option::Option::Some(DeviceMetricCalibrationTypeCode_Value::OFFSET),
            3 => ::std::option::Option::Some(DeviceMetricCalibrationTypeCode_Value::GAIN),
            4 => ::std::option::Option::Some(DeviceMetricCalibrationTypeCode_Value::TWO_POINT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeviceMetricCalibrationTypeCode_Value] = &[
            DeviceMetricCalibrationTypeCode_Value::INVALID_UNINITIALIZED,
            DeviceMetricCalibrationTypeCode_Value::UNSPECIFIED,
            DeviceMetricCalibrationTypeCode_Value::OFFSET,
            DeviceMetricCalibrationTypeCode_Value::GAIN,
            DeviceMetricCalibrationTypeCode_Value::TWO_POINT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DeviceMetricCalibrationTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DeviceMetricCalibrationTypeCode_Value {
}

impl ::std::default::Default for DeviceMetricCalibrationTypeCode_Value {
    fn default() -> Self {
        DeviceMetricCalibrationTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceMetricCalibrationTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceMetricCategoryCode {
    // message fields
    pub value: DeviceMetricCategoryCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeviceMetricCategoryCode {
    pub fn new() -> DeviceMetricCategoryCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DeviceMetricCategoryCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DeviceMetricCategoryCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DeviceMetricCategoryCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DeviceMetricCategoryCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DeviceMetricCategoryCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DeviceMetricCategoryCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DeviceMetricCategoryCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceMetricCategoryCode {
        DeviceMetricCategoryCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DeviceMetricCategoryCode_Value>>(
                    "value",
                    |m: &DeviceMetricCategoryCode| { &m.value },
                    |m: &mut DeviceMetricCategoryCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DeviceMetricCategoryCode| { &m.id },
                    |m: &mut DeviceMetricCategoryCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DeviceMetricCategoryCode| { &m.extension },
                    |m: &mut DeviceMetricCategoryCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceMetricCategoryCode>(
                    "DeviceMetricCategoryCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceMetricCategoryCode {
        static mut instance: ::protobuf::lazy::Lazy<DeviceMetricCategoryCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceMetricCategoryCode,
        };
        unsafe {
            instance.get(DeviceMetricCategoryCode::new)
        }
    }
}

impl ::protobuf::Clear for DeviceMetricCategoryCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceMetricCategoryCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceMetricCategoryCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeviceMetricCategoryCode_Value {
    INVALID_UNINITIALIZED = 0,
    MEASUREMENT = 1,
    SETTING = 2,
    CALCULATION = 3,
    UNSPECIFIED = 4,
}

impl ::protobuf::ProtobufEnum for DeviceMetricCategoryCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceMetricCategoryCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DeviceMetricCategoryCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DeviceMetricCategoryCode_Value::MEASUREMENT),
            2 => ::std::option::Option::Some(DeviceMetricCategoryCode_Value::SETTING),
            3 => ::std::option::Option::Some(DeviceMetricCategoryCode_Value::CALCULATION),
            4 => ::std::option::Option::Some(DeviceMetricCategoryCode_Value::UNSPECIFIED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeviceMetricCategoryCode_Value] = &[
            DeviceMetricCategoryCode_Value::INVALID_UNINITIALIZED,
            DeviceMetricCategoryCode_Value::MEASUREMENT,
            DeviceMetricCategoryCode_Value::SETTING,
            DeviceMetricCategoryCode_Value::CALCULATION,
            DeviceMetricCategoryCode_Value::UNSPECIFIED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DeviceMetricCategoryCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DeviceMetricCategoryCode_Value {
}

impl ::std::default::Default for DeviceMetricCategoryCode_Value {
    fn default() -> Self {
        DeviceMetricCategoryCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceMetricCategoryCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceMetricColorCode {
    // message fields
    pub value: DeviceMetricColorCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeviceMetricColorCode {
    pub fn new() -> DeviceMetricColorCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DeviceMetricColorCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DeviceMetricColorCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DeviceMetricColorCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DeviceMetricColorCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DeviceMetricColorCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DeviceMetricColorCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DeviceMetricColorCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceMetricColorCode {
        DeviceMetricColorCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DeviceMetricColorCode_Value>>(
                    "value",
                    |m: &DeviceMetricColorCode| { &m.value },
                    |m: &mut DeviceMetricColorCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DeviceMetricColorCode| { &m.id },
                    |m: &mut DeviceMetricColorCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DeviceMetricColorCode| { &m.extension },
                    |m: &mut DeviceMetricColorCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceMetricColorCode>(
                    "DeviceMetricColorCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceMetricColorCode {
        static mut instance: ::protobuf::lazy::Lazy<DeviceMetricColorCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceMetricColorCode,
        };
        unsafe {
            instance.get(DeviceMetricColorCode::new)
        }
    }
}

impl ::protobuf::Clear for DeviceMetricColorCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceMetricColorCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceMetricColorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeviceMetricColorCode_Value {
    INVALID_UNINITIALIZED = 0,
    BLACK = 1,
    RED = 2,
    GREEN = 3,
    YELLOW = 4,
    BLUE = 5,
    MAGENTA = 6,
    CYAN = 7,
    WHITE = 8,
}

impl ::protobuf::ProtobufEnum for DeviceMetricColorCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceMetricColorCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DeviceMetricColorCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DeviceMetricColorCode_Value::BLACK),
            2 => ::std::option::Option::Some(DeviceMetricColorCode_Value::RED),
            3 => ::std::option::Option::Some(DeviceMetricColorCode_Value::GREEN),
            4 => ::std::option::Option::Some(DeviceMetricColorCode_Value::YELLOW),
            5 => ::std::option::Option::Some(DeviceMetricColorCode_Value::BLUE),
            6 => ::std::option::Option::Some(DeviceMetricColorCode_Value::MAGENTA),
            7 => ::std::option::Option::Some(DeviceMetricColorCode_Value::CYAN),
            8 => ::std::option::Option::Some(DeviceMetricColorCode_Value::WHITE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeviceMetricColorCode_Value] = &[
            DeviceMetricColorCode_Value::INVALID_UNINITIALIZED,
            DeviceMetricColorCode_Value::BLACK,
            DeviceMetricColorCode_Value::RED,
            DeviceMetricColorCode_Value::GREEN,
            DeviceMetricColorCode_Value::YELLOW,
            DeviceMetricColorCode_Value::BLUE,
            DeviceMetricColorCode_Value::MAGENTA,
            DeviceMetricColorCode_Value::CYAN,
            DeviceMetricColorCode_Value::WHITE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DeviceMetricColorCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DeviceMetricColorCode_Value {
}

impl ::std::default::Default for DeviceMetricColorCode_Value {
    fn default() -> Self {
        DeviceMetricColorCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceMetricColorCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceMetricOperationalStatusCode {
    // message fields
    pub value: DeviceMetricOperationalStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeviceMetricOperationalStatusCode {
    pub fn new() -> DeviceMetricOperationalStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DeviceMetricOperationalStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DeviceMetricOperationalStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DeviceMetricOperationalStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DeviceMetricOperationalStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DeviceMetricOperationalStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DeviceMetricOperationalStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DeviceMetricOperationalStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceMetricOperationalStatusCode {
        DeviceMetricOperationalStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DeviceMetricOperationalStatusCode_Value>>(
                    "value",
                    |m: &DeviceMetricOperationalStatusCode| { &m.value },
                    |m: &mut DeviceMetricOperationalStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DeviceMetricOperationalStatusCode| { &m.id },
                    |m: &mut DeviceMetricOperationalStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DeviceMetricOperationalStatusCode| { &m.extension },
                    |m: &mut DeviceMetricOperationalStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceMetricOperationalStatusCode>(
                    "DeviceMetricOperationalStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceMetricOperationalStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<DeviceMetricOperationalStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceMetricOperationalStatusCode,
        };
        unsafe {
            instance.get(DeviceMetricOperationalStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for DeviceMetricOperationalStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceMetricOperationalStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceMetricOperationalStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeviceMetricOperationalStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ON = 1,
    OFF = 2,
    STANDBY = 3,
    ENTERED_IN_ERROR = 4,
}

impl ::protobuf::ProtobufEnum for DeviceMetricOperationalStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceMetricOperationalStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DeviceMetricOperationalStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DeviceMetricOperationalStatusCode_Value::ON),
            2 => ::std::option::Option::Some(DeviceMetricOperationalStatusCode_Value::OFF),
            3 => ::std::option::Option::Some(DeviceMetricOperationalStatusCode_Value::STANDBY),
            4 => ::std::option::Option::Some(DeviceMetricOperationalStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeviceMetricOperationalStatusCode_Value] = &[
            DeviceMetricOperationalStatusCode_Value::INVALID_UNINITIALIZED,
            DeviceMetricOperationalStatusCode_Value::ON,
            DeviceMetricOperationalStatusCode_Value::OFF,
            DeviceMetricOperationalStatusCode_Value::STANDBY,
            DeviceMetricOperationalStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DeviceMetricOperationalStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DeviceMetricOperationalStatusCode_Value {
}

impl ::std::default::Default for DeviceMetricOperationalStatusCode_Value {
    fn default() -> Self {
        DeviceMetricOperationalStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceMetricOperationalStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HumanNameAssemblyOrderCode {
    // message fields
    pub value: HumanNameAssemblyOrderCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl HumanNameAssemblyOrderCode {
    pub fn new() -> HumanNameAssemblyOrderCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.HumanNameAssemblyOrderCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = HumanNameAssemblyOrderCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: HumanNameAssemblyOrderCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> HumanNameAssemblyOrderCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for HumanNameAssemblyOrderCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != HumanNameAssemblyOrderCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != HumanNameAssemblyOrderCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HumanNameAssemblyOrderCode {
        HumanNameAssemblyOrderCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HumanNameAssemblyOrderCode_Value>>(
                    "value",
                    |m: &HumanNameAssemblyOrderCode| { &m.value },
                    |m: &mut HumanNameAssemblyOrderCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &HumanNameAssemblyOrderCode| { &m.id },
                    |m: &mut HumanNameAssemblyOrderCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &HumanNameAssemblyOrderCode| { &m.extension },
                    |m: &mut HumanNameAssemblyOrderCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HumanNameAssemblyOrderCode>(
                    "HumanNameAssemblyOrderCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HumanNameAssemblyOrderCode {
        static mut instance: ::protobuf::lazy::Lazy<HumanNameAssemblyOrderCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HumanNameAssemblyOrderCode,
        };
        unsafe {
            instance.get(HumanNameAssemblyOrderCode::new)
        }
    }
}

impl ::protobuf::Clear for HumanNameAssemblyOrderCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HumanNameAssemblyOrderCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HumanNameAssemblyOrderCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HumanNameAssemblyOrderCode_Value {
    INVALID_UNINITIALIZED = 0,
    NL1 = 1,
    NL2 = 2,
    NL3 = 3,
    NL4 = 4,
}

impl ::protobuf::ProtobufEnum for HumanNameAssemblyOrderCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HumanNameAssemblyOrderCode_Value> {
        match value {
            0 => ::std::option::Option::Some(HumanNameAssemblyOrderCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(HumanNameAssemblyOrderCode_Value::NL1),
            2 => ::std::option::Option::Some(HumanNameAssemblyOrderCode_Value::NL2),
            3 => ::std::option::Option::Some(HumanNameAssemblyOrderCode_Value::NL3),
            4 => ::std::option::Option::Some(HumanNameAssemblyOrderCode_Value::NL4),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HumanNameAssemblyOrderCode_Value] = &[
            HumanNameAssemblyOrderCode_Value::INVALID_UNINITIALIZED,
            HumanNameAssemblyOrderCode_Value::NL1,
            HumanNameAssemblyOrderCode_Value::NL2,
            HumanNameAssemblyOrderCode_Value::NL3,
            HumanNameAssemblyOrderCode_Value::NL4,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("HumanNameAssemblyOrderCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for HumanNameAssemblyOrderCode_Value {
}

impl ::std::default::Default for HumanNameAssemblyOrderCode_Value {
    fn default() -> Self {
        HumanNameAssemblyOrderCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for HumanNameAssemblyOrderCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NameRepresentationUseCode {
    // message fields
    pub value: NameRepresentationUseCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NameRepresentationUseCode {
    pub fn new() -> NameRepresentationUseCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.NameRepresentationUseCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = NameRepresentationUseCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: NameRepresentationUseCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> NameRepresentationUseCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for NameRepresentationUseCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != NameRepresentationUseCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != NameRepresentationUseCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NameRepresentationUseCode {
        NameRepresentationUseCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NameRepresentationUseCode_Value>>(
                    "value",
                    |m: &NameRepresentationUseCode| { &m.value },
                    |m: &mut NameRepresentationUseCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &NameRepresentationUseCode| { &m.id },
                    |m: &mut NameRepresentationUseCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &NameRepresentationUseCode| { &m.extension },
                    |m: &mut NameRepresentationUseCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NameRepresentationUseCode>(
                    "NameRepresentationUseCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NameRepresentationUseCode {
        static mut instance: ::protobuf::lazy::Lazy<NameRepresentationUseCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NameRepresentationUseCode,
        };
        unsafe {
            instance.get(NameRepresentationUseCode::new)
        }
    }
}

impl ::protobuf::Clear for NameRepresentationUseCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NameRepresentationUseCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NameRepresentationUseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NameRepresentationUseCode_Value {
    INVALID_UNINITIALIZED = 0,
    ABC = 1,
    IDE = 2,
    SYL = 3,
}

impl ::protobuf::ProtobufEnum for NameRepresentationUseCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NameRepresentationUseCode_Value> {
        match value {
            0 => ::std::option::Option::Some(NameRepresentationUseCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(NameRepresentationUseCode_Value::ABC),
            2 => ::std::option::Option::Some(NameRepresentationUseCode_Value::IDE),
            3 => ::std::option::Option::Some(NameRepresentationUseCode_Value::SYL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NameRepresentationUseCode_Value] = &[
            NameRepresentationUseCode_Value::INVALID_UNINITIALIZED,
            NameRepresentationUseCode_Value::ABC,
            NameRepresentationUseCode_Value::IDE,
            NameRepresentationUseCode_Value::SYL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NameRepresentationUseCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NameRepresentationUseCode_Value {
}

impl ::std::default::Default for NameRepresentationUseCode_Value {
    fn default() -> Self {
        NameRepresentationUseCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for NameRepresentationUseCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamingSystemIdentifierTypeCode {
    // message fields
    pub value: NamingSystemIdentifierTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NamingSystemIdentifierTypeCode {
    pub fn new() -> NamingSystemIdentifierTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.NamingSystemIdentifierTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = NamingSystemIdentifierTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: NamingSystemIdentifierTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> NamingSystemIdentifierTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for NamingSystemIdentifierTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != NamingSystemIdentifierTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != NamingSystemIdentifierTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamingSystemIdentifierTypeCode {
        NamingSystemIdentifierTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NamingSystemIdentifierTypeCode_Value>>(
                    "value",
                    |m: &NamingSystemIdentifierTypeCode| { &m.value },
                    |m: &mut NamingSystemIdentifierTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &NamingSystemIdentifierTypeCode| { &m.id },
                    |m: &mut NamingSystemIdentifierTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &NamingSystemIdentifierTypeCode| { &m.extension },
                    |m: &mut NamingSystemIdentifierTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NamingSystemIdentifierTypeCode>(
                    "NamingSystemIdentifierTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NamingSystemIdentifierTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<NamingSystemIdentifierTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NamingSystemIdentifierTypeCode,
        };
        unsafe {
            instance.get(NamingSystemIdentifierTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for NamingSystemIdentifierTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamingSystemIdentifierTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamingSystemIdentifierTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NamingSystemIdentifierTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    OID = 1,
    UUID = 2,
    URI = 3,
    OTHER = 4,
}

impl ::protobuf::ProtobufEnum for NamingSystemIdentifierTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NamingSystemIdentifierTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(NamingSystemIdentifierTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(NamingSystemIdentifierTypeCode_Value::OID),
            2 => ::std::option::Option::Some(NamingSystemIdentifierTypeCode_Value::UUID),
            3 => ::std::option::Option::Some(NamingSystemIdentifierTypeCode_Value::URI),
            4 => ::std::option::Option::Some(NamingSystemIdentifierTypeCode_Value::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NamingSystemIdentifierTypeCode_Value] = &[
            NamingSystemIdentifierTypeCode_Value::INVALID_UNINITIALIZED,
            NamingSystemIdentifierTypeCode_Value::OID,
            NamingSystemIdentifierTypeCode_Value::UUID,
            NamingSystemIdentifierTypeCode_Value::URI,
            NamingSystemIdentifierTypeCode_Value::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NamingSystemIdentifierTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NamingSystemIdentifierTypeCode_Value {
}

impl ::std::default::Default for NamingSystemIdentifierTypeCode_Value {
    fn default() -> Self {
        NamingSystemIdentifierTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for NamingSystemIdentifierTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamingSystemTypeCode {
    // message fields
    pub value: NamingSystemTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NamingSystemTypeCode {
    pub fn new() -> NamingSystemTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.NamingSystemTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = NamingSystemTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: NamingSystemTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> NamingSystemTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for NamingSystemTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != NamingSystemTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != NamingSystemTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamingSystemTypeCode {
        NamingSystemTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NamingSystemTypeCode_Value>>(
                    "value",
                    |m: &NamingSystemTypeCode| { &m.value },
                    |m: &mut NamingSystemTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &NamingSystemTypeCode| { &m.id },
                    |m: &mut NamingSystemTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &NamingSystemTypeCode| { &m.extension },
                    |m: &mut NamingSystemTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NamingSystemTypeCode>(
                    "NamingSystemTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NamingSystemTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<NamingSystemTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NamingSystemTypeCode,
        };
        unsafe {
            instance.get(NamingSystemTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for NamingSystemTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamingSystemTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamingSystemTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NamingSystemTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    CODESYSTEM = 1,
    IDENTIFIER = 2,
    ROOT = 3,
}

impl ::protobuf::ProtobufEnum for NamingSystemTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NamingSystemTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(NamingSystemTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(NamingSystemTypeCode_Value::CODESYSTEM),
            2 => ::std::option::Option::Some(NamingSystemTypeCode_Value::IDENTIFIER),
            3 => ::std::option::Option::Some(NamingSystemTypeCode_Value::ROOT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NamingSystemTypeCode_Value] = &[
            NamingSystemTypeCode_Value::INVALID_UNINITIALIZED,
            NamingSystemTypeCode_Value::CODESYSTEM,
            NamingSystemTypeCode_Value::IDENTIFIER,
            NamingSystemTypeCode_Value::ROOT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NamingSystemTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NamingSystemTypeCode_Value {
}

impl ::std::default::Default for NamingSystemTypeCode_Value {
    fn default() -> Self {
        NamingSystemTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for NamingSystemTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuditEventAgentNetworkTypeCode {
    // message fields
    pub value: AuditEventAgentNetworkTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AuditEventAgentNetworkTypeCode {
    pub fn new() -> AuditEventAgentNetworkTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AuditEventAgentNetworkTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AuditEventAgentNetworkTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AuditEventAgentNetworkTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AuditEventAgentNetworkTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AuditEventAgentNetworkTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AuditEventAgentNetworkTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AuditEventAgentNetworkTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuditEventAgentNetworkTypeCode {
        AuditEventAgentNetworkTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AuditEventAgentNetworkTypeCode_Value>>(
                    "value",
                    |m: &AuditEventAgentNetworkTypeCode| { &m.value },
                    |m: &mut AuditEventAgentNetworkTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AuditEventAgentNetworkTypeCode| { &m.id },
                    |m: &mut AuditEventAgentNetworkTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AuditEventAgentNetworkTypeCode| { &m.extension },
                    |m: &mut AuditEventAgentNetworkTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AuditEventAgentNetworkTypeCode>(
                    "AuditEventAgentNetworkTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AuditEventAgentNetworkTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<AuditEventAgentNetworkTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AuditEventAgentNetworkTypeCode,
        };
        unsafe {
            instance.get(AuditEventAgentNetworkTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for AuditEventAgentNetworkTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuditEventAgentNetworkTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditEventAgentNetworkTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuditEventAgentNetworkTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    MACHINE_NAME = 1,
    IP_ADDRESS = 2,
    TELEPHONE_NUMBER = 3,
    EMAIL_ADDRESS = 4,
    URI = 5,
}

impl ::protobuf::ProtobufEnum for AuditEventAgentNetworkTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuditEventAgentNetworkTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AuditEventAgentNetworkTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AuditEventAgentNetworkTypeCode_Value::MACHINE_NAME),
            2 => ::std::option::Option::Some(AuditEventAgentNetworkTypeCode_Value::IP_ADDRESS),
            3 => ::std::option::Option::Some(AuditEventAgentNetworkTypeCode_Value::TELEPHONE_NUMBER),
            4 => ::std::option::Option::Some(AuditEventAgentNetworkTypeCode_Value::EMAIL_ADDRESS),
            5 => ::std::option::Option::Some(AuditEventAgentNetworkTypeCode_Value::URI),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuditEventAgentNetworkTypeCode_Value] = &[
            AuditEventAgentNetworkTypeCode_Value::INVALID_UNINITIALIZED,
            AuditEventAgentNetworkTypeCode_Value::MACHINE_NAME,
            AuditEventAgentNetworkTypeCode_Value::IP_ADDRESS,
            AuditEventAgentNetworkTypeCode_Value::TELEPHONE_NUMBER,
            AuditEventAgentNetworkTypeCode_Value::EMAIL_ADDRESS,
            AuditEventAgentNetworkTypeCode_Value::URI,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AuditEventAgentNetworkTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AuditEventAgentNetworkTypeCode_Value {
}

impl ::std::default::Default for AuditEventAgentNetworkTypeCode_Value {
    fn default() -> Self {
        AuditEventAgentNetworkTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AuditEventAgentNetworkTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NoteTypeCode {
    // message fields
    pub value: NoteTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NoteTypeCode {
    pub fn new() -> NoteTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.NoteTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = NoteTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: NoteTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> NoteTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for NoteTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != NoteTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != NoteTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NoteTypeCode {
        NoteTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NoteTypeCode_Value>>(
                    "value",
                    |m: &NoteTypeCode| { &m.value },
                    |m: &mut NoteTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &NoteTypeCode| { &m.id },
                    |m: &mut NoteTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &NoteTypeCode| { &m.extension },
                    |m: &mut NoteTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NoteTypeCode>(
                    "NoteTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NoteTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<NoteTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NoteTypeCode,
        };
        unsafe {
            instance.get(NoteTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for NoteTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NoteTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoteTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NoteTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    DISPLAY = 1,
    PRINT = 2,
    PRINTOPER = 3,
}

impl ::protobuf::ProtobufEnum for NoteTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NoteTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(NoteTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(NoteTypeCode_Value::DISPLAY),
            2 => ::std::option::Option::Some(NoteTypeCode_Value::PRINT),
            3 => ::std::option::Option::Some(NoteTypeCode_Value::PRINTOPER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NoteTypeCode_Value] = &[
            NoteTypeCode_Value::INVALID_UNINITIALIZED,
            NoteTypeCode_Value::DISPLAY,
            NoteTypeCode_Value::PRINT,
            NoteTypeCode_Value::PRINTOPER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NoteTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NoteTypeCode_Value {
}

impl ::std::default::Default for NoteTypeCode_Value {
    fn default() -> Self {
        NoteTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for NoteTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NullFlavorCode {
    // message fields
    pub value: NullFlavorCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NullFlavorCode {
    pub fn new() -> NullFlavorCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.NullFlavorCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = NullFlavorCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: NullFlavorCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> NullFlavorCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for NullFlavorCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != NullFlavorCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != NullFlavorCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NullFlavorCode {
        NullFlavorCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NullFlavorCode_Value>>(
                    "value",
                    |m: &NullFlavorCode| { &m.value },
                    |m: &mut NullFlavorCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &NullFlavorCode| { &m.id },
                    |m: &mut NullFlavorCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &NullFlavorCode| { &m.extension },
                    |m: &mut NullFlavorCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NullFlavorCode>(
                    "NullFlavorCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NullFlavorCode {
        static mut instance: ::protobuf::lazy::Lazy<NullFlavorCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NullFlavorCode,
        };
        unsafe {
            instance.get(NullFlavorCode::new)
        }
    }
}

impl ::protobuf::Clear for NullFlavorCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NullFlavorCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NullFlavorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NullFlavorCode_Value {
    INVALID_UNINITIALIZED = 0,
    NI = 1,
    INV = 2,
    DER = 3,
    OTH = 4,
    NINF = 5,
    PINF = 6,
    UNC = 7,
    MSK = 8,
    NA = 9,
    UNK = 10,
    ASKU = 11,
    NAV = 12,
    NASK = 13,
    NAVU = 14,
    QS = 15,
    TRC = 16,
    NP = 17,
}

impl ::protobuf::ProtobufEnum for NullFlavorCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NullFlavorCode_Value> {
        match value {
            0 => ::std::option::Option::Some(NullFlavorCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(NullFlavorCode_Value::NI),
            2 => ::std::option::Option::Some(NullFlavorCode_Value::INV),
            3 => ::std::option::Option::Some(NullFlavorCode_Value::DER),
            4 => ::std::option::Option::Some(NullFlavorCode_Value::OTH),
            5 => ::std::option::Option::Some(NullFlavorCode_Value::NINF),
            6 => ::std::option::Option::Some(NullFlavorCode_Value::PINF),
            7 => ::std::option::Option::Some(NullFlavorCode_Value::UNC),
            8 => ::std::option::Option::Some(NullFlavorCode_Value::MSK),
            9 => ::std::option::Option::Some(NullFlavorCode_Value::NA),
            10 => ::std::option::Option::Some(NullFlavorCode_Value::UNK),
            11 => ::std::option::Option::Some(NullFlavorCode_Value::ASKU),
            12 => ::std::option::Option::Some(NullFlavorCode_Value::NAV),
            13 => ::std::option::Option::Some(NullFlavorCode_Value::NASK),
            14 => ::std::option::Option::Some(NullFlavorCode_Value::NAVU),
            15 => ::std::option::Option::Some(NullFlavorCode_Value::QS),
            16 => ::std::option::Option::Some(NullFlavorCode_Value::TRC),
            17 => ::std::option::Option::Some(NullFlavorCode_Value::NP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NullFlavorCode_Value] = &[
            NullFlavorCode_Value::INVALID_UNINITIALIZED,
            NullFlavorCode_Value::NI,
            NullFlavorCode_Value::INV,
            NullFlavorCode_Value::DER,
            NullFlavorCode_Value::OTH,
            NullFlavorCode_Value::NINF,
            NullFlavorCode_Value::PINF,
            NullFlavorCode_Value::UNC,
            NullFlavorCode_Value::MSK,
            NullFlavorCode_Value::NA,
            NullFlavorCode_Value::UNK,
            NullFlavorCode_Value::ASKU,
            NullFlavorCode_Value::NAV,
            NullFlavorCode_Value::NASK,
            NullFlavorCode_Value::NAVU,
            NullFlavorCode_Value::QS,
            NullFlavorCode_Value::TRC,
            NullFlavorCode_Value::NP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NullFlavorCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NullFlavorCode_Value {
}

impl ::std::default::Default for NullFlavorCode_Value {
    fn default() -> Self {
        NullFlavorCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for NullFlavorCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NutritionOrderStatusCode {
    // message fields
    pub value: NutritionOrderStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NutritionOrderStatusCode {
    pub fn new() -> NutritionOrderStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.NutritionOrderStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = NutritionOrderStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: NutritionOrderStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> NutritionOrderStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for NutritionOrderStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != NutritionOrderStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != NutritionOrderStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NutritionOrderStatusCode {
        NutritionOrderStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NutritionOrderStatusCode_Value>>(
                    "value",
                    |m: &NutritionOrderStatusCode| { &m.value },
                    |m: &mut NutritionOrderStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &NutritionOrderStatusCode| { &m.id },
                    |m: &mut NutritionOrderStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &NutritionOrderStatusCode| { &m.extension },
                    |m: &mut NutritionOrderStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NutritionOrderStatusCode>(
                    "NutritionOrderStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NutritionOrderStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<NutritionOrderStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NutritionOrderStatusCode,
        };
        unsafe {
            instance.get(NutritionOrderStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for NutritionOrderStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NutritionOrderStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NutritionOrderStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NutritionOrderStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROPOSED = 1,
    DRAFT = 2,
    PLANNED = 3,
    REQUESTED = 4,
    ACTIVE = 5,
    ON_HOLD = 6,
    COMPLETED = 7,
    CANCELLED = 8,
    ENTERED_IN_ERROR = 9,
}

impl ::protobuf::ProtobufEnum for NutritionOrderStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NutritionOrderStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(NutritionOrderStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(NutritionOrderStatusCode_Value::PROPOSED),
            2 => ::std::option::Option::Some(NutritionOrderStatusCode_Value::DRAFT),
            3 => ::std::option::Option::Some(NutritionOrderStatusCode_Value::PLANNED),
            4 => ::std::option::Option::Some(NutritionOrderStatusCode_Value::REQUESTED),
            5 => ::std::option::Option::Some(NutritionOrderStatusCode_Value::ACTIVE),
            6 => ::std::option::Option::Some(NutritionOrderStatusCode_Value::ON_HOLD),
            7 => ::std::option::Option::Some(NutritionOrderStatusCode_Value::COMPLETED),
            8 => ::std::option::Option::Some(NutritionOrderStatusCode_Value::CANCELLED),
            9 => ::std::option::Option::Some(NutritionOrderStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NutritionOrderStatusCode_Value] = &[
            NutritionOrderStatusCode_Value::INVALID_UNINITIALIZED,
            NutritionOrderStatusCode_Value::PROPOSED,
            NutritionOrderStatusCode_Value::DRAFT,
            NutritionOrderStatusCode_Value::PLANNED,
            NutritionOrderStatusCode_Value::REQUESTED,
            NutritionOrderStatusCode_Value::ACTIVE,
            NutritionOrderStatusCode_Value::ON_HOLD,
            NutritionOrderStatusCode_Value::COMPLETED,
            NutritionOrderStatusCode_Value::CANCELLED,
            NutritionOrderStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NutritionOrderStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NutritionOrderStatusCode_Value {
}

impl ::std::default::Default for NutritionOrderStatusCode_Value {
    fn default() -> Self {
        NutritionOrderStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for NutritionOrderStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObservationCategoryCodesCode {
    // message fields
    pub value: ObservationCategoryCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ObservationCategoryCodesCode {
    pub fn new() -> ObservationCategoryCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ObservationCategoryCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ObservationCategoryCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ObservationCategoryCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ObservationCategoryCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ObservationCategoryCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ObservationCategoryCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ObservationCategoryCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObservationCategoryCodesCode {
        ObservationCategoryCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ObservationCategoryCodesCode_Value>>(
                    "value",
                    |m: &ObservationCategoryCodesCode| { &m.value },
                    |m: &mut ObservationCategoryCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ObservationCategoryCodesCode| { &m.id },
                    |m: &mut ObservationCategoryCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ObservationCategoryCodesCode| { &m.extension },
                    |m: &mut ObservationCategoryCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ObservationCategoryCodesCode>(
                    "ObservationCategoryCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ObservationCategoryCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ObservationCategoryCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ObservationCategoryCodesCode,
        };
        unsafe {
            instance.get(ObservationCategoryCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ObservationCategoryCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObservationCategoryCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationCategoryCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ObservationCategoryCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    SOCIAL_HISTORY = 1,
    VITAL_SIGNS = 2,
    IMAGING = 3,
    LABORATORY = 4,
    PROCEDURE = 5,
    SURVEY = 6,
    EXAM = 7,
    THERAPY = 8,
}

impl ::protobuf::ProtobufEnum for ObservationCategoryCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ObservationCategoryCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ObservationCategoryCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ObservationCategoryCodesCode_Value::SOCIAL_HISTORY),
            2 => ::std::option::Option::Some(ObservationCategoryCodesCode_Value::VITAL_SIGNS),
            3 => ::std::option::Option::Some(ObservationCategoryCodesCode_Value::IMAGING),
            4 => ::std::option::Option::Some(ObservationCategoryCodesCode_Value::LABORATORY),
            5 => ::std::option::Option::Some(ObservationCategoryCodesCode_Value::PROCEDURE),
            6 => ::std::option::Option::Some(ObservationCategoryCodesCode_Value::SURVEY),
            7 => ::std::option::Option::Some(ObservationCategoryCodesCode_Value::EXAM),
            8 => ::std::option::Option::Some(ObservationCategoryCodesCode_Value::THERAPY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ObservationCategoryCodesCode_Value] = &[
            ObservationCategoryCodesCode_Value::INVALID_UNINITIALIZED,
            ObservationCategoryCodesCode_Value::SOCIAL_HISTORY,
            ObservationCategoryCodesCode_Value::VITAL_SIGNS,
            ObservationCategoryCodesCode_Value::IMAGING,
            ObservationCategoryCodesCode_Value::LABORATORY,
            ObservationCategoryCodesCode_Value::PROCEDURE,
            ObservationCategoryCodesCode_Value::SURVEY,
            ObservationCategoryCodesCode_Value::EXAM,
            ObservationCategoryCodesCode_Value::THERAPY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ObservationCategoryCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ObservationCategoryCodesCode_Value {
}

impl ::std::default::Default for ObservationCategoryCodesCode_Value {
    fn default() -> Self {
        ObservationCategoryCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationCategoryCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObservationRelationshipTypeCode {
    // message fields
    pub value: ObservationRelationshipTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ObservationRelationshipTypeCode {
    pub fn new() -> ObservationRelationshipTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ObservationRelationshipTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ObservationRelationshipTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ObservationRelationshipTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ObservationRelationshipTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ObservationRelationshipTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ObservationRelationshipTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ObservationRelationshipTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObservationRelationshipTypeCode {
        ObservationRelationshipTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ObservationRelationshipTypeCode_Value>>(
                    "value",
                    |m: &ObservationRelationshipTypeCode| { &m.value },
                    |m: &mut ObservationRelationshipTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ObservationRelationshipTypeCode| { &m.id },
                    |m: &mut ObservationRelationshipTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ObservationRelationshipTypeCode| { &m.extension },
                    |m: &mut ObservationRelationshipTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ObservationRelationshipTypeCode>(
                    "ObservationRelationshipTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ObservationRelationshipTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ObservationRelationshipTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ObservationRelationshipTypeCode,
        };
        unsafe {
            instance.get(ObservationRelationshipTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ObservationRelationshipTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObservationRelationshipTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationRelationshipTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ObservationRelationshipTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    HAS_MEMBER = 1,
    DERIVED_FROM = 2,
    SEQUEL_TO = 3,
    REPLACES = 4,
    QUALIFIED_BY = 5,
    INTERFERED_BY = 6,
}

impl ::protobuf::ProtobufEnum for ObservationRelationshipTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ObservationRelationshipTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ObservationRelationshipTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ObservationRelationshipTypeCode_Value::HAS_MEMBER),
            2 => ::std::option::Option::Some(ObservationRelationshipTypeCode_Value::DERIVED_FROM),
            3 => ::std::option::Option::Some(ObservationRelationshipTypeCode_Value::SEQUEL_TO),
            4 => ::std::option::Option::Some(ObservationRelationshipTypeCode_Value::REPLACES),
            5 => ::std::option::Option::Some(ObservationRelationshipTypeCode_Value::QUALIFIED_BY),
            6 => ::std::option::Option::Some(ObservationRelationshipTypeCode_Value::INTERFERED_BY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ObservationRelationshipTypeCode_Value] = &[
            ObservationRelationshipTypeCode_Value::INVALID_UNINITIALIZED,
            ObservationRelationshipTypeCode_Value::HAS_MEMBER,
            ObservationRelationshipTypeCode_Value::DERIVED_FROM,
            ObservationRelationshipTypeCode_Value::SEQUEL_TO,
            ObservationRelationshipTypeCode_Value::REPLACES,
            ObservationRelationshipTypeCode_Value::QUALIFIED_BY,
            ObservationRelationshipTypeCode_Value::INTERFERED_BY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ObservationRelationshipTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ObservationRelationshipTypeCode_Value {
}

impl ::std::default::Default for ObservationRelationshipTypeCode_Value {
    fn default() -> Self {
        ObservationRelationshipTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationRelationshipTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatisticsCodeCode {
    // message fields
    pub value: StatisticsCodeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StatisticsCodeCode {
    pub fn new() -> StatisticsCodeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.StatisticsCodeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = StatisticsCodeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: StatisticsCodeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> StatisticsCodeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for StatisticsCodeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != StatisticsCodeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != StatisticsCodeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatisticsCodeCode {
        StatisticsCodeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatisticsCodeCode_Value>>(
                    "value",
                    |m: &StatisticsCodeCode| { &m.value },
                    |m: &mut StatisticsCodeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &StatisticsCodeCode| { &m.id },
                    |m: &mut StatisticsCodeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &StatisticsCodeCode| { &m.extension },
                    |m: &mut StatisticsCodeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatisticsCodeCode>(
                    "StatisticsCodeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatisticsCodeCode {
        static mut instance: ::protobuf::lazy::Lazy<StatisticsCodeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatisticsCodeCode,
        };
        unsafe {
            instance.get(StatisticsCodeCode::new)
        }
    }
}

impl ::protobuf::Clear for StatisticsCodeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatisticsCodeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatisticsCodeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StatisticsCodeCode_Value {
    INVALID_UNINITIALIZED = 0,
    AVERAGE = 1,
    MAXIMUM = 2,
    MINIMUM = 3,
    COUNT = 4,
    TOTALCOUNT = 5,
    MEDIAN = 6,
    STD_DEV = 7,
    SUM = 8,
    VARIANCE = 9,
    TWENTY_PERCENT = 10,
    EIGHTY_PERCENT = 11,
    FOUR_LOWER = 12,
    FOUR_UPPER = 13,
    FOUR_DEV = 14,
    FIVE_ONE = 15,
    FIVE_TWO = 16,
    FIVE_THREE = 17,
    FIVE_FOUR = 18,
    SKEW = 19,
    KURTOSIS = 20,
    REGRESSION = 21,
}

impl ::protobuf::ProtobufEnum for StatisticsCodeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StatisticsCodeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(StatisticsCodeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(StatisticsCodeCode_Value::AVERAGE),
            2 => ::std::option::Option::Some(StatisticsCodeCode_Value::MAXIMUM),
            3 => ::std::option::Option::Some(StatisticsCodeCode_Value::MINIMUM),
            4 => ::std::option::Option::Some(StatisticsCodeCode_Value::COUNT),
            5 => ::std::option::Option::Some(StatisticsCodeCode_Value::TOTALCOUNT),
            6 => ::std::option::Option::Some(StatisticsCodeCode_Value::MEDIAN),
            7 => ::std::option::Option::Some(StatisticsCodeCode_Value::STD_DEV),
            8 => ::std::option::Option::Some(StatisticsCodeCode_Value::SUM),
            9 => ::std::option::Option::Some(StatisticsCodeCode_Value::VARIANCE),
            10 => ::std::option::Option::Some(StatisticsCodeCode_Value::TWENTY_PERCENT),
            11 => ::std::option::Option::Some(StatisticsCodeCode_Value::EIGHTY_PERCENT),
            12 => ::std::option::Option::Some(StatisticsCodeCode_Value::FOUR_LOWER),
            13 => ::std::option::Option::Some(StatisticsCodeCode_Value::FOUR_UPPER),
            14 => ::std::option::Option::Some(StatisticsCodeCode_Value::FOUR_DEV),
            15 => ::std::option::Option::Some(StatisticsCodeCode_Value::FIVE_ONE),
            16 => ::std::option::Option::Some(StatisticsCodeCode_Value::FIVE_TWO),
            17 => ::std::option::Option::Some(StatisticsCodeCode_Value::FIVE_THREE),
            18 => ::std::option::Option::Some(StatisticsCodeCode_Value::FIVE_FOUR),
            19 => ::std::option::Option::Some(StatisticsCodeCode_Value::SKEW),
            20 => ::std::option::Option::Some(StatisticsCodeCode_Value::KURTOSIS),
            21 => ::std::option::Option::Some(StatisticsCodeCode_Value::REGRESSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StatisticsCodeCode_Value] = &[
            StatisticsCodeCode_Value::INVALID_UNINITIALIZED,
            StatisticsCodeCode_Value::AVERAGE,
            StatisticsCodeCode_Value::MAXIMUM,
            StatisticsCodeCode_Value::MINIMUM,
            StatisticsCodeCode_Value::COUNT,
            StatisticsCodeCode_Value::TOTALCOUNT,
            StatisticsCodeCode_Value::MEDIAN,
            StatisticsCodeCode_Value::STD_DEV,
            StatisticsCodeCode_Value::SUM,
            StatisticsCodeCode_Value::VARIANCE,
            StatisticsCodeCode_Value::TWENTY_PERCENT,
            StatisticsCodeCode_Value::EIGHTY_PERCENT,
            StatisticsCodeCode_Value::FOUR_LOWER,
            StatisticsCodeCode_Value::FOUR_UPPER,
            StatisticsCodeCode_Value::FOUR_DEV,
            StatisticsCodeCode_Value::FIVE_ONE,
            StatisticsCodeCode_Value::FIVE_TWO,
            StatisticsCodeCode_Value::FIVE_THREE,
            StatisticsCodeCode_Value::FIVE_FOUR,
            StatisticsCodeCode_Value::SKEW,
            StatisticsCodeCode_Value::KURTOSIS,
            StatisticsCodeCode_Value::REGRESSION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StatisticsCodeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StatisticsCodeCode_Value {
}

impl ::std::default::Default for StatisticsCodeCode_Value {
    fn default() -> Self {
        StatisticsCodeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for StatisticsCodeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObservationStatusCode {
    // message fields
    pub value: ObservationStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ObservationStatusCode {
    pub fn new() -> ObservationStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ObservationStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ObservationStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ObservationStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ObservationStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ObservationStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ObservationStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ObservationStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObservationStatusCode {
        ObservationStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ObservationStatusCode_Value>>(
                    "value",
                    |m: &ObservationStatusCode| { &m.value },
                    |m: &mut ObservationStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ObservationStatusCode| { &m.id },
                    |m: &mut ObservationStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ObservationStatusCode| { &m.extension },
                    |m: &mut ObservationStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ObservationStatusCode>(
                    "ObservationStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ObservationStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ObservationStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ObservationStatusCode,
        };
        unsafe {
            instance.get(ObservationStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ObservationStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObservationStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ObservationStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    REGISTERED = 1,
    PRELIMINARY = 2,
    FINAL = 3,
    AMENDED = 4,
    CORRECTED = 5,
    CANCELLED = 6,
    ENTERED_IN_ERROR = 7,
    UNKNOWN = 8,
}

impl ::protobuf::ProtobufEnum for ObservationStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ObservationStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ObservationStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ObservationStatusCode_Value::REGISTERED),
            2 => ::std::option::Option::Some(ObservationStatusCode_Value::PRELIMINARY),
            3 => ::std::option::Option::Some(ObservationStatusCode_Value::FINAL),
            4 => ::std::option::Option::Some(ObservationStatusCode_Value::AMENDED),
            5 => ::std::option::Option::Some(ObservationStatusCode_Value::CORRECTED),
            6 => ::std::option::Option::Some(ObservationStatusCode_Value::CANCELLED),
            7 => ::std::option::Option::Some(ObservationStatusCode_Value::ENTERED_IN_ERROR),
            8 => ::std::option::Option::Some(ObservationStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ObservationStatusCode_Value] = &[
            ObservationStatusCode_Value::INVALID_UNINITIALIZED,
            ObservationStatusCode_Value::REGISTERED,
            ObservationStatusCode_Value::PRELIMINARY,
            ObservationStatusCode_Value::FINAL,
            ObservationStatusCode_Value::AMENDED,
            ObservationStatusCode_Value::CORRECTED,
            ObservationStatusCode_Value::CANCELLED,
            ObservationStatusCode_Value::ENTERED_IN_ERROR,
            ObservationStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ObservationStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ObservationStatusCode_Value {
}

impl ::std::default::Default for ObservationStatusCode_Value {
    fn default() -> Self {
        ObservationStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceComponentOperationalStatusCode {
    // message fields
    pub value: DeviceComponentOperationalStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeviceComponentOperationalStatusCode {
    pub fn new() -> DeviceComponentOperationalStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DeviceComponentOperationalStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DeviceComponentOperationalStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DeviceComponentOperationalStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DeviceComponentOperationalStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DeviceComponentOperationalStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DeviceComponentOperationalStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DeviceComponentOperationalStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceComponentOperationalStatusCode {
        DeviceComponentOperationalStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DeviceComponentOperationalStatusCode_Value>>(
                    "value",
                    |m: &DeviceComponentOperationalStatusCode| { &m.value },
                    |m: &mut DeviceComponentOperationalStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DeviceComponentOperationalStatusCode| { &m.id },
                    |m: &mut DeviceComponentOperationalStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DeviceComponentOperationalStatusCode| { &m.extension },
                    |m: &mut DeviceComponentOperationalStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceComponentOperationalStatusCode>(
                    "DeviceComponentOperationalStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceComponentOperationalStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<DeviceComponentOperationalStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceComponentOperationalStatusCode,
        };
        unsafe {
            instance.get(DeviceComponentOperationalStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for DeviceComponentOperationalStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceComponentOperationalStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceComponentOperationalStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeviceComponentOperationalStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    OFF = 1,
    ON = 2,
    NOT_READY = 3,
    STANDBY = 4,
    TRANSDUC_DISCON = 5,
    HW_DISCON = 6,
    ENTERED_IN_ERROR = 7,
}

impl ::protobuf::ProtobufEnum for DeviceComponentOperationalStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceComponentOperationalStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DeviceComponentOperationalStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DeviceComponentOperationalStatusCode_Value::OFF),
            2 => ::std::option::Option::Some(DeviceComponentOperationalStatusCode_Value::ON),
            3 => ::std::option::Option::Some(DeviceComponentOperationalStatusCode_Value::NOT_READY),
            4 => ::std::option::Option::Some(DeviceComponentOperationalStatusCode_Value::STANDBY),
            5 => ::std::option::Option::Some(DeviceComponentOperationalStatusCode_Value::TRANSDUC_DISCON),
            6 => ::std::option::Option::Some(DeviceComponentOperationalStatusCode_Value::HW_DISCON),
            7 => ::std::option::Option::Some(DeviceComponentOperationalStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeviceComponentOperationalStatusCode_Value] = &[
            DeviceComponentOperationalStatusCode_Value::INVALID_UNINITIALIZED,
            DeviceComponentOperationalStatusCode_Value::OFF,
            DeviceComponentOperationalStatusCode_Value::ON,
            DeviceComponentOperationalStatusCode_Value::NOT_READY,
            DeviceComponentOperationalStatusCode_Value::STANDBY,
            DeviceComponentOperationalStatusCode_Value::TRANSDUC_DISCON,
            DeviceComponentOperationalStatusCode_Value::HW_DISCON,
            DeviceComponentOperationalStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DeviceComponentOperationalStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DeviceComponentOperationalStatusCode_Value {
}

impl ::std::default::Default for DeviceComponentOperationalStatusCode_Value {
    fn default() -> Self {
        DeviceComponentOperationalStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceComponentOperationalStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationKindCode {
    // message fields
    pub value: OperationKindCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl OperationKindCode {
    pub fn new() -> OperationKindCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.OperationKindCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = OperationKindCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: OperationKindCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> OperationKindCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for OperationKindCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != OperationKindCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != OperationKindCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationKindCode {
        OperationKindCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationKindCode_Value>>(
                    "value",
                    |m: &OperationKindCode| { &m.value },
                    |m: &mut OperationKindCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &OperationKindCode| { &m.id },
                    |m: &mut OperationKindCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &OperationKindCode| { &m.extension },
                    |m: &mut OperationKindCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationKindCode>(
                    "OperationKindCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperationKindCode {
        static mut instance: ::protobuf::lazy::Lazy<OperationKindCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationKindCode,
        };
        unsafe {
            instance.get(OperationKindCode::new)
        }
    }
}

impl ::protobuf::Clear for OperationKindCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationKindCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationKindCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperationKindCode_Value {
    INVALID_UNINITIALIZED = 0,
    OPERATION = 1,
    QUERY = 2,
}

impl ::protobuf::ProtobufEnum for OperationKindCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperationKindCode_Value> {
        match value {
            0 => ::std::option::Option::Some(OperationKindCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(OperationKindCode_Value::OPERATION),
            2 => ::std::option::Option::Some(OperationKindCode_Value::QUERY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperationKindCode_Value] = &[
            OperationKindCode_Value::INVALID_UNINITIALIZED,
            OperationKindCode_Value::OPERATION,
            OperationKindCode_Value::QUERY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OperationKindCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OperationKindCode_Value {
}

impl ::std::default::Default for OperationKindCode_Value {
    fn default() -> Self {
        OperationKindCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationKindCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationOutcomeCodesCode {
    // message fields
    pub value: OperationOutcomeCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl OperationOutcomeCodesCode {
    pub fn new() -> OperationOutcomeCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.OperationOutcomeCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = OperationOutcomeCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: OperationOutcomeCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> OperationOutcomeCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for OperationOutcomeCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != OperationOutcomeCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != OperationOutcomeCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationOutcomeCodesCode {
        OperationOutcomeCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationOutcomeCodesCode_Value>>(
                    "value",
                    |m: &OperationOutcomeCodesCode| { &m.value },
                    |m: &mut OperationOutcomeCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &OperationOutcomeCodesCode| { &m.id },
                    |m: &mut OperationOutcomeCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &OperationOutcomeCodesCode| { &m.extension },
                    |m: &mut OperationOutcomeCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationOutcomeCodesCode>(
                    "OperationOutcomeCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperationOutcomeCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<OperationOutcomeCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationOutcomeCodesCode,
        };
        unsafe {
            instance.get(OperationOutcomeCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for OperationOutcomeCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationOutcomeCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationOutcomeCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperationOutcomeCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    MSG_AUTH_REQUIRED = 1,
    MSG_BAD_FORMAT = 2,
    MSG_BAD_SYNTAX = 3,
    MSG_CANT_PARSE_CONTENT = 4,
    MSG_CANT_PARSE_ROOT = 5,
    MSG_CREATED = 6,
    MSG_DATE_FORMAT = 7,
    MSG_DELETED = 8,
    MSG_DELETED_DONE = 9,
    MSG_DELETED_ID = 10,
    MSG_DUPLICATE_ID = 11,
    MSG_ERROR_PARSING = 12,
    MSG_ID_INVALID = 13,
    MSG_ID_TOO_LONG = 14,
    MSG_INVALID_ID = 15,
    MSG_JSON_OBJECT = 16,
    MSG_LOCAL_FAIL = 17,
    MSG_NO_MATCH = 18,
    MSG_NO_EXIST = 19,
    MSG_NO_MODULE = 20,
    MSG_NO_SUMMARY = 21,
    MSG_OP_NOT_ALLOWED = 22,
    MSG_PARAM_CHAINED = 23,
    MSG_PARAM_NO_REPEAT = 24,
    MSG_PARAM_UNKNOWN = 25,
    MSG_PARAM_INVALID = 26,
    MSG_PARAM_MODIFIER_INVALID = 27,
    MSG_RESOURCE_EXAMPLE_PROTECTED = 28,
    MSG_RESOURCE_ID_FAIL = 29,
    MSG_RESOURCE_NOT_ALLOWED = 30,
    MSG_RESOURCE_REQUIRED = 31,
    MSG_RESOURCE_ID_MISMATCH = 32,
    MSG_RESOURCE_ID_MISSING = 33,
    MSG_RESOURCE_TYPE_MISMATCH = 34,
    MSG_SORT_UNKNOWN = 35,
    MSG_TRANSACTION_DUPLICATE_ID = 36,
    MSG_TRANSACTION_MISSING_ID = 37,
    MSG_UNHANDLED_NODE_TYPE = 38,
    MSG_UNKNOWN_CONTENT = 39,
    MSG_UNKNOWN_OPERATION = 40,
    MSG_UNKNOWN_TYPE = 41,
    MSG_UPDATED = 42,
    MSG_VERSION_AWARE = 43,
    MSG_VERSION_AWARE_CONFLICT = 44,
    MSG_VERSION_AWARE_URL = 45,
    MSG_WRONG_NS = 46,
    SEARCH_MULTIPLE = 47,
    UPDATE_MULTIPLE_MATCHES = 48,
    DELETE_MULTIPLE_MATCHES = 49,
    SEARCH_NONE = 50,
}

impl ::protobuf::ProtobufEnum for OperationOutcomeCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperationOutcomeCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_AUTH_REQUIRED),
            2 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_BAD_FORMAT),
            3 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_BAD_SYNTAX),
            4 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_CANT_PARSE_CONTENT),
            5 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_CANT_PARSE_ROOT),
            6 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_CREATED),
            7 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_DATE_FORMAT),
            8 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_DELETED),
            9 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_DELETED_DONE),
            10 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_DELETED_ID),
            11 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_DUPLICATE_ID),
            12 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_ERROR_PARSING),
            13 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_ID_INVALID),
            14 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_ID_TOO_LONG),
            15 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_INVALID_ID),
            16 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_JSON_OBJECT),
            17 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_LOCAL_FAIL),
            18 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_NO_MATCH),
            19 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_NO_EXIST),
            20 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_NO_MODULE),
            21 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_NO_SUMMARY),
            22 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_OP_NOT_ALLOWED),
            23 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_PARAM_CHAINED),
            24 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_PARAM_NO_REPEAT),
            25 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_PARAM_UNKNOWN),
            26 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_PARAM_INVALID),
            27 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_PARAM_MODIFIER_INVALID),
            28 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_RESOURCE_EXAMPLE_PROTECTED),
            29 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_RESOURCE_ID_FAIL),
            30 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_RESOURCE_NOT_ALLOWED),
            31 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_RESOURCE_REQUIRED),
            32 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_RESOURCE_ID_MISMATCH),
            33 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_RESOURCE_ID_MISSING),
            34 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_RESOURCE_TYPE_MISMATCH),
            35 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_SORT_UNKNOWN),
            36 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_TRANSACTION_DUPLICATE_ID),
            37 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_TRANSACTION_MISSING_ID),
            38 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_UNHANDLED_NODE_TYPE),
            39 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_UNKNOWN_CONTENT),
            40 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_UNKNOWN_OPERATION),
            41 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_UNKNOWN_TYPE),
            42 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_UPDATED),
            43 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_VERSION_AWARE),
            44 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_VERSION_AWARE_CONFLICT),
            45 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_VERSION_AWARE_URL),
            46 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::MSG_WRONG_NS),
            47 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::SEARCH_MULTIPLE),
            48 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::UPDATE_MULTIPLE_MATCHES),
            49 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::DELETE_MULTIPLE_MATCHES),
            50 => ::std::option::Option::Some(OperationOutcomeCodesCode_Value::SEARCH_NONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperationOutcomeCodesCode_Value] = &[
            OperationOutcomeCodesCode_Value::INVALID_UNINITIALIZED,
            OperationOutcomeCodesCode_Value::MSG_AUTH_REQUIRED,
            OperationOutcomeCodesCode_Value::MSG_BAD_FORMAT,
            OperationOutcomeCodesCode_Value::MSG_BAD_SYNTAX,
            OperationOutcomeCodesCode_Value::MSG_CANT_PARSE_CONTENT,
            OperationOutcomeCodesCode_Value::MSG_CANT_PARSE_ROOT,
            OperationOutcomeCodesCode_Value::MSG_CREATED,
            OperationOutcomeCodesCode_Value::MSG_DATE_FORMAT,
            OperationOutcomeCodesCode_Value::MSG_DELETED,
            OperationOutcomeCodesCode_Value::MSG_DELETED_DONE,
            OperationOutcomeCodesCode_Value::MSG_DELETED_ID,
            OperationOutcomeCodesCode_Value::MSG_DUPLICATE_ID,
            OperationOutcomeCodesCode_Value::MSG_ERROR_PARSING,
            OperationOutcomeCodesCode_Value::MSG_ID_INVALID,
            OperationOutcomeCodesCode_Value::MSG_ID_TOO_LONG,
            OperationOutcomeCodesCode_Value::MSG_INVALID_ID,
            OperationOutcomeCodesCode_Value::MSG_JSON_OBJECT,
            OperationOutcomeCodesCode_Value::MSG_LOCAL_FAIL,
            OperationOutcomeCodesCode_Value::MSG_NO_MATCH,
            OperationOutcomeCodesCode_Value::MSG_NO_EXIST,
            OperationOutcomeCodesCode_Value::MSG_NO_MODULE,
            OperationOutcomeCodesCode_Value::MSG_NO_SUMMARY,
            OperationOutcomeCodesCode_Value::MSG_OP_NOT_ALLOWED,
            OperationOutcomeCodesCode_Value::MSG_PARAM_CHAINED,
            OperationOutcomeCodesCode_Value::MSG_PARAM_NO_REPEAT,
            OperationOutcomeCodesCode_Value::MSG_PARAM_UNKNOWN,
            OperationOutcomeCodesCode_Value::MSG_PARAM_INVALID,
            OperationOutcomeCodesCode_Value::MSG_PARAM_MODIFIER_INVALID,
            OperationOutcomeCodesCode_Value::MSG_RESOURCE_EXAMPLE_PROTECTED,
            OperationOutcomeCodesCode_Value::MSG_RESOURCE_ID_FAIL,
            OperationOutcomeCodesCode_Value::MSG_RESOURCE_NOT_ALLOWED,
            OperationOutcomeCodesCode_Value::MSG_RESOURCE_REQUIRED,
            OperationOutcomeCodesCode_Value::MSG_RESOURCE_ID_MISMATCH,
            OperationOutcomeCodesCode_Value::MSG_RESOURCE_ID_MISSING,
            OperationOutcomeCodesCode_Value::MSG_RESOURCE_TYPE_MISMATCH,
            OperationOutcomeCodesCode_Value::MSG_SORT_UNKNOWN,
            OperationOutcomeCodesCode_Value::MSG_TRANSACTION_DUPLICATE_ID,
            OperationOutcomeCodesCode_Value::MSG_TRANSACTION_MISSING_ID,
            OperationOutcomeCodesCode_Value::MSG_UNHANDLED_NODE_TYPE,
            OperationOutcomeCodesCode_Value::MSG_UNKNOWN_CONTENT,
            OperationOutcomeCodesCode_Value::MSG_UNKNOWN_OPERATION,
            OperationOutcomeCodesCode_Value::MSG_UNKNOWN_TYPE,
            OperationOutcomeCodesCode_Value::MSG_UPDATED,
            OperationOutcomeCodesCode_Value::MSG_VERSION_AWARE,
            OperationOutcomeCodesCode_Value::MSG_VERSION_AWARE_CONFLICT,
            OperationOutcomeCodesCode_Value::MSG_VERSION_AWARE_URL,
            OperationOutcomeCodesCode_Value::MSG_WRONG_NS,
            OperationOutcomeCodesCode_Value::SEARCH_MULTIPLE,
            OperationOutcomeCodesCode_Value::UPDATE_MULTIPLE_MATCHES,
            OperationOutcomeCodesCode_Value::DELETE_MULTIPLE_MATCHES,
            OperationOutcomeCodesCode_Value::SEARCH_NONE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OperationOutcomeCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OperationOutcomeCodesCode_Value {
}

impl ::std::default::Default for OperationOutcomeCodesCode_Value {
    fn default() -> Self {
        OperationOutcomeCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationOutcomeCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NarrativeStatusCode {
    // message fields
    pub value: NarrativeStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NarrativeStatusCode {
    pub fn new() -> NarrativeStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.NarrativeStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = NarrativeStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: NarrativeStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> NarrativeStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for NarrativeStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != NarrativeStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != NarrativeStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NarrativeStatusCode {
        NarrativeStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NarrativeStatusCode_Value>>(
                    "value",
                    |m: &NarrativeStatusCode| { &m.value },
                    |m: &mut NarrativeStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &NarrativeStatusCode| { &m.id },
                    |m: &mut NarrativeStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &NarrativeStatusCode| { &m.extension },
                    |m: &mut NarrativeStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NarrativeStatusCode>(
                    "NarrativeStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NarrativeStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<NarrativeStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NarrativeStatusCode,
        };
        unsafe {
            instance.get(NarrativeStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for NarrativeStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NarrativeStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NarrativeStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NarrativeStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    GENERATED = 1,
    EXTENSIONS = 2,
    ADDITIONAL = 3,
    EMPTY = 4,
}

impl ::protobuf::ProtobufEnum for NarrativeStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NarrativeStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(NarrativeStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(NarrativeStatusCode_Value::GENERATED),
            2 => ::std::option::Option::Some(NarrativeStatusCode_Value::EXTENSIONS),
            3 => ::std::option::Option::Some(NarrativeStatusCode_Value::ADDITIONAL),
            4 => ::std::option::Option::Some(NarrativeStatusCode_Value::EMPTY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NarrativeStatusCode_Value] = &[
            NarrativeStatusCode_Value::INVALID_UNINITIALIZED,
            NarrativeStatusCode_Value::GENERATED,
            NarrativeStatusCode_Value::EXTENSIONS,
            NarrativeStatusCode_Value::ADDITIONAL,
            NarrativeStatusCode_Value::EMPTY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NarrativeStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NarrativeStatusCode_Value {
}

impl ::std::default::Default for NarrativeStatusCode_Value {
    fn default() -> Self {
        NarrativeStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for NarrativeStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationParameterUseCode {
    // message fields
    pub value: OperationParameterUseCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl OperationParameterUseCode {
    pub fn new() -> OperationParameterUseCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.OperationParameterUseCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = OperationParameterUseCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: OperationParameterUseCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> OperationParameterUseCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for OperationParameterUseCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != OperationParameterUseCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != OperationParameterUseCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationParameterUseCode {
        OperationParameterUseCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationParameterUseCode_Value>>(
                    "value",
                    |m: &OperationParameterUseCode| { &m.value },
                    |m: &mut OperationParameterUseCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &OperationParameterUseCode| { &m.id },
                    |m: &mut OperationParameterUseCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &OperationParameterUseCode| { &m.extension },
                    |m: &mut OperationParameterUseCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationParameterUseCode>(
                    "OperationParameterUseCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperationParameterUseCode {
        static mut instance: ::protobuf::lazy::Lazy<OperationParameterUseCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationParameterUseCode,
        };
        unsafe {
            instance.get(OperationParameterUseCode::new)
        }
    }
}

impl ::protobuf::Clear for OperationParameterUseCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationParameterUseCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationParameterUseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperationParameterUseCode_Value {
    INVALID_UNINITIALIZED = 0,
    IN = 1,
    OUT = 2,
}

impl ::protobuf::ProtobufEnum for OperationParameterUseCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperationParameterUseCode_Value> {
        match value {
            0 => ::std::option::Option::Some(OperationParameterUseCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(OperationParameterUseCode_Value::IN),
            2 => ::std::option::Option::Some(OperationParameterUseCode_Value::OUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperationParameterUseCode_Value] = &[
            OperationParameterUseCode_Value::INVALID_UNINITIALIZED,
            OperationParameterUseCode_Value::IN,
            OperationParameterUseCode_Value::OUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OperationParameterUseCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OperationParameterUseCode_Value {
}

impl ::std::default::Default for OperationParameterUseCode_Value {
    fn default() -> Self {
        OperationParameterUseCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationParameterUseCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OrganizationTypeCode {
    // message fields
    pub value: OrganizationTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl OrganizationTypeCode {
    pub fn new() -> OrganizationTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.OrganizationTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = OrganizationTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: OrganizationTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> OrganizationTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for OrganizationTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != OrganizationTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != OrganizationTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrganizationTypeCode {
        OrganizationTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OrganizationTypeCode_Value>>(
                    "value",
                    |m: &OrganizationTypeCode| { &m.value },
                    |m: &mut OrganizationTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &OrganizationTypeCode| { &m.id },
                    |m: &mut OrganizationTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &OrganizationTypeCode| { &m.extension },
                    |m: &mut OrganizationTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OrganizationTypeCode>(
                    "OrganizationTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OrganizationTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<OrganizationTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OrganizationTypeCode,
        };
        unsafe {
            instance.get(OrganizationTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for OrganizationTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OrganizationTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OrganizationTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OrganizationTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROV = 1,
    DEPT = 2,
    TEAM = 3,
    GOVT = 4,
    INS = 5,
    EDU = 6,
    RELI = 7,
    CRS = 8,
    CG = 9,
    BUS = 10,
    OTHER = 11,
}

impl ::protobuf::ProtobufEnum for OrganizationTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrganizationTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(OrganizationTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(OrganizationTypeCode_Value::PROV),
            2 => ::std::option::Option::Some(OrganizationTypeCode_Value::DEPT),
            3 => ::std::option::Option::Some(OrganizationTypeCode_Value::TEAM),
            4 => ::std::option::Option::Some(OrganizationTypeCode_Value::GOVT),
            5 => ::std::option::Option::Some(OrganizationTypeCode_Value::INS),
            6 => ::std::option::Option::Some(OrganizationTypeCode_Value::EDU),
            7 => ::std::option::Option::Some(OrganizationTypeCode_Value::RELI),
            8 => ::std::option::Option::Some(OrganizationTypeCode_Value::CRS),
            9 => ::std::option::Option::Some(OrganizationTypeCode_Value::CG),
            10 => ::std::option::Option::Some(OrganizationTypeCode_Value::BUS),
            11 => ::std::option::Option::Some(OrganizationTypeCode_Value::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OrganizationTypeCode_Value] = &[
            OrganizationTypeCode_Value::INVALID_UNINITIALIZED,
            OrganizationTypeCode_Value::PROV,
            OrganizationTypeCode_Value::DEPT,
            OrganizationTypeCode_Value::TEAM,
            OrganizationTypeCode_Value::GOVT,
            OrganizationTypeCode_Value::INS,
            OrganizationTypeCode_Value::EDU,
            OrganizationTypeCode_Value::RELI,
            OrganizationTypeCode_Value::CRS,
            OrganizationTypeCode_Value::CG,
            OrganizationTypeCode_Value::BUS,
            OrganizationTypeCode_Value::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OrganizationTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OrganizationTypeCode_Value {
}

impl ::std::default::Default for OrganizationTypeCode_Value {
    fn default() -> Self {
        OrganizationTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for OrganizationTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceComponentParameterGroupCode {
    // message fields
    pub value: DeviceComponentParameterGroupCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeviceComponentParameterGroupCode {
    pub fn new() -> DeviceComponentParameterGroupCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DeviceComponentParameterGroupCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DeviceComponentParameterGroupCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DeviceComponentParameterGroupCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DeviceComponentParameterGroupCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DeviceComponentParameterGroupCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DeviceComponentParameterGroupCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DeviceComponentParameterGroupCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceComponentParameterGroupCode {
        DeviceComponentParameterGroupCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DeviceComponentParameterGroupCode_Value>>(
                    "value",
                    |m: &DeviceComponentParameterGroupCode| { &m.value },
                    |m: &mut DeviceComponentParameterGroupCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DeviceComponentParameterGroupCode| { &m.id },
                    |m: &mut DeviceComponentParameterGroupCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DeviceComponentParameterGroupCode| { &m.extension },
                    |m: &mut DeviceComponentParameterGroupCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceComponentParameterGroupCode>(
                    "DeviceComponentParameterGroupCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceComponentParameterGroupCode {
        static mut instance: ::protobuf::lazy::Lazy<DeviceComponentParameterGroupCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceComponentParameterGroupCode,
        };
        unsafe {
            instance.get(DeviceComponentParameterGroupCode::new)
        }
    }
}

impl ::protobuf::Clear for DeviceComponentParameterGroupCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceComponentParameterGroupCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceComponentParameterGroupCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeviceComponentParameterGroupCode_Value {
    INVALID_UNINITIALIZED = 0,
    HAEMODYNAMIC = 1,
    ECG = 2,
    RESPIRATORY = 3,
    VENTILATION = 4,
    NEUROLOGICAL = 5,
    DRUG_DELIVERY = 6,
    FLUID_CHEMISTRY = 7,
    BLOOD_CHEMISTRY = 8,
    MISCELLANEOUS = 9,
}

impl ::protobuf::ProtobufEnum for DeviceComponentParameterGroupCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceComponentParameterGroupCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DeviceComponentParameterGroupCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DeviceComponentParameterGroupCode_Value::HAEMODYNAMIC),
            2 => ::std::option::Option::Some(DeviceComponentParameterGroupCode_Value::ECG),
            3 => ::std::option::Option::Some(DeviceComponentParameterGroupCode_Value::RESPIRATORY),
            4 => ::std::option::Option::Some(DeviceComponentParameterGroupCode_Value::VENTILATION),
            5 => ::std::option::Option::Some(DeviceComponentParameterGroupCode_Value::NEUROLOGICAL),
            6 => ::std::option::Option::Some(DeviceComponentParameterGroupCode_Value::DRUG_DELIVERY),
            7 => ::std::option::Option::Some(DeviceComponentParameterGroupCode_Value::FLUID_CHEMISTRY),
            8 => ::std::option::Option::Some(DeviceComponentParameterGroupCode_Value::BLOOD_CHEMISTRY),
            9 => ::std::option::Option::Some(DeviceComponentParameterGroupCode_Value::MISCELLANEOUS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeviceComponentParameterGroupCode_Value] = &[
            DeviceComponentParameterGroupCode_Value::INVALID_UNINITIALIZED,
            DeviceComponentParameterGroupCode_Value::HAEMODYNAMIC,
            DeviceComponentParameterGroupCode_Value::ECG,
            DeviceComponentParameterGroupCode_Value::RESPIRATORY,
            DeviceComponentParameterGroupCode_Value::VENTILATION,
            DeviceComponentParameterGroupCode_Value::NEUROLOGICAL,
            DeviceComponentParameterGroupCode_Value::DRUG_DELIVERY,
            DeviceComponentParameterGroupCode_Value::FLUID_CHEMISTRY,
            DeviceComponentParameterGroupCode_Value::BLOOD_CHEMISTRY,
            DeviceComponentParameterGroupCode_Value::MISCELLANEOUS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DeviceComponentParameterGroupCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DeviceComponentParameterGroupCode_Value {
}

impl ::std::default::Default for DeviceComponentParameterGroupCode_Value {
    fn default() -> Self {
        DeviceComponentParameterGroupCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceComponentParameterGroupCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ParticipantRequiredCode {
    // message fields
    pub value: ParticipantRequiredCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ParticipantRequiredCode {
    pub fn new() -> ParticipantRequiredCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ParticipantRequiredCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ParticipantRequiredCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ParticipantRequiredCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ParticipantRequiredCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ParticipantRequiredCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ParticipantRequiredCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ParticipantRequiredCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParticipantRequiredCode {
        ParticipantRequiredCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ParticipantRequiredCode_Value>>(
                    "value",
                    |m: &ParticipantRequiredCode| { &m.value },
                    |m: &mut ParticipantRequiredCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ParticipantRequiredCode| { &m.id },
                    |m: &mut ParticipantRequiredCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ParticipantRequiredCode| { &m.extension },
                    |m: &mut ParticipantRequiredCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ParticipantRequiredCode>(
                    "ParticipantRequiredCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ParticipantRequiredCode {
        static mut instance: ::protobuf::lazy::Lazy<ParticipantRequiredCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ParticipantRequiredCode,
        };
        unsafe {
            instance.get(ParticipantRequiredCode::new)
        }
    }
}

impl ::protobuf::Clear for ParticipantRequiredCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParticipantRequiredCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParticipantRequiredCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ParticipantRequiredCode_Value {
    INVALID_UNINITIALIZED = 0,
    REQUIRED = 1,
    OPTIONAL = 2,
    INFORMATION_ONLY = 3,
}

impl ::protobuf::ProtobufEnum for ParticipantRequiredCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ParticipantRequiredCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ParticipantRequiredCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ParticipantRequiredCode_Value::REQUIRED),
            2 => ::std::option::Option::Some(ParticipantRequiredCode_Value::OPTIONAL),
            3 => ::std::option::Option::Some(ParticipantRequiredCode_Value::INFORMATION_ONLY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ParticipantRequiredCode_Value] = &[
            ParticipantRequiredCode_Value::INVALID_UNINITIALIZED,
            ParticipantRequiredCode_Value::REQUIRED,
            ParticipantRequiredCode_Value::OPTIONAL,
            ParticipantRequiredCode_Value::INFORMATION_ONLY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ParticipantRequiredCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ParticipantRequiredCode_Value {
}

impl ::std::default::Default for ParticipantRequiredCode_Value {
    fn default() -> Self {
        ParticipantRequiredCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ParticipantRequiredCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ParticipationStatusCode {
    // message fields
    pub value: ParticipationStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ParticipationStatusCode {
    pub fn new() -> ParticipationStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ParticipationStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ParticipationStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ParticipationStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ParticipationStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ParticipationStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ParticipationStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ParticipationStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParticipationStatusCode {
        ParticipationStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ParticipationStatusCode_Value>>(
                    "value",
                    |m: &ParticipationStatusCode| { &m.value },
                    |m: &mut ParticipationStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ParticipationStatusCode| { &m.id },
                    |m: &mut ParticipationStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ParticipationStatusCode| { &m.extension },
                    |m: &mut ParticipationStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ParticipationStatusCode>(
                    "ParticipationStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ParticipationStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ParticipationStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ParticipationStatusCode,
        };
        unsafe {
            instance.get(ParticipationStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ParticipationStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParticipationStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParticipationStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ParticipationStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACCEPTED = 1,
    DECLINED = 2,
    TENTATIVE = 3,
    NEEDS_ACTION = 4,
}

impl ::protobuf::ProtobufEnum for ParticipationStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ParticipationStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ParticipationStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ParticipationStatusCode_Value::ACCEPTED),
            2 => ::std::option::Option::Some(ParticipationStatusCode_Value::DECLINED),
            3 => ::std::option::Option::Some(ParticipationStatusCode_Value::TENTATIVE),
            4 => ::std::option::Option::Some(ParticipationStatusCode_Value::NEEDS_ACTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ParticipationStatusCode_Value] = &[
            ParticipationStatusCode_Value::INVALID_UNINITIALIZED,
            ParticipationStatusCode_Value::ACCEPTED,
            ParticipationStatusCode_Value::DECLINED,
            ParticipationStatusCode_Value::TENTATIVE,
            ParticipationStatusCode_Value::NEEDS_ACTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ParticipationStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ParticipationStatusCode_Value {
}

impl ::std::default::Default for ParticipationStatusCode_Value {
    fn default() -> Self {
        ParticipationStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ParticipationStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlanDefinitionTypeCode {
    // message fields
    pub value: PlanDefinitionTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PlanDefinitionTypeCode {
    pub fn new() -> PlanDefinitionTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.PlanDefinitionTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = PlanDefinitionTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: PlanDefinitionTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> PlanDefinitionTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for PlanDefinitionTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != PlanDefinitionTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != PlanDefinitionTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlanDefinitionTypeCode {
        PlanDefinitionTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PlanDefinitionTypeCode_Value>>(
                    "value",
                    |m: &PlanDefinitionTypeCode| { &m.value },
                    |m: &mut PlanDefinitionTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &PlanDefinitionTypeCode| { &m.id },
                    |m: &mut PlanDefinitionTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &PlanDefinitionTypeCode| { &m.extension },
                    |m: &mut PlanDefinitionTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PlanDefinitionTypeCode>(
                    "PlanDefinitionTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PlanDefinitionTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<PlanDefinitionTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PlanDefinitionTypeCode,
        };
        unsafe {
            instance.get(PlanDefinitionTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for PlanDefinitionTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlanDefinitionTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlanDefinitionTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PlanDefinitionTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    ORDER_SET = 1,
    PROTOCOL = 2,
    ECA_RULE = 3,
}

impl ::protobuf::ProtobufEnum for PlanDefinitionTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PlanDefinitionTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(PlanDefinitionTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(PlanDefinitionTypeCode_Value::ORDER_SET),
            2 => ::std::option::Option::Some(PlanDefinitionTypeCode_Value::PROTOCOL),
            3 => ::std::option::Option::Some(PlanDefinitionTypeCode_Value::ECA_RULE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PlanDefinitionTypeCode_Value] = &[
            PlanDefinitionTypeCode_Value::INVALID_UNINITIALIZED,
            PlanDefinitionTypeCode_Value::ORDER_SET,
            PlanDefinitionTypeCode_Value::PROTOCOL,
            PlanDefinitionTypeCode_Value::ECA_RULE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PlanDefinitionTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PlanDefinitionTypeCode_Value {
}

impl ::std::default::Default for PlanDefinitionTypeCode_Value {
    fn default() -> Self {
        PlanDefinitionTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for PlanDefinitionTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PostalAddressUseTypeCode {
    // message fields
    pub value: PostalAddressUseTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PostalAddressUseTypeCode {
    pub fn new() -> PostalAddressUseTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.PostalAddressUseTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = PostalAddressUseTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: PostalAddressUseTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> PostalAddressUseTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for PostalAddressUseTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != PostalAddressUseTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != PostalAddressUseTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PostalAddressUseTypeCode {
        PostalAddressUseTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PostalAddressUseTypeCode_Value>>(
                    "value",
                    |m: &PostalAddressUseTypeCode| { &m.value },
                    |m: &mut PostalAddressUseTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &PostalAddressUseTypeCode| { &m.id },
                    |m: &mut PostalAddressUseTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &PostalAddressUseTypeCode| { &m.extension },
                    |m: &mut PostalAddressUseTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PostalAddressUseTypeCode>(
                    "PostalAddressUseTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PostalAddressUseTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<PostalAddressUseTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PostalAddressUseTypeCode,
        };
        unsafe {
            instance.get(PostalAddressUseTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for PostalAddressUseTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PostalAddressUseTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PostalAddressUseTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PostalAddressUseTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    BAD_ADDRESS = 1,
    CONFIDENTIAL_ADDRESS = 2,
    PRIMARY_HOME = 3,
    VACATION_HOME = 4,
    DIRECT = 5,
    PUBLIC = 6,
    PHYSICAL_VISIT_ADDRESS = 7,
    POSTAL_ADDRESS = 8,
}

impl ::protobuf::ProtobufEnum for PostalAddressUseTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PostalAddressUseTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(PostalAddressUseTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(PostalAddressUseTypeCode_Value::BAD_ADDRESS),
            2 => ::std::option::Option::Some(PostalAddressUseTypeCode_Value::CONFIDENTIAL_ADDRESS),
            3 => ::std::option::Option::Some(PostalAddressUseTypeCode_Value::PRIMARY_HOME),
            4 => ::std::option::Option::Some(PostalAddressUseTypeCode_Value::VACATION_HOME),
            5 => ::std::option::Option::Some(PostalAddressUseTypeCode_Value::DIRECT),
            6 => ::std::option::Option::Some(PostalAddressUseTypeCode_Value::PUBLIC),
            7 => ::std::option::Option::Some(PostalAddressUseTypeCode_Value::PHYSICAL_VISIT_ADDRESS),
            8 => ::std::option::Option::Some(PostalAddressUseTypeCode_Value::POSTAL_ADDRESS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PostalAddressUseTypeCode_Value] = &[
            PostalAddressUseTypeCode_Value::INVALID_UNINITIALIZED,
            PostalAddressUseTypeCode_Value::BAD_ADDRESS,
            PostalAddressUseTypeCode_Value::CONFIDENTIAL_ADDRESS,
            PostalAddressUseTypeCode_Value::PRIMARY_HOME,
            PostalAddressUseTypeCode_Value::VACATION_HOME,
            PostalAddressUseTypeCode_Value::DIRECT,
            PostalAddressUseTypeCode_Value::PUBLIC,
            PostalAddressUseTypeCode_Value::PHYSICAL_VISIT_ADDRESS,
            PostalAddressUseTypeCode_Value::POSTAL_ADDRESS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PostalAddressUseTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PostalAddressUseTypeCode_Value {
}

impl ::std::default::Default for PostalAddressUseTypeCode_Value {
    fn default() -> Self {
        PostalAddressUseTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for PostalAddressUseTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PractitionerRoleCode {
    // message fields
    pub value: PractitionerRoleCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PractitionerRoleCode {
    pub fn new() -> PractitionerRoleCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.PractitionerRoleCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = PractitionerRoleCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: PractitionerRoleCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> PractitionerRoleCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for PractitionerRoleCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != PractitionerRoleCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != PractitionerRoleCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PractitionerRoleCode {
        PractitionerRoleCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PractitionerRoleCode_Value>>(
                    "value",
                    |m: &PractitionerRoleCode| { &m.value },
                    |m: &mut PractitionerRoleCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &PractitionerRoleCode| { &m.id },
                    |m: &mut PractitionerRoleCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &PractitionerRoleCode| { &m.extension },
                    |m: &mut PractitionerRoleCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PractitionerRoleCode>(
                    "PractitionerRoleCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PractitionerRoleCode {
        static mut instance: ::protobuf::lazy::Lazy<PractitionerRoleCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PractitionerRoleCode,
        };
        unsafe {
            instance.get(PractitionerRoleCode::new)
        }
    }
}

impl ::protobuf::Clear for PractitionerRoleCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PractitionerRoleCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PractitionerRoleCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PractitionerRoleCode_Value {
    INVALID_UNINITIALIZED = 0,
    DOCTOR = 1,
    NURSE = 2,
    PHARMACIST = 3,
    RESEARCHER = 4,
    TEACHER = 5,
    ICT = 6,
}

impl ::protobuf::ProtobufEnum for PractitionerRoleCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PractitionerRoleCode_Value> {
        match value {
            0 => ::std::option::Option::Some(PractitionerRoleCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(PractitionerRoleCode_Value::DOCTOR),
            2 => ::std::option::Option::Some(PractitionerRoleCode_Value::NURSE),
            3 => ::std::option::Option::Some(PractitionerRoleCode_Value::PHARMACIST),
            4 => ::std::option::Option::Some(PractitionerRoleCode_Value::RESEARCHER),
            5 => ::std::option::Option::Some(PractitionerRoleCode_Value::TEACHER),
            6 => ::std::option::Option::Some(PractitionerRoleCode_Value::ICT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PractitionerRoleCode_Value] = &[
            PractitionerRoleCode_Value::INVALID_UNINITIALIZED,
            PractitionerRoleCode_Value::DOCTOR,
            PractitionerRoleCode_Value::NURSE,
            PractitionerRoleCode_Value::PHARMACIST,
            PractitionerRoleCode_Value::RESEARCHER,
            PractitionerRoleCode_Value::TEACHER,
            PractitionerRoleCode_Value::ICT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PractitionerRoleCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PractitionerRoleCode_Value {
}

impl ::std::default::Default for PractitionerRoleCode_Value {
    fn default() -> Self {
        PractitionerRoleCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for PractitionerRoleCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PractitionerSpecialtyCode {
    // message fields
    pub value: PractitionerSpecialtyCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PractitionerSpecialtyCode {
    pub fn new() -> PractitionerSpecialtyCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.PractitionerSpecialtyCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = PractitionerSpecialtyCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: PractitionerSpecialtyCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> PractitionerSpecialtyCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for PractitionerSpecialtyCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != PractitionerSpecialtyCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != PractitionerSpecialtyCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PractitionerSpecialtyCode {
        PractitionerSpecialtyCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PractitionerSpecialtyCode_Value>>(
                    "value",
                    |m: &PractitionerSpecialtyCode| { &m.value },
                    |m: &mut PractitionerSpecialtyCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &PractitionerSpecialtyCode| { &m.id },
                    |m: &mut PractitionerSpecialtyCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &PractitionerSpecialtyCode| { &m.extension },
                    |m: &mut PractitionerSpecialtyCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PractitionerSpecialtyCode>(
                    "PractitionerSpecialtyCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PractitionerSpecialtyCode {
        static mut instance: ::protobuf::lazy::Lazy<PractitionerSpecialtyCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PractitionerSpecialtyCode,
        };
        unsafe {
            instance.get(PractitionerSpecialtyCode::new)
        }
    }
}

impl ::protobuf::Clear for PractitionerSpecialtyCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PractitionerSpecialtyCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PractitionerSpecialtyCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PractitionerSpecialtyCode_Value {
    INVALID_UNINITIALIZED = 0,
    CARDIO = 1,
    DENT = 2,
    DIETARY = 3,
    MIDW = 4,
    SYSARCH = 5,
}

impl ::protobuf::ProtobufEnum for PractitionerSpecialtyCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PractitionerSpecialtyCode_Value> {
        match value {
            0 => ::std::option::Option::Some(PractitionerSpecialtyCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(PractitionerSpecialtyCode_Value::CARDIO),
            2 => ::std::option::Option::Some(PractitionerSpecialtyCode_Value::DENT),
            3 => ::std::option::Option::Some(PractitionerSpecialtyCode_Value::DIETARY),
            4 => ::std::option::Option::Some(PractitionerSpecialtyCode_Value::MIDW),
            5 => ::std::option::Option::Some(PractitionerSpecialtyCode_Value::SYSARCH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PractitionerSpecialtyCode_Value] = &[
            PractitionerSpecialtyCode_Value::INVALID_UNINITIALIZED,
            PractitionerSpecialtyCode_Value::CARDIO,
            PractitionerSpecialtyCode_Value::DENT,
            PractitionerSpecialtyCode_Value::DIETARY,
            PractitionerSpecialtyCode_Value::MIDW,
            PractitionerSpecialtyCode_Value::SYSARCH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PractitionerSpecialtyCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PractitionerSpecialtyCode_Value {
}

impl ::std::default::Default for PractitionerSpecialtyCode_Value {
    fn default() -> Self {
        PractitionerSpecialtyCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for PractitionerSpecialtyCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProcedureProgressStatusCodesCode {
    // message fields
    pub value: ProcedureProgressStatusCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ProcedureProgressStatusCodesCode {
    pub fn new() -> ProcedureProgressStatusCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ProcedureProgressStatusCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ProcedureProgressStatusCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ProcedureProgressStatusCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ProcedureProgressStatusCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ProcedureProgressStatusCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ProcedureProgressStatusCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ProcedureProgressStatusCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProcedureProgressStatusCodesCode {
        ProcedureProgressStatusCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ProcedureProgressStatusCodesCode_Value>>(
                    "value",
                    |m: &ProcedureProgressStatusCodesCode| { &m.value },
                    |m: &mut ProcedureProgressStatusCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ProcedureProgressStatusCodesCode| { &m.id },
                    |m: &mut ProcedureProgressStatusCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ProcedureProgressStatusCodesCode| { &m.extension },
                    |m: &mut ProcedureProgressStatusCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProcedureProgressStatusCodesCode>(
                    "ProcedureProgressStatusCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProcedureProgressStatusCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ProcedureProgressStatusCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProcedureProgressStatusCodesCode,
        };
        unsafe {
            instance.get(ProcedureProgressStatusCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ProcedureProgressStatusCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProcedureProgressStatusCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcedureProgressStatusCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProcedureProgressStatusCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    IN_OPERATING_ROOM = 1,
    PREPARED = 2,
    ANESTHESIA_INDUCED = 3,
    OPEN_INCISION = 4,
    CLOSED_INCISION = 5,
    IN_RECOVERY_ROOM = 6,
}

impl ::protobuf::ProtobufEnum for ProcedureProgressStatusCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProcedureProgressStatusCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ProcedureProgressStatusCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ProcedureProgressStatusCodesCode_Value::IN_OPERATING_ROOM),
            2 => ::std::option::Option::Some(ProcedureProgressStatusCodesCode_Value::PREPARED),
            3 => ::std::option::Option::Some(ProcedureProgressStatusCodesCode_Value::ANESTHESIA_INDUCED),
            4 => ::std::option::Option::Some(ProcedureProgressStatusCodesCode_Value::OPEN_INCISION),
            5 => ::std::option::Option::Some(ProcedureProgressStatusCodesCode_Value::CLOSED_INCISION),
            6 => ::std::option::Option::Some(ProcedureProgressStatusCodesCode_Value::IN_RECOVERY_ROOM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProcedureProgressStatusCodesCode_Value] = &[
            ProcedureProgressStatusCodesCode_Value::INVALID_UNINITIALIZED,
            ProcedureProgressStatusCodesCode_Value::IN_OPERATING_ROOM,
            ProcedureProgressStatusCodesCode_Value::PREPARED,
            ProcedureProgressStatusCodesCode_Value::ANESTHESIA_INDUCED,
            ProcedureProgressStatusCodesCode_Value::OPEN_INCISION,
            ProcedureProgressStatusCodesCode_Value::CLOSED_INCISION,
            ProcedureProgressStatusCodesCode_Value::IN_RECOVERY_ROOM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ProcedureProgressStatusCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ProcedureProgressStatusCodesCode_Value {
}

impl ::std::default::Default for ProcedureProgressStatusCodesCode_Value {
    fn default() -> Self {
        ProcedureProgressStatusCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcedureProgressStatusCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProvenanceEntityRoleCode {
    // message fields
    pub value: ProvenanceEntityRoleCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ProvenanceEntityRoleCode {
    pub fn new() -> ProvenanceEntityRoleCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ProvenanceEntityRoleCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ProvenanceEntityRoleCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ProvenanceEntityRoleCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ProvenanceEntityRoleCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ProvenanceEntityRoleCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ProvenanceEntityRoleCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ProvenanceEntityRoleCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProvenanceEntityRoleCode {
        ProvenanceEntityRoleCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ProvenanceEntityRoleCode_Value>>(
                    "value",
                    |m: &ProvenanceEntityRoleCode| { &m.value },
                    |m: &mut ProvenanceEntityRoleCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ProvenanceEntityRoleCode| { &m.id },
                    |m: &mut ProvenanceEntityRoleCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ProvenanceEntityRoleCode| { &m.extension },
                    |m: &mut ProvenanceEntityRoleCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProvenanceEntityRoleCode>(
                    "ProvenanceEntityRoleCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProvenanceEntityRoleCode {
        static mut instance: ::protobuf::lazy::Lazy<ProvenanceEntityRoleCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProvenanceEntityRoleCode,
        };
        unsafe {
            instance.get(ProvenanceEntityRoleCode::new)
        }
    }
}

impl ::protobuf::Clear for ProvenanceEntityRoleCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProvenanceEntityRoleCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProvenanceEntityRoleCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProvenanceEntityRoleCode_Value {
    INVALID_UNINITIALIZED = 0,
    DERIVATION = 1,
    REVISION = 2,
    QUOTATION = 3,
    SOURCE = 4,
    REMOVAL = 5,
}

impl ::protobuf::ProtobufEnum for ProvenanceEntityRoleCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProvenanceEntityRoleCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ProvenanceEntityRoleCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ProvenanceEntityRoleCode_Value::DERIVATION),
            2 => ::std::option::Option::Some(ProvenanceEntityRoleCode_Value::REVISION),
            3 => ::std::option::Option::Some(ProvenanceEntityRoleCode_Value::QUOTATION),
            4 => ::std::option::Option::Some(ProvenanceEntityRoleCode_Value::SOURCE),
            5 => ::std::option::Option::Some(ProvenanceEntityRoleCode_Value::REMOVAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProvenanceEntityRoleCode_Value] = &[
            ProvenanceEntityRoleCode_Value::INVALID_UNINITIALIZED,
            ProvenanceEntityRoleCode_Value::DERIVATION,
            ProvenanceEntityRoleCode_Value::REVISION,
            ProvenanceEntityRoleCode_Value::QUOTATION,
            ProvenanceEntityRoleCode_Value::SOURCE,
            ProvenanceEntityRoleCode_Value::REMOVAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ProvenanceEntityRoleCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ProvenanceEntityRoleCode_Value {
}

impl ::std::default::Default for ProvenanceEntityRoleCode_Value {
    fn default() -> Self {
        ProvenanceEntityRoleCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ProvenanceEntityRoleCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PublicationStatusCode {
    // message fields
    pub value: PublicationStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PublicationStatusCode {
    pub fn new() -> PublicationStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.PublicationStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = PublicationStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: PublicationStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> PublicationStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for PublicationStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != PublicationStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != PublicationStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublicationStatusCode {
        PublicationStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PublicationStatusCode_Value>>(
                    "value",
                    |m: &PublicationStatusCode| { &m.value },
                    |m: &mut PublicationStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &PublicationStatusCode| { &m.id },
                    |m: &mut PublicationStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &PublicationStatusCode| { &m.extension },
                    |m: &mut PublicationStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublicationStatusCode>(
                    "PublicationStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublicationStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<PublicationStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublicationStatusCode,
        };
        unsafe {
            instance.get(PublicationStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for PublicationStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublicationStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicationStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PublicationStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    DRAFT = 1,
    ACTIVE = 2,
    RETIRED = 3,
    UNKNOWN = 4,
}

impl ::protobuf::ProtobufEnum for PublicationStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PublicationStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(PublicationStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(PublicationStatusCode_Value::DRAFT),
            2 => ::std::option::Option::Some(PublicationStatusCode_Value::ACTIVE),
            3 => ::std::option::Option::Some(PublicationStatusCode_Value::RETIRED),
            4 => ::std::option::Option::Some(PublicationStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PublicationStatusCode_Value] = &[
            PublicationStatusCode_Value::INVALID_UNINITIALIZED,
            PublicationStatusCode_Value::DRAFT,
            PublicationStatusCode_Value::ACTIVE,
            PublicationStatusCode_Value::RETIRED,
            PublicationStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PublicationStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PublicationStatusCode_Value {
}

impl ::std::default::Default for PublicationStatusCode_Value {
    fn default() -> Self {
        PublicationStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicationStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QualityTypeCode {
    // message fields
    pub value: QualityTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl QualityTypeCode {
    pub fn new() -> QualityTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.QualityTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = QualityTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: QualityTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> QualityTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for QualityTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != QualityTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != QualityTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QualityTypeCode {
        QualityTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<QualityTypeCode_Value>>(
                    "value",
                    |m: &QualityTypeCode| { &m.value },
                    |m: &mut QualityTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &QualityTypeCode| { &m.id },
                    |m: &mut QualityTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &QualityTypeCode| { &m.extension },
                    |m: &mut QualityTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QualityTypeCode>(
                    "QualityTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QualityTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<QualityTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QualityTypeCode,
        };
        unsafe {
            instance.get(QualityTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for QualityTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QualityTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QualityTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum QualityTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    INDEL = 1,
    SNP = 2,
    UNKNOWN = 3,
}

impl ::protobuf::ProtobufEnum for QualityTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<QualityTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(QualityTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(QualityTypeCode_Value::INDEL),
            2 => ::std::option::Option::Some(QualityTypeCode_Value::SNP),
            3 => ::std::option::Option::Some(QualityTypeCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [QualityTypeCode_Value] = &[
            QualityTypeCode_Value::INVALID_UNINITIALIZED,
            QualityTypeCode_Value::INDEL,
            QualityTypeCode_Value::SNP,
            QualityTypeCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("QualityTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for QualityTypeCode_Value {
}

impl ::std::default::Default for QualityTypeCode_Value {
    fn default() -> Self {
        QualityTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for QualityTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MaxOccursCode {
    // message fields
    pub value: MaxOccursCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MaxOccursCode {
    pub fn new() -> MaxOccursCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.MaxOccursCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = MaxOccursCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: MaxOccursCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> MaxOccursCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for MaxOccursCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != MaxOccursCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != MaxOccursCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MaxOccursCode {
        MaxOccursCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MaxOccursCode_Value>>(
                    "value",
                    |m: &MaxOccursCode| { &m.value },
                    |m: &mut MaxOccursCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &MaxOccursCode| { &m.id },
                    |m: &mut MaxOccursCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &MaxOccursCode| { &m.extension },
                    |m: &mut MaxOccursCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MaxOccursCode>(
                    "MaxOccursCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MaxOccursCode {
        static mut instance: ::protobuf::lazy::Lazy<MaxOccursCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MaxOccursCode,
        };
        unsafe {
            instance.get(MaxOccursCode::new)
        }
    }
}

impl ::protobuf::Clear for MaxOccursCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MaxOccursCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaxOccursCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MaxOccursCode_Value {
    INVALID_UNINITIALIZED = 0,
    MAX = 1,
}

impl ::protobuf::ProtobufEnum for MaxOccursCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MaxOccursCode_Value> {
        match value {
            0 => ::std::option::Option::Some(MaxOccursCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(MaxOccursCode_Value::MAX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MaxOccursCode_Value] = &[
            MaxOccursCode_Value::INVALID_UNINITIALIZED,
            MaxOccursCode_Value::MAX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MaxOccursCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MaxOccursCode_Value {
}

impl ::std::default::Default for MaxOccursCode_Value {
    fn default() -> Self {
        MaxOccursCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for MaxOccursCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuestionnaireResponseStatusCode {
    // message fields
    pub value: QuestionnaireResponseStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl QuestionnaireResponseStatusCode {
    pub fn new() -> QuestionnaireResponseStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.QuestionnaireResponseStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = QuestionnaireResponseStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: QuestionnaireResponseStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> QuestionnaireResponseStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for QuestionnaireResponseStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != QuestionnaireResponseStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != QuestionnaireResponseStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuestionnaireResponseStatusCode {
        QuestionnaireResponseStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<QuestionnaireResponseStatusCode_Value>>(
                    "value",
                    |m: &QuestionnaireResponseStatusCode| { &m.value },
                    |m: &mut QuestionnaireResponseStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &QuestionnaireResponseStatusCode| { &m.id },
                    |m: &mut QuestionnaireResponseStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &QuestionnaireResponseStatusCode| { &m.extension },
                    |m: &mut QuestionnaireResponseStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QuestionnaireResponseStatusCode>(
                    "QuestionnaireResponseStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QuestionnaireResponseStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<QuestionnaireResponseStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QuestionnaireResponseStatusCode,
        };
        unsafe {
            instance.get(QuestionnaireResponseStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for QuestionnaireResponseStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuestionnaireResponseStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuestionnaireResponseStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum QuestionnaireResponseStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    IN_PROGRESS = 1,
    COMPLETED = 2,
    AMENDED = 3,
    ENTERED_IN_ERROR = 4,
    STOPPED = 5,
}

impl ::protobuf::ProtobufEnum for QuestionnaireResponseStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<QuestionnaireResponseStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(QuestionnaireResponseStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(QuestionnaireResponseStatusCode_Value::IN_PROGRESS),
            2 => ::std::option::Option::Some(QuestionnaireResponseStatusCode_Value::COMPLETED),
            3 => ::std::option::Option::Some(QuestionnaireResponseStatusCode_Value::AMENDED),
            4 => ::std::option::Option::Some(QuestionnaireResponseStatusCode_Value::ENTERED_IN_ERROR),
            5 => ::std::option::Option::Some(QuestionnaireResponseStatusCode_Value::STOPPED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [QuestionnaireResponseStatusCode_Value] = &[
            QuestionnaireResponseStatusCode_Value::INVALID_UNINITIALIZED,
            QuestionnaireResponseStatusCode_Value::IN_PROGRESS,
            QuestionnaireResponseStatusCode_Value::COMPLETED,
            QuestionnaireResponseStatusCode_Value::AMENDED,
            QuestionnaireResponseStatusCode_Value::ENTERED_IN_ERROR,
            QuestionnaireResponseStatusCode_Value::STOPPED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("QuestionnaireResponseStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for QuestionnaireResponseStatusCode_Value {
}

impl ::std::default::Default for QuestionnaireResponseStatusCode_Value {
    fn default() -> Self {
        QuestionnaireResponseStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for QuestionnaireResponseStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuestionnaireTextCategoriesCode {
    // message fields
    pub value: QuestionnaireTextCategoriesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl QuestionnaireTextCategoriesCode {
    pub fn new() -> QuestionnaireTextCategoriesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.QuestionnaireTextCategoriesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = QuestionnaireTextCategoriesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: QuestionnaireTextCategoriesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> QuestionnaireTextCategoriesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for QuestionnaireTextCategoriesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != QuestionnaireTextCategoriesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != QuestionnaireTextCategoriesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuestionnaireTextCategoriesCode {
        QuestionnaireTextCategoriesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<QuestionnaireTextCategoriesCode_Value>>(
                    "value",
                    |m: &QuestionnaireTextCategoriesCode| { &m.value },
                    |m: &mut QuestionnaireTextCategoriesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &QuestionnaireTextCategoriesCode| { &m.id },
                    |m: &mut QuestionnaireTextCategoriesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &QuestionnaireTextCategoriesCode| { &m.extension },
                    |m: &mut QuestionnaireTextCategoriesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QuestionnaireTextCategoriesCode>(
                    "QuestionnaireTextCategoriesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QuestionnaireTextCategoriesCode {
        static mut instance: ::protobuf::lazy::Lazy<QuestionnaireTextCategoriesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QuestionnaireTextCategoriesCode,
        };
        unsafe {
            instance.get(QuestionnaireTextCategoriesCode::new)
        }
    }
}

impl ::protobuf::Clear for QuestionnaireTextCategoriesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuestionnaireTextCategoriesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuestionnaireTextCategoriesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum QuestionnaireTextCategoriesCode_Value {
    INVALID_UNINITIALIZED = 0,
    INSTRUCTIONS = 1,
    SECURITY = 2,
}

impl ::protobuf::ProtobufEnum for QuestionnaireTextCategoriesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<QuestionnaireTextCategoriesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(QuestionnaireTextCategoriesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(QuestionnaireTextCategoriesCode_Value::INSTRUCTIONS),
            2 => ::std::option::Option::Some(QuestionnaireTextCategoriesCode_Value::SECURITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [QuestionnaireTextCategoriesCode_Value] = &[
            QuestionnaireTextCategoriesCode_Value::INVALID_UNINITIALIZED,
            QuestionnaireTextCategoriesCode_Value::INSTRUCTIONS,
            QuestionnaireTextCategoriesCode_Value::SECURITY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("QuestionnaireTextCategoriesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for QuestionnaireTextCategoriesCode_Value {
}

impl ::std::default::Default for QuestionnaireTextCategoriesCode_Value {
    fn default() -> Self {
        QuestionnaireTextCategoriesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for QuestionnaireTextCategoriesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuestionnaireItemUIControlCodesCode {
    // message fields
    pub value: QuestionnaireItemUIControlCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl QuestionnaireItemUIControlCodesCode {
    pub fn new() -> QuestionnaireItemUIControlCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.QuestionnaireItemUIControlCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = QuestionnaireItemUIControlCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: QuestionnaireItemUIControlCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> QuestionnaireItemUIControlCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for QuestionnaireItemUIControlCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != QuestionnaireItemUIControlCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != QuestionnaireItemUIControlCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuestionnaireItemUIControlCodesCode {
        QuestionnaireItemUIControlCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<QuestionnaireItemUIControlCodesCode_Value>>(
                    "value",
                    |m: &QuestionnaireItemUIControlCodesCode| { &m.value },
                    |m: &mut QuestionnaireItemUIControlCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &QuestionnaireItemUIControlCodesCode| { &m.id },
                    |m: &mut QuestionnaireItemUIControlCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &QuestionnaireItemUIControlCodesCode| { &m.extension },
                    |m: &mut QuestionnaireItemUIControlCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QuestionnaireItemUIControlCodesCode>(
                    "QuestionnaireItemUIControlCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QuestionnaireItemUIControlCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<QuestionnaireItemUIControlCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QuestionnaireItemUIControlCodesCode,
        };
        unsafe {
            instance.get(QuestionnaireItemUIControlCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for QuestionnaireItemUIControlCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuestionnaireItemUIControlCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuestionnaireItemUIControlCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum QuestionnaireItemUIControlCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    LIST = 1,
    TABLE = 2,
    HEADER = 3,
    FOOTER = 4,
    INLINE = 5,
    PROMPT = 6,
    UNIT = 7,
    LOWER = 8,
    UPPER = 9,
    FLYOVER = 10,
    HELP = 11,
    AUTOCOMPLETE = 12,
    DROP_DOWN = 13,
    CHECK_BOX = 14,
    LOOKUP = 15,
    RADIO_BUTTON = 16,
    SLIDER = 17,
    SPINNER = 18,
    TEXT_BOX = 19,
}

impl ::protobuf::ProtobufEnum for QuestionnaireItemUIControlCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<QuestionnaireItemUIControlCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::LIST),
            2 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::TABLE),
            3 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::HEADER),
            4 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::FOOTER),
            5 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::INLINE),
            6 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::PROMPT),
            7 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::UNIT),
            8 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::LOWER),
            9 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::UPPER),
            10 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::FLYOVER),
            11 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::HELP),
            12 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::AUTOCOMPLETE),
            13 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::DROP_DOWN),
            14 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::CHECK_BOX),
            15 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::LOOKUP),
            16 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::RADIO_BUTTON),
            17 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::SLIDER),
            18 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::SPINNER),
            19 => ::std::option::Option::Some(QuestionnaireItemUIControlCodesCode_Value::TEXT_BOX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [QuestionnaireItemUIControlCodesCode_Value] = &[
            QuestionnaireItemUIControlCodesCode_Value::INVALID_UNINITIALIZED,
            QuestionnaireItemUIControlCodesCode_Value::LIST,
            QuestionnaireItemUIControlCodesCode_Value::TABLE,
            QuestionnaireItemUIControlCodesCode_Value::HEADER,
            QuestionnaireItemUIControlCodesCode_Value::FOOTER,
            QuestionnaireItemUIControlCodesCode_Value::INLINE,
            QuestionnaireItemUIControlCodesCode_Value::PROMPT,
            QuestionnaireItemUIControlCodesCode_Value::UNIT,
            QuestionnaireItemUIControlCodesCode_Value::LOWER,
            QuestionnaireItemUIControlCodesCode_Value::UPPER,
            QuestionnaireItemUIControlCodesCode_Value::FLYOVER,
            QuestionnaireItemUIControlCodesCode_Value::HELP,
            QuestionnaireItemUIControlCodesCode_Value::AUTOCOMPLETE,
            QuestionnaireItemUIControlCodesCode_Value::DROP_DOWN,
            QuestionnaireItemUIControlCodesCode_Value::CHECK_BOX,
            QuestionnaireItemUIControlCodesCode_Value::LOOKUP,
            QuestionnaireItemUIControlCodesCode_Value::RADIO_BUTTON,
            QuestionnaireItemUIControlCodesCode_Value::SLIDER,
            QuestionnaireItemUIControlCodesCode_Value::SPINNER,
            QuestionnaireItemUIControlCodesCode_Value::TEXT_BOX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("QuestionnaireItemUIControlCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for QuestionnaireItemUIControlCodesCode_Value {
}

impl ::std::default::Default for QuestionnaireItemUIControlCodesCode_Value {
    fn default() -> Self {
        QuestionnaireItemUIControlCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for QuestionnaireItemUIControlCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuestionnaireItemUsageModeCode {
    // message fields
    pub value: QuestionnaireItemUsageModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl QuestionnaireItemUsageModeCode {
    pub fn new() -> QuestionnaireItemUsageModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.QuestionnaireItemUsageModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = QuestionnaireItemUsageModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: QuestionnaireItemUsageModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> QuestionnaireItemUsageModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for QuestionnaireItemUsageModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != QuestionnaireItemUsageModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != QuestionnaireItemUsageModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuestionnaireItemUsageModeCode {
        QuestionnaireItemUsageModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<QuestionnaireItemUsageModeCode_Value>>(
                    "value",
                    |m: &QuestionnaireItemUsageModeCode| { &m.value },
                    |m: &mut QuestionnaireItemUsageModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &QuestionnaireItemUsageModeCode| { &m.id },
                    |m: &mut QuestionnaireItemUsageModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &QuestionnaireItemUsageModeCode| { &m.extension },
                    |m: &mut QuestionnaireItemUsageModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QuestionnaireItemUsageModeCode>(
                    "QuestionnaireItemUsageModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QuestionnaireItemUsageModeCode {
        static mut instance: ::protobuf::lazy::Lazy<QuestionnaireItemUsageModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QuestionnaireItemUsageModeCode,
        };
        unsafe {
            instance.get(QuestionnaireItemUsageModeCode::new)
        }
    }
}

impl ::protobuf::Clear for QuestionnaireItemUsageModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuestionnaireItemUsageModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuestionnaireItemUsageModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum QuestionnaireItemUsageModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    CAPTURE_DISPLAY = 1,
    CAPTURE = 2,
    DISPLAY = 3,
    DISPLAY_NON_EMPTY = 4,
    CAPTURE_DISPLAY_NON_EMPTY = 5,
}

impl ::protobuf::ProtobufEnum for QuestionnaireItemUsageModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<QuestionnaireItemUsageModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(QuestionnaireItemUsageModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(QuestionnaireItemUsageModeCode_Value::CAPTURE_DISPLAY),
            2 => ::std::option::Option::Some(QuestionnaireItemUsageModeCode_Value::CAPTURE),
            3 => ::std::option::Option::Some(QuestionnaireItemUsageModeCode_Value::DISPLAY),
            4 => ::std::option::Option::Some(QuestionnaireItemUsageModeCode_Value::DISPLAY_NON_EMPTY),
            5 => ::std::option::Option::Some(QuestionnaireItemUsageModeCode_Value::CAPTURE_DISPLAY_NON_EMPTY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [QuestionnaireItemUsageModeCode_Value] = &[
            QuestionnaireItemUsageModeCode_Value::INVALID_UNINITIALIZED,
            QuestionnaireItemUsageModeCode_Value::CAPTURE_DISPLAY,
            QuestionnaireItemUsageModeCode_Value::CAPTURE,
            QuestionnaireItemUsageModeCode_Value::DISPLAY,
            QuestionnaireItemUsageModeCode_Value::DISPLAY_NON_EMPTY,
            QuestionnaireItemUsageModeCode_Value::CAPTURE_DISPLAY_NON_EMPTY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("QuestionnaireItemUsageModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for QuestionnaireItemUsageModeCode_Value {
}

impl ::std::default::Default for QuestionnaireItemUsageModeCode_Value {
    fn default() -> Self {
        QuestionnaireItemUsageModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for QuestionnaireItemUsageModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllergyIntoleranceCertaintyCode {
    // message fields
    pub value: AllergyIntoleranceCertaintyCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AllergyIntoleranceCertaintyCode {
    pub fn new() -> AllergyIntoleranceCertaintyCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AllergyIntoleranceCertaintyCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AllergyIntoleranceCertaintyCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AllergyIntoleranceCertaintyCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AllergyIntoleranceCertaintyCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AllergyIntoleranceCertaintyCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AllergyIntoleranceCertaintyCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AllergyIntoleranceCertaintyCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllergyIntoleranceCertaintyCode {
        AllergyIntoleranceCertaintyCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AllergyIntoleranceCertaintyCode_Value>>(
                    "value",
                    |m: &AllergyIntoleranceCertaintyCode| { &m.value },
                    |m: &mut AllergyIntoleranceCertaintyCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AllergyIntoleranceCertaintyCode| { &m.id },
                    |m: &mut AllergyIntoleranceCertaintyCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AllergyIntoleranceCertaintyCode| { &m.extension },
                    |m: &mut AllergyIntoleranceCertaintyCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllergyIntoleranceCertaintyCode>(
                    "AllergyIntoleranceCertaintyCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AllergyIntoleranceCertaintyCode {
        static mut instance: ::protobuf::lazy::Lazy<AllergyIntoleranceCertaintyCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllergyIntoleranceCertaintyCode,
        };
        unsafe {
            instance.get(AllergyIntoleranceCertaintyCode::new)
        }
    }
}

impl ::protobuf::Clear for AllergyIntoleranceCertaintyCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllergyIntoleranceCertaintyCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceCertaintyCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AllergyIntoleranceCertaintyCode_Value {
    INVALID_UNINITIALIZED = 0,
    UNLIKELY = 1,
    LIKELY = 2,
    CONFIRMED = 3,
    UNKNOWN = 4,
}

impl ::protobuf::ProtobufEnum for AllergyIntoleranceCertaintyCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AllergyIntoleranceCertaintyCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AllergyIntoleranceCertaintyCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AllergyIntoleranceCertaintyCode_Value::UNLIKELY),
            2 => ::std::option::Option::Some(AllergyIntoleranceCertaintyCode_Value::LIKELY),
            3 => ::std::option::Option::Some(AllergyIntoleranceCertaintyCode_Value::CONFIRMED),
            4 => ::std::option::Option::Some(AllergyIntoleranceCertaintyCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AllergyIntoleranceCertaintyCode_Value] = &[
            AllergyIntoleranceCertaintyCode_Value::INVALID_UNINITIALIZED,
            AllergyIntoleranceCertaintyCode_Value::UNLIKELY,
            AllergyIntoleranceCertaintyCode_Value::LIKELY,
            AllergyIntoleranceCertaintyCode_Value::CONFIRMED,
            AllergyIntoleranceCertaintyCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AllergyIntoleranceCertaintyCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AllergyIntoleranceCertaintyCode_Value {
}

impl ::std::default::Default for AllergyIntoleranceCertaintyCode_Value {
    fn default() -> Self {
        AllergyIntoleranceCertaintyCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceCertaintyCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllergyIntoleranceSeverityCode {
    // message fields
    pub value: AllergyIntoleranceSeverityCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AllergyIntoleranceSeverityCode {
    pub fn new() -> AllergyIntoleranceSeverityCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.AllergyIntoleranceSeverityCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = AllergyIntoleranceSeverityCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: AllergyIntoleranceSeverityCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> AllergyIntoleranceSeverityCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for AllergyIntoleranceSeverityCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != AllergyIntoleranceSeverityCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != AllergyIntoleranceSeverityCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllergyIntoleranceSeverityCode {
        AllergyIntoleranceSeverityCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AllergyIntoleranceSeverityCode_Value>>(
                    "value",
                    |m: &AllergyIntoleranceSeverityCode| { &m.value },
                    |m: &mut AllergyIntoleranceSeverityCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &AllergyIntoleranceSeverityCode| { &m.id },
                    |m: &mut AllergyIntoleranceSeverityCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &AllergyIntoleranceSeverityCode| { &m.extension },
                    |m: &mut AllergyIntoleranceSeverityCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllergyIntoleranceSeverityCode>(
                    "AllergyIntoleranceSeverityCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AllergyIntoleranceSeverityCode {
        static mut instance: ::protobuf::lazy::Lazy<AllergyIntoleranceSeverityCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllergyIntoleranceSeverityCode,
        };
        unsafe {
            instance.get(AllergyIntoleranceSeverityCode::new)
        }
    }
}

impl ::protobuf::Clear for AllergyIntoleranceSeverityCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllergyIntoleranceSeverityCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceSeverityCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AllergyIntoleranceSeverityCode_Value {
    INVALID_UNINITIALIZED = 0,
    MILD = 1,
    MODERATE = 2,
    SEVERE = 3,
}

impl ::protobuf::ProtobufEnum for AllergyIntoleranceSeverityCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AllergyIntoleranceSeverityCode_Value> {
        match value {
            0 => ::std::option::Option::Some(AllergyIntoleranceSeverityCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(AllergyIntoleranceSeverityCode_Value::MILD),
            2 => ::std::option::Option::Some(AllergyIntoleranceSeverityCode_Value::MODERATE),
            3 => ::std::option::Option::Some(AllergyIntoleranceSeverityCode_Value::SEVERE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AllergyIntoleranceSeverityCode_Value] = &[
            AllergyIntoleranceSeverityCode_Value::INVALID_UNINITIALIZED,
            AllergyIntoleranceSeverityCode_Value::MILD,
            AllergyIntoleranceSeverityCode_Value::MODERATE,
            AllergyIntoleranceSeverityCode_Value::SEVERE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AllergyIntoleranceSeverityCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AllergyIntoleranceSeverityCode_Value {
}

impl ::std::default::Default for AllergyIntoleranceSeverityCode_Value {
    fn default() -> Self {
        AllergyIntoleranceSeverityCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for AllergyIntoleranceSeverityCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReasonMedicationGivenCodesCode {
    // message fields
    pub value: ReasonMedicationGivenCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ReasonMedicationGivenCodesCode {
    pub fn new() -> ReasonMedicationGivenCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ReasonMedicationGivenCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ReasonMedicationGivenCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ReasonMedicationGivenCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ReasonMedicationGivenCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ReasonMedicationGivenCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ReasonMedicationGivenCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ReasonMedicationGivenCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReasonMedicationGivenCodesCode {
        ReasonMedicationGivenCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReasonMedicationGivenCodesCode_Value>>(
                    "value",
                    |m: &ReasonMedicationGivenCodesCode| { &m.value },
                    |m: &mut ReasonMedicationGivenCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ReasonMedicationGivenCodesCode| { &m.id },
                    |m: &mut ReasonMedicationGivenCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ReasonMedicationGivenCodesCode| { &m.extension },
                    |m: &mut ReasonMedicationGivenCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReasonMedicationGivenCodesCode>(
                    "ReasonMedicationGivenCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReasonMedicationGivenCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ReasonMedicationGivenCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReasonMedicationGivenCodesCode,
        };
        unsafe {
            instance.get(ReasonMedicationGivenCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ReasonMedicationGivenCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReasonMedicationGivenCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReasonMedicationGivenCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReasonMedicationGivenCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    A = 1,
    B = 2,
    C = 3,
}

impl ::protobuf::ProtobufEnum for ReasonMedicationGivenCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReasonMedicationGivenCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ReasonMedicationGivenCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ReasonMedicationGivenCodesCode_Value::A),
            2 => ::std::option::Option::Some(ReasonMedicationGivenCodesCode_Value::B),
            3 => ::std::option::Option::Some(ReasonMedicationGivenCodesCode_Value::C),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReasonMedicationGivenCodesCode_Value] = &[
            ReasonMedicationGivenCodesCode_Value::INVALID_UNINITIALIZED,
            ReasonMedicationGivenCodesCode_Value::A,
            ReasonMedicationGivenCodesCode_Value::B,
            ReasonMedicationGivenCodesCode_Value::C,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ReasonMedicationGivenCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ReasonMedicationGivenCodesCode_Value {
}

impl ::std::default::Default for ReasonMedicationGivenCodesCode_Value {
    fn default() -> Self {
        ReasonMedicationGivenCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ReasonMedicationGivenCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReferenceHandlingPolicyCode {
    // message fields
    pub value: ReferenceHandlingPolicyCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ReferenceHandlingPolicyCode {
    pub fn new() -> ReferenceHandlingPolicyCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ReferenceHandlingPolicyCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ReferenceHandlingPolicyCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ReferenceHandlingPolicyCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ReferenceHandlingPolicyCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ReferenceHandlingPolicyCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ReferenceHandlingPolicyCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ReferenceHandlingPolicyCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReferenceHandlingPolicyCode {
        ReferenceHandlingPolicyCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReferenceHandlingPolicyCode_Value>>(
                    "value",
                    |m: &ReferenceHandlingPolicyCode| { &m.value },
                    |m: &mut ReferenceHandlingPolicyCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ReferenceHandlingPolicyCode| { &m.id },
                    |m: &mut ReferenceHandlingPolicyCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ReferenceHandlingPolicyCode| { &m.extension },
                    |m: &mut ReferenceHandlingPolicyCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReferenceHandlingPolicyCode>(
                    "ReferenceHandlingPolicyCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReferenceHandlingPolicyCode {
        static mut instance: ::protobuf::lazy::Lazy<ReferenceHandlingPolicyCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReferenceHandlingPolicyCode,
        };
        unsafe {
            instance.get(ReferenceHandlingPolicyCode::new)
        }
    }
}

impl ::protobuf::Clear for ReferenceHandlingPolicyCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReferenceHandlingPolicyCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReferenceHandlingPolicyCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReferenceHandlingPolicyCode_Value {
    INVALID_UNINITIALIZED = 0,
    LITERAL = 1,
    LOGICAL = 2,
    RESOLVES = 3,
    ENFORCED = 4,
    LOCAL = 5,
}

impl ::protobuf::ProtobufEnum for ReferenceHandlingPolicyCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReferenceHandlingPolicyCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ReferenceHandlingPolicyCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ReferenceHandlingPolicyCode_Value::LITERAL),
            2 => ::std::option::Option::Some(ReferenceHandlingPolicyCode_Value::LOGICAL),
            3 => ::std::option::Option::Some(ReferenceHandlingPolicyCode_Value::RESOLVES),
            4 => ::std::option::Option::Some(ReferenceHandlingPolicyCode_Value::ENFORCED),
            5 => ::std::option::Option::Some(ReferenceHandlingPolicyCode_Value::LOCAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReferenceHandlingPolicyCode_Value] = &[
            ReferenceHandlingPolicyCode_Value::INVALID_UNINITIALIZED,
            ReferenceHandlingPolicyCode_Value::LITERAL,
            ReferenceHandlingPolicyCode_Value::LOGICAL,
            ReferenceHandlingPolicyCode_Value::RESOLVES,
            ReferenceHandlingPolicyCode_Value::ENFORCED,
            ReferenceHandlingPolicyCode_Value::LOCAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ReferenceHandlingPolicyCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ReferenceHandlingPolicyCode_Value {
}

impl ::std::default::Default for ReferenceHandlingPolicyCode_Value {
    fn default() -> Self {
        ReferenceHandlingPolicyCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ReferenceHandlingPolicyCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelatedArtifactTypeCode {
    // message fields
    pub value: RelatedArtifactTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RelatedArtifactTypeCode {
    pub fn new() -> RelatedArtifactTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.RelatedArtifactTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = RelatedArtifactTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: RelatedArtifactTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> RelatedArtifactTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for RelatedArtifactTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != RelatedArtifactTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != RelatedArtifactTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelatedArtifactTypeCode {
        RelatedArtifactTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RelatedArtifactTypeCode_Value>>(
                    "value",
                    |m: &RelatedArtifactTypeCode| { &m.value },
                    |m: &mut RelatedArtifactTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &RelatedArtifactTypeCode| { &m.id },
                    |m: &mut RelatedArtifactTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &RelatedArtifactTypeCode| { &m.extension },
                    |m: &mut RelatedArtifactTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RelatedArtifactTypeCode>(
                    "RelatedArtifactTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelatedArtifactTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<RelatedArtifactTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelatedArtifactTypeCode,
        };
        unsafe {
            instance.get(RelatedArtifactTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for RelatedArtifactTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelatedArtifactTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelatedArtifactTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RelatedArtifactTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    DOCUMENTATION = 1,
    JUSTIFICATION = 2,
    CITATION = 3,
    PREDECESSOR = 4,
    SUCCESSOR = 5,
    DERIVED_FROM = 6,
    DEPENDS_ON = 7,
    COMPOSED_OF = 8,
}

impl ::protobuf::ProtobufEnum for RelatedArtifactTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RelatedArtifactTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(RelatedArtifactTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(RelatedArtifactTypeCode_Value::DOCUMENTATION),
            2 => ::std::option::Option::Some(RelatedArtifactTypeCode_Value::JUSTIFICATION),
            3 => ::std::option::Option::Some(RelatedArtifactTypeCode_Value::CITATION),
            4 => ::std::option::Option::Some(RelatedArtifactTypeCode_Value::PREDECESSOR),
            5 => ::std::option::Option::Some(RelatedArtifactTypeCode_Value::SUCCESSOR),
            6 => ::std::option::Option::Some(RelatedArtifactTypeCode_Value::DERIVED_FROM),
            7 => ::std::option::Option::Some(RelatedArtifactTypeCode_Value::DEPENDS_ON),
            8 => ::std::option::Option::Some(RelatedArtifactTypeCode_Value::COMPOSED_OF),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RelatedArtifactTypeCode_Value] = &[
            RelatedArtifactTypeCode_Value::INVALID_UNINITIALIZED,
            RelatedArtifactTypeCode_Value::DOCUMENTATION,
            RelatedArtifactTypeCode_Value::JUSTIFICATION,
            RelatedArtifactTypeCode_Value::CITATION,
            RelatedArtifactTypeCode_Value::PREDECESSOR,
            RelatedArtifactTypeCode_Value::SUCCESSOR,
            RelatedArtifactTypeCode_Value::DERIVED_FROM,
            RelatedArtifactTypeCode_Value::DEPENDS_ON,
            RelatedArtifactTypeCode_Value::COMPOSED_OF,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RelatedArtifactTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RelatedArtifactTypeCode_Value {
}

impl ::std::default::Default for RelatedArtifactTypeCode_Value {
    fn default() -> Self {
        RelatedArtifactTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for RelatedArtifactTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObservationReferenceRangeMeaningCodesCode {
    // message fields
    pub value: ObservationReferenceRangeMeaningCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ObservationReferenceRangeMeaningCodesCode {
    pub fn new() -> ObservationReferenceRangeMeaningCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ObservationReferenceRangeMeaningCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ObservationReferenceRangeMeaningCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ObservationReferenceRangeMeaningCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ObservationReferenceRangeMeaningCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ObservationReferenceRangeMeaningCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ObservationReferenceRangeMeaningCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ObservationReferenceRangeMeaningCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObservationReferenceRangeMeaningCodesCode {
        ObservationReferenceRangeMeaningCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ObservationReferenceRangeMeaningCodesCode_Value>>(
                    "value",
                    |m: &ObservationReferenceRangeMeaningCodesCode| { &m.value },
                    |m: &mut ObservationReferenceRangeMeaningCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ObservationReferenceRangeMeaningCodesCode| { &m.id },
                    |m: &mut ObservationReferenceRangeMeaningCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ObservationReferenceRangeMeaningCodesCode| { &m.extension },
                    |m: &mut ObservationReferenceRangeMeaningCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ObservationReferenceRangeMeaningCodesCode>(
                    "ObservationReferenceRangeMeaningCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ObservationReferenceRangeMeaningCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<ObservationReferenceRangeMeaningCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ObservationReferenceRangeMeaningCodesCode,
        };
        unsafe {
            instance.get(ObservationReferenceRangeMeaningCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for ObservationReferenceRangeMeaningCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObservationReferenceRangeMeaningCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationReferenceRangeMeaningCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ObservationReferenceRangeMeaningCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    NORMAL = 1,
    RECOMMENDED = 2,
    TREATMENT = 3,
    THERAPEUTIC = 4,
    PRE = 5,
    POST = 6,
    PRE_PUBERTY = 7,
    FOLLICULAR = 8,
    MIDCYCLE = 9,
    LUTEAL = 10,
    POSTMEOPAUSAL = 11,
}

impl ::protobuf::ProtobufEnum for ObservationReferenceRangeMeaningCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ObservationReferenceRangeMeaningCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::NORMAL),
            2 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::RECOMMENDED),
            3 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::TREATMENT),
            4 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::THERAPEUTIC),
            5 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::PRE),
            6 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::POST),
            7 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::PRE_PUBERTY),
            8 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::FOLLICULAR),
            9 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::MIDCYCLE),
            10 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::LUTEAL),
            11 => ::std::option::Option::Some(ObservationReferenceRangeMeaningCodesCode_Value::POSTMEOPAUSAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ObservationReferenceRangeMeaningCodesCode_Value] = &[
            ObservationReferenceRangeMeaningCodesCode_Value::INVALID_UNINITIALIZED,
            ObservationReferenceRangeMeaningCodesCode_Value::NORMAL,
            ObservationReferenceRangeMeaningCodesCode_Value::RECOMMENDED,
            ObservationReferenceRangeMeaningCodesCode_Value::TREATMENT,
            ObservationReferenceRangeMeaningCodesCode_Value::THERAPEUTIC,
            ObservationReferenceRangeMeaningCodesCode_Value::PRE,
            ObservationReferenceRangeMeaningCodesCode_Value::POST,
            ObservationReferenceRangeMeaningCodesCode_Value::PRE_PUBERTY,
            ObservationReferenceRangeMeaningCodesCode_Value::FOLLICULAR,
            ObservationReferenceRangeMeaningCodesCode_Value::MIDCYCLE,
            ObservationReferenceRangeMeaningCodesCode_Value::LUTEAL,
            ObservationReferenceRangeMeaningCodesCode_Value::POSTMEOPAUSAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ObservationReferenceRangeMeaningCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ObservationReferenceRangeMeaningCodesCode_Value {
}

impl ::std::default::Default for ObservationReferenceRangeMeaningCodesCode_Value {
    fn default() -> Self {
        ObservationReferenceRangeMeaningCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ObservationReferenceRangeMeaningCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestReportActionResultCode {
    // message fields
    pub value: TestReportActionResultCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestReportActionResultCode {
    pub fn new() -> TestReportActionResultCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TestReportActionResultCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TestReportActionResultCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TestReportActionResultCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TestReportActionResultCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TestReportActionResultCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TestReportActionResultCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TestReportActionResultCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestReportActionResultCode {
        TestReportActionResultCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestReportActionResultCode_Value>>(
                    "value",
                    |m: &TestReportActionResultCode| { &m.value },
                    |m: &mut TestReportActionResultCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TestReportActionResultCode| { &m.id },
                    |m: &mut TestReportActionResultCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TestReportActionResultCode| { &m.extension },
                    |m: &mut TestReportActionResultCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestReportActionResultCode>(
                    "TestReportActionResultCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestReportActionResultCode {
        static mut instance: ::protobuf::lazy::Lazy<TestReportActionResultCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestReportActionResultCode,
        };
        unsafe {
            instance.get(TestReportActionResultCode::new)
        }
    }
}

impl ::protobuf::Clear for TestReportActionResultCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestReportActionResultCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestReportActionResultCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestReportActionResultCode_Value {
    INVALID_UNINITIALIZED = 0,
    PASS = 1,
    SKIP = 2,
    FAIL = 3,
    WARNING = 4,
    ERROR = 5,
}

impl ::protobuf::ProtobufEnum for TestReportActionResultCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestReportActionResultCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TestReportActionResultCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TestReportActionResultCode_Value::PASS),
            2 => ::std::option::Option::Some(TestReportActionResultCode_Value::SKIP),
            3 => ::std::option::Option::Some(TestReportActionResultCode_Value::FAIL),
            4 => ::std::option::Option::Some(TestReportActionResultCode_Value::WARNING),
            5 => ::std::option::Option::Some(TestReportActionResultCode_Value::ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestReportActionResultCode_Value] = &[
            TestReportActionResultCode_Value::INVALID_UNINITIALIZED,
            TestReportActionResultCode_Value::PASS,
            TestReportActionResultCode_Value::SKIP,
            TestReportActionResultCode_Value::FAIL,
            TestReportActionResultCode_Value::WARNING,
            TestReportActionResultCode_Value::ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestReportActionResultCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestReportActionResultCode_Value {
}

impl ::std::default::Default for TestReportActionResultCode_Value {
    fn default() -> Self {
        TestReportActionResultCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TestReportActionResultCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestReportParticipantTypeCode {
    // message fields
    pub value: TestReportParticipantTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestReportParticipantTypeCode {
    pub fn new() -> TestReportParticipantTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TestReportParticipantTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TestReportParticipantTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TestReportParticipantTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TestReportParticipantTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TestReportParticipantTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TestReportParticipantTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TestReportParticipantTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestReportParticipantTypeCode {
        TestReportParticipantTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestReportParticipantTypeCode_Value>>(
                    "value",
                    |m: &TestReportParticipantTypeCode| { &m.value },
                    |m: &mut TestReportParticipantTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TestReportParticipantTypeCode| { &m.id },
                    |m: &mut TestReportParticipantTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TestReportParticipantTypeCode| { &m.extension },
                    |m: &mut TestReportParticipantTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestReportParticipantTypeCode>(
                    "TestReportParticipantTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestReportParticipantTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<TestReportParticipantTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestReportParticipantTypeCode,
        };
        unsafe {
            instance.get(TestReportParticipantTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for TestReportParticipantTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestReportParticipantTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestReportParticipantTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestReportParticipantTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    TEST_ENGINE = 1,
    CLIENT = 2,
    SERVER = 3,
}

impl ::protobuf::ProtobufEnum for TestReportParticipantTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestReportParticipantTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TestReportParticipantTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TestReportParticipantTypeCode_Value::TEST_ENGINE),
            2 => ::std::option::Option::Some(TestReportParticipantTypeCode_Value::CLIENT),
            3 => ::std::option::Option::Some(TestReportParticipantTypeCode_Value::SERVER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestReportParticipantTypeCode_Value] = &[
            TestReportParticipantTypeCode_Value::INVALID_UNINITIALIZED,
            TestReportParticipantTypeCode_Value::TEST_ENGINE,
            TestReportParticipantTypeCode_Value::CLIENT,
            TestReportParticipantTypeCode_Value::SERVER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestReportParticipantTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestReportParticipantTypeCode_Value {
}

impl ::std::default::Default for TestReportParticipantTypeCode_Value {
    fn default() -> Self {
        TestReportParticipantTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TestReportParticipantTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestReportResultCode {
    // message fields
    pub value: TestReportResultCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestReportResultCode {
    pub fn new() -> TestReportResultCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TestReportResultCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TestReportResultCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TestReportResultCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TestReportResultCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TestReportResultCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TestReportResultCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TestReportResultCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestReportResultCode {
        TestReportResultCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestReportResultCode_Value>>(
                    "value",
                    |m: &TestReportResultCode| { &m.value },
                    |m: &mut TestReportResultCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TestReportResultCode| { &m.id },
                    |m: &mut TestReportResultCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TestReportResultCode| { &m.extension },
                    |m: &mut TestReportResultCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestReportResultCode>(
                    "TestReportResultCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestReportResultCode {
        static mut instance: ::protobuf::lazy::Lazy<TestReportResultCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestReportResultCode,
        };
        unsafe {
            instance.get(TestReportResultCode::new)
        }
    }
}

impl ::protobuf::Clear for TestReportResultCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestReportResultCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestReportResultCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestReportResultCode_Value {
    INVALID_UNINITIALIZED = 0,
    PASS = 1,
    FAIL = 2,
    PENDING = 3,
}

impl ::protobuf::ProtobufEnum for TestReportResultCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestReportResultCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TestReportResultCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TestReportResultCode_Value::PASS),
            2 => ::std::option::Option::Some(TestReportResultCode_Value::FAIL),
            3 => ::std::option::Option::Some(TestReportResultCode_Value::PENDING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestReportResultCode_Value] = &[
            TestReportResultCode_Value::INVALID_UNINITIALIZED,
            TestReportResultCode_Value::PASS,
            TestReportResultCode_Value::FAIL,
            TestReportResultCode_Value::PENDING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestReportResultCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestReportResultCode_Value {
}

impl ::std::default::Default for TestReportResultCode_Value {
    fn default() -> Self {
        TestReportResultCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TestReportResultCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestReportStatusCode {
    // message fields
    pub value: TestReportStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestReportStatusCode {
    pub fn new() -> TestReportStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TestReportStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TestReportStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TestReportStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TestReportStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TestReportStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TestReportStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TestReportStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestReportStatusCode {
        TestReportStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestReportStatusCode_Value>>(
                    "value",
                    |m: &TestReportStatusCode| { &m.value },
                    |m: &mut TestReportStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TestReportStatusCode| { &m.id },
                    |m: &mut TestReportStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TestReportStatusCode| { &m.extension },
                    |m: &mut TestReportStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestReportStatusCode>(
                    "TestReportStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestReportStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<TestReportStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestReportStatusCode,
        };
        unsafe {
            instance.get(TestReportStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for TestReportStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestReportStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestReportStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestReportStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    COMPLETED = 1,
    IN_PROGRESS = 2,
    WAITING = 3,
    STOPPED = 4,
    ENTERED_IN_ERROR = 5,
}

impl ::protobuf::ProtobufEnum for TestReportStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestReportStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TestReportStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TestReportStatusCode_Value::COMPLETED),
            2 => ::std::option::Option::Some(TestReportStatusCode_Value::IN_PROGRESS),
            3 => ::std::option::Option::Some(TestReportStatusCode_Value::WAITING),
            4 => ::std::option::Option::Some(TestReportStatusCode_Value::STOPPED),
            5 => ::std::option::Option::Some(TestReportStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestReportStatusCode_Value] = &[
            TestReportStatusCode_Value::INVALID_UNINITIALIZED,
            TestReportStatusCode_Value::COMPLETED,
            TestReportStatusCode_Value::IN_PROGRESS,
            TestReportStatusCode_Value::WAITING,
            TestReportStatusCode_Value::STOPPED,
            TestReportStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestReportStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestReportStatusCode_Value {
}

impl ::std::default::Default for TestReportStatusCode_Value {
    fn default() -> Self {
        TestReportStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TestReportStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RepositoryTypeCode {
    // message fields
    pub value: RepositoryTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RepositoryTypeCode {
    pub fn new() -> RepositoryTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.RepositoryTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = RepositoryTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: RepositoryTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> RepositoryTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for RepositoryTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != RepositoryTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != RepositoryTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RepositoryTypeCode {
        RepositoryTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RepositoryTypeCode_Value>>(
                    "value",
                    |m: &RepositoryTypeCode| { &m.value },
                    |m: &mut RepositoryTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &RepositoryTypeCode| { &m.id },
                    |m: &mut RepositoryTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &RepositoryTypeCode| { &m.extension },
                    |m: &mut RepositoryTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RepositoryTypeCode>(
                    "RepositoryTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RepositoryTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<RepositoryTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RepositoryTypeCode,
        };
        unsafe {
            instance.get(RepositoryTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for RepositoryTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RepositoryTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RepositoryTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RepositoryTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    DIRECTLINK = 1,
    OPENAPI = 2,
    LOGIN = 3,
    OAUTH = 4,
    OTHER = 5,
}

impl ::protobuf::ProtobufEnum for RepositoryTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RepositoryTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(RepositoryTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(RepositoryTypeCode_Value::DIRECTLINK),
            2 => ::std::option::Option::Some(RepositoryTypeCode_Value::OPENAPI),
            3 => ::std::option::Option::Some(RepositoryTypeCode_Value::LOGIN),
            4 => ::std::option::Option::Some(RepositoryTypeCode_Value::OAUTH),
            5 => ::std::option::Option::Some(RepositoryTypeCode_Value::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RepositoryTypeCode_Value] = &[
            RepositoryTypeCode_Value::INVALID_UNINITIALIZED,
            RepositoryTypeCode_Value::DIRECTLINK,
            RepositoryTypeCode_Value::OPENAPI,
            RepositoryTypeCode_Value::LOGIN,
            RepositoryTypeCode_Value::OAUTH,
            RepositoryTypeCode_Value::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RepositoryTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RepositoryTypeCode_Value {
}

impl ::std::default::Default for RepositoryTypeCode_Value {
    fn default() -> Self {
        RepositoryTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for RepositoryTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestIntentCode {
    // message fields
    pub value: RequestIntentCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RequestIntentCode {
    pub fn new() -> RequestIntentCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.RequestIntentCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = RequestIntentCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: RequestIntentCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> RequestIntentCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for RequestIntentCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != RequestIntentCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != RequestIntentCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestIntentCode {
        RequestIntentCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RequestIntentCode_Value>>(
                    "value",
                    |m: &RequestIntentCode| { &m.value },
                    |m: &mut RequestIntentCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &RequestIntentCode| { &m.id },
                    |m: &mut RequestIntentCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &RequestIntentCode| { &m.extension },
                    |m: &mut RequestIntentCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RequestIntentCode>(
                    "RequestIntentCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RequestIntentCode {
        static mut instance: ::protobuf::lazy::Lazy<RequestIntentCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RequestIntentCode,
        };
        unsafe {
            instance.get(RequestIntentCode::new)
        }
    }
}

impl ::protobuf::Clear for RequestIntentCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestIntentCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestIntentCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RequestIntentCode_Value {
    INVALID_UNINITIALIZED = 0,
    PROPOSAL = 1,
    PLAN = 2,
    ORDER = 3,
    ORIGINAL_ORDER = 4,
    REFLEX_ORDER = 5,
    FILLER_ORDER = 6,
    INSTANCE_ORDER = 7,
    OPTION = 8,
}

impl ::protobuf::ProtobufEnum for RequestIntentCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestIntentCode_Value> {
        match value {
            0 => ::std::option::Option::Some(RequestIntentCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(RequestIntentCode_Value::PROPOSAL),
            2 => ::std::option::Option::Some(RequestIntentCode_Value::PLAN),
            3 => ::std::option::Option::Some(RequestIntentCode_Value::ORDER),
            4 => ::std::option::Option::Some(RequestIntentCode_Value::ORIGINAL_ORDER),
            5 => ::std::option::Option::Some(RequestIntentCode_Value::REFLEX_ORDER),
            6 => ::std::option::Option::Some(RequestIntentCode_Value::FILLER_ORDER),
            7 => ::std::option::Option::Some(RequestIntentCode_Value::INSTANCE_ORDER),
            8 => ::std::option::Option::Some(RequestIntentCode_Value::OPTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RequestIntentCode_Value] = &[
            RequestIntentCode_Value::INVALID_UNINITIALIZED,
            RequestIntentCode_Value::PROPOSAL,
            RequestIntentCode_Value::PLAN,
            RequestIntentCode_Value::ORDER,
            RequestIntentCode_Value::ORIGINAL_ORDER,
            RequestIntentCode_Value::REFLEX_ORDER,
            RequestIntentCode_Value::FILLER_ORDER,
            RequestIntentCode_Value::INSTANCE_ORDER,
            RequestIntentCode_Value::OPTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RequestIntentCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RequestIntentCode_Value {
}

impl ::std::default::Default for RequestIntentCode_Value {
    fn default() -> Self {
        RequestIntentCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestIntentCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestPriorityCode {
    // message fields
    pub value: RequestPriorityCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RequestPriorityCode {
    pub fn new() -> RequestPriorityCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.RequestPriorityCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = RequestPriorityCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: RequestPriorityCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> RequestPriorityCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for RequestPriorityCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != RequestPriorityCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != RequestPriorityCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestPriorityCode {
        RequestPriorityCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RequestPriorityCode_Value>>(
                    "value",
                    |m: &RequestPriorityCode| { &m.value },
                    |m: &mut RequestPriorityCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &RequestPriorityCode| { &m.id },
                    |m: &mut RequestPriorityCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &RequestPriorityCode| { &m.extension },
                    |m: &mut RequestPriorityCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RequestPriorityCode>(
                    "RequestPriorityCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RequestPriorityCode {
        static mut instance: ::protobuf::lazy::Lazy<RequestPriorityCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RequestPriorityCode,
        };
        unsafe {
            instance.get(RequestPriorityCode::new)
        }
    }
}

impl ::protobuf::Clear for RequestPriorityCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestPriorityCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestPriorityCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RequestPriorityCode_Value {
    INVALID_UNINITIALIZED = 0,
    ROUTINE = 1,
    URGENT = 2,
    ASAP = 3,
    STAT = 4,
}

impl ::protobuf::ProtobufEnum for RequestPriorityCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestPriorityCode_Value> {
        match value {
            0 => ::std::option::Option::Some(RequestPriorityCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(RequestPriorityCode_Value::ROUTINE),
            2 => ::std::option::Option::Some(RequestPriorityCode_Value::URGENT),
            3 => ::std::option::Option::Some(RequestPriorityCode_Value::ASAP),
            4 => ::std::option::Option::Some(RequestPriorityCode_Value::STAT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RequestPriorityCode_Value] = &[
            RequestPriorityCode_Value::INVALID_UNINITIALIZED,
            RequestPriorityCode_Value::ROUTINE,
            RequestPriorityCode_Value::URGENT,
            RequestPriorityCode_Value::ASAP,
            RequestPriorityCode_Value::STAT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RequestPriorityCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RequestPriorityCode_Value {
}

impl ::std::default::Default for RequestPriorityCode_Value {
    fn default() -> Self {
        RequestPriorityCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestPriorityCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequestStatusCode {
    // message fields
    pub value: RequestStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RequestStatusCode {
    pub fn new() -> RequestStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.RequestStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = RequestStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: RequestStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> RequestStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for RequestStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != RequestStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != RequestStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequestStatusCode {
        RequestStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RequestStatusCode_Value>>(
                    "value",
                    |m: &RequestStatusCode| { &m.value },
                    |m: &mut RequestStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &RequestStatusCode| { &m.id },
                    |m: &mut RequestStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &RequestStatusCode| { &m.extension },
                    |m: &mut RequestStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RequestStatusCode>(
                    "RequestStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RequestStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<RequestStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RequestStatusCode,
        };
        unsafe {
            instance.get(RequestStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for RequestStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequestStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RequestStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    DRAFT = 1,
    ACTIVE = 2,
    SUSPENDED = 3,
    CANCELLED = 4,
    COMPLETED = 5,
    ENTERED_IN_ERROR = 6,
    UNKNOWN = 7,
}

impl ::protobuf::ProtobufEnum for RequestStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(RequestStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(RequestStatusCode_Value::DRAFT),
            2 => ::std::option::Option::Some(RequestStatusCode_Value::ACTIVE),
            3 => ::std::option::Option::Some(RequestStatusCode_Value::SUSPENDED),
            4 => ::std::option::Option::Some(RequestStatusCode_Value::CANCELLED),
            5 => ::std::option::Option::Some(RequestStatusCode_Value::COMPLETED),
            6 => ::std::option::Option::Some(RequestStatusCode_Value::ENTERED_IN_ERROR),
            7 => ::std::option::Option::Some(RequestStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RequestStatusCode_Value] = &[
            RequestStatusCode_Value::INVALID_UNINITIALIZED,
            RequestStatusCode_Value::DRAFT,
            RequestStatusCode_Value::ACTIVE,
            RequestStatusCode_Value::SUSPENDED,
            RequestStatusCode_Value::CANCELLED,
            RequestStatusCode_Value::COMPLETED,
            RequestStatusCode_Value::ENTERED_IN_ERROR,
            RequestStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RequestStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RequestStatusCode_Value {
}

impl ::std::default::Default for RequestStatusCode_Value {
    fn default() -> Self {
        RequestStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResearchStudyStatusCode {
    // message fields
    pub value: ResearchStudyStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ResearchStudyStatusCode {
    pub fn new() -> ResearchStudyStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ResearchStudyStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ResearchStudyStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ResearchStudyStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ResearchStudyStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ResearchStudyStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ResearchStudyStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ResearchStudyStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResearchStudyStatusCode {
        ResearchStudyStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResearchStudyStatusCode_Value>>(
                    "value",
                    |m: &ResearchStudyStatusCode| { &m.value },
                    |m: &mut ResearchStudyStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ResearchStudyStatusCode| { &m.id },
                    |m: &mut ResearchStudyStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ResearchStudyStatusCode| { &m.extension },
                    |m: &mut ResearchStudyStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResearchStudyStatusCode>(
                    "ResearchStudyStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResearchStudyStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ResearchStudyStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResearchStudyStatusCode,
        };
        unsafe {
            instance.get(ResearchStudyStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ResearchStudyStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResearchStudyStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResearchStudyStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResearchStudyStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    DRAFT = 1,
    IN_PROGRESS = 2,
    SUSPENDED = 3,
    STOPPED = 4,
    COMPLETED = 5,
    ENTERED_IN_ERROR = 6,
}

impl ::protobuf::ProtobufEnum for ResearchStudyStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResearchStudyStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ResearchStudyStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ResearchStudyStatusCode_Value::DRAFT),
            2 => ::std::option::Option::Some(ResearchStudyStatusCode_Value::IN_PROGRESS),
            3 => ::std::option::Option::Some(ResearchStudyStatusCode_Value::SUSPENDED),
            4 => ::std::option::Option::Some(ResearchStudyStatusCode_Value::STOPPED),
            5 => ::std::option::Option::Some(ResearchStudyStatusCode_Value::COMPLETED),
            6 => ::std::option::Option::Some(ResearchStudyStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResearchStudyStatusCode_Value] = &[
            ResearchStudyStatusCode_Value::INVALID_UNINITIALIZED,
            ResearchStudyStatusCode_Value::DRAFT,
            ResearchStudyStatusCode_Value::IN_PROGRESS,
            ResearchStudyStatusCode_Value::SUSPENDED,
            ResearchStudyStatusCode_Value::STOPPED,
            ResearchStudyStatusCode_Value::COMPLETED,
            ResearchStudyStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ResearchStudyStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResearchStudyStatusCode_Value {
}

impl ::std::default::Default for ResearchStudyStatusCode_Value {
    fn default() -> Self {
        ResearchStudyStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ResearchStudyStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResearchSubjectStatusCode {
    // message fields
    pub value: ResearchSubjectStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ResearchSubjectStatusCode {
    pub fn new() -> ResearchSubjectStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ResearchSubjectStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ResearchSubjectStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ResearchSubjectStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ResearchSubjectStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ResearchSubjectStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ResearchSubjectStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ResearchSubjectStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResearchSubjectStatusCode {
        ResearchSubjectStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResearchSubjectStatusCode_Value>>(
                    "value",
                    |m: &ResearchSubjectStatusCode| { &m.value },
                    |m: &mut ResearchSubjectStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ResearchSubjectStatusCode| { &m.id },
                    |m: &mut ResearchSubjectStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ResearchSubjectStatusCode| { &m.extension },
                    |m: &mut ResearchSubjectStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResearchSubjectStatusCode>(
                    "ResearchSubjectStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResearchSubjectStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<ResearchSubjectStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResearchSubjectStatusCode,
        };
        unsafe {
            instance.get(ResearchSubjectStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for ResearchSubjectStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResearchSubjectStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResearchSubjectStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResearchSubjectStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    CANDIDATE = 1,
    ENROLLED = 2,
    ACTIVE = 3,
    SUSPENDED = 4,
    WITHDRAWN = 5,
    COMPLETED = 6,
}

impl ::protobuf::ProtobufEnum for ResearchSubjectStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResearchSubjectStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ResearchSubjectStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ResearchSubjectStatusCode_Value::CANDIDATE),
            2 => ::std::option::Option::Some(ResearchSubjectStatusCode_Value::ENROLLED),
            3 => ::std::option::Option::Some(ResearchSubjectStatusCode_Value::ACTIVE),
            4 => ::std::option::Option::Some(ResearchSubjectStatusCode_Value::SUSPENDED),
            5 => ::std::option::Option::Some(ResearchSubjectStatusCode_Value::WITHDRAWN),
            6 => ::std::option::Option::Some(ResearchSubjectStatusCode_Value::COMPLETED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResearchSubjectStatusCode_Value] = &[
            ResearchSubjectStatusCode_Value::INVALID_UNINITIALIZED,
            ResearchSubjectStatusCode_Value::CANDIDATE,
            ResearchSubjectStatusCode_Value::ENROLLED,
            ResearchSubjectStatusCode_Value::ACTIVE,
            ResearchSubjectStatusCode_Value::SUSPENDED,
            ResearchSubjectStatusCode_Value::WITHDRAWN,
            ResearchSubjectStatusCode_Value::COMPLETED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ResearchSubjectStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResearchSubjectStatusCode_Value {
}

impl ::std::default::Default for ResearchSubjectStatusCode_Value {
    fn default() -> Self {
        ResearchSubjectStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ResearchSubjectStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PayeeResourceTypeCode {
    // message fields
    pub value: PayeeResourceTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PayeeResourceTypeCode {
    pub fn new() -> PayeeResourceTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.PayeeResourceTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = PayeeResourceTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: PayeeResourceTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> PayeeResourceTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for PayeeResourceTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != PayeeResourceTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != PayeeResourceTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayeeResourceTypeCode {
        PayeeResourceTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PayeeResourceTypeCode_Value>>(
                    "value",
                    |m: &PayeeResourceTypeCode| { &m.value },
                    |m: &mut PayeeResourceTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &PayeeResourceTypeCode| { &m.id },
                    |m: &mut PayeeResourceTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &PayeeResourceTypeCode| { &m.extension },
                    |m: &mut PayeeResourceTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PayeeResourceTypeCode>(
                    "PayeeResourceTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PayeeResourceTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<PayeeResourceTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PayeeResourceTypeCode,
        };
        unsafe {
            instance.get(PayeeResourceTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for PayeeResourceTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayeeResourceTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayeeResourceTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PayeeResourceTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    ORGANIZATION = 1,
    PATIENT = 2,
    PRACTITIONER = 3,
    RELATEDPERSON = 4,
}

impl ::protobuf::ProtobufEnum for PayeeResourceTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PayeeResourceTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(PayeeResourceTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(PayeeResourceTypeCode_Value::ORGANIZATION),
            2 => ::std::option::Option::Some(PayeeResourceTypeCode_Value::PATIENT),
            3 => ::std::option::Option::Some(PayeeResourceTypeCode_Value::PRACTITIONER),
            4 => ::std::option::Option::Some(PayeeResourceTypeCode_Value::RELATEDPERSON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PayeeResourceTypeCode_Value] = &[
            PayeeResourceTypeCode_Value::INVALID_UNINITIALIZED,
            PayeeResourceTypeCode_Value::ORGANIZATION,
            PayeeResourceTypeCode_Value::PATIENT,
            PayeeResourceTypeCode_Value::PRACTITIONER,
            PayeeResourceTypeCode_Value::RELATEDPERSON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PayeeResourceTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PayeeResourceTypeCode_Value {
}

impl ::std::default::Default for PayeeResourceTypeCode_Value {
    fn default() -> Self {
        PayeeResourceTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for PayeeResourceTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceTypeCode {
    // message fields
    pub value: ResourceTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ResourceTypeCode {
    pub fn new() -> ResourceTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ResourceTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ResourceTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ResourceTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ResourceTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ResourceTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ResourceTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ResourceTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceTypeCode {
        ResourceTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResourceTypeCode_Value>>(
                    "value",
                    |m: &ResourceTypeCode| { &m.value },
                    |m: &mut ResourceTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ResourceTypeCode| { &m.id },
                    |m: &mut ResourceTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ResourceTypeCode| { &m.extension },
                    |m: &mut ResourceTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceTypeCode>(
                    "ResourceTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResourceTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ResourceTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceTypeCode,
        };
        unsafe {
            instance.get(ResourceTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ResourceTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResourceTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACCOUNT = 1,
    ACTIVITY_DEFINITION = 2,
    ADVERSE_EVENT = 3,
    ALLERGY_INTOLERANCE = 4,
    APPOINTMENT = 5,
    APPOINTMENT_RESPONSE = 6,
    AUDIT_EVENT = 7,
    BASIC = 8,
    BINARY = 9,
    BODY_SITE = 10,
    BUNDLE = 11,
    CAPABILITY_STATEMENT = 12,
    CARE_PLAN = 13,
    CARE_TEAM = 14,
    CHARGE_ITEM = 15,
    CLAIM = 16,
    CLAIM_RESPONSE = 17,
    CLINICAL_IMPRESSION = 18,
    CODE_SYSTEM = 19,
    COMMUNICATION = 20,
    COMMUNICATION_REQUEST = 21,
    COMPARTMENT_DEFINITION = 22,
    COMPOSITION = 23,
    CONCEPT_MAP = 24,
    CONDITION = 25,
    CONSENT = 26,
    CONTRACT = 27,
    COVERAGE = 28,
    DATA_ELEMENT = 29,
    DETECTED_ISSUE = 30,
    DEVICE = 31,
    DEVICE_COMPONENT = 32,
    DEVICE_METRIC = 33,
    DEVICE_REQUEST = 34,
    DEVICE_USE_STATEMENT = 35,
    DIAGNOSTIC_REPORT = 36,
    DOCUMENT_MANIFEST = 37,
    DOCUMENT_REFERENCE = 38,
    DOMAIN_RESOURCE = 39,
    ELIGIBILITY_REQUEST = 40,
    ELIGIBILITY_RESPONSE = 41,
    ENCOUNTER = 42,
    ENDPOINT = 43,
    ENROLLMENT_REQUEST = 44,
    ENROLLMENT_RESPONSE = 45,
    EPISODE_OF_CARE = 46,
    EXPANSION_PROFILE = 47,
    EXPLANATION_OF_BENEFIT = 48,
    FAMILY_MEMBER_HISTORY = 49,
    FLAG = 50,
    GOAL = 51,
    GRAPH_DEFINITION = 52,
    GROUP = 53,
    GUIDANCE_RESPONSE = 54,
    HEALTHCARE_SERVICE = 55,
    IMAGING_MANIFEST = 56,
    IMAGING_STUDY = 57,
    IMMUNIZATION = 58,
    IMMUNIZATION_RECOMMENDATION = 59,
    IMPLEMENTATION_GUIDE = 60,
    LIBRARY = 61,
    LINKAGE = 62,
    LIST = 63,
    LOCATION = 64,
    MEASURE = 65,
    MEASURE_REPORT = 66,
    MEDIA = 67,
    MEDICATION = 68,
    MEDICATION_ADMINISTRATION = 69,
    MEDICATION_DISPENSE = 70,
    MEDICATION_REQUEST = 71,
    MEDICATION_STATEMENT = 72,
    MESSAGE_DEFINITION = 73,
    MESSAGE_HEADER = 74,
    NAMING_SYSTEM = 75,
    NUTRITION_ORDER = 76,
    OBSERVATION = 77,
    OPERATION_DEFINITION = 78,
    OPERATION_OUTCOME = 79,
    ORGANIZATION = 80,
    PARAMETERS = 81,
    PATIENT = 82,
    PAYMENT_NOTICE = 83,
    PAYMENT_RECONCILIATION = 84,
    PERSON = 85,
    PLAN_DEFINITION = 86,
    PRACTITIONER = 87,
    PRACTITIONER_ROLE = 88,
    PROCEDURE = 89,
    PROCEDURE_REQUEST = 90,
    PROCESS_REQUEST = 91,
    PROCESS_RESPONSE = 92,
    PROVENANCE = 93,
    QUESTIONNAIRE = 94,
    QUESTIONNAIRE_RESPONSE = 95,
    REFERRAL_REQUEST = 96,
    RELATED_PERSON = 97,
    REQUEST_GROUP = 98,
    RESEARCH_STUDY = 99,
    RESEARCH_SUBJECT = 100,
    RESOURCE = 101,
    RISK_ASSESSMENT = 102,
    SCHEDULE = 103,
    SEARCH_PARAMETER = 104,
    SEQUENCE = 105,
    SERVICE_DEFINITION = 106,
    SLOT = 107,
    SPECIMEN = 108,
    STRUCTURE_DEFINITION = 109,
    STRUCTURE_MAP = 110,
    SUBSCRIPTION = 111,
    SUBSTANCE = 112,
    SUPPLY_DELIVERY = 113,
    SUPPLY_REQUEST = 114,
    TASK = 115,
    TEST_REPORT = 116,
    TEST_SCRIPT = 117,
    VALUE_SET = 118,
    VISION_PRESCRIPTION = 119,
}

impl ::protobuf::ProtobufEnum for ResourceTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResourceTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ResourceTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ResourceTypeCode_Value::ACCOUNT),
            2 => ::std::option::Option::Some(ResourceTypeCode_Value::ACTIVITY_DEFINITION),
            3 => ::std::option::Option::Some(ResourceTypeCode_Value::ADVERSE_EVENT),
            4 => ::std::option::Option::Some(ResourceTypeCode_Value::ALLERGY_INTOLERANCE),
            5 => ::std::option::Option::Some(ResourceTypeCode_Value::APPOINTMENT),
            6 => ::std::option::Option::Some(ResourceTypeCode_Value::APPOINTMENT_RESPONSE),
            7 => ::std::option::Option::Some(ResourceTypeCode_Value::AUDIT_EVENT),
            8 => ::std::option::Option::Some(ResourceTypeCode_Value::BASIC),
            9 => ::std::option::Option::Some(ResourceTypeCode_Value::BINARY),
            10 => ::std::option::Option::Some(ResourceTypeCode_Value::BODY_SITE),
            11 => ::std::option::Option::Some(ResourceTypeCode_Value::BUNDLE),
            12 => ::std::option::Option::Some(ResourceTypeCode_Value::CAPABILITY_STATEMENT),
            13 => ::std::option::Option::Some(ResourceTypeCode_Value::CARE_PLAN),
            14 => ::std::option::Option::Some(ResourceTypeCode_Value::CARE_TEAM),
            15 => ::std::option::Option::Some(ResourceTypeCode_Value::CHARGE_ITEM),
            16 => ::std::option::Option::Some(ResourceTypeCode_Value::CLAIM),
            17 => ::std::option::Option::Some(ResourceTypeCode_Value::CLAIM_RESPONSE),
            18 => ::std::option::Option::Some(ResourceTypeCode_Value::CLINICAL_IMPRESSION),
            19 => ::std::option::Option::Some(ResourceTypeCode_Value::CODE_SYSTEM),
            20 => ::std::option::Option::Some(ResourceTypeCode_Value::COMMUNICATION),
            21 => ::std::option::Option::Some(ResourceTypeCode_Value::COMMUNICATION_REQUEST),
            22 => ::std::option::Option::Some(ResourceTypeCode_Value::COMPARTMENT_DEFINITION),
            23 => ::std::option::Option::Some(ResourceTypeCode_Value::COMPOSITION),
            24 => ::std::option::Option::Some(ResourceTypeCode_Value::CONCEPT_MAP),
            25 => ::std::option::Option::Some(ResourceTypeCode_Value::CONDITION),
            26 => ::std::option::Option::Some(ResourceTypeCode_Value::CONSENT),
            27 => ::std::option::Option::Some(ResourceTypeCode_Value::CONTRACT),
            28 => ::std::option::Option::Some(ResourceTypeCode_Value::COVERAGE),
            29 => ::std::option::Option::Some(ResourceTypeCode_Value::DATA_ELEMENT),
            30 => ::std::option::Option::Some(ResourceTypeCode_Value::DETECTED_ISSUE),
            31 => ::std::option::Option::Some(ResourceTypeCode_Value::DEVICE),
            32 => ::std::option::Option::Some(ResourceTypeCode_Value::DEVICE_COMPONENT),
            33 => ::std::option::Option::Some(ResourceTypeCode_Value::DEVICE_METRIC),
            34 => ::std::option::Option::Some(ResourceTypeCode_Value::DEVICE_REQUEST),
            35 => ::std::option::Option::Some(ResourceTypeCode_Value::DEVICE_USE_STATEMENT),
            36 => ::std::option::Option::Some(ResourceTypeCode_Value::DIAGNOSTIC_REPORT),
            37 => ::std::option::Option::Some(ResourceTypeCode_Value::DOCUMENT_MANIFEST),
            38 => ::std::option::Option::Some(ResourceTypeCode_Value::DOCUMENT_REFERENCE),
            39 => ::std::option::Option::Some(ResourceTypeCode_Value::DOMAIN_RESOURCE),
            40 => ::std::option::Option::Some(ResourceTypeCode_Value::ELIGIBILITY_REQUEST),
            41 => ::std::option::Option::Some(ResourceTypeCode_Value::ELIGIBILITY_RESPONSE),
            42 => ::std::option::Option::Some(ResourceTypeCode_Value::ENCOUNTER),
            43 => ::std::option::Option::Some(ResourceTypeCode_Value::ENDPOINT),
            44 => ::std::option::Option::Some(ResourceTypeCode_Value::ENROLLMENT_REQUEST),
            45 => ::std::option::Option::Some(ResourceTypeCode_Value::ENROLLMENT_RESPONSE),
            46 => ::std::option::Option::Some(ResourceTypeCode_Value::EPISODE_OF_CARE),
            47 => ::std::option::Option::Some(ResourceTypeCode_Value::EXPANSION_PROFILE),
            48 => ::std::option::Option::Some(ResourceTypeCode_Value::EXPLANATION_OF_BENEFIT),
            49 => ::std::option::Option::Some(ResourceTypeCode_Value::FAMILY_MEMBER_HISTORY),
            50 => ::std::option::Option::Some(ResourceTypeCode_Value::FLAG),
            51 => ::std::option::Option::Some(ResourceTypeCode_Value::GOAL),
            52 => ::std::option::Option::Some(ResourceTypeCode_Value::GRAPH_DEFINITION),
            53 => ::std::option::Option::Some(ResourceTypeCode_Value::GROUP),
            54 => ::std::option::Option::Some(ResourceTypeCode_Value::GUIDANCE_RESPONSE),
            55 => ::std::option::Option::Some(ResourceTypeCode_Value::HEALTHCARE_SERVICE),
            56 => ::std::option::Option::Some(ResourceTypeCode_Value::IMAGING_MANIFEST),
            57 => ::std::option::Option::Some(ResourceTypeCode_Value::IMAGING_STUDY),
            58 => ::std::option::Option::Some(ResourceTypeCode_Value::IMMUNIZATION),
            59 => ::std::option::Option::Some(ResourceTypeCode_Value::IMMUNIZATION_RECOMMENDATION),
            60 => ::std::option::Option::Some(ResourceTypeCode_Value::IMPLEMENTATION_GUIDE),
            61 => ::std::option::Option::Some(ResourceTypeCode_Value::LIBRARY),
            62 => ::std::option::Option::Some(ResourceTypeCode_Value::LINKAGE),
            63 => ::std::option::Option::Some(ResourceTypeCode_Value::LIST),
            64 => ::std::option::Option::Some(ResourceTypeCode_Value::LOCATION),
            65 => ::std::option::Option::Some(ResourceTypeCode_Value::MEASURE),
            66 => ::std::option::Option::Some(ResourceTypeCode_Value::MEASURE_REPORT),
            67 => ::std::option::Option::Some(ResourceTypeCode_Value::MEDIA),
            68 => ::std::option::Option::Some(ResourceTypeCode_Value::MEDICATION),
            69 => ::std::option::Option::Some(ResourceTypeCode_Value::MEDICATION_ADMINISTRATION),
            70 => ::std::option::Option::Some(ResourceTypeCode_Value::MEDICATION_DISPENSE),
            71 => ::std::option::Option::Some(ResourceTypeCode_Value::MEDICATION_REQUEST),
            72 => ::std::option::Option::Some(ResourceTypeCode_Value::MEDICATION_STATEMENT),
            73 => ::std::option::Option::Some(ResourceTypeCode_Value::MESSAGE_DEFINITION),
            74 => ::std::option::Option::Some(ResourceTypeCode_Value::MESSAGE_HEADER),
            75 => ::std::option::Option::Some(ResourceTypeCode_Value::NAMING_SYSTEM),
            76 => ::std::option::Option::Some(ResourceTypeCode_Value::NUTRITION_ORDER),
            77 => ::std::option::Option::Some(ResourceTypeCode_Value::OBSERVATION),
            78 => ::std::option::Option::Some(ResourceTypeCode_Value::OPERATION_DEFINITION),
            79 => ::std::option::Option::Some(ResourceTypeCode_Value::OPERATION_OUTCOME),
            80 => ::std::option::Option::Some(ResourceTypeCode_Value::ORGANIZATION),
            81 => ::std::option::Option::Some(ResourceTypeCode_Value::PARAMETERS),
            82 => ::std::option::Option::Some(ResourceTypeCode_Value::PATIENT),
            83 => ::std::option::Option::Some(ResourceTypeCode_Value::PAYMENT_NOTICE),
            84 => ::std::option::Option::Some(ResourceTypeCode_Value::PAYMENT_RECONCILIATION),
            85 => ::std::option::Option::Some(ResourceTypeCode_Value::PERSON),
            86 => ::std::option::Option::Some(ResourceTypeCode_Value::PLAN_DEFINITION),
            87 => ::std::option::Option::Some(ResourceTypeCode_Value::PRACTITIONER),
            88 => ::std::option::Option::Some(ResourceTypeCode_Value::PRACTITIONER_ROLE),
            89 => ::std::option::Option::Some(ResourceTypeCode_Value::PROCEDURE),
            90 => ::std::option::Option::Some(ResourceTypeCode_Value::PROCEDURE_REQUEST),
            91 => ::std::option::Option::Some(ResourceTypeCode_Value::PROCESS_REQUEST),
            92 => ::std::option::Option::Some(ResourceTypeCode_Value::PROCESS_RESPONSE),
            93 => ::std::option::Option::Some(ResourceTypeCode_Value::PROVENANCE),
            94 => ::std::option::Option::Some(ResourceTypeCode_Value::QUESTIONNAIRE),
            95 => ::std::option::Option::Some(ResourceTypeCode_Value::QUESTIONNAIRE_RESPONSE),
            96 => ::std::option::Option::Some(ResourceTypeCode_Value::REFERRAL_REQUEST),
            97 => ::std::option::Option::Some(ResourceTypeCode_Value::RELATED_PERSON),
            98 => ::std::option::Option::Some(ResourceTypeCode_Value::REQUEST_GROUP),
            99 => ::std::option::Option::Some(ResourceTypeCode_Value::RESEARCH_STUDY),
            100 => ::std::option::Option::Some(ResourceTypeCode_Value::RESEARCH_SUBJECT),
            101 => ::std::option::Option::Some(ResourceTypeCode_Value::RESOURCE),
            102 => ::std::option::Option::Some(ResourceTypeCode_Value::RISK_ASSESSMENT),
            103 => ::std::option::Option::Some(ResourceTypeCode_Value::SCHEDULE),
            104 => ::std::option::Option::Some(ResourceTypeCode_Value::SEARCH_PARAMETER),
            105 => ::std::option::Option::Some(ResourceTypeCode_Value::SEQUENCE),
            106 => ::std::option::Option::Some(ResourceTypeCode_Value::SERVICE_DEFINITION),
            107 => ::std::option::Option::Some(ResourceTypeCode_Value::SLOT),
            108 => ::std::option::Option::Some(ResourceTypeCode_Value::SPECIMEN),
            109 => ::std::option::Option::Some(ResourceTypeCode_Value::STRUCTURE_DEFINITION),
            110 => ::std::option::Option::Some(ResourceTypeCode_Value::STRUCTURE_MAP),
            111 => ::std::option::Option::Some(ResourceTypeCode_Value::SUBSCRIPTION),
            112 => ::std::option::Option::Some(ResourceTypeCode_Value::SUBSTANCE),
            113 => ::std::option::Option::Some(ResourceTypeCode_Value::SUPPLY_DELIVERY),
            114 => ::std::option::Option::Some(ResourceTypeCode_Value::SUPPLY_REQUEST),
            115 => ::std::option::Option::Some(ResourceTypeCode_Value::TASK),
            116 => ::std::option::Option::Some(ResourceTypeCode_Value::TEST_REPORT),
            117 => ::std::option::Option::Some(ResourceTypeCode_Value::TEST_SCRIPT),
            118 => ::std::option::Option::Some(ResourceTypeCode_Value::VALUE_SET),
            119 => ::std::option::Option::Some(ResourceTypeCode_Value::VISION_PRESCRIPTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResourceTypeCode_Value] = &[
            ResourceTypeCode_Value::INVALID_UNINITIALIZED,
            ResourceTypeCode_Value::ACCOUNT,
            ResourceTypeCode_Value::ACTIVITY_DEFINITION,
            ResourceTypeCode_Value::ADVERSE_EVENT,
            ResourceTypeCode_Value::ALLERGY_INTOLERANCE,
            ResourceTypeCode_Value::APPOINTMENT,
            ResourceTypeCode_Value::APPOINTMENT_RESPONSE,
            ResourceTypeCode_Value::AUDIT_EVENT,
            ResourceTypeCode_Value::BASIC,
            ResourceTypeCode_Value::BINARY,
            ResourceTypeCode_Value::BODY_SITE,
            ResourceTypeCode_Value::BUNDLE,
            ResourceTypeCode_Value::CAPABILITY_STATEMENT,
            ResourceTypeCode_Value::CARE_PLAN,
            ResourceTypeCode_Value::CARE_TEAM,
            ResourceTypeCode_Value::CHARGE_ITEM,
            ResourceTypeCode_Value::CLAIM,
            ResourceTypeCode_Value::CLAIM_RESPONSE,
            ResourceTypeCode_Value::CLINICAL_IMPRESSION,
            ResourceTypeCode_Value::CODE_SYSTEM,
            ResourceTypeCode_Value::COMMUNICATION,
            ResourceTypeCode_Value::COMMUNICATION_REQUEST,
            ResourceTypeCode_Value::COMPARTMENT_DEFINITION,
            ResourceTypeCode_Value::COMPOSITION,
            ResourceTypeCode_Value::CONCEPT_MAP,
            ResourceTypeCode_Value::CONDITION,
            ResourceTypeCode_Value::CONSENT,
            ResourceTypeCode_Value::CONTRACT,
            ResourceTypeCode_Value::COVERAGE,
            ResourceTypeCode_Value::DATA_ELEMENT,
            ResourceTypeCode_Value::DETECTED_ISSUE,
            ResourceTypeCode_Value::DEVICE,
            ResourceTypeCode_Value::DEVICE_COMPONENT,
            ResourceTypeCode_Value::DEVICE_METRIC,
            ResourceTypeCode_Value::DEVICE_REQUEST,
            ResourceTypeCode_Value::DEVICE_USE_STATEMENT,
            ResourceTypeCode_Value::DIAGNOSTIC_REPORT,
            ResourceTypeCode_Value::DOCUMENT_MANIFEST,
            ResourceTypeCode_Value::DOCUMENT_REFERENCE,
            ResourceTypeCode_Value::DOMAIN_RESOURCE,
            ResourceTypeCode_Value::ELIGIBILITY_REQUEST,
            ResourceTypeCode_Value::ELIGIBILITY_RESPONSE,
            ResourceTypeCode_Value::ENCOUNTER,
            ResourceTypeCode_Value::ENDPOINT,
            ResourceTypeCode_Value::ENROLLMENT_REQUEST,
            ResourceTypeCode_Value::ENROLLMENT_RESPONSE,
            ResourceTypeCode_Value::EPISODE_OF_CARE,
            ResourceTypeCode_Value::EXPANSION_PROFILE,
            ResourceTypeCode_Value::EXPLANATION_OF_BENEFIT,
            ResourceTypeCode_Value::FAMILY_MEMBER_HISTORY,
            ResourceTypeCode_Value::FLAG,
            ResourceTypeCode_Value::GOAL,
            ResourceTypeCode_Value::GRAPH_DEFINITION,
            ResourceTypeCode_Value::GROUP,
            ResourceTypeCode_Value::GUIDANCE_RESPONSE,
            ResourceTypeCode_Value::HEALTHCARE_SERVICE,
            ResourceTypeCode_Value::IMAGING_MANIFEST,
            ResourceTypeCode_Value::IMAGING_STUDY,
            ResourceTypeCode_Value::IMMUNIZATION,
            ResourceTypeCode_Value::IMMUNIZATION_RECOMMENDATION,
            ResourceTypeCode_Value::IMPLEMENTATION_GUIDE,
            ResourceTypeCode_Value::LIBRARY,
            ResourceTypeCode_Value::LINKAGE,
            ResourceTypeCode_Value::LIST,
            ResourceTypeCode_Value::LOCATION,
            ResourceTypeCode_Value::MEASURE,
            ResourceTypeCode_Value::MEASURE_REPORT,
            ResourceTypeCode_Value::MEDIA,
            ResourceTypeCode_Value::MEDICATION,
            ResourceTypeCode_Value::MEDICATION_ADMINISTRATION,
            ResourceTypeCode_Value::MEDICATION_DISPENSE,
            ResourceTypeCode_Value::MEDICATION_REQUEST,
            ResourceTypeCode_Value::MEDICATION_STATEMENT,
            ResourceTypeCode_Value::MESSAGE_DEFINITION,
            ResourceTypeCode_Value::MESSAGE_HEADER,
            ResourceTypeCode_Value::NAMING_SYSTEM,
            ResourceTypeCode_Value::NUTRITION_ORDER,
            ResourceTypeCode_Value::OBSERVATION,
            ResourceTypeCode_Value::OPERATION_DEFINITION,
            ResourceTypeCode_Value::OPERATION_OUTCOME,
            ResourceTypeCode_Value::ORGANIZATION,
            ResourceTypeCode_Value::PARAMETERS,
            ResourceTypeCode_Value::PATIENT,
            ResourceTypeCode_Value::PAYMENT_NOTICE,
            ResourceTypeCode_Value::PAYMENT_RECONCILIATION,
            ResourceTypeCode_Value::PERSON,
            ResourceTypeCode_Value::PLAN_DEFINITION,
            ResourceTypeCode_Value::PRACTITIONER,
            ResourceTypeCode_Value::PRACTITIONER_ROLE,
            ResourceTypeCode_Value::PROCEDURE,
            ResourceTypeCode_Value::PROCEDURE_REQUEST,
            ResourceTypeCode_Value::PROCESS_REQUEST,
            ResourceTypeCode_Value::PROCESS_RESPONSE,
            ResourceTypeCode_Value::PROVENANCE,
            ResourceTypeCode_Value::QUESTIONNAIRE,
            ResourceTypeCode_Value::QUESTIONNAIRE_RESPONSE,
            ResourceTypeCode_Value::REFERRAL_REQUEST,
            ResourceTypeCode_Value::RELATED_PERSON,
            ResourceTypeCode_Value::REQUEST_GROUP,
            ResourceTypeCode_Value::RESEARCH_STUDY,
            ResourceTypeCode_Value::RESEARCH_SUBJECT,
            ResourceTypeCode_Value::RESOURCE,
            ResourceTypeCode_Value::RISK_ASSESSMENT,
            ResourceTypeCode_Value::SCHEDULE,
            ResourceTypeCode_Value::SEARCH_PARAMETER,
            ResourceTypeCode_Value::SEQUENCE,
            ResourceTypeCode_Value::SERVICE_DEFINITION,
            ResourceTypeCode_Value::SLOT,
            ResourceTypeCode_Value::SPECIMEN,
            ResourceTypeCode_Value::STRUCTURE_DEFINITION,
            ResourceTypeCode_Value::STRUCTURE_MAP,
            ResourceTypeCode_Value::SUBSCRIPTION,
            ResourceTypeCode_Value::SUBSTANCE,
            ResourceTypeCode_Value::SUPPLY_DELIVERY,
            ResourceTypeCode_Value::SUPPLY_REQUEST,
            ResourceTypeCode_Value::TASK,
            ResourceTypeCode_Value::TEST_REPORT,
            ResourceTypeCode_Value::TEST_SCRIPT,
            ResourceTypeCode_Value::VALUE_SET,
            ResourceTypeCode_Value::VISION_PRESCRIPTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ResourceTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResourceTypeCode_Value {
}

impl ::std::default::Default for ResourceTypeCode_Value {
    fn default() -> Self {
        ResourceTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceValidationModeCode {
    // message fields
    pub value: ResourceValidationModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ResourceValidationModeCode {
    pub fn new() -> ResourceValidationModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ResourceValidationModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ResourceValidationModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ResourceValidationModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ResourceValidationModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ResourceValidationModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ResourceValidationModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ResourceValidationModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceValidationModeCode {
        ResourceValidationModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResourceValidationModeCode_Value>>(
                    "value",
                    |m: &ResourceValidationModeCode| { &m.value },
                    |m: &mut ResourceValidationModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ResourceValidationModeCode| { &m.id },
                    |m: &mut ResourceValidationModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ResourceValidationModeCode| { &m.extension },
                    |m: &mut ResourceValidationModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceValidationModeCode>(
                    "ResourceValidationModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResourceValidationModeCode {
        static mut instance: ::protobuf::lazy::Lazy<ResourceValidationModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceValidationModeCode,
        };
        unsafe {
            instance.get(ResourceValidationModeCode::new)
        }
    }
}

impl ::protobuf::Clear for ResourceValidationModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceValidationModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceValidationModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResourceValidationModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    CREATE = 1,
    UPDATE = 2,
    DELETE = 3,
}

impl ::protobuf::ProtobufEnum for ResourceValidationModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResourceValidationModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ResourceValidationModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ResourceValidationModeCode_Value::CREATE),
            2 => ::std::option::Option::Some(ResourceValidationModeCode_Value::UPDATE),
            3 => ::std::option::Option::Some(ResourceValidationModeCode_Value::DELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResourceValidationModeCode_Value] = &[
            ResourceValidationModeCode_Value::INVALID_UNINITIALIZED,
            ResourceValidationModeCode_Value::CREATE,
            ResourceValidationModeCode_Value::UPDATE,
            ResourceValidationModeCode_Value::DELETE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ResourceValidationModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResourceValidationModeCode_Value {
}

impl ::std::default::Default for ResourceValidationModeCode_Value {
    fn default() -> Self {
        ResourceValidationModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceValidationModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResponseTypeCode {
    // message fields
    pub value: ResponseTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ResponseTypeCode {
    pub fn new() -> ResponseTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ResponseTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ResponseTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ResponseTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ResponseTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ResponseTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ResponseTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ResponseTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResponseTypeCode {
        ResponseTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseTypeCode_Value>>(
                    "value",
                    |m: &ResponseTypeCode| { &m.value },
                    |m: &mut ResponseTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ResponseTypeCode| { &m.id },
                    |m: &mut ResponseTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ResponseTypeCode| { &m.extension },
                    |m: &mut ResponseTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResponseTypeCode>(
                    "ResponseTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResponseTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<ResponseTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResponseTypeCode,
        };
        unsafe {
            instance.get(ResponseTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for ResponseTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResponseTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    OK = 1,
    TRANSIENT_ERROR = 2,
    FATAL_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for ResponseTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ResponseTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ResponseTypeCode_Value::OK),
            2 => ::std::option::Option::Some(ResponseTypeCode_Value::TRANSIENT_ERROR),
            3 => ::std::option::Option::Some(ResponseTypeCode_Value::FATAL_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseTypeCode_Value] = &[
            ResponseTypeCode_Value::INVALID_UNINITIALIZED,
            ResponseTypeCode_Value::OK,
            ResponseTypeCode_Value::TRANSIENT_ERROR,
            ResponseTypeCode_Value::FATAL_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ResponseTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResponseTypeCode_Value {
}

impl ::std::default::Default for ResponseTypeCode_Value {
    fn default() -> Self {
        ResponseTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestfulCapabilityModeCode {
    // message fields
    pub value: RestfulCapabilityModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RestfulCapabilityModeCode {
    pub fn new() -> RestfulCapabilityModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.RestfulCapabilityModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = RestfulCapabilityModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: RestfulCapabilityModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> RestfulCapabilityModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for RestfulCapabilityModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != RestfulCapabilityModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != RestfulCapabilityModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestfulCapabilityModeCode {
        RestfulCapabilityModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RestfulCapabilityModeCode_Value>>(
                    "value",
                    |m: &RestfulCapabilityModeCode| { &m.value },
                    |m: &mut RestfulCapabilityModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &RestfulCapabilityModeCode| { &m.id },
                    |m: &mut RestfulCapabilityModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &RestfulCapabilityModeCode| { &m.extension },
                    |m: &mut RestfulCapabilityModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RestfulCapabilityModeCode>(
                    "RestfulCapabilityModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RestfulCapabilityModeCode {
        static mut instance: ::protobuf::lazy::Lazy<RestfulCapabilityModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestfulCapabilityModeCode,
        };
        unsafe {
            instance.get(RestfulCapabilityModeCode::new)
        }
    }
}

impl ::protobuf::Clear for RestfulCapabilityModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestfulCapabilityModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestfulCapabilityModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RestfulCapabilityModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    CLIENT = 1,
    SERVER = 2,
}

impl ::protobuf::ProtobufEnum for RestfulCapabilityModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RestfulCapabilityModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(RestfulCapabilityModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(RestfulCapabilityModeCode_Value::CLIENT),
            2 => ::std::option::Option::Some(RestfulCapabilityModeCode_Value::SERVER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RestfulCapabilityModeCode_Value] = &[
            RestfulCapabilityModeCode_Value::INVALID_UNINITIALIZED,
            RestfulCapabilityModeCode_Value::CLIENT,
            RestfulCapabilityModeCode_Value::SERVER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RestfulCapabilityModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RestfulCapabilityModeCode_Value {
}

impl ::std::default::Default for RestfulCapabilityModeCode_Value {
    fn default() -> Self {
        RestfulCapabilityModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for RestfulCapabilityModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestfulSecurityServiceCode {
    // message fields
    pub value: RestfulSecurityServiceCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RestfulSecurityServiceCode {
    pub fn new() -> RestfulSecurityServiceCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.RestfulSecurityServiceCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = RestfulSecurityServiceCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: RestfulSecurityServiceCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> RestfulSecurityServiceCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for RestfulSecurityServiceCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != RestfulSecurityServiceCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != RestfulSecurityServiceCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestfulSecurityServiceCode {
        RestfulSecurityServiceCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RestfulSecurityServiceCode_Value>>(
                    "value",
                    |m: &RestfulSecurityServiceCode| { &m.value },
                    |m: &mut RestfulSecurityServiceCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &RestfulSecurityServiceCode| { &m.id },
                    |m: &mut RestfulSecurityServiceCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &RestfulSecurityServiceCode| { &m.extension },
                    |m: &mut RestfulSecurityServiceCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RestfulSecurityServiceCode>(
                    "RestfulSecurityServiceCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RestfulSecurityServiceCode {
        static mut instance: ::protobuf::lazy::Lazy<RestfulSecurityServiceCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestfulSecurityServiceCode,
        };
        unsafe {
            instance.get(RestfulSecurityServiceCode::new)
        }
    }
}

impl ::protobuf::Clear for RestfulSecurityServiceCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestfulSecurityServiceCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestfulSecurityServiceCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RestfulSecurityServiceCode_Value {
    INVALID_UNINITIALIZED = 0,
    OAUTH = 1,
    SMART_ON_FHIR = 2,
    NTLM = 3,
    BASIC = 4,
    KERBEROS = 5,
    CERTIFICATES = 6,
}

impl ::protobuf::ProtobufEnum for RestfulSecurityServiceCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RestfulSecurityServiceCode_Value> {
        match value {
            0 => ::std::option::Option::Some(RestfulSecurityServiceCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(RestfulSecurityServiceCode_Value::OAUTH),
            2 => ::std::option::Option::Some(RestfulSecurityServiceCode_Value::SMART_ON_FHIR),
            3 => ::std::option::Option::Some(RestfulSecurityServiceCode_Value::NTLM),
            4 => ::std::option::Option::Some(RestfulSecurityServiceCode_Value::BASIC),
            5 => ::std::option::Option::Some(RestfulSecurityServiceCode_Value::KERBEROS),
            6 => ::std::option::Option::Some(RestfulSecurityServiceCode_Value::CERTIFICATES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RestfulSecurityServiceCode_Value] = &[
            RestfulSecurityServiceCode_Value::INVALID_UNINITIALIZED,
            RestfulSecurityServiceCode_Value::OAUTH,
            RestfulSecurityServiceCode_Value::SMART_ON_FHIR,
            RestfulSecurityServiceCode_Value::NTLM,
            RestfulSecurityServiceCode_Value::BASIC,
            RestfulSecurityServiceCode_Value::KERBEROS,
            RestfulSecurityServiceCode_Value::CERTIFICATES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RestfulSecurityServiceCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RestfulSecurityServiceCode_Value {
}

impl ::std::default::Default for RestfulSecurityServiceCode_Value {
    fn default() -> Self {
        RestfulSecurityServiceCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for RestfulSecurityServiceCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RiskProbabilityCode {
    // message fields
    pub value: RiskProbabilityCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RiskProbabilityCode {
    pub fn new() -> RiskProbabilityCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.RiskProbabilityCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = RiskProbabilityCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: RiskProbabilityCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> RiskProbabilityCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for RiskProbabilityCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != RiskProbabilityCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != RiskProbabilityCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RiskProbabilityCode {
        RiskProbabilityCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RiskProbabilityCode_Value>>(
                    "value",
                    |m: &RiskProbabilityCode| { &m.value },
                    |m: &mut RiskProbabilityCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &RiskProbabilityCode| { &m.id },
                    |m: &mut RiskProbabilityCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &RiskProbabilityCode| { &m.extension },
                    |m: &mut RiskProbabilityCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RiskProbabilityCode>(
                    "RiskProbabilityCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RiskProbabilityCode {
        static mut instance: ::protobuf::lazy::Lazy<RiskProbabilityCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RiskProbabilityCode,
        };
        unsafe {
            instance.get(RiskProbabilityCode::new)
        }
    }
}

impl ::protobuf::Clear for RiskProbabilityCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RiskProbabilityCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RiskProbabilityCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RiskProbabilityCode_Value {
    INVALID_UNINITIALIZED = 0,
    NEGLIGIBLE = 1,
    LOW = 2,
    MODERATE = 3,
    HIGH = 4,
    CERTAIN = 5,
}

impl ::protobuf::ProtobufEnum for RiskProbabilityCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RiskProbabilityCode_Value> {
        match value {
            0 => ::std::option::Option::Some(RiskProbabilityCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(RiskProbabilityCode_Value::NEGLIGIBLE),
            2 => ::std::option::Option::Some(RiskProbabilityCode_Value::LOW),
            3 => ::std::option::Option::Some(RiskProbabilityCode_Value::MODERATE),
            4 => ::std::option::Option::Some(RiskProbabilityCode_Value::HIGH),
            5 => ::std::option::Option::Some(RiskProbabilityCode_Value::CERTAIN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RiskProbabilityCode_Value] = &[
            RiskProbabilityCode_Value::INVALID_UNINITIALIZED,
            RiskProbabilityCode_Value::NEGLIGIBLE,
            RiskProbabilityCode_Value::LOW,
            RiskProbabilityCode_Value::MODERATE,
            RiskProbabilityCode_Value::HIGH,
            RiskProbabilityCode_Value::CERTAIN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RiskProbabilityCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RiskProbabilityCode_Value {
}

impl ::std::default::Default for RiskProbabilityCode_Value {
    fn default() -> Self {
        RiskProbabilityCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for RiskProbabilityCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchComparatorCode {
    // message fields
    pub value: SearchComparatorCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SearchComparatorCode {
    pub fn new() -> SearchComparatorCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SearchComparatorCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SearchComparatorCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SearchComparatorCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SearchComparatorCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SearchComparatorCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SearchComparatorCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SearchComparatorCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchComparatorCode {
        SearchComparatorCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SearchComparatorCode_Value>>(
                    "value",
                    |m: &SearchComparatorCode| { &m.value },
                    |m: &mut SearchComparatorCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SearchComparatorCode| { &m.id },
                    |m: &mut SearchComparatorCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SearchComparatorCode| { &m.extension },
                    |m: &mut SearchComparatorCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SearchComparatorCode>(
                    "SearchComparatorCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SearchComparatorCode {
        static mut instance: ::protobuf::lazy::Lazy<SearchComparatorCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SearchComparatorCode,
        };
        unsafe {
            instance.get(SearchComparatorCode::new)
        }
    }
}

impl ::protobuf::Clear for SearchComparatorCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchComparatorCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchComparatorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SearchComparatorCode_Value {
    INVALID_UNINITIALIZED = 0,
    EQ = 1,
    NE = 2,
    GT = 3,
    LT = 4,
    GE = 5,
    LE = 6,
    SA = 7,
    EB = 8,
    AP = 9,
}

impl ::protobuf::ProtobufEnum for SearchComparatorCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SearchComparatorCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SearchComparatorCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SearchComparatorCode_Value::EQ),
            2 => ::std::option::Option::Some(SearchComparatorCode_Value::NE),
            3 => ::std::option::Option::Some(SearchComparatorCode_Value::GT),
            4 => ::std::option::Option::Some(SearchComparatorCode_Value::LT),
            5 => ::std::option::Option::Some(SearchComparatorCode_Value::GE),
            6 => ::std::option::Option::Some(SearchComparatorCode_Value::LE),
            7 => ::std::option::Option::Some(SearchComparatorCode_Value::SA),
            8 => ::std::option::Option::Some(SearchComparatorCode_Value::EB),
            9 => ::std::option::Option::Some(SearchComparatorCode_Value::AP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SearchComparatorCode_Value] = &[
            SearchComparatorCode_Value::INVALID_UNINITIALIZED,
            SearchComparatorCode_Value::EQ,
            SearchComparatorCode_Value::NE,
            SearchComparatorCode_Value::GT,
            SearchComparatorCode_Value::LT,
            SearchComparatorCode_Value::GE,
            SearchComparatorCode_Value::LE,
            SearchComparatorCode_Value::SA,
            SearchComparatorCode_Value::EB,
            SearchComparatorCode_Value::AP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SearchComparatorCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SearchComparatorCode_Value {
}

impl ::std::default::Default for SearchComparatorCode_Value {
    fn default() -> Self {
        SearchComparatorCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchComparatorCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchEntryModeCode {
    // message fields
    pub value: SearchEntryModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SearchEntryModeCode {
    pub fn new() -> SearchEntryModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SearchEntryModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SearchEntryModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SearchEntryModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SearchEntryModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SearchEntryModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SearchEntryModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SearchEntryModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchEntryModeCode {
        SearchEntryModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SearchEntryModeCode_Value>>(
                    "value",
                    |m: &SearchEntryModeCode| { &m.value },
                    |m: &mut SearchEntryModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SearchEntryModeCode| { &m.id },
                    |m: &mut SearchEntryModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SearchEntryModeCode| { &m.extension },
                    |m: &mut SearchEntryModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SearchEntryModeCode>(
                    "SearchEntryModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SearchEntryModeCode {
        static mut instance: ::protobuf::lazy::Lazy<SearchEntryModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SearchEntryModeCode,
        };
        unsafe {
            instance.get(SearchEntryModeCode::new)
        }
    }
}

impl ::protobuf::Clear for SearchEntryModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchEntryModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchEntryModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SearchEntryModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    MATCH = 1,
    INCLUDE = 2,
    OUTCOME = 3,
}

impl ::protobuf::ProtobufEnum for SearchEntryModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SearchEntryModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SearchEntryModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SearchEntryModeCode_Value::MATCH),
            2 => ::std::option::Option::Some(SearchEntryModeCode_Value::INCLUDE),
            3 => ::std::option::Option::Some(SearchEntryModeCode_Value::OUTCOME),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SearchEntryModeCode_Value] = &[
            SearchEntryModeCode_Value::INVALID_UNINITIALIZED,
            SearchEntryModeCode_Value::MATCH,
            SearchEntryModeCode_Value::INCLUDE,
            SearchEntryModeCode_Value::OUTCOME,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SearchEntryModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SearchEntryModeCode_Value {
}

impl ::std::default::Default for SearchEntryModeCode_Value {
    fn default() -> Self {
        SearchEntryModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchEntryModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchModifierCodeCode {
    // message fields
    pub value: SearchModifierCodeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SearchModifierCodeCode {
    pub fn new() -> SearchModifierCodeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SearchModifierCodeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SearchModifierCodeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SearchModifierCodeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SearchModifierCodeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SearchModifierCodeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SearchModifierCodeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SearchModifierCodeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchModifierCodeCode {
        SearchModifierCodeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SearchModifierCodeCode_Value>>(
                    "value",
                    |m: &SearchModifierCodeCode| { &m.value },
                    |m: &mut SearchModifierCodeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SearchModifierCodeCode| { &m.id },
                    |m: &mut SearchModifierCodeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SearchModifierCodeCode| { &m.extension },
                    |m: &mut SearchModifierCodeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SearchModifierCodeCode>(
                    "SearchModifierCodeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SearchModifierCodeCode {
        static mut instance: ::protobuf::lazy::Lazy<SearchModifierCodeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SearchModifierCodeCode,
        };
        unsafe {
            instance.get(SearchModifierCodeCode::new)
        }
    }
}

impl ::protobuf::Clear for SearchModifierCodeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchModifierCodeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchModifierCodeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SearchModifierCodeCode_Value {
    INVALID_UNINITIALIZED = 0,
    MISSING = 1,
    EXACT = 2,
    CONTAINS = 3,
    NOT = 4,
    TEXT = 5,
    IN = 6,
    NOT_IN = 7,
    BELOW = 8,
    ABOVE = 9,
    TYPE = 10,
}

impl ::protobuf::ProtobufEnum for SearchModifierCodeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SearchModifierCodeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SearchModifierCodeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SearchModifierCodeCode_Value::MISSING),
            2 => ::std::option::Option::Some(SearchModifierCodeCode_Value::EXACT),
            3 => ::std::option::Option::Some(SearchModifierCodeCode_Value::CONTAINS),
            4 => ::std::option::Option::Some(SearchModifierCodeCode_Value::NOT),
            5 => ::std::option::Option::Some(SearchModifierCodeCode_Value::TEXT),
            6 => ::std::option::Option::Some(SearchModifierCodeCode_Value::IN),
            7 => ::std::option::Option::Some(SearchModifierCodeCode_Value::NOT_IN),
            8 => ::std::option::Option::Some(SearchModifierCodeCode_Value::BELOW),
            9 => ::std::option::Option::Some(SearchModifierCodeCode_Value::ABOVE),
            10 => ::std::option::Option::Some(SearchModifierCodeCode_Value::TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SearchModifierCodeCode_Value] = &[
            SearchModifierCodeCode_Value::INVALID_UNINITIALIZED,
            SearchModifierCodeCode_Value::MISSING,
            SearchModifierCodeCode_Value::EXACT,
            SearchModifierCodeCode_Value::CONTAINS,
            SearchModifierCodeCode_Value::NOT,
            SearchModifierCodeCode_Value::TEXT,
            SearchModifierCodeCode_Value::IN,
            SearchModifierCodeCode_Value::NOT_IN,
            SearchModifierCodeCode_Value::BELOW,
            SearchModifierCodeCode_Value::ABOVE,
            SearchModifierCodeCode_Value::TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SearchModifierCodeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SearchModifierCodeCode_Value {
}

impl ::std::default::Default for SearchModifierCodeCode_Value {
    fn default() -> Self {
        SearchModifierCodeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchModifierCodeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchParamTypeCode {
    // message fields
    pub value: SearchParamTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SearchParamTypeCode {
    pub fn new() -> SearchParamTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SearchParamTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SearchParamTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SearchParamTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SearchParamTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SearchParamTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SearchParamTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SearchParamTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchParamTypeCode {
        SearchParamTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SearchParamTypeCode_Value>>(
                    "value",
                    |m: &SearchParamTypeCode| { &m.value },
                    |m: &mut SearchParamTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SearchParamTypeCode| { &m.id },
                    |m: &mut SearchParamTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SearchParamTypeCode| { &m.extension },
                    |m: &mut SearchParamTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SearchParamTypeCode>(
                    "SearchParamTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SearchParamTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<SearchParamTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SearchParamTypeCode,
        };
        unsafe {
            instance.get(SearchParamTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for SearchParamTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchParamTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchParamTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SearchParamTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    NUMBER = 1,
    DATE = 2,
    STRING = 3,
    TOKEN = 4,
    REFERENCE = 5,
    COMPOSITE = 6,
    QUANTITY = 7,
    URI = 8,
}

impl ::protobuf::ProtobufEnum for SearchParamTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SearchParamTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SearchParamTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SearchParamTypeCode_Value::NUMBER),
            2 => ::std::option::Option::Some(SearchParamTypeCode_Value::DATE),
            3 => ::std::option::Option::Some(SearchParamTypeCode_Value::STRING),
            4 => ::std::option::Option::Some(SearchParamTypeCode_Value::TOKEN),
            5 => ::std::option::Option::Some(SearchParamTypeCode_Value::REFERENCE),
            6 => ::std::option::Option::Some(SearchParamTypeCode_Value::COMPOSITE),
            7 => ::std::option::Option::Some(SearchParamTypeCode_Value::QUANTITY),
            8 => ::std::option::Option::Some(SearchParamTypeCode_Value::URI),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SearchParamTypeCode_Value] = &[
            SearchParamTypeCode_Value::INVALID_UNINITIALIZED,
            SearchParamTypeCode_Value::NUMBER,
            SearchParamTypeCode_Value::DATE,
            SearchParamTypeCode_Value::STRING,
            SearchParamTypeCode_Value::TOKEN,
            SearchParamTypeCode_Value::REFERENCE,
            SearchParamTypeCode_Value::COMPOSITE,
            SearchParamTypeCode_Value::QUANTITY,
            SearchParamTypeCode_Value::URI,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SearchParamTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SearchParamTypeCode_Value {
}

impl ::std::default::Default for SearchParamTypeCode_Value {
    fn default() -> Self {
        SearchParamTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchParamTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct XPathUsageTypeCode {
    // message fields
    pub value: XPathUsageTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl XPathUsageTypeCode {
    pub fn new() -> XPathUsageTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.XPathUsageTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = XPathUsageTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: XPathUsageTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> XPathUsageTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for XPathUsageTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != XPathUsageTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != XPathUsageTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> XPathUsageTypeCode {
        XPathUsageTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<XPathUsageTypeCode_Value>>(
                    "value",
                    |m: &XPathUsageTypeCode| { &m.value },
                    |m: &mut XPathUsageTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &XPathUsageTypeCode| { &m.id },
                    |m: &mut XPathUsageTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &XPathUsageTypeCode| { &m.extension },
                    |m: &mut XPathUsageTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<XPathUsageTypeCode>(
                    "XPathUsageTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static XPathUsageTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<XPathUsageTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const XPathUsageTypeCode,
        };
        unsafe {
            instance.get(XPathUsageTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for XPathUsageTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for XPathUsageTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for XPathUsageTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum XPathUsageTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    NORMAL = 1,
    PHONETIC = 2,
    NEARBY = 3,
    DISTANCE = 4,
    OTHER = 5,
}

impl ::protobuf::ProtobufEnum for XPathUsageTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<XPathUsageTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(XPathUsageTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(XPathUsageTypeCode_Value::NORMAL),
            2 => ::std::option::Option::Some(XPathUsageTypeCode_Value::PHONETIC),
            3 => ::std::option::Option::Some(XPathUsageTypeCode_Value::NEARBY),
            4 => ::std::option::Option::Some(XPathUsageTypeCode_Value::DISTANCE),
            5 => ::std::option::Option::Some(XPathUsageTypeCode_Value::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [XPathUsageTypeCode_Value] = &[
            XPathUsageTypeCode_Value::INVALID_UNINITIALIZED,
            XPathUsageTypeCode_Value::NORMAL,
            XPathUsageTypeCode_Value::PHONETIC,
            XPathUsageTypeCode_Value::NEARBY,
            XPathUsageTypeCode_Value::DISTANCE,
            XPathUsageTypeCode_Value::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("XPathUsageTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for XPathUsageTypeCode_Value {
}

impl ::std::default::Default for XPathUsageTypeCode_Value {
    fn default() -> Self {
        XPathUsageTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for XPathUsageTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SequenceTypeCode {
    // message fields
    pub value: SequenceTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SequenceTypeCode {
    pub fn new() -> SequenceTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SequenceTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SequenceTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SequenceTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SequenceTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SequenceTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SequenceTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SequenceTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SequenceTypeCode {
        SequenceTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SequenceTypeCode_Value>>(
                    "value",
                    |m: &SequenceTypeCode| { &m.value },
                    |m: &mut SequenceTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SequenceTypeCode| { &m.id },
                    |m: &mut SequenceTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SequenceTypeCode| { &m.extension },
                    |m: &mut SequenceTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SequenceTypeCode>(
                    "SequenceTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SequenceTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<SequenceTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SequenceTypeCode,
        };
        unsafe {
            instance.get(SequenceTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for SequenceTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SequenceTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SequenceTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    AA = 1,
    DNA = 2,
    RNA = 3,
}

impl ::protobuf::ProtobufEnum for SequenceTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SequenceTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SequenceTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SequenceTypeCode_Value::AA),
            2 => ::std::option::Option::Some(SequenceTypeCode_Value::DNA),
            3 => ::std::option::Option::Some(SequenceTypeCode_Value::RNA),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SequenceTypeCode_Value] = &[
            SequenceTypeCode_Value::INVALID_UNINITIALIZED,
            SequenceTypeCode_Value::AA,
            SequenceTypeCode_Value::DNA,
            SequenceTypeCode_Value::RNA,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SequenceTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SequenceTypeCode_Value {
}

impl ::std::default::Default for SequenceTypeCode_Value {
    fn default() -> Self {
        SequenceTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SequenceTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceProvisionConditionsCode {
    // message fields
    pub value: ServiceProvisionConditionsCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ServiceProvisionConditionsCode {
    pub fn new() -> ServiceProvisionConditionsCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ServiceProvisionConditionsCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ServiceProvisionConditionsCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ServiceProvisionConditionsCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ServiceProvisionConditionsCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ServiceProvisionConditionsCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ServiceProvisionConditionsCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ServiceProvisionConditionsCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceProvisionConditionsCode {
        ServiceProvisionConditionsCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServiceProvisionConditionsCode_Value>>(
                    "value",
                    |m: &ServiceProvisionConditionsCode| { &m.value },
                    |m: &mut ServiceProvisionConditionsCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ServiceProvisionConditionsCode| { &m.id },
                    |m: &mut ServiceProvisionConditionsCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ServiceProvisionConditionsCode| { &m.extension },
                    |m: &mut ServiceProvisionConditionsCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceProvisionConditionsCode>(
                    "ServiceProvisionConditionsCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServiceProvisionConditionsCode {
        static mut instance: ::protobuf::lazy::Lazy<ServiceProvisionConditionsCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceProvisionConditionsCode,
        };
        unsafe {
            instance.get(ServiceProvisionConditionsCode::new)
        }
    }
}

impl ::protobuf::Clear for ServiceProvisionConditionsCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceProvisionConditionsCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceProvisionConditionsCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServiceProvisionConditionsCode_Value {
    INVALID_UNINITIALIZED = 0,
    FREE = 1,
    DISC = 2,
    COST = 3,
}

impl ::protobuf::ProtobufEnum for ServiceProvisionConditionsCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServiceProvisionConditionsCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ServiceProvisionConditionsCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ServiceProvisionConditionsCode_Value::FREE),
            2 => ::std::option::Option::Some(ServiceProvisionConditionsCode_Value::DISC),
            3 => ::std::option::Option::Some(ServiceProvisionConditionsCode_Value::COST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServiceProvisionConditionsCode_Value] = &[
            ServiceProvisionConditionsCode_Value::INVALID_UNINITIALIZED,
            ServiceProvisionConditionsCode_Value::FREE,
            ServiceProvisionConditionsCode_Value::DISC,
            ServiceProvisionConditionsCode_Value::COST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ServiceProvisionConditionsCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ServiceProvisionConditionsCode_Value {
}

impl ::std::default::Default for ServiceProvisionConditionsCode_Value {
    fn default() -> Self {
        ServiceProvisionConditionsCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceProvisionConditionsCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReferralMethodCode {
    // message fields
    pub value: ReferralMethodCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ReferralMethodCode {
    pub fn new() -> ReferralMethodCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ReferralMethodCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ReferralMethodCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ReferralMethodCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ReferralMethodCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ReferralMethodCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ReferralMethodCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ReferralMethodCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReferralMethodCode {
        ReferralMethodCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReferralMethodCode_Value>>(
                    "value",
                    |m: &ReferralMethodCode| { &m.value },
                    |m: &mut ReferralMethodCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ReferralMethodCode| { &m.id },
                    |m: &mut ReferralMethodCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ReferralMethodCode| { &m.extension },
                    |m: &mut ReferralMethodCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReferralMethodCode>(
                    "ReferralMethodCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReferralMethodCode {
        static mut instance: ::protobuf::lazy::Lazy<ReferralMethodCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReferralMethodCode,
        };
        unsafe {
            instance.get(ReferralMethodCode::new)
        }
    }
}

impl ::protobuf::Clear for ReferralMethodCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReferralMethodCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReferralMethodCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReferralMethodCode_Value {
    INVALID_UNINITIALIZED = 0,
    FAX = 1,
    PHONE = 2,
    ELEC = 3,
    SEMAIL = 4,
    MAIL = 5,
}

impl ::protobuf::ProtobufEnum for ReferralMethodCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReferralMethodCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ReferralMethodCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ReferralMethodCode_Value::FAX),
            2 => ::std::option::Option::Some(ReferralMethodCode_Value::PHONE),
            3 => ::std::option::Option::Some(ReferralMethodCode_Value::ELEC),
            4 => ::std::option::Option::Some(ReferralMethodCode_Value::SEMAIL),
            5 => ::std::option::Option::Some(ReferralMethodCode_Value::MAIL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReferralMethodCode_Value] = &[
            ReferralMethodCode_Value::INVALID_UNINITIALIZED,
            ReferralMethodCode_Value::FAX,
            ReferralMethodCode_Value::PHONE,
            ReferralMethodCode_Value::ELEC,
            ReferralMethodCode_Value::SEMAIL,
            ReferralMethodCode_Value::MAIL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ReferralMethodCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ReferralMethodCode_Value {
}

impl ::std::default::Default for ReferralMethodCode_Value {
    fn default() -> Self {
        ReferralMethodCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ReferralMethodCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SlotStatusCode {
    // message fields
    pub value: SlotStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SlotStatusCode {
    pub fn new() -> SlotStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SlotStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SlotStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SlotStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SlotStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SlotStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SlotStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SlotStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SlotStatusCode {
        SlotStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SlotStatusCode_Value>>(
                    "value",
                    |m: &SlotStatusCode| { &m.value },
                    |m: &mut SlotStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SlotStatusCode| { &m.id },
                    |m: &mut SlotStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SlotStatusCode| { &m.extension },
                    |m: &mut SlotStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SlotStatusCode>(
                    "SlotStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SlotStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<SlotStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SlotStatusCode,
        };
        unsafe {
            instance.get(SlotStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for SlotStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SlotStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SlotStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SlotStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    BUSY = 1,
    FREE = 2,
    BUSY_UNAVAILABLE = 3,
    BUSY_TENTATIVE = 4,
    ENTERED_IN_ERROR = 5,
}

impl ::protobuf::ProtobufEnum for SlotStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SlotStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SlotStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SlotStatusCode_Value::BUSY),
            2 => ::std::option::Option::Some(SlotStatusCode_Value::FREE),
            3 => ::std::option::Option::Some(SlotStatusCode_Value::BUSY_UNAVAILABLE),
            4 => ::std::option::Option::Some(SlotStatusCode_Value::BUSY_TENTATIVE),
            5 => ::std::option::Option::Some(SlotStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SlotStatusCode_Value] = &[
            SlotStatusCode_Value::INVALID_UNINITIALIZED,
            SlotStatusCode_Value::BUSY,
            SlotStatusCode_Value::FREE,
            SlotStatusCode_Value::BUSY_UNAVAILABLE,
            SlotStatusCode_Value::BUSY_TENTATIVE,
            SlotStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SlotStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SlotStatusCode_Value {
}

impl ::std::default::Default for SlotStatusCode_Value {
    fn default() -> Self {
        SlotStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SlotStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SpecialValuesCode {
    // message fields
    pub value: SpecialValuesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SpecialValuesCode {
    pub fn new() -> SpecialValuesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SpecialValuesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SpecialValuesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SpecialValuesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SpecialValuesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SpecialValuesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SpecialValuesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SpecialValuesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpecialValuesCode {
        SpecialValuesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SpecialValuesCode_Value>>(
                    "value",
                    |m: &SpecialValuesCode| { &m.value },
                    |m: &mut SpecialValuesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SpecialValuesCode| { &m.id },
                    |m: &mut SpecialValuesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SpecialValuesCode| { &m.extension },
                    |m: &mut SpecialValuesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SpecialValuesCode>(
                    "SpecialValuesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SpecialValuesCode {
        static mut instance: ::protobuf::lazy::Lazy<SpecialValuesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SpecialValuesCode,
        };
        unsafe {
            instance.get(SpecialValuesCode::new)
        }
    }
}

impl ::protobuf::Clear for SpecialValuesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpecialValuesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpecialValuesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SpecialValuesCode_Value {
    INVALID_UNINITIALIZED = 0,
    TRUE = 1,
    FALSE = 2,
    TRACE = 3,
    SUFFICIENT = 4,
    WITHDRAWN = 5,
    NIL_KNOWN = 6,
}

impl ::protobuf::ProtobufEnum for SpecialValuesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SpecialValuesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SpecialValuesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SpecialValuesCode_Value::TRUE),
            2 => ::std::option::Option::Some(SpecialValuesCode_Value::FALSE),
            3 => ::std::option::Option::Some(SpecialValuesCode_Value::TRACE),
            4 => ::std::option::Option::Some(SpecialValuesCode_Value::SUFFICIENT),
            5 => ::std::option::Option::Some(SpecialValuesCode_Value::WITHDRAWN),
            6 => ::std::option::Option::Some(SpecialValuesCode_Value::NIL_KNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SpecialValuesCode_Value] = &[
            SpecialValuesCode_Value::INVALID_UNINITIALIZED,
            SpecialValuesCode_Value::TRUE,
            SpecialValuesCode_Value::FALSE,
            SpecialValuesCode_Value::TRACE,
            SpecialValuesCode_Value::SUFFICIENT,
            SpecialValuesCode_Value::WITHDRAWN,
            SpecialValuesCode_Value::NIL_KNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SpecialValuesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SpecialValuesCode_Value {
}

impl ::std::default::Default for SpecialValuesCode_Value {
    fn default() -> Self {
        SpecialValuesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SpecialValuesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceSpecificationSpecTypeCode {
    // message fields
    pub value: DeviceSpecificationSpecTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DeviceSpecificationSpecTypeCode {
    pub fn new() -> DeviceSpecificationSpecTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.DeviceSpecificationSpecTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = DeviceSpecificationSpecTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: DeviceSpecificationSpecTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> DeviceSpecificationSpecTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for DeviceSpecificationSpecTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != DeviceSpecificationSpecTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != DeviceSpecificationSpecTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceSpecificationSpecTypeCode {
        DeviceSpecificationSpecTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DeviceSpecificationSpecTypeCode_Value>>(
                    "value",
                    |m: &DeviceSpecificationSpecTypeCode| { &m.value },
                    |m: &mut DeviceSpecificationSpecTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &DeviceSpecificationSpecTypeCode| { &m.id },
                    |m: &mut DeviceSpecificationSpecTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &DeviceSpecificationSpecTypeCode| { &m.extension },
                    |m: &mut DeviceSpecificationSpecTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeviceSpecificationSpecTypeCode>(
                    "DeviceSpecificationSpecTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeviceSpecificationSpecTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<DeviceSpecificationSpecTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeviceSpecificationSpecTypeCode,
        };
        unsafe {
            instance.get(DeviceSpecificationSpecTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for DeviceSpecificationSpecTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceSpecificationSpecTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceSpecificationSpecTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeviceSpecificationSpecTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    UNSPECIFIED = 1,
    SERIAL_NUMBER = 2,
    PART_NUMBER = 3,
    HARDWARE_REVISION = 4,
    SOFTWARE_REVISION = 5,
    FIRMWARE_REVISION = 6,
    PROTOCOL_REVISION = 7,
    GMDN = 8,
}

impl ::protobuf::ProtobufEnum for DeviceSpecificationSpecTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceSpecificationSpecTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(DeviceSpecificationSpecTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(DeviceSpecificationSpecTypeCode_Value::UNSPECIFIED),
            2 => ::std::option::Option::Some(DeviceSpecificationSpecTypeCode_Value::SERIAL_NUMBER),
            3 => ::std::option::Option::Some(DeviceSpecificationSpecTypeCode_Value::PART_NUMBER),
            4 => ::std::option::Option::Some(DeviceSpecificationSpecTypeCode_Value::HARDWARE_REVISION),
            5 => ::std::option::Option::Some(DeviceSpecificationSpecTypeCode_Value::SOFTWARE_REVISION),
            6 => ::std::option::Option::Some(DeviceSpecificationSpecTypeCode_Value::FIRMWARE_REVISION),
            7 => ::std::option::Option::Some(DeviceSpecificationSpecTypeCode_Value::PROTOCOL_REVISION),
            8 => ::std::option::Option::Some(DeviceSpecificationSpecTypeCode_Value::GMDN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeviceSpecificationSpecTypeCode_Value] = &[
            DeviceSpecificationSpecTypeCode_Value::INVALID_UNINITIALIZED,
            DeviceSpecificationSpecTypeCode_Value::UNSPECIFIED,
            DeviceSpecificationSpecTypeCode_Value::SERIAL_NUMBER,
            DeviceSpecificationSpecTypeCode_Value::PART_NUMBER,
            DeviceSpecificationSpecTypeCode_Value::HARDWARE_REVISION,
            DeviceSpecificationSpecTypeCode_Value::SOFTWARE_REVISION,
            DeviceSpecificationSpecTypeCode_Value::FIRMWARE_REVISION,
            DeviceSpecificationSpecTypeCode_Value::PROTOCOL_REVISION,
            DeviceSpecificationSpecTypeCode_Value::GMDN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DeviceSpecificationSpecTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DeviceSpecificationSpecTypeCode_Value {
}

impl ::std::default::Default for DeviceSpecificationSpecTypeCode_Value {
    fn default() -> Self {
        DeviceSpecificationSpecTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceSpecificationSpecTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SpecimenStatusCode {
    // message fields
    pub value: SpecimenStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SpecimenStatusCode {
    pub fn new() -> SpecimenStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SpecimenStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SpecimenStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SpecimenStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SpecimenStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SpecimenStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SpecimenStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SpecimenStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpecimenStatusCode {
        SpecimenStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SpecimenStatusCode_Value>>(
                    "value",
                    |m: &SpecimenStatusCode| { &m.value },
                    |m: &mut SpecimenStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SpecimenStatusCode| { &m.id },
                    |m: &mut SpecimenStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SpecimenStatusCode| { &m.extension },
                    |m: &mut SpecimenStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SpecimenStatusCode>(
                    "SpecimenStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SpecimenStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<SpecimenStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SpecimenStatusCode,
        };
        unsafe {
            instance.get(SpecimenStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for SpecimenStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpecimenStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpecimenStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SpecimenStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    AVAILABLE = 1,
    UNAVAILABLE = 2,
    UNSATISFACTORY = 3,
    ENTERED_IN_ERROR = 4,
}

impl ::protobuf::ProtobufEnum for SpecimenStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SpecimenStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SpecimenStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SpecimenStatusCode_Value::AVAILABLE),
            2 => ::std::option::Option::Some(SpecimenStatusCode_Value::UNAVAILABLE),
            3 => ::std::option::Option::Some(SpecimenStatusCode_Value::UNSATISFACTORY),
            4 => ::std::option::Option::Some(SpecimenStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SpecimenStatusCode_Value] = &[
            SpecimenStatusCode_Value::INVALID_UNINITIALIZED,
            SpecimenStatusCode_Value::AVAILABLE,
            SpecimenStatusCode_Value::UNAVAILABLE,
            SpecimenStatusCode_Value::UNSATISFACTORY,
            SpecimenStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SpecimenStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SpecimenStatusCode_Value {
}

impl ::std::default::Default for SpecimenStatusCode_Value {
    fn default() -> Self {
        SpecimenStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SpecimenStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructureDefinitionKindCode {
    // message fields
    pub value: StructureDefinitionKindCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StructureDefinitionKindCode {
    pub fn new() -> StructureDefinitionKindCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.StructureDefinitionKindCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = StructureDefinitionKindCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: StructureDefinitionKindCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> StructureDefinitionKindCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for StructureDefinitionKindCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != StructureDefinitionKindCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != StructureDefinitionKindCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructureDefinitionKindCode {
        StructureDefinitionKindCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructureDefinitionKindCode_Value>>(
                    "value",
                    |m: &StructureDefinitionKindCode| { &m.value },
                    |m: &mut StructureDefinitionKindCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &StructureDefinitionKindCode| { &m.id },
                    |m: &mut StructureDefinitionKindCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &StructureDefinitionKindCode| { &m.extension },
                    |m: &mut StructureDefinitionKindCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructureDefinitionKindCode>(
                    "StructureDefinitionKindCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructureDefinitionKindCode {
        static mut instance: ::protobuf::lazy::Lazy<StructureDefinitionKindCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructureDefinitionKindCode,
        };
        unsafe {
            instance.get(StructureDefinitionKindCode::new)
        }
    }
}

impl ::protobuf::Clear for StructureDefinitionKindCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructureDefinitionKindCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureDefinitionKindCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructureDefinitionKindCode_Value {
    INVALID_UNINITIALIZED = 0,
    PRIMITIVE_TYPE = 1,
    COMPLEX_TYPE = 2,
    RESOURCE = 3,
    LOGICAL = 4,
}

impl ::protobuf::ProtobufEnum for StructureDefinitionKindCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructureDefinitionKindCode_Value> {
        match value {
            0 => ::std::option::Option::Some(StructureDefinitionKindCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(StructureDefinitionKindCode_Value::PRIMITIVE_TYPE),
            2 => ::std::option::Option::Some(StructureDefinitionKindCode_Value::COMPLEX_TYPE),
            3 => ::std::option::Option::Some(StructureDefinitionKindCode_Value::RESOURCE),
            4 => ::std::option::Option::Some(StructureDefinitionKindCode_Value::LOGICAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructureDefinitionKindCode_Value] = &[
            StructureDefinitionKindCode_Value::INVALID_UNINITIALIZED,
            StructureDefinitionKindCode_Value::PRIMITIVE_TYPE,
            StructureDefinitionKindCode_Value::COMPLEX_TYPE,
            StructureDefinitionKindCode_Value::RESOURCE,
            StructureDefinitionKindCode_Value::LOGICAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructureDefinitionKindCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructureDefinitionKindCode_Value {
}

impl ::std::default::Default for StructureDefinitionKindCode_Value {
    fn default() -> Self {
        StructureDefinitionKindCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructureDefinitionKindCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscriptionChannelTypeCode {
    // message fields
    pub value: SubscriptionChannelTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SubscriptionChannelTypeCode {
    pub fn new() -> SubscriptionChannelTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SubscriptionChannelTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SubscriptionChannelTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SubscriptionChannelTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SubscriptionChannelTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SubscriptionChannelTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SubscriptionChannelTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SubscriptionChannelTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionChannelTypeCode {
        SubscriptionChannelTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SubscriptionChannelTypeCode_Value>>(
                    "value",
                    |m: &SubscriptionChannelTypeCode| { &m.value },
                    |m: &mut SubscriptionChannelTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SubscriptionChannelTypeCode| { &m.id },
                    |m: &mut SubscriptionChannelTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SubscriptionChannelTypeCode| { &m.extension },
                    |m: &mut SubscriptionChannelTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SubscriptionChannelTypeCode>(
                    "SubscriptionChannelTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscriptionChannelTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<SubscriptionChannelTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscriptionChannelTypeCode,
        };
        unsafe {
            instance.get(SubscriptionChannelTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for SubscriptionChannelTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionChannelTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionChannelTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SubscriptionChannelTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    REST_HOOK = 1,
    WEBSOCKET = 2,
    EMAIL = 3,
    SMS = 4,
    MESSAGE = 5,
}

impl ::protobuf::ProtobufEnum for SubscriptionChannelTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SubscriptionChannelTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SubscriptionChannelTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SubscriptionChannelTypeCode_Value::REST_HOOK),
            2 => ::std::option::Option::Some(SubscriptionChannelTypeCode_Value::WEBSOCKET),
            3 => ::std::option::Option::Some(SubscriptionChannelTypeCode_Value::EMAIL),
            4 => ::std::option::Option::Some(SubscriptionChannelTypeCode_Value::SMS),
            5 => ::std::option::Option::Some(SubscriptionChannelTypeCode_Value::MESSAGE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SubscriptionChannelTypeCode_Value] = &[
            SubscriptionChannelTypeCode_Value::INVALID_UNINITIALIZED,
            SubscriptionChannelTypeCode_Value::REST_HOOK,
            SubscriptionChannelTypeCode_Value::WEBSOCKET,
            SubscriptionChannelTypeCode_Value::EMAIL,
            SubscriptionChannelTypeCode_Value::SMS,
            SubscriptionChannelTypeCode_Value::MESSAGE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SubscriptionChannelTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SubscriptionChannelTypeCode_Value {
}

impl ::std::default::Default for SubscriptionChannelTypeCode_Value {
    fn default() -> Self {
        SubscriptionChannelTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionChannelTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscriptionStatusCode {
    // message fields
    pub value: SubscriptionStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SubscriptionStatusCode {
    pub fn new() -> SubscriptionStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SubscriptionStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SubscriptionStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SubscriptionStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SubscriptionStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SubscriptionStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SubscriptionStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SubscriptionStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionStatusCode {
        SubscriptionStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SubscriptionStatusCode_Value>>(
                    "value",
                    |m: &SubscriptionStatusCode| { &m.value },
                    |m: &mut SubscriptionStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SubscriptionStatusCode| { &m.id },
                    |m: &mut SubscriptionStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SubscriptionStatusCode| { &m.extension },
                    |m: &mut SubscriptionStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SubscriptionStatusCode>(
                    "SubscriptionStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscriptionStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<SubscriptionStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscriptionStatusCode,
        };
        unsafe {
            instance.get(SubscriptionStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for SubscriptionStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SubscriptionStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    REQUESTED = 1,
    ACTIVE = 2,
    ERROR = 3,
    OFF = 4,
}

impl ::protobuf::ProtobufEnum for SubscriptionStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SubscriptionStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SubscriptionStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SubscriptionStatusCode_Value::REQUESTED),
            2 => ::std::option::Option::Some(SubscriptionStatusCode_Value::ACTIVE),
            3 => ::std::option::Option::Some(SubscriptionStatusCode_Value::ERROR),
            4 => ::std::option::Option::Some(SubscriptionStatusCode_Value::OFF),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SubscriptionStatusCode_Value] = &[
            SubscriptionStatusCode_Value::INVALID_UNINITIALIZED,
            SubscriptionStatusCode_Value::REQUESTED,
            SubscriptionStatusCode_Value::ACTIVE,
            SubscriptionStatusCode_Value::ERROR,
            SubscriptionStatusCode_Value::OFF,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SubscriptionStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SubscriptionStatusCode_Value {
}

impl ::std::default::Default for SubscriptionStatusCode_Value {
    fn default() -> Self {
        SubscriptionStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscriptionTagCode {
    // message fields
    pub value: SubscriptionTagCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SubscriptionTagCode {
    pub fn new() -> SubscriptionTagCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SubscriptionTagCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SubscriptionTagCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SubscriptionTagCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SubscriptionTagCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SubscriptionTagCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SubscriptionTagCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SubscriptionTagCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscriptionTagCode {
        SubscriptionTagCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SubscriptionTagCode_Value>>(
                    "value",
                    |m: &SubscriptionTagCode| { &m.value },
                    |m: &mut SubscriptionTagCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SubscriptionTagCode| { &m.id },
                    |m: &mut SubscriptionTagCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SubscriptionTagCode| { &m.extension },
                    |m: &mut SubscriptionTagCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SubscriptionTagCode>(
                    "SubscriptionTagCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscriptionTagCode {
        static mut instance: ::protobuf::lazy::Lazy<SubscriptionTagCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscriptionTagCode,
        };
        unsafe {
            instance.get(SubscriptionTagCode::new)
        }
    }
}

impl ::protobuf::Clear for SubscriptionTagCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscriptionTagCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionTagCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SubscriptionTagCode_Value {
    INVALID_UNINITIALIZED = 0,
    QUEUED = 1,
    DELIVERED = 2,
}

impl ::protobuf::ProtobufEnum for SubscriptionTagCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SubscriptionTagCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SubscriptionTagCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SubscriptionTagCode_Value::QUEUED),
            2 => ::std::option::Option::Some(SubscriptionTagCode_Value::DELIVERED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SubscriptionTagCode_Value] = &[
            SubscriptionTagCode_Value::INVALID_UNINITIALIZED,
            SubscriptionTagCode_Value::QUEUED,
            SubscriptionTagCode_Value::DELIVERED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SubscriptionTagCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SubscriptionTagCode_Value {
}

impl ::std::default::Default for SubscriptionTagCode_Value {
    fn default() -> Self {
        SubscriptionTagCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscriptionTagCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubstanceCategoryCodesCode {
    // message fields
    pub value: SubstanceCategoryCodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SubstanceCategoryCodesCode {
    pub fn new() -> SubstanceCategoryCodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SubstanceCategoryCodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SubstanceCategoryCodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SubstanceCategoryCodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SubstanceCategoryCodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SubstanceCategoryCodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SubstanceCategoryCodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SubstanceCategoryCodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubstanceCategoryCodesCode {
        SubstanceCategoryCodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SubstanceCategoryCodesCode_Value>>(
                    "value",
                    |m: &SubstanceCategoryCodesCode| { &m.value },
                    |m: &mut SubstanceCategoryCodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SubstanceCategoryCodesCode| { &m.id },
                    |m: &mut SubstanceCategoryCodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SubstanceCategoryCodesCode| { &m.extension },
                    |m: &mut SubstanceCategoryCodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SubstanceCategoryCodesCode>(
                    "SubstanceCategoryCodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubstanceCategoryCodesCode {
        static mut instance: ::protobuf::lazy::Lazy<SubstanceCategoryCodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubstanceCategoryCodesCode,
        };
        unsafe {
            instance.get(SubstanceCategoryCodesCode::new)
        }
    }
}

impl ::protobuf::Clear for SubstanceCategoryCodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubstanceCategoryCodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubstanceCategoryCodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SubstanceCategoryCodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    ALLERGEN = 1,
    BIOLOGICAL = 2,
    BODY = 3,
    CHEMICAL = 4,
    FOOD = 5,
    DRUG = 6,
    MATERIAL = 7,
}

impl ::protobuf::ProtobufEnum for SubstanceCategoryCodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SubstanceCategoryCodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SubstanceCategoryCodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SubstanceCategoryCodesCode_Value::ALLERGEN),
            2 => ::std::option::Option::Some(SubstanceCategoryCodesCode_Value::BIOLOGICAL),
            3 => ::std::option::Option::Some(SubstanceCategoryCodesCode_Value::BODY),
            4 => ::std::option::Option::Some(SubstanceCategoryCodesCode_Value::CHEMICAL),
            5 => ::std::option::Option::Some(SubstanceCategoryCodesCode_Value::FOOD),
            6 => ::std::option::Option::Some(SubstanceCategoryCodesCode_Value::DRUG),
            7 => ::std::option::Option::Some(SubstanceCategoryCodesCode_Value::MATERIAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SubstanceCategoryCodesCode_Value] = &[
            SubstanceCategoryCodesCode_Value::INVALID_UNINITIALIZED,
            SubstanceCategoryCodesCode_Value::ALLERGEN,
            SubstanceCategoryCodesCode_Value::BIOLOGICAL,
            SubstanceCategoryCodesCode_Value::BODY,
            SubstanceCategoryCodesCode_Value::CHEMICAL,
            SubstanceCategoryCodesCode_Value::FOOD,
            SubstanceCategoryCodesCode_Value::DRUG,
            SubstanceCategoryCodesCode_Value::MATERIAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SubstanceCategoryCodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SubstanceCategoryCodesCode_Value {
}

impl ::std::default::Default for SubstanceCategoryCodesCode_Value {
    fn default() -> Self {
        SubstanceCategoryCodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SubstanceCategoryCodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FHIRSubstanceStatusCode {
    // message fields
    pub value: FHIRSubstanceStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FHIRSubstanceStatusCode {
    pub fn new() -> FHIRSubstanceStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.FHIRSubstanceStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = FHIRSubstanceStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: FHIRSubstanceStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> FHIRSubstanceStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for FHIRSubstanceStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != FHIRSubstanceStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != FHIRSubstanceStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FHIRSubstanceStatusCode {
        FHIRSubstanceStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FHIRSubstanceStatusCode_Value>>(
                    "value",
                    |m: &FHIRSubstanceStatusCode| { &m.value },
                    |m: &mut FHIRSubstanceStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &FHIRSubstanceStatusCode| { &m.id },
                    |m: &mut FHIRSubstanceStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &FHIRSubstanceStatusCode| { &m.extension },
                    |m: &mut FHIRSubstanceStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FHIRSubstanceStatusCode>(
                    "FHIRSubstanceStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FHIRSubstanceStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<FHIRSubstanceStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FHIRSubstanceStatusCode,
        };
        unsafe {
            instance.get(FHIRSubstanceStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for FHIRSubstanceStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FHIRSubstanceStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FHIRSubstanceStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FHIRSubstanceStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    ACTIVE = 1,
    INACTIVE = 2,
    ENTERED_IN_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for FHIRSubstanceStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FHIRSubstanceStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(FHIRSubstanceStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(FHIRSubstanceStatusCode_Value::ACTIVE),
            2 => ::std::option::Option::Some(FHIRSubstanceStatusCode_Value::INACTIVE),
            3 => ::std::option::Option::Some(FHIRSubstanceStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FHIRSubstanceStatusCode_Value] = &[
            FHIRSubstanceStatusCode_Value::INVALID_UNINITIALIZED,
            FHIRSubstanceStatusCode_Value::ACTIVE,
            FHIRSubstanceStatusCode_Value::INACTIVE,
            FHIRSubstanceStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FHIRSubstanceStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FHIRSubstanceStatusCode_Value {
}

impl ::std::default::Default for FHIRSubstanceStatusCode_Value {
    fn default() -> Self {
        FHIRSubstanceStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for FHIRSubstanceStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SupplyDeliveryStatusCode {
    // message fields
    pub value: SupplyDeliveryStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SupplyDeliveryStatusCode {
    pub fn new() -> SupplyDeliveryStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SupplyDeliveryStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SupplyDeliveryStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SupplyDeliveryStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SupplyDeliveryStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SupplyDeliveryStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SupplyDeliveryStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SupplyDeliveryStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SupplyDeliveryStatusCode {
        SupplyDeliveryStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SupplyDeliveryStatusCode_Value>>(
                    "value",
                    |m: &SupplyDeliveryStatusCode| { &m.value },
                    |m: &mut SupplyDeliveryStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SupplyDeliveryStatusCode| { &m.id },
                    |m: &mut SupplyDeliveryStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SupplyDeliveryStatusCode| { &m.extension },
                    |m: &mut SupplyDeliveryStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SupplyDeliveryStatusCode>(
                    "SupplyDeliveryStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SupplyDeliveryStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<SupplyDeliveryStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SupplyDeliveryStatusCode,
        };
        unsafe {
            instance.get(SupplyDeliveryStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for SupplyDeliveryStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SupplyDeliveryStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SupplyDeliveryStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SupplyDeliveryStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    IN_PROGRESS = 1,
    COMPLETED = 2,
    ABANDONED = 3,
    ENTERED_IN_ERROR = 4,
}

impl ::protobuf::ProtobufEnum for SupplyDeliveryStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SupplyDeliveryStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SupplyDeliveryStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SupplyDeliveryStatusCode_Value::IN_PROGRESS),
            2 => ::std::option::Option::Some(SupplyDeliveryStatusCode_Value::COMPLETED),
            3 => ::std::option::Option::Some(SupplyDeliveryStatusCode_Value::ABANDONED),
            4 => ::std::option::Option::Some(SupplyDeliveryStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SupplyDeliveryStatusCode_Value] = &[
            SupplyDeliveryStatusCode_Value::INVALID_UNINITIALIZED,
            SupplyDeliveryStatusCode_Value::IN_PROGRESS,
            SupplyDeliveryStatusCode_Value::COMPLETED,
            SupplyDeliveryStatusCode_Value::ABANDONED,
            SupplyDeliveryStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SupplyDeliveryStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SupplyDeliveryStatusCode_Value {
}

impl ::std::default::Default for SupplyDeliveryStatusCode_Value {
    fn default() -> Self {
        SupplyDeliveryStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SupplyDeliveryStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SupplyItemTypeCode {
    // message fields
    pub value: SupplyItemTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SupplyItemTypeCode {
    pub fn new() -> SupplyItemTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SupplyItemTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SupplyItemTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SupplyItemTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SupplyItemTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SupplyItemTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SupplyItemTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SupplyItemTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SupplyItemTypeCode {
        SupplyItemTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SupplyItemTypeCode_Value>>(
                    "value",
                    |m: &SupplyItemTypeCode| { &m.value },
                    |m: &mut SupplyItemTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SupplyItemTypeCode| { &m.id },
                    |m: &mut SupplyItemTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SupplyItemTypeCode| { &m.extension },
                    |m: &mut SupplyItemTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SupplyItemTypeCode>(
                    "SupplyItemTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SupplyItemTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<SupplyItemTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SupplyItemTypeCode,
        };
        unsafe {
            instance.get(SupplyItemTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for SupplyItemTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SupplyItemTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SupplyItemTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SupplyItemTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    MEDICATION = 1,
    DEVICE = 2,
}

impl ::protobuf::ProtobufEnum for SupplyItemTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SupplyItemTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SupplyItemTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SupplyItemTypeCode_Value::MEDICATION),
            2 => ::std::option::Option::Some(SupplyItemTypeCode_Value::DEVICE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SupplyItemTypeCode_Value] = &[
            SupplyItemTypeCode_Value::INVALID_UNINITIALIZED,
            SupplyItemTypeCode_Value::MEDICATION,
            SupplyItemTypeCode_Value::DEVICE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SupplyItemTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SupplyItemTypeCode_Value {
}

impl ::std::default::Default for SupplyItemTypeCode_Value {
    fn default() -> Self {
        SupplyItemTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SupplyItemTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SupplyTypeCode {
    // message fields
    pub value: SupplyTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SupplyTypeCode {
    pub fn new() -> SupplyTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SupplyTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SupplyTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SupplyTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SupplyTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SupplyTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SupplyTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SupplyTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SupplyTypeCode {
        SupplyTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SupplyTypeCode_Value>>(
                    "value",
                    |m: &SupplyTypeCode| { &m.value },
                    |m: &mut SupplyTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SupplyTypeCode| { &m.id },
                    |m: &mut SupplyTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SupplyTypeCode| { &m.extension },
                    |m: &mut SupplyTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SupplyTypeCode>(
                    "SupplyTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SupplyTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<SupplyTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SupplyTypeCode,
        };
        unsafe {
            instance.get(SupplyTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for SupplyTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SupplyTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SupplyTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SupplyTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    CENTRAL = 1,
    NONSTOCK = 2,
}

impl ::protobuf::ProtobufEnum for SupplyTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SupplyTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SupplyTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SupplyTypeCode_Value::CENTRAL),
            2 => ::std::option::Option::Some(SupplyTypeCode_Value::NONSTOCK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SupplyTypeCode_Value] = &[
            SupplyTypeCode_Value::INVALID_UNINITIALIZED,
            SupplyTypeCode_Value::CENTRAL,
            SupplyTypeCode_Value::NONSTOCK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SupplyTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SupplyTypeCode_Value {
}

impl ::std::default::Default for SupplyTypeCode_Value {
    fn default() -> Self {
        SupplyTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SupplyTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SupplyRequestReasonCode {
    // message fields
    pub value: SupplyRequestReasonCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SupplyRequestReasonCode {
    pub fn new() -> SupplyRequestReasonCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SupplyRequestReasonCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SupplyRequestReasonCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SupplyRequestReasonCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SupplyRequestReasonCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SupplyRequestReasonCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SupplyRequestReasonCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SupplyRequestReasonCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SupplyRequestReasonCode {
        SupplyRequestReasonCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SupplyRequestReasonCode_Value>>(
                    "value",
                    |m: &SupplyRequestReasonCode| { &m.value },
                    |m: &mut SupplyRequestReasonCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SupplyRequestReasonCode| { &m.id },
                    |m: &mut SupplyRequestReasonCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SupplyRequestReasonCode| { &m.extension },
                    |m: &mut SupplyRequestReasonCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SupplyRequestReasonCode>(
                    "SupplyRequestReasonCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SupplyRequestReasonCode {
        static mut instance: ::protobuf::lazy::Lazy<SupplyRequestReasonCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SupplyRequestReasonCode,
        };
        unsafe {
            instance.get(SupplyRequestReasonCode::new)
        }
    }
}

impl ::protobuf::Clear for SupplyRequestReasonCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SupplyRequestReasonCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SupplyRequestReasonCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SupplyRequestReasonCode_Value {
    INVALID_UNINITIALIZED = 0,
    PATIENT_CARE = 1,
    WARD_STOCK = 2,
}

impl ::protobuf::ProtobufEnum for SupplyRequestReasonCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SupplyRequestReasonCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SupplyRequestReasonCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SupplyRequestReasonCode_Value::PATIENT_CARE),
            2 => ::std::option::Option::Some(SupplyRequestReasonCode_Value::WARD_STOCK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SupplyRequestReasonCode_Value] = &[
            SupplyRequestReasonCode_Value::INVALID_UNINITIALIZED,
            SupplyRequestReasonCode_Value::PATIENT_CARE,
            SupplyRequestReasonCode_Value::WARD_STOCK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SupplyRequestReasonCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SupplyRequestReasonCode_Value {
}

impl ::std::default::Default for SupplyRequestReasonCode_Value {
    fn default() -> Self {
        SupplyRequestReasonCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SupplyRequestReasonCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SupplyRequestStatusCode {
    // message fields
    pub value: SupplyRequestStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SupplyRequestStatusCode {
    pub fn new() -> SupplyRequestStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SupplyRequestStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SupplyRequestStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SupplyRequestStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SupplyRequestStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SupplyRequestStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SupplyRequestStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SupplyRequestStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SupplyRequestStatusCode {
        SupplyRequestStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SupplyRequestStatusCode_Value>>(
                    "value",
                    |m: &SupplyRequestStatusCode| { &m.value },
                    |m: &mut SupplyRequestStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SupplyRequestStatusCode| { &m.id },
                    |m: &mut SupplyRequestStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SupplyRequestStatusCode| { &m.extension },
                    |m: &mut SupplyRequestStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SupplyRequestStatusCode>(
                    "SupplyRequestStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SupplyRequestStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<SupplyRequestStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SupplyRequestStatusCode,
        };
        unsafe {
            instance.get(SupplyRequestStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for SupplyRequestStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SupplyRequestStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SupplyRequestStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SupplyRequestStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    DRAFT = 1,
    ACTIVE = 2,
    SUSPENDED = 3,
    CANCELLED = 4,
    COMPLETED = 5,
    ENTERED_IN_ERROR = 6,
    UNKNOWN = 7,
}

impl ::protobuf::ProtobufEnum for SupplyRequestStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SupplyRequestStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SupplyRequestStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SupplyRequestStatusCode_Value::DRAFT),
            2 => ::std::option::Option::Some(SupplyRequestStatusCode_Value::ACTIVE),
            3 => ::std::option::Option::Some(SupplyRequestStatusCode_Value::SUSPENDED),
            4 => ::std::option::Option::Some(SupplyRequestStatusCode_Value::CANCELLED),
            5 => ::std::option::Option::Some(SupplyRequestStatusCode_Value::COMPLETED),
            6 => ::std::option::Option::Some(SupplyRequestStatusCode_Value::ENTERED_IN_ERROR),
            7 => ::std::option::Option::Some(SupplyRequestStatusCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SupplyRequestStatusCode_Value] = &[
            SupplyRequestStatusCode_Value::INVALID_UNINITIALIZED,
            SupplyRequestStatusCode_Value::DRAFT,
            SupplyRequestStatusCode_Value::ACTIVE,
            SupplyRequestStatusCode_Value::SUSPENDED,
            SupplyRequestStatusCode_Value::CANCELLED,
            SupplyRequestStatusCode_Value::COMPLETED,
            SupplyRequestStatusCode_Value::ENTERED_IN_ERROR,
            SupplyRequestStatusCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SupplyRequestStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SupplyRequestStatusCode_Value {
}

impl ::std::default::Default for SupplyRequestStatusCode_Value {
    fn default() -> Self {
        SupplyRequestStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SupplyRequestStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SystemRestfulInteractionCode {
    // message fields
    pub value: SystemRestfulInteractionCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SystemRestfulInteractionCode {
    pub fn new() -> SystemRestfulInteractionCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SystemRestfulInteractionCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SystemRestfulInteractionCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SystemRestfulInteractionCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SystemRestfulInteractionCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SystemRestfulInteractionCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SystemRestfulInteractionCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SystemRestfulInteractionCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SystemRestfulInteractionCode {
        SystemRestfulInteractionCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SystemRestfulInteractionCode_Value>>(
                    "value",
                    |m: &SystemRestfulInteractionCode| { &m.value },
                    |m: &mut SystemRestfulInteractionCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SystemRestfulInteractionCode| { &m.id },
                    |m: &mut SystemRestfulInteractionCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SystemRestfulInteractionCode| { &m.extension },
                    |m: &mut SystemRestfulInteractionCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SystemRestfulInteractionCode>(
                    "SystemRestfulInteractionCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SystemRestfulInteractionCode {
        static mut instance: ::protobuf::lazy::Lazy<SystemRestfulInteractionCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SystemRestfulInteractionCode,
        };
        unsafe {
            instance.get(SystemRestfulInteractionCode::new)
        }
    }
}

impl ::protobuf::Clear for SystemRestfulInteractionCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SystemRestfulInteractionCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemRestfulInteractionCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SystemRestfulInteractionCode_Value {
    INVALID_UNINITIALIZED = 0,
    TRANSACTION = 1,
    BATCH = 2,
    SEARCH_SYSTEM = 3,
    HISTORY_SYSTEM = 4,
}

impl ::protobuf::ProtobufEnum for SystemRestfulInteractionCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SystemRestfulInteractionCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SystemRestfulInteractionCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SystemRestfulInteractionCode_Value::TRANSACTION),
            2 => ::std::option::Option::Some(SystemRestfulInteractionCode_Value::BATCH),
            3 => ::std::option::Option::Some(SystemRestfulInteractionCode_Value::SEARCH_SYSTEM),
            4 => ::std::option::Option::Some(SystemRestfulInteractionCode_Value::HISTORY_SYSTEM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SystemRestfulInteractionCode_Value] = &[
            SystemRestfulInteractionCode_Value::INVALID_UNINITIALIZED,
            SystemRestfulInteractionCode_Value::TRANSACTION,
            SystemRestfulInteractionCode_Value::BATCH,
            SystemRestfulInteractionCode_Value::SEARCH_SYSTEM,
            SystemRestfulInteractionCode_Value::HISTORY_SYSTEM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SystemRestfulInteractionCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SystemRestfulInteractionCode_Value {
}

impl ::std::default::Default for SystemRestfulInteractionCode_Value {
    fn default() -> Self {
        SystemRestfulInteractionCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemRestfulInteractionCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SystemVersionProcessingModeCode {
    // message fields
    pub value: SystemVersionProcessingModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SystemVersionProcessingModeCode {
    pub fn new() -> SystemVersionProcessingModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.SystemVersionProcessingModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = SystemVersionProcessingModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: SystemVersionProcessingModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> SystemVersionProcessingModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for SystemVersionProcessingModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != SystemVersionProcessingModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != SystemVersionProcessingModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SystemVersionProcessingModeCode {
        SystemVersionProcessingModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SystemVersionProcessingModeCode_Value>>(
                    "value",
                    |m: &SystemVersionProcessingModeCode| { &m.value },
                    |m: &mut SystemVersionProcessingModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &SystemVersionProcessingModeCode| { &m.id },
                    |m: &mut SystemVersionProcessingModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &SystemVersionProcessingModeCode| { &m.extension },
                    |m: &mut SystemVersionProcessingModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SystemVersionProcessingModeCode>(
                    "SystemVersionProcessingModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SystemVersionProcessingModeCode {
        static mut instance: ::protobuf::lazy::Lazy<SystemVersionProcessingModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SystemVersionProcessingModeCode,
        };
        unsafe {
            instance.get(SystemVersionProcessingModeCode::new)
        }
    }
}

impl ::protobuf::Clear for SystemVersionProcessingModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SystemVersionProcessingModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemVersionProcessingModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SystemVersionProcessingModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    DEFAULT = 1,
    CHECK = 2,
    OVERRIDE = 3,
}

impl ::protobuf::ProtobufEnum for SystemVersionProcessingModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SystemVersionProcessingModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(SystemVersionProcessingModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(SystemVersionProcessingModeCode_Value::DEFAULT),
            2 => ::std::option::Option::Some(SystemVersionProcessingModeCode_Value::CHECK),
            3 => ::std::option::Option::Some(SystemVersionProcessingModeCode_Value::OVERRIDE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SystemVersionProcessingModeCode_Value] = &[
            SystemVersionProcessingModeCode_Value::INVALID_UNINITIALIZED,
            SystemVersionProcessingModeCode_Value::DEFAULT,
            SystemVersionProcessingModeCode_Value::CHECK,
            SystemVersionProcessingModeCode_Value::OVERRIDE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SystemVersionProcessingModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SystemVersionProcessingModeCode_Value {
}

impl ::std::default::Default for SystemVersionProcessingModeCode_Value {
    fn default() -> Self {
        SystemVersionProcessingModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemVersionProcessingModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskPerformerTypeCode {
    // message fields
    pub value: TaskPerformerTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TaskPerformerTypeCode {
    pub fn new() -> TaskPerformerTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TaskPerformerTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TaskPerformerTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TaskPerformerTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TaskPerformerTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TaskPerformerTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TaskPerformerTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TaskPerformerTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskPerformerTypeCode {
        TaskPerformerTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskPerformerTypeCode_Value>>(
                    "value",
                    |m: &TaskPerformerTypeCode| { &m.value },
                    |m: &mut TaskPerformerTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TaskPerformerTypeCode| { &m.id },
                    |m: &mut TaskPerformerTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TaskPerformerTypeCode| { &m.extension },
                    |m: &mut TaskPerformerTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskPerformerTypeCode>(
                    "TaskPerformerTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TaskPerformerTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<TaskPerformerTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskPerformerTypeCode,
        };
        unsafe {
            instance.get(TaskPerformerTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for TaskPerformerTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskPerformerTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskPerformerTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskPerformerTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    REQUESTER = 1,
    DISPATCHER = 2,
    SCHEDULER = 3,
    PERFORMER = 4,
    MONITOR = 5,
    MANAGER = 6,
    ACQUIRER = 7,
    REVIEWER = 8,
}

impl ::protobuf::ProtobufEnum for TaskPerformerTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskPerformerTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TaskPerformerTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TaskPerformerTypeCode_Value::REQUESTER),
            2 => ::std::option::Option::Some(TaskPerformerTypeCode_Value::DISPATCHER),
            3 => ::std::option::Option::Some(TaskPerformerTypeCode_Value::SCHEDULER),
            4 => ::std::option::Option::Some(TaskPerformerTypeCode_Value::PERFORMER),
            5 => ::std::option::Option::Some(TaskPerformerTypeCode_Value::MONITOR),
            6 => ::std::option::Option::Some(TaskPerformerTypeCode_Value::MANAGER),
            7 => ::std::option::Option::Some(TaskPerformerTypeCode_Value::ACQUIRER),
            8 => ::std::option::Option::Some(TaskPerformerTypeCode_Value::REVIEWER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskPerformerTypeCode_Value] = &[
            TaskPerformerTypeCode_Value::INVALID_UNINITIALIZED,
            TaskPerformerTypeCode_Value::REQUESTER,
            TaskPerformerTypeCode_Value::DISPATCHER,
            TaskPerformerTypeCode_Value::SCHEDULER,
            TaskPerformerTypeCode_Value::PERFORMER,
            TaskPerformerTypeCode_Value::MONITOR,
            TaskPerformerTypeCode_Value::MANAGER,
            TaskPerformerTypeCode_Value::ACQUIRER,
            TaskPerformerTypeCode_Value::REVIEWER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TaskPerformerTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TaskPerformerTypeCode_Value {
}

impl ::std::default::Default for TaskPerformerTypeCode_Value {
    fn default() -> Self {
        TaskPerformerTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskPerformerTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TemplateStatusCodeCode {
    // message fields
    pub value: TemplateStatusCodeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TemplateStatusCodeCode {
    pub fn new() -> TemplateStatusCodeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TemplateStatusCodeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TemplateStatusCodeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TemplateStatusCodeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TemplateStatusCodeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TemplateStatusCodeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TemplateStatusCodeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TemplateStatusCodeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TemplateStatusCodeCode {
        TemplateStatusCodeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TemplateStatusCodeCode_Value>>(
                    "value",
                    |m: &TemplateStatusCodeCode| { &m.value },
                    |m: &mut TemplateStatusCodeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TemplateStatusCodeCode| { &m.id },
                    |m: &mut TemplateStatusCodeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TemplateStatusCodeCode| { &m.extension },
                    |m: &mut TemplateStatusCodeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TemplateStatusCodeCode>(
                    "TemplateStatusCodeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TemplateStatusCodeCode {
        static mut instance: ::protobuf::lazy::Lazy<TemplateStatusCodeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TemplateStatusCodeCode,
        };
        unsafe {
            instance.get(TemplateStatusCodeCode::new)
        }
    }
}

impl ::protobuf::Clear for TemplateStatusCodeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TemplateStatusCodeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplateStatusCodeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TemplateStatusCodeCode_Value {
    INVALID_UNINITIALIZED = 0,
    DRAFT = 1,
    PENDING = 2,
    ACTIVE = 3,
    REVIEW = 4,
    CANCELLED = 5,
    REJECTED = 6,
    RETIRED = 7,
    TERMINATED = 8,
}

impl ::protobuf::ProtobufEnum for TemplateStatusCodeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TemplateStatusCodeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TemplateStatusCodeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TemplateStatusCodeCode_Value::DRAFT),
            2 => ::std::option::Option::Some(TemplateStatusCodeCode_Value::PENDING),
            3 => ::std::option::Option::Some(TemplateStatusCodeCode_Value::ACTIVE),
            4 => ::std::option::Option::Some(TemplateStatusCodeCode_Value::REVIEW),
            5 => ::std::option::Option::Some(TemplateStatusCodeCode_Value::CANCELLED),
            6 => ::std::option::Option::Some(TemplateStatusCodeCode_Value::REJECTED),
            7 => ::std::option::Option::Some(TemplateStatusCodeCode_Value::RETIRED),
            8 => ::std::option::Option::Some(TemplateStatusCodeCode_Value::TERMINATED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TemplateStatusCodeCode_Value] = &[
            TemplateStatusCodeCode_Value::INVALID_UNINITIALIZED,
            TemplateStatusCodeCode_Value::DRAFT,
            TemplateStatusCodeCode_Value::PENDING,
            TemplateStatusCodeCode_Value::ACTIVE,
            TemplateStatusCodeCode_Value::REVIEW,
            TemplateStatusCodeCode_Value::CANCELLED,
            TemplateStatusCodeCode_Value::REJECTED,
            TemplateStatusCodeCode_Value::RETIRED,
            TemplateStatusCodeCode_Value::TERMINATED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TemplateStatusCodeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TemplateStatusCodeCode_Value {
}

impl ::std::default::Default for TemplateStatusCodeCode_Value {
    fn default() -> Self {
        TemplateStatusCodeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TemplateStatusCodeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskStatusCode {
    // message fields
    pub value: TaskStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TaskStatusCode {
    pub fn new() -> TaskStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TaskStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TaskStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TaskStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TaskStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TaskStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TaskStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TaskStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskStatusCode {
        TaskStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TaskStatusCode_Value>>(
                    "value",
                    |m: &TaskStatusCode| { &m.value },
                    |m: &mut TaskStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TaskStatusCode| { &m.id },
                    |m: &mut TaskStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TaskStatusCode| { &m.extension },
                    |m: &mut TaskStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskStatusCode>(
                    "TaskStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TaskStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<TaskStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskStatusCode,
        };
        unsafe {
            instance.get(TaskStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for TaskStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    DRAFT = 1,
    REQUESTED = 2,
    RECEIVED = 3,
    ACCEPTED = 4,
    REJECTED = 5,
    READY = 6,
    CANCELLED = 7,
    IN_PROGRESS = 8,
    ON_HOLD = 9,
    FAILED = 10,
    COMPLETED = 11,
    ENTERED_IN_ERROR = 12,
}

impl ::protobuf::ProtobufEnum for TaskStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TaskStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TaskStatusCode_Value::DRAFT),
            2 => ::std::option::Option::Some(TaskStatusCode_Value::REQUESTED),
            3 => ::std::option::Option::Some(TaskStatusCode_Value::RECEIVED),
            4 => ::std::option::Option::Some(TaskStatusCode_Value::ACCEPTED),
            5 => ::std::option::Option::Some(TaskStatusCode_Value::REJECTED),
            6 => ::std::option::Option::Some(TaskStatusCode_Value::READY),
            7 => ::std::option::Option::Some(TaskStatusCode_Value::CANCELLED),
            8 => ::std::option::Option::Some(TaskStatusCode_Value::IN_PROGRESS),
            9 => ::std::option::Option::Some(TaskStatusCode_Value::ON_HOLD),
            10 => ::std::option::Option::Some(TaskStatusCode_Value::FAILED),
            11 => ::std::option::Option::Some(TaskStatusCode_Value::COMPLETED),
            12 => ::std::option::Option::Some(TaskStatusCode_Value::ENTERED_IN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskStatusCode_Value] = &[
            TaskStatusCode_Value::INVALID_UNINITIALIZED,
            TaskStatusCode_Value::DRAFT,
            TaskStatusCode_Value::REQUESTED,
            TaskStatusCode_Value::RECEIVED,
            TaskStatusCode_Value::ACCEPTED,
            TaskStatusCode_Value::REJECTED,
            TaskStatusCode_Value::READY,
            TaskStatusCode_Value::CANCELLED,
            TaskStatusCode_Value::IN_PROGRESS,
            TaskStatusCode_Value::ON_HOLD,
            TaskStatusCode_Value::FAILED,
            TaskStatusCode_Value::COMPLETED,
            TaskStatusCode_Value::ENTERED_IN_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TaskStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TaskStatusCode_Value {
}

impl ::std::default::Default for TaskStatusCode_Value {
    fn default() -> Self {
        TaskStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestScriptOperationCodeCode {
    // message fields
    pub value: TestScriptOperationCodeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestScriptOperationCodeCode {
    pub fn new() -> TestScriptOperationCodeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TestScriptOperationCodeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TestScriptOperationCodeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TestScriptOperationCodeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TestScriptOperationCodeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TestScriptOperationCodeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TestScriptOperationCodeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TestScriptOperationCodeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestScriptOperationCodeCode {
        TestScriptOperationCodeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestScriptOperationCodeCode_Value>>(
                    "value",
                    |m: &TestScriptOperationCodeCode| { &m.value },
                    |m: &mut TestScriptOperationCodeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TestScriptOperationCodeCode| { &m.id },
                    |m: &mut TestScriptOperationCodeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TestScriptOperationCodeCode| { &m.extension },
                    |m: &mut TestScriptOperationCodeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestScriptOperationCodeCode>(
                    "TestScriptOperationCodeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestScriptOperationCodeCode {
        static mut instance: ::protobuf::lazy::Lazy<TestScriptOperationCodeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestScriptOperationCodeCode,
        };
        unsafe {
            instance.get(TestScriptOperationCodeCode::new)
        }
    }
}

impl ::protobuf::Clear for TestScriptOperationCodeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestScriptOperationCodeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestScriptOperationCodeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestScriptOperationCodeCode_Value {
    INVALID_UNINITIALIZED = 0,
    READ = 1,
    VREAD = 2,
    UPDATE = 3,
    UPDATE_CREATE = 4,
    DELETE = 5,
    DELETE_COND_SINGLE = 6,
    DELETE_COND_MULTIPLE = 7,
    HISTORY = 8,
    CREATE = 9,
    SEARCH = 10,
    BATCH = 11,
    TRANSACTION = 12,
    CAPABILITIES = 13,
    APPLY = 14,
    CANCEL = 15,
    CLOSURE = 16,
    COMPOSE = 17,
    CONFORMS = 18,
    DATA_REQUIREMENTS = 19,
    DOCUMENT = 20,
    EVALUATE = 21,
    EVALUATE_MEASURE = 22,
    EVERYTHING = 23,
    EXPAND = 24,
    FAIL = 25,
    FIND = 26,
    FINISH = 27,
    IMPLEMENTS = 28,
    LOOKUP = 29,
    MATCH = 30,
    META = 31,
    META_ADD = 32,
    META_DELETE = 33,
    POPULATE = 34,
    POPULATEHTML = 35,
    POPULATELINK = 36,
    PROCESS_MESSAGE = 37,
    QUESTIONNAIRE = 38,
    RELEASE = 39,
    RESERVE = 40,
    RESUME = 41,
    SET_INPUT = 42,
    SET_OUTPUT = 43,
    START = 44,
    STATS = 45,
    STOP = 46,
    SUBSET = 47,
    SUBSUMES = 48,
    SUSPEND = 49,
    TRANSFORM = 50,
    TRANSLATE = 51,
    VALIDATE = 52,
    VALIDATE_CODE = 53,
}

impl ::protobuf::ProtobufEnum for TestScriptOperationCodeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestScriptOperationCodeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::READ),
            2 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::VREAD),
            3 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::UPDATE),
            4 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::UPDATE_CREATE),
            5 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::DELETE),
            6 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::DELETE_COND_SINGLE),
            7 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::DELETE_COND_MULTIPLE),
            8 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::HISTORY),
            9 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::CREATE),
            10 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::SEARCH),
            11 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::BATCH),
            12 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::TRANSACTION),
            13 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::CAPABILITIES),
            14 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::APPLY),
            15 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::CANCEL),
            16 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::CLOSURE),
            17 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::COMPOSE),
            18 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::CONFORMS),
            19 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::DATA_REQUIREMENTS),
            20 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::DOCUMENT),
            21 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::EVALUATE),
            22 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::EVALUATE_MEASURE),
            23 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::EVERYTHING),
            24 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::EXPAND),
            25 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::FAIL),
            26 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::FIND),
            27 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::FINISH),
            28 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::IMPLEMENTS),
            29 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::LOOKUP),
            30 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::MATCH),
            31 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::META),
            32 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::META_ADD),
            33 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::META_DELETE),
            34 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::POPULATE),
            35 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::POPULATEHTML),
            36 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::POPULATELINK),
            37 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::PROCESS_MESSAGE),
            38 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::QUESTIONNAIRE),
            39 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::RELEASE),
            40 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::RESERVE),
            41 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::RESUME),
            42 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::SET_INPUT),
            43 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::SET_OUTPUT),
            44 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::START),
            45 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::STATS),
            46 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::STOP),
            47 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::SUBSET),
            48 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::SUBSUMES),
            49 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::SUSPEND),
            50 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::TRANSFORM),
            51 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::TRANSLATE),
            52 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::VALIDATE),
            53 => ::std::option::Option::Some(TestScriptOperationCodeCode_Value::VALIDATE_CODE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestScriptOperationCodeCode_Value] = &[
            TestScriptOperationCodeCode_Value::INVALID_UNINITIALIZED,
            TestScriptOperationCodeCode_Value::READ,
            TestScriptOperationCodeCode_Value::VREAD,
            TestScriptOperationCodeCode_Value::UPDATE,
            TestScriptOperationCodeCode_Value::UPDATE_CREATE,
            TestScriptOperationCodeCode_Value::DELETE,
            TestScriptOperationCodeCode_Value::DELETE_COND_SINGLE,
            TestScriptOperationCodeCode_Value::DELETE_COND_MULTIPLE,
            TestScriptOperationCodeCode_Value::HISTORY,
            TestScriptOperationCodeCode_Value::CREATE,
            TestScriptOperationCodeCode_Value::SEARCH,
            TestScriptOperationCodeCode_Value::BATCH,
            TestScriptOperationCodeCode_Value::TRANSACTION,
            TestScriptOperationCodeCode_Value::CAPABILITIES,
            TestScriptOperationCodeCode_Value::APPLY,
            TestScriptOperationCodeCode_Value::CANCEL,
            TestScriptOperationCodeCode_Value::CLOSURE,
            TestScriptOperationCodeCode_Value::COMPOSE,
            TestScriptOperationCodeCode_Value::CONFORMS,
            TestScriptOperationCodeCode_Value::DATA_REQUIREMENTS,
            TestScriptOperationCodeCode_Value::DOCUMENT,
            TestScriptOperationCodeCode_Value::EVALUATE,
            TestScriptOperationCodeCode_Value::EVALUATE_MEASURE,
            TestScriptOperationCodeCode_Value::EVERYTHING,
            TestScriptOperationCodeCode_Value::EXPAND,
            TestScriptOperationCodeCode_Value::FAIL,
            TestScriptOperationCodeCode_Value::FIND,
            TestScriptOperationCodeCode_Value::FINISH,
            TestScriptOperationCodeCode_Value::IMPLEMENTS,
            TestScriptOperationCodeCode_Value::LOOKUP,
            TestScriptOperationCodeCode_Value::MATCH,
            TestScriptOperationCodeCode_Value::META,
            TestScriptOperationCodeCode_Value::META_ADD,
            TestScriptOperationCodeCode_Value::META_DELETE,
            TestScriptOperationCodeCode_Value::POPULATE,
            TestScriptOperationCodeCode_Value::POPULATEHTML,
            TestScriptOperationCodeCode_Value::POPULATELINK,
            TestScriptOperationCodeCode_Value::PROCESS_MESSAGE,
            TestScriptOperationCodeCode_Value::QUESTIONNAIRE,
            TestScriptOperationCodeCode_Value::RELEASE,
            TestScriptOperationCodeCode_Value::RESERVE,
            TestScriptOperationCodeCode_Value::RESUME,
            TestScriptOperationCodeCode_Value::SET_INPUT,
            TestScriptOperationCodeCode_Value::SET_OUTPUT,
            TestScriptOperationCodeCode_Value::START,
            TestScriptOperationCodeCode_Value::STATS,
            TestScriptOperationCodeCode_Value::STOP,
            TestScriptOperationCodeCode_Value::SUBSET,
            TestScriptOperationCodeCode_Value::SUBSUMES,
            TestScriptOperationCodeCode_Value::SUSPEND,
            TestScriptOperationCodeCode_Value::TRANSFORM,
            TestScriptOperationCodeCode_Value::TRANSLATE,
            TestScriptOperationCodeCode_Value::VALIDATE,
            TestScriptOperationCodeCode_Value::VALIDATE_CODE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestScriptOperationCodeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestScriptOperationCodeCode_Value {
}

impl ::std::default::Default for TestScriptOperationCodeCode_Value {
    fn default() -> Self {
        TestScriptOperationCodeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TestScriptOperationCodeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestScriptProfileDestinationTypeCode {
    // message fields
    pub value: TestScriptProfileDestinationTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestScriptProfileDestinationTypeCode {
    pub fn new() -> TestScriptProfileDestinationTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TestScriptProfileDestinationTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TestScriptProfileDestinationTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TestScriptProfileDestinationTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TestScriptProfileDestinationTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TestScriptProfileDestinationTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TestScriptProfileDestinationTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TestScriptProfileDestinationTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestScriptProfileDestinationTypeCode {
        TestScriptProfileDestinationTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestScriptProfileDestinationTypeCode_Value>>(
                    "value",
                    |m: &TestScriptProfileDestinationTypeCode| { &m.value },
                    |m: &mut TestScriptProfileDestinationTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TestScriptProfileDestinationTypeCode| { &m.id },
                    |m: &mut TestScriptProfileDestinationTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TestScriptProfileDestinationTypeCode| { &m.extension },
                    |m: &mut TestScriptProfileDestinationTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestScriptProfileDestinationTypeCode>(
                    "TestScriptProfileDestinationTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestScriptProfileDestinationTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<TestScriptProfileDestinationTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestScriptProfileDestinationTypeCode,
        };
        unsafe {
            instance.get(TestScriptProfileDestinationTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for TestScriptProfileDestinationTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestScriptProfileDestinationTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestScriptProfileDestinationTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestScriptProfileDestinationTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    FHIR_SERVER = 1,
    FHIR_SDC_FORMMANAGER = 2,
    FHIR_SDC_FORMPROCESSOR = 3,
    FHIR_SDC_FORMRECEIVER = 4,
}

impl ::protobuf::ProtobufEnum for TestScriptProfileDestinationTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestScriptProfileDestinationTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TestScriptProfileDestinationTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TestScriptProfileDestinationTypeCode_Value::FHIR_SERVER),
            2 => ::std::option::Option::Some(TestScriptProfileDestinationTypeCode_Value::FHIR_SDC_FORMMANAGER),
            3 => ::std::option::Option::Some(TestScriptProfileDestinationTypeCode_Value::FHIR_SDC_FORMPROCESSOR),
            4 => ::std::option::Option::Some(TestScriptProfileDestinationTypeCode_Value::FHIR_SDC_FORMRECEIVER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestScriptProfileDestinationTypeCode_Value] = &[
            TestScriptProfileDestinationTypeCode_Value::INVALID_UNINITIALIZED,
            TestScriptProfileDestinationTypeCode_Value::FHIR_SERVER,
            TestScriptProfileDestinationTypeCode_Value::FHIR_SDC_FORMMANAGER,
            TestScriptProfileDestinationTypeCode_Value::FHIR_SDC_FORMPROCESSOR,
            TestScriptProfileDestinationTypeCode_Value::FHIR_SDC_FORMRECEIVER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestScriptProfileDestinationTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestScriptProfileDestinationTypeCode_Value {
}

impl ::std::default::Default for TestScriptProfileDestinationTypeCode_Value {
    fn default() -> Self {
        TestScriptProfileDestinationTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TestScriptProfileDestinationTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TestScriptProfileOriginTypeCode {
    // message fields
    pub value: TestScriptProfileOriginTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TestScriptProfileOriginTypeCode {
    pub fn new() -> TestScriptProfileOriginTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TestScriptProfileOriginTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TestScriptProfileOriginTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TestScriptProfileOriginTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TestScriptProfileOriginTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TestScriptProfileOriginTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TestScriptProfileOriginTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TestScriptProfileOriginTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TestScriptProfileOriginTypeCode {
        TestScriptProfileOriginTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TestScriptProfileOriginTypeCode_Value>>(
                    "value",
                    |m: &TestScriptProfileOriginTypeCode| { &m.value },
                    |m: &mut TestScriptProfileOriginTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TestScriptProfileOriginTypeCode| { &m.id },
                    |m: &mut TestScriptProfileOriginTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TestScriptProfileOriginTypeCode| { &m.extension },
                    |m: &mut TestScriptProfileOriginTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TestScriptProfileOriginTypeCode>(
                    "TestScriptProfileOriginTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TestScriptProfileOriginTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<TestScriptProfileOriginTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TestScriptProfileOriginTypeCode,
        };
        unsafe {
            instance.get(TestScriptProfileOriginTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for TestScriptProfileOriginTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TestScriptProfileOriginTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestScriptProfileOriginTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TestScriptProfileOriginTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    FHIR_CLIENT = 1,
    FHIR_SDC_FORMFILLER = 2,
}

impl ::protobuf::ProtobufEnum for TestScriptProfileOriginTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TestScriptProfileOriginTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TestScriptProfileOriginTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TestScriptProfileOriginTypeCode_Value::FHIR_CLIENT),
            2 => ::std::option::Option::Some(TestScriptProfileOriginTypeCode_Value::FHIR_SDC_FORMFILLER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TestScriptProfileOriginTypeCode_Value] = &[
            TestScriptProfileOriginTypeCode_Value::INVALID_UNINITIALIZED,
            TestScriptProfileOriginTypeCode_Value::FHIR_CLIENT,
            TestScriptProfileOriginTypeCode_Value::FHIR_SDC_FORMFILLER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TestScriptProfileOriginTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TestScriptProfileOriginTypeCode_Value {
}

impl ::std::default::Default for TestScriptProfileOriginTypeCode_Value {
    fn default() -> Self {
        TestScriptProfileOriginTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TestScriptProfileOriginTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionModeCode {
    // message fields
    pub value: TransactionModeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TransactionModeCode {
    pub fn new() -> TransactionModeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TransactionModeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TransactionModeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TransactionModeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TransactionModeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TransactionModeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TransactionModeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TransactionModeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionModeCode {
        TransactionModeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TransactionModeCode_Value>>(
                    "value",
                    |m: &TransactionModeCode| { &m.value },
                    |m: &mut TransactionModeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TransactionModeCode| { &m.id },
                    |m: &mut TransactionModeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TransactionModeCode| { &m.extension },
                    |m: &mut TransactionModeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionModeCode>(
                    "TransactionModeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionModeCode {
        static mut instance: ::protobuf::lazy::Lazy<TransactionModeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionModeCode,
        };
        unsafe {
            instance.get(TransactionModeCode::new)
        }
    }
}

impl ::protobuf::Clear for TransactionModeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionModeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionModeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TransactionModeCode_Value {
    INVALID_UNINITIALIZED = 0,
    NOT_SUPPORTED = 1,
    BATCH = 2,
    TRANSACTION = 3,
    BOTH = 4,
}

impl ::protobuf::ProtobufEnum for TransactionModeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionModeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TransactionModeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TransactionModeCode_Value::NOT_SUPPORTED),
            2 => ::std::option::Option::Some(TransactionModeCode_Value::BATCH),
            3 => ::std::option::Option::Some(TransactionModeCode_Value::TRANSACTION),
            4 => ::std::option::Option::Some(TransactionModeCode_Value::BOTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransactionModeCode_Value] = &[
            TransactionModeCode_Value::INVALID_UNINITIALIZED,
            TransactionModeCode_Value::NOT_SUPPORTED,
            TransactionModeCode_Value::BATCH,
            TransactionModeCode_Value::TRANSACTION,
            TransactionModeCode_Value::BOTH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TransactionModeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TransactionModeCode_Value {
}

impl ::std::default::Default for TransactionModeCode_Value {
    fn default() -> Self {
        TransactionModeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionModeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeDerivationRuleCode {
    // message fields
    pub value: TypeDerivationRuleCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TypeDerivationRuleCode {
    pub fn new() -> TypeDerivationRuleCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TypeDerivationRuleCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TypeDerivationRuleCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TypeDerivationRuleCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TypeDerivationRuleCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TypeDerivationRuleCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TypeDerivationRuleCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TypeDerivationRuleCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeDerivationRuleCode {
        TypeDerivationRuleCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TypeDerivationRuleCode_Value>>(
                    "value",
                    |m: &TypeDerivationRuleCode| { &m.value },
                    |m: &mut TypeDerivationRuleCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TypeDerivationRuleCode| { &m.id },
                    |m: &mut TypeDerivationRuleCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TypeDerivationRuleCode| { &m.extension },
                    |m: &mut TypeDerivationRuleCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeDerivationRuleCode>(
                    "TypeDerivationRuleCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeDerivationRuleCode {
        static mut instance: ::protobuf::lazy::Lazy<TypeDerivationRuleCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeDerivationRuleCode,
        };
        unsafe {
            instance.get(TypeDerivationRuleCode::new)
        }
    }
}

impl ::protobuf::Clear for TypeDerivationRuleCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeDerivationRuleCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeDerivationRuleCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TypeDerivationRuleCode_Value {
    INVALID_UNINITIALIZED = 0,
    SPECIALIZATION = 1,
    CONSTRAINT = 2,
}

impl ::protobuf::ProtobufEnum for TypeDerivationRuleCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TypeDerivationRuleCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TypeDerivationRuleCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TypeDerivationRuleCode_Value::SPECIALIZATION),
            2 => ::std::option::Option::Some(TypeDerivationRuleCode_Value::CONSTRAINT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TypeDerivationRuleCode_Value] = &[
            TypeDerivationRuleCode_Value::INVALID_UNINITIALIZED,
            TypeDerivationRuleCode_Value::SPECIALIZATION,
            TypeDerivationRuleCode_Value::CONSTRAINT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TypeDerivationRuleCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TypeDerivationRuleCode_Value {
}

impl ::std::default::Default for TypeDerivationRuleCode_Value {
    fn default() -> Self {
        TypeDerivationRuleCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeDerivationRuleCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeRestfulInteractionCode {
    // message fields
    pub value: TypeRestfulInteractionCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TypeRestfulInteractionCode {
    pub fn new() -> TypeRestfulInteractionCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.TypeRestfulInteractionCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = TypeRestfulInteractionCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: TypeRestfulInteractionCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> TypeRestfulInteractionCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for TypeRestfulInteractionCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != TypeRestfulInteractionCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != TypeRestfulInteractionCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeRestfulInteractionCode {
        TypeRestfulInteractionCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TypeRestfulInteractionCode_Value>>(
                    "value",
                    |m: &TypeRestfulInteractionCode| { &m.value },
                    |m: &mut TypeRestfulInteractionCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &TypeRestfulInteractionCode| { &m.id },
                    |m: &mut TypeRestfulInteractionCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &TypeRestfulInteractionCode| { &m.extension },
                    |m: &mut TypeRestfulInteractionCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TypeRestfulInteractionCode>(
                    "TypeRestfulInteractionCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TypeRestfulInteractionCode {
        static mut instance: ::protobuf::lazy::Lazy<TypeRestfulInteractionCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TypeRestfulInteractionCode,
        };
        unsafe {
            instance.get(TypeRestfulInteractionCode::new)
        }
    }
}

impl ::protobuf::Clear for TypeRestfulInteractionCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeRestfulInteractionCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeRestfulInteractionCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TypeRestfulInteractionCode_Value {
    INVALID_UNINITIALIZED = 0,
    READ = 1,
    VREAD = 2,
    UPDATE = 3,
    PATCH = 4,
    DELETE = 5,
    HISTORY_INSTANCE = 6,
    HISTORY_TYPE = 7,
    CREATE = 8,
    SEARCH_TYPE = 9,
}

impl ::protobuf::ProtobufEnum for TypeRestfulInteractionCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TypeRestfulInteractionCode_Value> {
        match value {
            0 => ::std::option::Option::Some(TypeRestfulInteractionCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(TypeRestfulInteractionCode_Value::READ),
            2 => ::std::option::Option::Some(TypeRestfulInteractionCode_Value::VREAD),
            3 => ::std::option::Option::Some(TypeRestfulInteractionCode_Value::UPDATE),
            4 => ::std::option::Option::Some(TypeRestfulInteractionCode_Value::PATCH),
            5 => ::std::option::Option::Some(TypeRestfulInteractionCode_Value::DELETE),
            6 => ::std::option::Option::Some(TypeRestfulInteractionCode_Value::HISTORY_INSTANCE),
            7 => ::std::option::Option::Some(TypeRestfulInteractionCode_Value::HISTORY_TYPE),
            8 => ::std::option::Option::Some(TypeRestfulInteractionCode_Value::CREATE),
            9 => ::std::option::Option::Some(TypeRestfulInteractionCode_Value::SEARCH_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TypeRestfulInteractionCode_Value] = &[
            TypeRestfulInteractionCode_Value::INVALID_UNINITIALIZED,
            TypeRestfulInteractionCode_Value::READ,
            TypeRestfulInteractionCode_Value::VREAD,
            TypeRestfulInteractionCode_Value::UPDATE,
            TypeRestfulInteractionCode_Value::PATCH,
            TypeRestfulInteractionCode_Value::DELETE,
            TypeRestfulInteractionCode_Value::HISTORY_INSTANCE,
            TypeRestfulInteractionCode_Value::HISTORY_TYPE,
            TypeRestfulInteractionCode_Value::CREATE,
            TypeRestfulInteractionCode_Value::SEARCH_TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TypeRestfulInteractionCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TypeRestfulInteractionCode_Value {
}

impl ::std::default::Default for TypeRestfulInteractionCode_Value {
    fn default() -> Self {
        TypeRestfulInteractionCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeRestfulInteractionCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UDIEntryTypeCode {
    // message fields
    pub value: UDIEntryTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UDIEntryTypeCode {
    pub fn new() -> UDIEntryTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.UDIEntryTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = UDIEntryTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: UDIEntryTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> UDIEntryTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for UDIEntryTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != UDIEntryTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != UDIEntryTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UDIEntryTypeCode {
        UDIEntryTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UDIEntryTypeCode_Value>>(
                    "value",
                    |m: &UDIEntryTypeCode| { &m.value },
                    |m: &mut UDIEntryTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &UDIEntryTypeCode| { &m.id },
                    |m: &mut UDIEntryTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &UDIEntryTypeCode| { &m.extension },
                    |m: &mut UDIEntryTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UDIEntryTypeCode>(
                    "UDIEntryTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UDIEntryTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<UDIEntryTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UDIEntryTypeCode,
        };
        unsafe {
            instance.get(UDIEntryTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for UDIEntryTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UDIEntryTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UDIEntryTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UDIEntryTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    BARCODE = 1,
    RFID = 2,
    MANUAL = 3,
    CARD = 4,
    SELF_REPORTED = 5,
    UNKNOWN = 6,
}

impl ::protobuf::ProtobufEnum for UDIEntryTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UDIEntryTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(UDIEntryTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(UDIEntryTypeCode_Value::BARCODE),
            2 => ::std::option::Option::Some(UDIEntryTypeCode_Value::RFID),
            3 => ::std::option::Option::Some(UDIEntryTypeCode_Value::MANUAL),
            4 => ::std::option::Option::Some(UDIEntryTypeCode_Value::CARD),
            5 => ::std::option::Option::Some(UDIEntryTypeCode_Value::SELF_REPORTED),
            6 => ::std::option::Option::Some(UDIEntryTypeCode_Value::UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UDIEntryTypeCode_Value] = &[
            UDIEntryTypeCode_Value::INVALID_UNINITIALIZED,
            UDIEntryTypeCode_Value::BARCODE,
            UDIEntryTypeCode_Value::RFID,
            UDIEntryTypeCode_Value::MANUAL,
            UDIEntryTypeCode_Value::CARD,
            UDIEntryTypeCode_Value::SELF_REPORTED,
            UDIEntryTypeCode_Value::UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("UDIEntryTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for UDIEntryTypeCode_Value {
}

impl ::std::default::Default for UDIEntryTypeCode_Value {
    fn default() -> Self {
        UDIEntryTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for UDIEntryTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnknownContentCodeCode {
    // message fields
    pub value: UnknownContentCodeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UnknownContentCodeCode {
    pub fn new() -> UnknownContentCodeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.UnknownContentCodeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = UnknownContentCodeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: UnknownContentCodeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> UnknownContentCodeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for UnknownContentCodeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != UnknownContentCodeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != UnknownContentCodeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnknownContentCodeCode {
        UnknownContentCodeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UnknownContentCodeCode_Value>>(
                    "value",
                    |m: &UnknownContentCodeCode| { &m.value },
                    |m: &mut UnknownContentCodeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &UnknownContentCodeCode| { &m.id },
                    |m: &mut UnknownContentCodeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &UnknownContentCodeCode| { &m.extension },
                    |m: &mut UnknownContentCodeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnknownContentCodeCode>(
                    "UnknownContentCodeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnknownContentCodeCode {
        static mut instance: ::protobuf::lazy::Lazy<UnknownContentCodeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnknownContentCodeCode,
        };
        unsafe {
            instance.get(UnknownContentCodeCode::new)
        }
    }
}

impl ::protobuf::Clear for UnknownContentCodeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnknownContentCodeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnknownContentCodeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UnknownContentCodeCode_Value {
    INVALID_UNINITIALIZED = 0,
    NO = 1,
    EXTENSIONS = 2,
    ELEMENTS = 3,
    BOTH = 4,
}

impl ::protobuf::ProtobufEnum for UnknownContentCodeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UnknownContentCodeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(UnknownContentCodeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(UnknownContentCodeCode_Value::NO),
            2 => ::std::option::Option::Some(UnknownContentCodeCode_Value::EXTENSIONS),
            3 => ::std::option::Option::Some(UnknownContentCodeCode_Value::ELEMENTS),
            4 => ::std::option::Option::Some(UnknownContentCodeCode_Value::BOTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UnknownContentCodeCode_Value] = &[
            UnknownContentCodeCode_Value::INVALID_UNINITIALIZED,
            UnknownContentCodeCode_Value::NO,
            UnknownContentCodeCode_Value::EXTENSIONS,
            UnknownContentCodeCode_Value::ELEMENTS,
            UnknownContentCodeCode_Value::BOTH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("UnknownContentCodeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for UnknownContentCodeCode_Value {
}

impl ::std::default::Default for UnknownContentCodeCode_Value {
    fn default() -> Self {
        UnknownContentCodeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for UnknownContentCodeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UsageContextTypeCode {
    // message fields
    pub value: UsageContextTypeCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UsageContextTypeCode {
    pub fn new() -> UsageContextTypeCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.UsageContextTypeCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = UsageContextTypeCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: UsageContextTypeCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> UsageContextTypeCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for UsageContextTypeCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != UsageContextTypeCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != UsageContextTypeCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UsageContextTypeCode {
        UsageContextTypeCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UsageContextTypeCode_Value>>(
                    "value",
                    |m: &UsageContextTypeCode| { &m.value },
                    |m: &mut UsageContextTypeCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &UsageContextTypeCode| { &m.id },
                    |m: &mut UsageContextTypeCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &UsageContextTypeCode| { &m.extension },
                    |m: &mut UsageContextTypeCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UsageContextTypeCode>(
                    "UsageContextTypeCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UsageContextTypeCode {
        static mut instance: ::protobuf::lazy::Lazy<UsageContextTypeCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UsageContextTypeCode,
        };
        unsafe {
            instance.get(UsageContextTypeCode::new)
        }
    }
}

impl ::protobuf::Clear for UsageContextTypeCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UsageContextTypeCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UsageContextTypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UsageContextTypeCode_Value {
    INVALID_UNINITIALIZED = 0,
    GENDER = 1,
    AGE = 2,
    FOCUS = 3,
    USER = 4,
    WORKFLOW = 5,
    TASK = 6,
    VENUE = 7,
    SPECIES = 8,
}

impl ::protobuf::ProtobufEnum for UsageContextTypeCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UsageContextTypeCode_Value> {
        match value {
            0 => ::std::option::Option::Some(UsageContextTypeCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(UsageContextTypeCode_Value::GENDER),
            2 => ::std::option::Option::Some(UsageContextTypeCode_Value::AGE),
            3 => ::std::option::Option::Some(UsageContextTypeCode_Value::FOCUS),
            4 => ::std::option::Option::Some(UsageContextTypeCode_Value::USER),
            5 => ::std::option::Option::Some(UsageContextTypeCode_Value::WORKFLOW),
            6 => ::std::option::Option::Some(UsageContextTypeCode_Value::TASK),
            7 => ::std::option::Option::Some(UsageContextTypeCode_Value::VENUE),
            8 => ::std::option::Option::Some(UsageContextTypeCode_Value::SPECIES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UsageContextTypeCode_Value] = &[
            UsageContextTypeCode_Value::INVALID_UNINITIALIZED,
            UsageContextTypeCode_Value::GENDER,
            UsageContextTypeCode_Value::AGE,
            UsageContextTypeCode_Value::FOCUS,
            UsageContextTypeCode_Value::USER,
            UsageContextTypeCode_Value::WORKFLOW,
            UsageContextTypeCode_Value::TASK,
            UsageContextTypeCode_Value::VENUE,
            UsageContextTypeCode_Value::SPECIES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("UsageContextTypeCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for UsageContextTypeCode_Value {
}

impl ::std::default::Default for UsageContextTypeCode_Value {
    fn default() -> Self {
        UsageContextTypeCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for UsageContextTypeCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfidentialityClassificationCode {
    // message fields
    pub value: ConfidentialityClassificationCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConfidentialityClassificationCode {
    pub fn new() -> ConfidentialityClassificationCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ConfidentialityClassificationCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ConfidentialityClassificationCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ConfidentialityClassificationCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ConfidentialityClassificationCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ConfidentialityClassificationCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ConfidentialityClassificationCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ConfidentialityClassificationCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfidentialityClassificationCode {
        ConfidentialityClassificationCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConfidentialityClassificationCode_Value>>(
                    "value",
                    |m: &ConfidentialityClassificationCode| { &m.value },
                    |m: &mut ConfidentialityClassificationCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ConfidentialityClassificationCode| { &m.id },
                    |m: &mut ConfidentialityClassificationCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ConfidentialityClassificationCode| { &m.extension },
                    |m: &mut ConfidentialityClassificationCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfidentialityClassificationCode>(
                    "ConfidentialityClassificationCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConfidentialityClassificationCode {
        static mut instance: ::protobuf::lazy::Lazy<ConfidentialityClassificationCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfidentialityClassificationCode,
        };
        unsafe {
            instance.get(ConfidentialityClassificationCode::new)
        }
    }
}

impl ::protobuf::Clear for ConfidentialityClassificationCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfidentialityClassificationCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfidentialityClassificationCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConfidentialityClassificationCode_Value {
    INVALID_UNINITIALIZED = 0,
    U = 1,
    L = 2,
    M = 3,
    N = 4,
    R = 5,
    V = 6,
}

impl ::protobuf::ProtobufEnum for ConfidentialityClassificationCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConfidentialityClassificationCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ConfidentialityClassificationCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ConfidentialityClassificationCode_Value::U),
            2 => ::std::option::Option::Some(ConfidentialityClassificationCode_Value::L),
            3 => ::std::option::Option::Some(ConfidentialityClassificationCode_Value::M),
            4 => ::std::option::Option::Some(ConfidentialityClassificationCode_Value::N),
            5 => ::std::option::Option::Some(ConfidentialityClassificationCode_Value::R),
            6 => ::std::option::Option::Some(ConfidentialityClassificationCode_Value::V),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConfidentialityClassificationCode_Value] = &[
            ConfidentialityClassificationCode_Value::INVALID_UNINITIALIZED,
            ConfidentialityClassificationCode_Value::U,
            ConfidentialityClassificationCode_Value::L,
            ConfidentialityClassificationCode_Value::M,
            ConfidentialityClassificationCode_Value::N,
            ConfidentialityClassificationCode_Value::R,
            ConfidentialityClassificationCode_Value::V,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConfidentialityClassificationCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConfidentialityClassificationCode_Value {
}

impl ::std::default::Default for ConfidentialityClassificationCode_Value {
    fn default() -> Self {
        ConfidentialityClassificationCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfidentialityClassificationCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaccinationProtocolDoseStatuscodesCode {
    // message fields
    pub value: VaccinationProtocolDoseStatuscodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl VaccinationProtocolDoseStatuscodesCode {
    pub fn new() -> VaccinationProtocolDoseStatuscodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.VaccinationProtocolDoseStatuscodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = VaccinationProtocolDoseStatuscodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: VaccinationProtocolDoseStatuscodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> VaccinationProtocolDoseStatuscodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for VaccinationProtocolDoseStatuscodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != VaccinationProtocolDoseStatuscodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != VaccinationProtocolDoseStatuscodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaccinationProtocolDoseStatuscodesCode {
        VaccinationProtocolDoseStatuscodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VaccinationProtocolDoseStatuscodesCode_Value>>(
                    "value",
                    |m: &VaccinationProtocolDoseStatuscodesCode| { &m.value },
                    |m: &mut VaccinationProtocolDoseStatuscodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &VaccinationProtocolDoseStatuscodesCode| { &m.id },
                    |m: &mut VaccinationProtocolDoseStatuscodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &VaccinationProtocolDoseStatuscodesCode| { &m.extension },
                    |m: &mut VaccinationProtocolDoseStatuscodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VaccinationProtocolDoseStatuscodesCode>(
                    "VaccinationProtocolDoseStatuscodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VaccinationProtocolDoseStatuscodesCode {
        static mut instance: ::protobuf::lazy::Lazy<VaccinationProtocolDoseStatuscodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VaccinationProtocolDoseStatuscodesCode,
        };
        unsafe {
            instance.get(VaccinationProtocolDoseStatuscodesCode::new)
        }
    }
}

impl ::protobuf::Clear for VaccinationProtocolDoseStatuscodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaccinationProtocolDoseStatuscodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaccinationProtocolDoseStatuscodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VaccinationProtocolDoseStatuscodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    COUNT = 1,
    NOCOUNT = 2,
}

impl ::protobuf::ProtobufEnum for VaccinationProtocolDoseStatuscodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VaccinationProtocolDoseStatuscodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(VaccinationProtocolDoseStatuscodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(VaccinationProtocolDoseStatuscodesCode_Value::COUNT),
            2 => ::std::option::Option::Some(VaccinationProtocolDoseStatuscodesCode_Value::NOCOUNT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VaccinationProtocolDoseStatuscodesCode_Value] = &[
            VaccinationProtocolDoseStatuscodesCode_Value::INVALID_UNINITIALIZED,
            VaccinationProtocolDoseStatuscodesCode_Value::COUNT,
            VaccinationProtocolDoseStatuscodesCode_Value::NOCOUNT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("VaccinationProtocolDoseStatuscodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for VaccinationProtocolDoseStatuscodesCode_Value {
}

impl ::std::default::Default for VaccinationProtocolDoseStatuscodesCode_Value {
    fn default() -> Self {
        VaccinationProtocolDoseStatuscodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for VaccinationProtocolDoseStatuscodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaccinationProtocolDoseStatusReasoncodesCode {
    // message fields
    pub value: VaccinationProtocolDoseStatusReasoncodesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl VaccinationProtocolDoseStatusReasoncodesCode {
    pub fn new() -> VaccinationProtocolDoseStatusReasoncodesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.VaccinationProtocolDoseStatusReasoncodesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = VaccinationProtocolDoseStatusReasoncodesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: VaccinationProtocolDoseStatusReasoncodesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> VaccinationProtocolDoseStatusReasoncodesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for VaccinationProtocolDoseStatusReasoncodesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != VaccinationProtocolDoseStatusReasoncodesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != VaccinationProtocolDoseStatusReasoncodesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaccinationProtocolDoseStatusReasoncodesCode {
        VaccinationProtocolDoseStatusReasoncodesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VaccinationProtocolDoseStatusReasoncodesCode_Value>>(
                    "value",
                    |m: &VaccinationProtocolDoseStatusReasoncodesCode| { &m.value },
                    |m: &mut VaccinationProtocolDoseStatusReasoncodesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &VaccinationProtocolDoseStatusReasoncodesCode| { &m.id },
                    |m: &mut VaccinationProtocolDoseStatusReasoncodesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &VaccinationProtocolDoseStatusReasoncodesCode| { &m.extension },
                    |m: &mut VaccinationProtocolDoseStatusReasoncodesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VaccinationProtocolDoseStatusReasoncodesCode>(
                    "VaccinationProtocolDoseStatusReasoncodesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VaccinationProtocolDoseStatusReasoncodesCode {
        static mut instance: ::protobuf::lazy::Lazy<VaccinationProtocolDoseStatusReasoncodesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VaccinationProtocolDoseStatusReasoncodesCode,
        };
        unsafe {
            instance.get(VaccinationProtocolDoseStatusReasoncodesCode::new)
        }
    }
}

impl ::protobuf::Clear for VaccinationProtocolDoseStatusReasoncodesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaccinationProtocolDoseStatusReasoncodesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaccinationProtocolDoseStatusReasoncodesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VaccinationProtocolDoseStatusReasoncodesCode_Value {
    INVALID_UNINITIALIZED = 0,
    ADVSTORAGE = 1,
    COLDCHBRK = 2,
    EXPLOT = 3,
    OUTSIDESCHED = 4,
    PRODRECALL = 5,
}

impl ::protobuf::ProtobufEnum for VaccinationProtocolDoseStatusReasoncodesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VaccinationProtocolDoseStatusReasoncodesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(VaccinationProtocolDoseStatusReasoncodesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(VaccinationProtocolDoseStatusReasoncodesCode_Value::ADVSTORAGE),
            2 => ::std::option::Option::Some(VaccinationProtocolDoseStatusReasoncodesCode_Value::COLDCHBRK),
            3 => ::std::option::Option::Some(VaccinationProtocolDoseStatusReasoncodesCode_Value::EXPLOT),
            4 => ::std::option::Option::Some(VaccinationProtocolDoseStatusReasoncodesCode_Value::OUTSIDESCHED),
            5 => ::std::option::Option::Some(VaccinationProtocolDoseStatusReasoncodesCode_Value::PRODRECALL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VaccinationProtocolDoseStatusReasoncodesCode_Value] = &[
            VaccinationProtocolDoseStatusReasoncodesCode_Value::INVALID_UNINITIALIZED,
            VaccinationProtocolDoseStatusReasoncodesCode_Value::ADVSTORAGE,
            VaccinationProtocolDoseStatusReasoncodesCode_Value::COLDCHBRK,
            VaccinationProtocolDoseStatusReasoncodesCode_Value::EXPLOT,
            VaccinationProtocolDoseStatusReasoncodesCode_Value::OUTSIDESCHED,
            VaccinationProtocolDoseStatusReasoncodesCode_Value::PRODRECALL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("VaccinationProtocolDoseStatusReasoncodesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for VaccinationProtocolDoseStatusReasoncodesCode_Value {
}

impl ::std::default::Default for VaccinationProtocolDoseStatusReasoncodesCode_Value {
    fn default() -> Self {
        VaccinationProtocolDoseStatusReasoncodesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for VaccinationProtocolDoseStatusReasoncodesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct sequenceStatusCode {
    // message fields
    pub value: sequenceStatusCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl sequenceStatusCode {
    pub fn new() -> sequenceStatusCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.sequenceStatusCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = sequenceStatusCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: sequenceStatusCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> sequenceStatusCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for sequenceStatusCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != sequenceStatusCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != sequenceStatusCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> sequenceStatusCode {
        sequenceStatusCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<sequenceStatusCode_Value>>(
                    "value",
                    |m: &sequenceStatusCode| { &m.value },
                    |m: &mut sequenceStatusCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &sequenceStatusCode| { &m.id },
                    |m: &mut sequenceStatusCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &sequenceStatusCode| { &m.extension },
                    |m: &mut sequenceStatusCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<sequenceStatusCode>(
                    "sequenceStatusCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static sequenceStatusCode {
        static mut instance: ::protobuf::lazy::Lazy<sequenceStatusCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const sequenceStatusCode,
        };
        unsafe {
            instance.get(sequenceStatusCode::new)
        }
    }
}

impl ::protobuf::Clear for sequenceStatusCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for sequenceStatusCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for sequenceStatusCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum sequenceStatusCode_Value {
    INVALID_UNINITIALIZED = 0,
    POSITIVE = 1,
    NEGATIVE = 2,
    ABSENT = 3,
}

impl ::protobuf::ProtobufEnum for sequenceStatusCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<sequenceStatusCode_Value> {
        match value {
            0 => ::std::option::Option::Some(sequenceStatusCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(sequenceStatusCode_Value::POSITIVE),
            2 => ::std::option::Option::Some(sequenceStatusCode_Value::NEGATIVE),
            3 => ::std::option::Option::Some(sequenceStatusCode_Value::ABSENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [sequenceStatusCode_Value] = &[
            sequenceStatusCode_Value::INVALID_UNINITIALIZED,
            sequenceStatusCode_Value::POSITIVE,
            sequenceStatusCode_Value::NEGATIVE,
            sequenceStatusCode_Value::ABSENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("sequenceStatusCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for sequenceStatusCode_Value {
}

impl ::std::default::Default for sequenceStatusCode_Value {
    fn default() -> Self {
        sequenceStatusCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for sequenceStatusCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceVersionPolicyCode {
    // message fields
    pub value: ResourceVersionPolicyCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ResourceVersionPolicyCode {
    pub fn new() -> ResourceVersionPolicyCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.ResourceVersionPolicyCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = ResourceVersionPolicyCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ResourceVersionPolicyCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> ResourceVersionPolicyCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for ResourceVersionPolicyCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != ResourceVersionPolicyCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != ResourceVersionPolicyCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceVersionPolicyCode {
        ResourceVersionPolicyCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResourceVersionPolicyCode_Value>>(
                    "value",
                    |m: &ResourceVersionPolicyCode| { &m.value },
                    |m: &mut ResourceVersionPolicyCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &ResourceVersionPolicyCode| { &m.id },
                    |m: &mut ResourceVersionPolicyCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &ResourceVersionPolicyCode| { &m.extension },
                    |m: &mut ResourceVersionPolicyCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceVersionPolicyCode>(
                    "ResourceVersionPolicyCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResourceVersionPolicyCode {
        static mut instance: ::protobuf::lazy::Lazy<ResourceVersionPolicyCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceVersionPolicyCode,
        };
        unsafe {
            instance.get(ResourceVersionPolicyCode::new)
        }
    }
}

impl ::protobuf::Clear for ResourceVersionPolicyCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceVersionPolicyCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceVersionPolicyCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResourceVersionPolicyCode_Value {
    INVALID_UNINITIALIZED = 0,
    NO_VERSION = 1,
    VERSIONED = 2,
    VERSIONED_UPDATE = 3,
}

impl ::protobuf::ProtobufEnum for ResourceVersionPolicyCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResourceVersionPolicyCode_Value> {
        match value {
            0 => ::std::option::Option::Some(ResourceVersionPolicyCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(ResourceVersionPolicyCode_Value::NO_VERSION),
            2 => ::std::option::Option::Some(ResourceVersionPolicyCode_Value::VERSIONED),
            3 => ::std::option::Option::Some(ResourceVersionPolicyCode_Value::VERSIONED_UPDATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResourceVersionPolicyCode_Value] = &[
            ResourceVersionPolicyCode_Value::INVALID_UNINITIALIZED,
            ResourceVersionPolicyCode_Value::NO_VERSION,
            ResourceVersionPolicyCode_Value::VERSIONED,
            ResourceVersionPolicyCode_Value::VERSIONED_UPDATE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ResourceVersionPolicyCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResourceVersionPolicyCode_Value {
}

impl ::std::default::Default for ResourceVersionPolicyCode_Value {
    fn default() -> Self {
        ResourceVersionPolicyCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceVersionPolicyCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VisionBaseCode {
    // message fields
    pub value: VisionBaseCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl VisionBaseCode {
    pub fn new() -> VisionBaseCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.VisionBaseCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = VisionBaseCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: VisionBaseCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> VisionBaseCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for VisionBaseCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != VisionBaseCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != VisionBaseCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VisionBaseCode {
        VisionBaseCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VisionBaseCode_Value>>(
                    "value",
                    |m: &VisionBaseCode| { &m.value },
                    |m: &mut VisionBaseCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &VisionBaseCode| { &m.id },
                    |m: &mut VisionBaseCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &VisionBaseCode| { &m.extension },
                    |m: &mut VisionBaseCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VisionBaseCode>(
                    "VisionBaseCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VisionBaseCode {
        static mut instance: ::protobuf::lazy::Lazy<VisionBaseCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VisionBaseCode,
        };
        unsafe {
            instance.get(VisionBaseCode::new)
        }
    }
}

impl ::protobuf::Clear for VisionBaseCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VisionBaseCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VisionBaseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VisionBaseCode_Value {
    INVALID_UNINITIALIZED = 0,
    UP = 1,
    DOWN = 2,
    IN = 3,
    OUT = 4,
}

impl ::protobuf::ProtobufEnum for VisionBaseCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VisionBaseCode_Value> {
        match value {
            0 => ::std::option::Option::Some(VisionBaseCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(VisionBaseCode_Value::UP),
            2 => ::std::option::Option::Some(VisionBaseCode_Value::DOWN),
            3 => ::std::option::Option::Some(VisionBaseCode_Value::IN),
            4 => ::std::option::Option::Some(VisionBaseCode_Value::OUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VisionBaseCode_Value] = &[
            VisionBaseCode_Value::INVALID_UNINITIALIZED,
            VisionBaseCode_Value::UP,
            VisionBaseCode_Value::DOWN,
            VisionBaseCode_Value::IN,
            VisionBaseCode_Value::OUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("VisionBaseCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for VisionBaseCode_Value {
}

impl ::std::default::Default for VisionBaseCode_Value {
    fn default() -> Self {
        VisionBaseCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for VisionBaseCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VisionEyesCode {
    // message fields
    pub value: VisionEyesCode_Value,
    pub id: ::protobuf::SingularPtrField<super::datatypes::String>,
    pub extension: ::protobuf::RepeatedField<super::datatypes::Extension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl VisionEyesCode {
    pub fn new() -> VisionEyesCode {
        ::std::default::Default::default()
    }

    // .google.fhir.stu3.proto.VisionEyesCode.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value = VisionEyesCode_Value::INVALID_UNINITIALIZED;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: VisionEyesCode_Value) {
        self.value = v;
    }

    pub fn get_value(&self) -> VisionEyesCode_Value {
        self.value
    }

    // .google.fhir.stu3.proto.String id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: super::datatypes::String) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut super::datatypes::String {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> super::datatypes::String {
        self.id.take().unwrap_or_else(|| super::datatypes::String::new())
    }

    pub fn get_id(&self) -> &super::datatypes::String {
        self.id.as_ref().unwrap_or_else(|| super::datatypes::String::default_instance())
    }

    // repeated .google.fhir.stu3.proto.Extension extension = 3;

    pub fn clear_extension(&mut self) {
        self.extension.clear();
    }

    // Param is passed by value, moved
    pub fn set_extension(&mut self, v: ::protobuf::RepeatedField<super::datatypes::Extension>) {
        self.extension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extension(&mut self) -> &mut ::protobuf::RepeatedField<super::datatypes::Extension> {
        &mut self.extension
    }

    // Take field
    pub fn take_extension(&mut self) -> ::protobuf::RepeatedField<super::datatypes::Extension> {
        ::std::mem::replace(&mut self.extension, ::protobuf::RepeatedField::new())
    }

    pub fn get_extension(&self) -> &[super::datatypes::Extension] {
        &self.extension
    }
}

impl ::protobuf::Message for VisionEyesCode {
    fn is_initialized(&self) -> bool {
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.extension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value != VisionEyesCode_Value::INVALID_UNINITIALIZED {
            my_size += ::protobuf::rt::enum_size(1, self.value);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value != VisionEyesCode_Value::INVALID_UNINITIALIZED {
            os.write_enum(1, self.value.value())?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.extension {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VisionEyesCode {
        VisionEyesCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VisionEyesCode_Value>>(
                    "value",
                    |m: &VisionEyesCode| { &m.value },
                    |m: &mut VisionEyesCode| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::String>>(
                    "id",
                    |m: &VisionEyesCode| { &m.id },
                    |m: &mut VisionEyesCode| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::datatypes::Extension>>(
                    "extension",
                    |m: &VisionEyesCode| { &m.extension },
                    |m: &mut VisionEyesCode| { &mut m.extension },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VisionEyesCode>(
                    "VisionEyesCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VisionEyesCode {
        static mut instance: ::protobuf::lazy::Lazy<VisionEyesCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VisionEyesCode,
        };
        unsafe {
            instance.get(VisionEyesCode::new)
        }
    }
}

impl ::protobuf::Clear for VisionEyesCode {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_id();
        self.clear_extension();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VisionEyesCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VisionEyesCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VisionEyesCode_Value {
    INVALID_UNINITIALIZED = 0,
    RIGHT = 1,
    LEFT = 2,
}

impl ::protobuf::ProtobufEnum for VisionEyesCode_Value {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VisionEyesCode_Value> {
        match value {
            0 => ::std::option::Option::Some(VisionEyesCode_Value::INVALID_UNINITIALIZED),
            1 => ::std::option::Option::Some(VisionEyesCode_Value::RIGHT),
            2 => ::std::option::Option::Some(VisionEyesCode_Value::LEFT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VisionEyesCode_Value] = &[
            VisionEyesCode_Value::INVALID_UNINITIALIZED,
            VisionEyesCode_Value::RIGHT,
            VisionEyesCode_Value::LEFT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("VisionEyesCode_Value", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for VisionEyesCode_Value {
}

impl ::std::default::Default for VisionEyesCode_Value {
    fn default() -> Self {
        VisionEyesCode_Value::INVALID_UNINITIALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for VisionEyesCode_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16proto/stu3/codes.proto\x12\x16google.fhir.stu3.proto\x1a\x1cproto/\
    stu3/annotations.proto\x1a\x1aproto/stu3/datatypes.proto\"\xd0\x02\n\x10\
    AbstractTypeCode\x12D\n\x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3\
    .proto.AbstractTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"L\n\x05Val\
    ue\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x14\n\x04TYPE\x10\x01\
    \x1a\n\xba\x96\xbb\xb2\x05\x04Type\x12\x12\n\x03ANY\x10\x02\x1a\t\xba\
    \x96\xbb\xb2\x05\x03Any:7\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05+ht\
    tp://hl7.org/fhir/ValueSet/abstract-types\"\xe3\x02\n\x13AggregationMode\
    Code\x12G\n\x05value\x18\x01\x20\x01(\x0e21.google.fhir.stu3.proto.Aggre\
    gationModeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.go\
    ogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"N\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\r\n\tCONTAINED\x10\x01\x12\x0e\
    \n\nREFERENCED\x10\x02\x12\x0b\n\x07BUNDLED\x10\x03:B\x8a\xf9\x83\xb2\
    \x056http://hl7.org/fhir/ValueSet/resource-aggregation-mode\xc0\x9f\xe3\
    \xb6\x05\x01\"\xe8\x02\n\x13BindingStrengthCode\x12G\n\x05value\x18\x01\
    \x20\x01(\x0e21.google.fhir.stu3.proto.BindingStrengthCode.ValueR\x05val\
    ue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"\\\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x0c\n\x08REQUIRED\x10\x01\x12\x0e\n\nEXTENSIBLE\x10\x02\x12\r\
    \n\tPREFERRED\x10\x03\x12\x0b\n\x07EXAMPLE\x10\x04:9\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x05-http://hl7.org/fhir/ValueSet/binding-strength\"\
    \xcf\x02\n\x16ConstraintSeverityCode\x12J\n\x05value\x18\x01\x20\x01(\
    \x0e24.google.fhir.stu3.proto.ConstraintSeverityCode.ValueR\x05value\x12\
    .\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\":\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\t\n\x05ERROR\x10\x01\x12\x0b\n\x07WARNING\x10\x02:<\xc0\x9f\xe3\xb6\
    \x05\x01\x8a\xf9\x83\xb2\x050http://hl7.org/fhir/ValueSet/constraint-sev\
    erity\"\xe6\x02\n\x10SlicingRulesCode\x12D\n\x05value\x18\x01\x20\x01(\
    \x0e2..google.fhir.stu3.proto.SlicingRulesCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"Z\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\n\n\x06CLOSED\x10\x01\x12\x08\n\x04OPEN\x10\x02\x12\x20\n\x0bOPEN_A\
    T_END\x10\x03\x1a\x0f\xba\x96\xbb\xb2\x05\topenAtEnd:?\x8a\xf9\x83\xb2\
    \x053http://hl7.org/fhir/ValueSet/resource-slicing-rules\xc0\x9f\xe3\xb6\
    \x05\x01\"\xef\x02\n\x15DiscriminatorTypeCode\x12I\n\x05value\x18\x01\
    \x20\x01(\x0e23.google.fhir.stu3.proto.DiscriminatorTypeCode.ValueR\x05v\
    alue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Strin\
    gR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto\
    .ExtensionR\textension\"]\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\t\n\x05VALUE\x10\x01\x12\n\n\x06EXISTS\x10\x02\x12\x0b\n\x07P\
    ATTERN\x10\x03\x12\x08\n\x04TYPE\x10\x04\x12\x0b\n\x07PROFILE\x10\x05:;\
    \x8a\xf9\x83\xb2\x05/http://hl7.org/fhir/ValueSet/discriminator-type\xc0\
    \x9f\xe3\xb6\x05\x01\"\xc5\x03\n\x1aPropertyRepresentationCode\x12N\n\
    \x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.PropertyRepresen\
    tationCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google\
    .fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.\
    google.fhir.stu3.proto.ExtensionR\textension\"\xa3\x01\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x1b\n\x08XML_ATTR\x10\x01\x1a\
    \r\xba\x96\xbb\xb2\x05\x07xmlAttr\x12\x1b\n\x08XML_TEXT\x10\x02\x1a\r\
    \xba\x96\xbb\xb2\x05\x07xmlText\x12\x1d\n\tTYPE_ATTR\x10\x03\x1a\x0e\xba\
    \x96\xbb\xb2\x05\x08typeAttr\x12\x1b\n\x08CDA_TEXT\x10\x04\x1a\r\xba\x96\
    \xbb\xb2\x05\x07cdaText\x12\t\n\x05XHTML\x10\x05:@\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/ValueSet/property-represent\
    ation\"\xec\x02\n\x19ReferenceVersionRulesCode\x12M\n\x05value\x18\x01\
    \x20\x01(\x0e27.google.fhir.stu3.proto.ReferenceVersionRulesCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"M\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\n\n\x06EITHER\x10\x01\x12\x0f\n\x0bINDEPENDENT\x10\x02\
    \x12\x0c\n\x08SPECIFIC\x10\x03:@\x8a\xf9\x83\xb2\x054http://hl7.org/fhir\
    /ValueSet/reference-version-rules\xc0\x9f\xe3\xb6\x05\x01\"\xd8\x02\n\
    \x11AccountStatusCode\x12E\n\x05value\x18\x01\x20\x01(\x0e2/.google.fhir\
    .stu3.proto.AccountStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"R\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06ACTIVE\
    \x10\x01\x12\x0c\n\x08INACTIVE\x10\x02\x12\x14\n\x10ENTERED_IN_ERROR\x10\
    \x03:7\x8a\xf9\x83\xb2\x05+http://hl7.org/fhir/ValueSet/account-status\
    \xc0\x9f\xe3\xb6\x05\x01\"\xe7\x02\n\x1dActionCardinalityBehaviorCode\
    \x12Q\n\x05value\x18\x01\x20\x01(\x0e2;.google.fhir.stu3.proto.ActionCar\
    dinalityBehaviorCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"<\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06SINGLE\x10\x01\x12\
    \x0c\n\x08MULTIPLE\x10\x02:D\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05\
    8http://hl7.org/fhir/ValueSet/action-cardinality-behavior\"\xe3\x02\n\
    \x17ActionConditionKindCode\x12K\n\x05value\x18\x01\x20\x01(\x0e25.googl\
    e.fhir.stu3.proto.ActionConditionKindCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"J\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x11\n\r\
    APPLICABILITY\x10\x01\x12\t\n\x05START\x10\x02\x12\x08\n\x04STOP\x10\x03\
    :>\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x052http://hl7.org/fhir/Value\
    Set/action-condition-kind\"\xfd\x02\n\x1aActionGroupingBehaviorCode\x12N\
    \n\x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.ActionGrouping\
    BehaviorCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goog\
    le.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2\
    !.google.fhir.stu3.proto.ExtensionR\textension\"[\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x10\n\x0cVISUAL_GROUP\x10\x01\x12\
    \x11\n\rLOGICAL_GROUP\x10\x02\x12\x12\n\x0eSENTENCE_GROUP\x10\x03:A\xc0\
    \x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x055http://hl7.org/fhir/ValueSet/ac\
    tion-grouping-behavior\"\xcf\x02\n\x0eActionListCode\x12B\n\x05value\x18\
    \x01\x20\x01(\x0e2,.google.fhir.stu3.proto.ActionListCode.ValueR\x05valu\
    e\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"S\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\n\n\x06CANCEL\x10\x01\x12\x08\n\x04POLL\x10\x02\x12\r\n\tREPR\
    OCESS\x10\x03\x12\n\n\x06STATUS\x10\x04:3\x8a\xf9\x83\xb2\x05'http://hl7\
    .org/fhir/ValueSet/actionlist\xc0\x9f\xe3\xb6\x05\x01\"\xf4\x02\n\x19Act\
    ionParticipantTypeCode\x12M\n\x05value\x18\x01\x20\x01(\x0e27.google.fhi\
    r.stu3.proto.ActionParticipantTypeCode.ValueR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"U\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07PA\
    TIENT\x10\x01\x12\x10\n\x0cPRACTITIONER\x10\x02\x12\x12\n\x0eRELATED_PER\
    SON\x10\x03:@\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x054http://hl7.org\
    /fhir/ValueSet/action-participant-type\"\xd5\x02\n\x1aActionPrecheckBeha\
    viorCode\x12N\n\x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.A\
    ctionPrecheckBehaviorCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"3\n\x05Val\
    ue\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x07\n\x03YES\x10\x01\x12\
    \x06\n\x02NO\x10\x02:A\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x055http:\
    //hl7.org/fhir/ValueSet/action-precheck-behavior\"\xe2\x03\n\x1aActionRe\
    lationshipTypeCode\x12N\n\x05value\x18\x01\x20\x01(\x0e28.google.fhir.st\
    u3.proto.ActionRelationshipTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\
    \xbf\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x10\n\
    \x0cBEFORE_START\x10\x01\x12\n\n\x06BEFORE\x10\x02\x12\x0e\n\nBEFORE_END\
    \x10\x03\x12\x19\n\x15CONCURRENT_WITH_START\x10\x04\x12\x0e\n\nCONCURREN\
    T\x10\x05\x12\x17\n\x13CONCURRENT_WITH_END\x10\x06\x12\x0f\n\x0bAFTER_ST\
    ART\x10\x07\x12\t\n\x05AFTER\x10\x08\x12\r\n\tAFTER_END\x10\t:A\xc0\x9f\
    \xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x055http://hl7.org/fhir/ValueSet/action\
    -relationship-type\"\xf5\x02\n\x1aActionRequiredBehaviorCode\x12N\n\x05v\
    alue\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.ActionRequiredBehavio\
    rCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir\
    .stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.googl\
    e.fhir.stu3.proto.ExtensionR\textension\"S\n\x05Value\x12\x19\n\x15INVAL\
    ID_UNINITIALIZED\x10\0\x12\x08\n\x04MUST\x10\x01\x12\t\n\x05COULD\x10\
    \x02\x12\x1a\n\x16MUST_UNLESS_DOCUMENTED\x10\x03:A\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x055http://hl7.org/fhir/ValueSet/action-required-be\
    havior\"\x9d\x03\n\x1bActionSelectionBehaviorCode\x12O\n\x05value\x18\
    \x01\x20\x01(\x0e29.google.fhir.stu3.proto.ActionSelectionBehaviorCode.V\
    alueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.p\
    roto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.\
    stu3.proto.ExtensionR\textension\"x\n\x05Value\x12\x19\n\x15INVALID_UNIN\
    ITIALIZED\x10\0\x12\x07\n\x03ANY\x10\x01\x12\x07\n\x03ALL\x10\x02\x12\
    \x0f\n\x0bALL_OR_NONE\x10\x03\x12\x0f\n\x0bEXACTLY_ONE\x10\x04\x12\x0f\n\
    \x0bAT_MOST_ONE\x10\x05\x12\x0f\n\x0bONE_OR_MORE\x10\x06:B\xc0\x9f\xe3\
    \xb6\x05\x01\x8a\xf9\x83\xb2\x056http://hl7.org/fhir/ValueSet/action-sel\
    ection-behavior\"\xd3\x02\n\x0eActionTypeCode\x12B\n\x05value\x18\x01\
    \x20\x01(\x0e2,.google.fhir.stu3.proto.ActionTypeCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"V\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\n\n\x06CREATE\x10\x01\x12\n\n\x06UPDATE\x10\x02\x12\n\n\x06RE\
    MOVE\x10\x03\x12\x0e\n\nFIRE_EVENT\x10\x04:4\xc0\x9f\xe3\xb6\x05\x01\x8a\
    \xf9\x83\xb2\x05(http://hl7.org/fhir/ValueSet/action-type\"\xfe\x02\n\
    \x1eActivityDefinitionCategoryCode\x12R\n\x05value\x18\x01\x20\x01(\x0e2\
    <.google.fhir.stu3.proto.ActivityDefinitionCategoryCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"P\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\r\n\tTREATMENT\x10\x01\x12\r\n\tEDUCATION\x10\x02\x12\x0e\n\n\
    ASSESSMENT\x10\x03:E\x8a\xf9\x83\xb2\x059http://hl7.org/fhir/ValueSet/ac\
    tivity-definition-category\xc0\x9f\xe3\xb6\x05\x01\"\xeb\x02\n\x18Admini\
    strativeGenderCode\x12L\n\x05value\x18\x01\x20\x01(\x0e26.google.fhir.st\
    u3.proto.AdministrativeGenderCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"P\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04MALE\
    \x10\x01\x12\n\n\x06FEMALE\x10\x02\x12\t\n\x05OTHER\x10\x03\x12\x0b\n\
    \x07UNKNOWN\x10\x04:>\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x052http:/\
    /hl7.org/fhir/ValueSet/administrative-gender\"\xe4\x02\n\x18AdverseEvent\
    CategoryCode\x12L\n\x05value\x18\x01\x20\x01(\x0e26.google.fhir.stu3.pro\
    to.AdverseEventCategoryCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01\
    (\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\
    \x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"H\n\
    \x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x10\n\x02AE\x10\
    \x01\x1a\x08\xba\x96\xbb\xb2\x05\x02AE\x12\x12\n\x03PAE\x10\x02\x1a\t\
    \xba\x96\xbb\xb2\x05\x03PAE:?\x8a\xf9\x83\xb2\x053http://hl7.org/fhir/Va\
    lueSet/adverse-event-category\xc0\x9f\xe3\xb6\x05\x01\"\xf6\x02\n#Advers\
    eEventCausalityAssessmentCode\x12W\n\x05value\x18\x01\x20\x01(\x0e2A.goo\
    gle.fhir.stu3.proto.AdverseEventCausalityAssessmentCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"<\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x0b\n\x07ASSESS1\x10\x01\x12\x0b\n\x07ASSESS2\x10\x02:G\x8a\
    \xf9\x83\xb2\x05;http://hl7.org/fhir/ValueSet/adverse-event-causality-as\
    sess\xc0\x9f\xe3\xb6\x05\x01\"\xe1\x02\n\x19AdverseEventCausalityCode\
    \x12M\n\x05value\x18\x01\x20\x01(\x0e27.google.fhir.stu3.proto.AdverseEv\
    entCausalityCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.\
    google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"B\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0e\n\nCAUSALITY1\x10\x01\x12\
    \x0e\n\nCAUSALITY2\x10\x02:@\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/Val\
    ueSet/adverse-event-causality\xc0\x9f\xe3\xb6\x05\x01\"\xee\x02\n\x1fAdv\
    erseEventCausalityMethodCode\x12S\n\x05value\x18\x01\x20\x01(\x0e2=.goog\
    le.fhir.stu3.proto.AdverseEventCausalityMethodCode.ValueR\x05value\x12.\
    \n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"<\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x0b\n\x07METHOD1\x10\x01\x12\x0b\n\x07METHOD2\x10\x02:G\x8a\xf9\x83\
    \xb2\x05;http://hl7.org/fhir/ValueSet/adverse-event-causality-method\xc0\
    \x9f\xe3\xb6\x05\x01\"\xee\x02\n\x1fAdverseEventCausalityResultCode\x12S\
    \n\x05value\x18\x01\x20\x01(\x0e2=.google.fhir.stu3.proto.AdverseEventCa\
    usalityResultCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e\
    .google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"<\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07RESULT1\x10\x01\x12\
    \x0b\n\x07RESULT2\x10\x02:G\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05;\
    http://hl7.org/fhir/ValueSet/adverse-event-causality-result\"\xb5\x03\n\
    \x17AdverseEventOutcomeCode\x12K\n\x05value\x18\x01\x20\x01(\x0e25.googl\
    e.fhir.stu3.proto.AdverseEventOutcomeCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"\x9b\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\
    \x0c\n\x08RESOLVED\x10\x01\x12\x0e\n\nRECOVERING\x10\x02\x12\x0b\n\x07ON\
    GOING\x10\x03\x124\n\x14RESOLVEDWITHSEQUELAE\x10\x04\x1a\x1a\xba\x96\xbb\
    \xb2\x05\x14resolvedWithSequelae\x12\t\n\x05FATAL\x10\x05\x12\x0b\n\x07U\
    NKNOWN\x10\x06:>\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x052http://hl7.\
    org/fhir/ValueSet/adverse-event-outcome\"\x95\x03\n\x1bAdverseEventSerio\
    usnessCode\x12O\n\x05value\x18\x01\x20\x01(\x0e29.google.fhir.stu3.proto\
    .AdverseEventSeriousnessCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"p\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x14\n\x04MILD\
    \x10\x01\x1a\n\xba\x96\xbb\xb2\x05\x04Mild\x12\x1c\n\x08MODERATE\x10\x02\
    \x1a\x0e\xba\x96\xbb\xb2\x05\x08Moderate\x12\x18\n\x06SEVERE\x10\x03\x1a\
    \x0c\xba\x96\xbb\xb2\x05\x06Severe:B\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\
    \xb2\x056http://hl7.org/fhir/ValueSet/adverse-event-seriousness\"\xa2\
    \x03\n+AllergyIntoleranceSubstanceExposureRiskCode\x12_\n\x05value\x18\
    \x01\x20\x01(\x0e2I.google.fhir.stu3.proto.AllergyIntoleranceSubstanceEx\
    posureRiskCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.go\
    ogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"W\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x17\n\x13KNOWN_REACTION_RISK\
    \x10\x01\x12\x1a\n\x16NO_KNOWN_REACTION_RISK\x10\x02:H\xc0\x9f\xe3\xb6\
    \x05\x01\x8a\xf9\x83\xb2\x05<http://hl7.org/fhir/ValueSet/allerg-intol-s\
    ubstance-exp-risk\"\xff\x02\n$AllergyIntoleranceClinicalStatusCode\x12X\
    \n\x05value\x18\x01\x20\x01(\x0e2B.google.fhir.stu3.proto.AllergyIntoler\
    anceClinicalStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b\
    2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"J\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\
    \x0c\n\x08INACTIVE\x10\x02\x12\x0c\n\x08RESOLVED\x10\x03:@\x8a\xf9\x83\
    \xb2\x054http://hl7.org/fhir/ValueSet/allergy-clinical-status\xc0\x9f\
    \xe3\xb6\x05\x01\"\x89\x03\n\x1eAllergyIntoleranceCategoryCode\x12R\n\
    \x05value\x18\x01\x20\x01(\x0e2<.google.fhir.stu3.proto.AllergyIntoleran\
    ceCategoryCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.go\
    ogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"[\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04FOOD\x10\x01\x12\x0e\
    \n\nMEDICATION\x10\x02\x12\x0f\n\x0bENVIRONMENT\x10\x03\x12\x0c\n\x08BIO\
    LOGIC\x10\x04:E\x8a\xf9\x83\xb2\x059http://hl7.org/fhir/ValueSet/allergy\
    -intolerance-category\xc0\x9f\xe3\xb6\x05\x01\"\x82\x03\n!AllergyIntoler\
    anceCriticalityCode\x12U\n\x05value\x18\x01\x20\x01(\x0e2?.google.fhir.s\
    tu3.proto.AllergyIntoleranceCriticalityCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"K\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x07\n\
    \x03LOW\x10\x01\x12\x08\n\x04HIGH\x10\x02\x12\x14\n\x10UNABLE_TO_ASSESS\
    \x10\x03:H\x8a\xf9\x83\xb2\x05<http://hl7.org/fhir/ValueSet/allergy-into\
    lerance-criticality\xc0\x9f\xe3\xb6\x05\x01\"\xe2\x02\n\x1aAllergyIntole\
    ranceTypeCode\x12N\n\x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.pr\
    oto.AllergyIntoleranceTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"@\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07ALLERG\
    Y\x10\x01\x12\x0f\n\x0bINTOLERANCE\x10\x02:A\xc0\x9f\xe3\xb6\x05\x01\x8a\
    \xf9\x83\xb2\x055http://hl7.org/fhir/ValueSet/allergy-intolerance-type\"\
    \xa6\x03\n(AllergyIntoleranceVerificationStatusCode\x12\\\n\x05value\x18\
    \x01\x20\x01(\x0e2F.google.fhir.stu3.proto.AllergyIntoleranceVerificatio\
    nStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.googl\
    e.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!\
    .google.fhir.stu3.proto.ExtensionR\textension\"e\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x0f\n\x0bUNCONFIRMED\x10\x01\x12\r\n\
    \tCONFIRMED\x10\x02\x12\x0b\n\x07REFUTED\x10\x03\x12\x14\n\x10ENTERED_IN\
    _ERROR\x10\x04:D\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x058http://hl7.\
    org/fhir/ValueSet/allergy-verification-status\"\xd2\x02\n\x10GenderStatu\
    sCode\x12D\n\x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3.proto.Gend\
    erStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goog\
    le.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2\
    !.google.fhir.stu3.proto.ExtensionR\textension\"I\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08NEUTERED\x10\x01\x12\n\n\
    \x06INTACT\x10\x02\x12\x0b\n\x07UNKNOWN\x10\x03:<\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x050http://hl7.org/fhir/ValueSet/animal-genderstatu\
    s\"\xa8\x03\n\x15AppointmentStatusCode\x12I\n\x05value\x18\x01\x20\x01(\
    \x0e23.google.fhir.stu3.proto.AppointmentStatusCode.ValueR\x05value\x12.\
    \n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\x96\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x0c\n\x08PROPOSED\x10\x01\x12\x0b\n\x07PENDING\x10\x02\x12\n\
    \n\x06BOOKED\x10\x03\x12\x0b\n\x07ARRIVED\x10\x04\x12\r\n\tFULFILLED\x10\
    \x05\x12\r\n\tCANCELLED\x10\x06\x12\n\n\x06NOSHOW\x10\x07\x12\x14\n\x10E\
    NTERED_IN_ERROR\x10\x08::\x8a\xf9\x83\xb2\x05.http://hl7.org/fhir/ValueS\
    et/appointmentstatus\xc0\x9f\xe3\xb6\x05\x01\"\xdd\x02\n\x1aAssertionDir\
    ectionTypeCode\x12N\n\x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.p\
    roto.AssertionDirectionTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"=\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08RESPON\
    SE\x10\x01\x12\x0b\n\x07REQUEST\x10\x02:?\xc0\x9f\xe3\xb6\x05\x01\x8a\
    \xf9\x83\xb2\x053http://hl7.org/fhir/ValueSet/assert-direction-codes\"\
    \xb3\x04\n\x19AssertionOperatorTypeCode\x12M\n\x05value\x18\x01\x20\x01(\
    \x0e27.google.fhir.stu3.proto.AssertionOperatorTypeCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"\x95\x02\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\n\n\x06EQUALS\x10\x01\x12\x1e\n\tNOTEQUALS\x10\x02\x1a\
    \x0f\xba\x96\xbb\xb2\x05\tnotEquals\x12\x06\n\x02IN\x10\x03\x12\x16\n\
    \x05NOTIN\x10\x04\x1a\x0b\xba\x96\xbb\xb2\x05\x05notIn\x12\"\n\x0bGREATE\
    RTHAN\x10\x05\x1a\x11\xba\x96\xbb\xb2\x05\x0bgreaterThan\x12\x1c\n\x08LE\
    SSTHAN\x10\x06\x1a\x0e\xba\x96\xbb\xb2\x05\x08lessThan\x12\t\n\x05EMPTY\
    \x10\x07\x12\x1c\n\x08NOTEMPTY\x10\x08\x1a\x0e\xba\x96\xbb\xb2\x05\x08no\
    tEmpty\x12\x0c\n\x08CONTAINS\x10\t\x12\"\n\x0bNOTCONTAINS\x10\n\x1a\x11\
    \xba\x96\xbb\xb2\x05\x0bnotContains\x12\x08\n\x04EVAL\x10\x0b:>\x8a\xf9\
    \x83\xb2\x052http://hl7.org/fhir/ValueSet/assert-operator-codes\xc0\x9f\
    \xe3\xb6\x05\x01\"\xe3\x04\n\x1aAssertionResponseTypesCode\x12N\n\x05val\
    ue\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.AssertionResponseTypesC\
    ode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.s\
    tu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.\
    fhir.stu3.proto.ExtensionR\textension\"\xbe\x02\n\x05Value\x12\x19\n\x15\
    INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04OKAY\x10\x01\x12\x0b\n\x07CREAT\
    ED\x10\x02\x12\x1e\n\tNOCONTENT\x10\x03\x1a\x0f\xba\x96\xbb\xb2\x05\tnoC\
    ontent\x12\"\n\x0bNOTMODIFIED\x10\x04\x1a\x11\xba\x96\xbb\xb2\x05\x0bnot\
    Modified\x12\x07\n\x03BAD\x10\x05\x12\r\n\tFORBIDDEN\x10\x06\x12\x1c\n\
    \x08NOTFOUND\x10\x07\x1a\x0e\xba\x96\xbb\xb2\x05\x08notFound\x12,\n\x10M\
    ETHODNOTALLOWED\x10\x08\x1a\x16\xba\x96\xbb\xb2\x05\x10methodNotAllowed\
    \x12\x0c\n\x08CONFLICT\x10\t\x12\x08\n\x04GONE\x10\n\x120\n\x12PRECONDIT\
    IONFAILED\x10\x0b\x1a\x18\xba\x96\xbb\xb2\x05\x12preconditionFailed\x12\
    \x11\n\rUNPROCESSABLE\x10\x0c:C\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\
    \x057http://hl7.org/fhir/ValueSet/assert-response-code-types\"\x82\x03\n\
    \x14AuditEventActionCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.google.f\
    hir.stu3.proto.AuditEventActionCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"r\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0e\n\x01C\x10\
    \x01\x1a\x07\xba\x96\xbb\xb2\x05\x01C\x12\x0e\n\x01R\x10\x02\x1a\x07\xba\
    \x96\xbb\xb2\x05\x01R\x12\x0e\n\x01U\x10\x03\x1a\x07\xba\x96\xbb\xb2\x05\
    \x01U\x12\x0e\n\x01D\x10\x04\x1a\x07\xba\x96\xbb\xb2\x05\x01D\x12\x0e\n\
    \x01E\x10\x05\x1a\x07\xba\x96\xbb\xb2\x05\x01E:;\x8a\xf9\x83\xb2\x05/htt\
    p://hl7.org/fhir/ValueSet/audit-event-action\xc0\x9f\xe3\xb6\x05\x01\"\
    \xa3\x03\n\x15AuditEventOutcomeCode\x12I\n\x05value\x18\x01\x20\x01(\x0e\
    23.google.fhir.stu3.proto.AuditEventOutcomeCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\x8f\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x14\n\x07SUCCESS\x10\x01\x1a\x07\xba\x96\xbb\xb2\x05\x010\x12\
    \x1a\n\rMINOR_FAILURE\x10\x02\x1a\x07\xba\x96\xbb\xb2\x05\x014\x12\x1c\n\
    \x0fSERIOUS_FAILURE\x10\x03\x1a\x07\xba\x96\xbb\xb2\x05\x018\x12\x1b\n\r\
    MAJOR_FAILURE\x10\x04\x1a\x08\xba\x96\xbb\xb2\x05\x0212:<\xc0\x9f\xe3\
    \xb6\x05\x01\x8a\xf9\x83\xb2\x050http://hl7.org/fhir/ValueSet/audit-even\
    t-outcome\"\x99\x04\n\x16BasicResourceTypesCode\x12J\n\x05value\x18\x01\
    \x20\x01(\x0e24.google.fhir.stu3.proto.BasicResourceTypesCode.ValueR\x05\
    value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Stri\
    ngR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.prot\
    o.ExtensionR\textension\"\x83\x02\n\x05Value\x12\x19\n\x15INVALID_UNINIT\
    IALIZED\x10\0\x12\x0b\n\x07CONSENT\x10\x01\x12\x0c\n\x08REFERRAL\x10\x02\
    \x12\x0c\n\x08ADVEVENT\x10\x03\x12\x0c\n\x08APTMTREQ\x10\x04\x12\x0c\n\
    \x08TRANSFER\x10\x05\x12\x08\n\x04DIET\x10\x06\x12\x0c\n\x08ADMINACT\x10\
    \x07\x12\x0c\n\x08EXPOSURE\x10\x08\x12\x11\n\rINVESTIGATION\x10\t\x12\
    \x0b\n\x07ACCOUNT\x10\n\x12\x0b\n\x07INVOICE\x10\x0b\x12\r\n\tADJUDICAT\
    \x10\x0c\x12\r\n\tPREDETREQ\x10\r\x12\x10\n\x0cPREDETERMINE\x10\x0e\x12\
    \t\n\x05STUDY\x10\x0f\x12\x0c\n\x08PROTOCOL\x10\x10:<\x8a\xf9\x83\xb2\
    \x050http://hl7.org/fhir/ValueSet/basic-resource-type\xc0\x9f\xe3\xb6\
    \x05\x01\"\xb1\x03\n\x0eBundleTypeCode\x12B\n\x05value\x18\x01\x20\x01(\
    \x0e2,.google.fhir.stu3.proto.BundleTypeCode.ValueR\x05value\x12.\n\x02i\
    d\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\"\xb3\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x0c\n\x08DOCUMENT\x10\x01\x12\x0b\n\x07MESSAGE\x10\x02\x12\x0f\n\
    \x0bTRANSACTION\x10\x03\x12\x18\n\x14TRANSACTION_RESPONSE\x10\x04\x12\t\
    \n\x05BATCH\x10\x05\x12\x12\n\x0eBATCH_RESPONSE\x10\x06\x12\x0b\n\x07HIS\
    TORY\x10\x07\x12\r\n\tSEARCHSET\x10\x08\x12\x0e\n\nCOLLECTION\x10\t:4\
    \x8a\xf9\x83\xb2\x05(http://hl7.org/fhir/ValueSet/bundle-type\xc0\x9f\
    \xe3\xb6\x05\x01\"\xf7\x02\n\x1bCapabilityStatementKindCode\x12O\n\x05va\
    lue\x18\x01\x20\x01(\x0e29.google.fhir.stu3.proto.CapabilityStatementKin\
    dCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir\
    .stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.googl\
    e.fhir.stu3.proto.ExtensionR\textension\"R\n\x05Value\x12\x19\n\x15INVAL\
    ID_UNINITIALIZED\x10\0\x12\x0c\n\x08INSTANCE\x10\x01\x12\x0e\n\nCAPABILI\
    TY\x10\x02\x12\x10\n\x0cREQUIREMENTS\x10\x03:B\xc0\x9f\xe3\xb6\x05\x01\
    \x8a\xf9\x83\xb2\x056http://hl7.org/fhir/ValueSet/capability-statement-k\
    ind\"\xa5\x03\n\x1cCarePlanActivityCategoryCode\x12P\n\x05value\x18\x01\
    \x20\x01(\x0e2:.google.fhir.stu3.proto.CarePlanActivityCategoryCode.Valu\
    eR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.prot\
    o.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu\
    3.proto.ExtensionR\textension\"|\n\x05Value\x12\x19\n\x15INVALID_UNINITI\
    ALIZED\x10\0\x12\x08\n\x04DIET\x10\x01\x12\x08\n\x04DRUG\x10\x02\x12\r\n\
    \tENCOUNTER\x10\x03\x12\x0f\n\x0bOBSERVATION\x10\x04\x12\r\n\tPROCEDURE\
    \x10\x05\x12\n\n\x06SUPPLY\x10\x06\x12\t\n\x05OTHER\x10\x07:D\xc0\x9f\
    \xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x058http://hl7.org/fhir/ValueSet/care-p\
    lan-activity-category\"\xaf\x03\n\x1aCarePlanActivityStatusCode\x12N\n\
    \x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.CarePlanActivity\
    StatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google\
    .fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.\
    google.fhir.stu3.proto.ExtensionR\textension\"\x8b\x01\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0f\n\x0bNOT_STARTED\x10\x01\
    \x12\r\n\tSCHEDULED\x10\x02\x12\x0f\n\x0bIN_PROGRESS\x10\x03\x12\x0b\n\
    \x07ON_HOLD\x10\x04\x12\r\n\tCOMPLETED\x10\x05\x12\r\n\tCANCELLED\x10\
    \x06\x12\x0b\n\x07UNKNOWN\x10\x07:B\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\
    \xb2\x056http://hl7.org/fhir/ValueSet/care-plan-activity-status\"\xdb\
    \x02\n\x12CarePlanIntentCode\x12F\n\x05value\x18\x01\x20\x01(\x0e20.goog\
    le.fhir.stu3.proto.CarePlanIntentCode.ValueR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"Q\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08PR\
    OPOSAL\x10\x01\x12\x08\n\x04PLAN\x10\x02\x12\t\n\x05ORDER\x10\x03\x12\n\
    \n\x06OPTION\x10\x04:9\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05-http:\
    //hl7.org/fhir/ValueSet/care-plan-intent\"\x94\x03\n\x12CarePlanStatusCo\
    de\x12F\n\x05value\x18\x01\x20\x01(\x0e20.google.fhir.stu3.proto.CarePla\
    nStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.googl\
    e.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!\
    .google.fhir.stu3.proto.ExtensionR\textension\"\x89\x01\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05DRAFT\x10\x01\x12\n\n\
    \x06ACTIVE\x10\x02\x12\r\n\tSUSPENDED\x10\x03\x12\r\n\tCOMPLETED\x10\x04\
    \x12\x14\n\x10ENTERED_IN_ERROR\x10\x05\x12\r\n\tCANCELLED\x10\x06\x12\
    \x0b\n\x07UNKNOWN\x10\x07:9\x8a\xf9\x83\xb2\x05-http://hl7.org/fhir/Valu\
    eSet/care-plan-status\xc0\x9f\xe3\xb6\x05\x01\"\x92\x03\n\x14CareTeamCat\
    egoryCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.google.fhir.stu3.proto.\
    CareTeamCategoryCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\x81\x01\n\x05\
    Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05EVENT\x10\x01\
    \x12\r\n\tENCOUNTER\x10\x02\x12\x0b\n\x07EPISODE\x10\x03\x12\x10\n\x0cLO\
    NGITUDINAL\x10\x04\x12\r\n\tCONDITION\x10\x05\x12\x15\n\x11CLINICAL_RESE\
    ARCH\x10\x06:;\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05/http://hl7.or\
    g/fhir/ValueSet/care-team-category\"\xf9\x02\n\x12CareTeamStatusCode\x12\
    F\n\x05value\x18\x01\x20\x01(\x0e20.google.fhir.stu3.proto.CareTeamStatu\
    sCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir\
    .stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.googl\
    e.fhir.stu3.proto.ExtensionR\textension\"o\n\x05Value\x12\x19\n\x15INVAL\
    ID_UNINITIALIZED\x10\0\x12\x0c\n\x08PROPOSED\x10\x01\x12\n\n\x06ACTIVE\
    \x10\x02\x12\r\n\tSUSPENDED\x10\x03\x12\x0c\n\x08INACTIVE\x10\x04\x12\
    \x14\n\x10ENTERED_IN_ERROR\x10\x05:9\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\
    \xb2\x05-http://hl7.org/fhir/ValueSet/care-team-status\"\x9b\x03\n\x14Ch\
    argeItemStatusCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.google.fhir.st\
    u3.proto.ChargeItemStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\
    \x8b\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\
    \x07PLANNED\x10\x01\x12\x0c\n\x08BILLABLE\x10\x02\x12\x10\n\x0cNOT_BILLA\
    BLE\x10\x03\x12\x0b\n\x07ABORTED\x10\x04\x12\n\n\x06BILLED\x10\x05\x12\
    \x14\n\x10ENTERED_IN_ERROR\x10\x06\x12\x0b\n\x07UNKNOWN\x10\x07::\x8a\
    \xf9\x83\xb2\x05.http://hl7.org/fhir/ValueSet/chargeitem-status\xc0\x9f\
    \xe3\xb6\x05\x01\"\xdf\x02\n\x19ChoiceListOrientationCode\x12M\n\x05valu\
    e\x18\x01\x20\x01(\x0e27.google.fhir.stu3.proto.ChoiceListOrientationCod\
    e.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu\
    3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fh\
    ir.stu3.proto.ExtensionR\textension\"@\n\x05Value\x12\x19\n\x15INVALID_U\
    NINITIALIZED\x10\0\x12\x0e\n\nHORIZONTAL\x10\x01\x12\x0c\n\x08VERTICAL\
    \x10\x02:@\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/ValueSet/choice-list-\
    orientation\xc0\x9f\xe3\xb6\x05\x01\"\xc7\x02\n\x07UseCode\x12;\n\x05val\
    ue\x18\x01\x20\x01(\x0e2%.google.fhir.stu3.proto.UseCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"Z\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x0c\n\x08COMPLETE\x10\x01\x12\x0c\n\x08PROPOSED\x10\x02\x12\
    \x0f\n\x0bEXPLORATORY\x10\x03\x12\t\n\x05OTHER\x10\x04:2\xc0\x9f\xe3\xb6\
    \x05\x01\x8a\xf9\x83\xb2\x05&http://hl7.org/fhir/ValueSet/claim-use\"\
    \xe8\x02\n\x1bClassificationOrContextCode\x12O\n\x05value\x18\x01\x20\
    \x01(\x0e29.google.fhir.stu3.proto.ClassificationOrContextCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"C\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x12\n\x0eCLASSIFICATION\x10\x01\x12\x0b\n\x07CONTEXT\x10\
    \x02:B\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x056http://hl7.org/fhir/V\
    alueSet/classification-or-context\"\xfa\x02\n\x1cClinicalImpressionStatu\
    sCode\x12P\n\x05value\x18\x01\x20\x01(\x0e2:.google.fhir.stu3.proto.Clin\
    icalImpressionStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"R\n\x05Val\
    ue\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05DRAFT\x10\x01\x12\
    \r\n\tCOMPLETED\x10\x02\x12\x14\n\x10ENTERED_IN_ERROR\x10\x03:C\x8a\xf9\
    \x83\xb2\x057http://hl7.org/fhir/ValueSet/clinical-impression-status\xc0\
    \x9f\xe3\xb6\x05\x01\"\xfb\x02\n\x19CodeSystemContentModeCode\x12M\n\x05\
    value\x18\x01\x20\x01(\x0e27.google.fhir.stu3.proto.CodeSystemContentMod\
    eCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir\
    .stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.googl\
    e.fhir.stu3.proto.ExtensionR\textension\"\\\n\x05Value\x12\x19\n\x15INVA\
    LID_UNINITIALIZED\x10\0\x12\x0f\n\x0bNOT_PRESENT\x10\x01\x12\x0b\n\x07EX\
    AMPLE\x10\x02\x12\x0c\n\x08FRAGMENT\x10\x03\x12\x0c\n\x08COMPLETE\x10\
    \x04:@\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/ValueSet/codesystem-conte\
    nt-mode\xc0\x9f\xe3\xb6\x05\x01\"\x8c\x03\n\x1eCodeSystemHierarchyMeanin\
    gCode\x12R\n\x05value\x18\x01\x20\x01(\x0e2<.google.fhir.stu3.proto.Code\
    SystemHierarchyMeaningCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"^\n\x05Val\
    ue\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0e\n\nGROUPED_BY\x10\
    \x01\x12\x08\n\x04IS_A\x10\x02\x12\x0b\n\x07PART_OF\x10\x03\x12\x13\n\
    \x0fCLASSIFIED_WITH\x10\x04:E\x8a\xf9\x83\xb2\x059http://hl7.org/fhir/Va\
    lueSet/codesystem-hierarchy-meaning\xc0\x9f\xe3\xb6\x05\x01\"\xaf\x02\n\
    \x0eCommonTagsCode\x12B\n\x05value\x18\x01\x20\x01(\x0e2,.google.fhir.st\
    u3.proto.CommonTagsCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"2\n\x05Val\
    ue\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0e\n\nACTIONABLE\x10\
    \x01:4\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05(http://hl7.org/fhir/V\
    alueSet/common-tags\"\xfc\x02\n\x19CommunicationCategoryCode\x12M\n\x05v\
    alue\x18\x01\x20\x01(\x0e27.google.fhir.stu3.proto.CommunicationCategory\
    Code.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.\
    stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google\
    .fhir.stu3.proto.ExtensionR\textension\"^\n\x05Value\x12\x19\n\x15INVALI\
    D_UNINITIALIZED\x10\0\x12\t\n\x05ALERT\x10\x01\x12\x10\n\x0cNOTIFICATION\
    \x10\x02\x12\x0c\n\x08REMINDER\x10\x03\x12\x0f\n\x0bINSTRUCTION\x10\x04:\
    ?\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x053http://hl7.org/fhir/ValueS\
    et/communication-category\"\xd3\x03\n\x1eCommunicationNotDoneReasonCode\
    \x12R\n\x05value\x18\x01\x20\x01(\x0e2<.google.fhir.stu3.proto.Communica\
    tionNotDoneReasonCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\xa3\x01\n\x05\
    Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07UNKNOWN\x10\
    \x01\x12\x10\n\x0cSYSTEM_ERROR\x10\x02\x12\x18\n\x14INVALID_PHONE_NUMBER\
    \x10\x03\x12\x19\n\x15RECIPIENT_UNAVAILABLE\x10\x04\x12\x14\n\x10FAMILY_\
    OBJECTION\x10\x05\x12\x15\n\x11PATIENT_OBJECTION\x10\x06:F\x8a\xf9\x83\
    \xb2\x05:http://hl7.org/fhir/ValueSet/communication-not-done-reason\xc0\
    \x9f\xe3\xb6\x05\x01\"\xd3\x03\n\x13CompartmentTypeCode\x12G\n\x05value\
    \x18\x01\x20\x01(\x0e21.google.fhir.stu3.proto.CompartmentTypeCode.Value\
    R\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto\
    .StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3\
    .proto.ExtensionR\textension\"\xc6\x01\n\x05Value\x12\x19\n\x15INVALID_U\
    NINITIALIZED\x10\0\x12\x1a\n\x07PATIENT\x10\x01\x1a\r\xba\x96\xbb\xb2\
    \x05\x07Patient\x12\x1e\n\tENCOUNTER\x10\x02\x1a\x0f\xba\x96\xbb\xb2\x05\
    \tEncounter\x12&\n\rRELATEDPERSON\x10\x03\x1a\x13\xba\x96\xbb\xb2\x05\rR\
    elatedPerson\x12$\n\x0cPRACTITIONER\x10\x04\x1a\x12\xba\x96\xbb\xb2\x05\
    \x0cPractitioner\x12\x18\n\x06DEVICE\x10\x05\x1a\x0c\xba\x96\xbb\xb2\x05\
    \x06Device:9\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05-http://hl7.org/\
    fhir/ValueSet/compartment-type\"\x86\x03\n\x1bCompositeMeasureScoringCod\
    e\x12O\n\x05value\x18\x01\x20\x01(\x0e29.google.fhir.stu3.proto.Composit\
    eMeasureScoringCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"a\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0f\n\x0bOPPORTUNITY\x10\
    \x01\x12\x12\n\x0eALL_OR_NOTHING\x10\x02\x12\n\n\x06LINEAR\x10\x03\x12\
    \x0c\n\x08WEIGHTED\x10\x04:B\x8a\xf9\x83\xb2\x056http://hl7.org/fhir/Val\
    ueSet/composite-measure-scoring\xc0\x9f\xe3\xb6\x05\x01\"\x89\x03\n\x1eC\
    ompositionAttestationModeCode\x12R\n\x05value\x18\x01\x20\x01(\x0e2<.goo\
    gle.fhir.stu3.proto.CompositionAttestationModeCode.ValueR\x05value\x12.\
    \n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"[\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x0c\n\x08PERSONAL\x10\x01\x12\x10\n\x0cPROFESSIONAL\x10\x02\x12\t\n\
    \x05LEGAL\x10\x03\x12\x0c\n\x08OFFICIAL\x10\x04:E\x8a\xf9\x83\xb2\x059ht\
    tp://hl7.org/fhir/ValueSet/composition-attestation-mode\xc0\x9f\xe3\xb6\
    \x05\x01\"\xf3\x02\n\x15CompositionStatusCode\x12I\n\x05value\x18\x01\
    \x20\x01(\x0e23.google.fhir.stu3.proto.CompositionStatusCode.ValueR\x05v\
    alue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Strin\
    gR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto\
    .ExtensionR\textension\"a\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x0f\n\x0bPRELIMINARY\x10\x01\x12\t\n\x05FINAL\x10\x02\x12\x0b\
    \n\x07AMENDED\x10\x03\x12\x14\n\x10ENTERED_IN_ERROR\x10\x04:;\x8a\xf9\
    \x83\xb2\x05/http://hl7.org/fhir/ValueSet/composition-status\xc0\x9f\xe3\
    \xb6\x05\x01\"\xce\x03\n\x19ConceptMapEquivalenceCode\x12M\n\x05value\
    \x18\x01\x20\x01(\x0e27.google.fhir.stu3.proto.ConceptMapEquivalenceCode\
    .ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3\
    .proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhi\
    r.stu3.proto.ExtensionR\textension\"\xae\x01\n\x05Value\x12\x19\n\x15INV\
    ALID_UNINITIALIZED\x10\0\x12\r\n\tRELATEDTO\x10\x01\x12\x0e\n\nEQUIVALEN\
    T\x10\x02\x12\t\n\x05EQUAL\x10\x03\x12\t\n\x05WIDER\x10\x04\x12\x0c\n\
    \x08SUBSUMES\x10\x05\x12\x0c\n\x08NARROWER\x10\x06\x12\x0f\n\x0bSPECIALI\
    ZES\x10\x07\x12\x0b\n\x07INEXACT\x10\x08\x12\r\n\tUNMATCHED\x10\t\x12\
    \x0c\n\x08DISJOINT\x10\n:@\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/Value\
    Set/concept-map-equivalence\xc0\x9f\xe3\xb6\x05\x01\"\xf6\x02\n\x1fConce\
    ptMapGroupUnmappedModeCode\x12S\n\x05value\x18\x01\x20\x01(\x0e2=.google\
    .fhir.stu3.proto.ConceptMapGroupUnmappedModeCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"J\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x0c\n\x08PROVIDED\x10\x01\x12\t\n\x05FIXED\x10\x02\x12\r\n\tOTHER_M\
    AP\x10\x03:A\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x055http://hl7.org/\
    fhir/ValueSet/conceptmap-unmapped-mode\"\x96\x03\n\x10PropertyTypeCode\
    \x12D\n\x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3.proto.PropertyT\
    ypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fh\
    ir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goo\
    gle.fhir.stu3.proto.ExtensionR\textension\"\x8a\x01\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04CODE\x10\x01\x12\x18\n\x06C\
    ODING\x10\x02\x1a\x0c\xba\x96\xbb\xb2\x05\x06Coding\x12\n\n\x06STRING\
    \x10\x03\x12\x0b\n\x07INTEGER\x10\x04\x12\x0b\n\x07BOOLEAN\x10\x05\x12\
    \x1c\n\x08DATETIME\x10\x06\x1a\x0e\xba\x96\xbb\xb2\x05\x08dateTime:>\xc0\
    \x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x052http://hl7.org/fhir/ValueSet/co\
    ncept-property-type\"\xf4\x02\n\x1bConditionalDeleteStatusCode\x12O\n\
    \x05value\x18\x01\x20\x01(\x0e29.google.fhir.stu3.proto.ConditionalDelet\
    eStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.googl\
    e.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!\
    .google.fhir.stu3.proto.ExtensionR\textension\"O\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x11\n\rNOT_SUPPORTED\x10\x01\x12\n\n\
    \x06SINGLE\x10\x02\x12\x0c\n\x08MULTIPLE\x10\x03:B\x8a\xf9\x83\xb2\x056h\
    ttp://hl7.org/fhir/ValueSet/conditional-delete-status\xc0\x9f\xe3\xb6\
    \x05\x01\"\x89\x03\n\x19ConditionalReadStatusCode\x12M\n\x05value\x18\
    \x01\x20\x01(\x0e27.google.fhir.stu3.proto.ConditionalReadStatusCode.Val\
    ueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.pro\
    to.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.st\
    u3.proto.ExtensionR\textension\"j\n\x05Value\x12\x19\n\x15INVALID_UNINIT\
    IALIZED\x10\0\x12\x11\n\rNOT_SUPPORTED\x10\x01\x12\x12\n\x0eMODIFIED_SIN\
    CE\x10\x02\x12\r\n\tNOT_MATCH\x10\x03\x12\x10\n\x0cFULL_SUPPORT\x10\x04:\
    @\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/ValueSet/conditional-read-stat\
    us\xc0\x9f\xe3\xb6\x05\x01\"\xee\x02\n\x1aConditionCategoryCodesCode\x12\
    N\n\x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.ConditionCate\
    goryCodesCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goo\
    gle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b\
    2!.google.fhir.stu3.proto.ExtensionR\textension\"R\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x15\n\x11PROBLEM_LIST_ITEM\x10\x01\
    \x12\x17\n\x13ENCOUNTER_DIAGNOSIS\x10\x02:;\xc0\x9f\xe3\xb6\x05\x01\x8a\
    \xf9\x83\xb2\x05/http://hl7.org/fhir/ValueSet/condition-category\"\x91\
    \x03\n\x20ConditionClinicalStatusCodesCode\x12T\n\x05value\x18\x01\x20\
    \x01(\x0e2>.google.fhir.stu3.proto.ConditionClinicalStatusCodesCode.Valu\
    eR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.prot\
    o.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu\
    3.proto.ExtensionR\textension\"i\n\x05Value\x12\x19\n\x15INVALID_UNINITI\
    ALIZED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\x0e\n\nRECURRENCE\x10\x02\x12\
    \x0c\n\x08INACTIVE\x10\x03\x12\r\n\tREMISSION\x10\x04\x12\x0c\n\x08RESOL\
    VED\x10\x05:;\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05/http://hl7.org\
    /fhir/ValueSet/condition-clinical\"\xd3\x02\n\x12ConditionStateCode\x12F\
    \n\x05value\x18\x01\x20\x01(\x0e20.google.fhir.stu3.proto.ConditionState\
    Code.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.\
    stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google\
    .fhir.stu3.proto.ExtensionR\textension\"J\n\x05Value\x12\x19\n\x15INVALI\
    D_UNINITIALIZED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\x0c\n\x08INACTIVE\
    \x10\x02\x12\x0c\n\x08RESOLVED\x10\x03:8\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\
    \x83\xb2\x05,http://hl7.org/fhir/ValueSet/condition-state\"\xad\x03\n\
    \x1fConditionVerificationStatusCode\x12S\n\x05value\x18\x01\x20\x01(\x0e\
    2=.google.fhir.stu3.proto.ConditionVerificationStatusCode.ValueR\x05valu\
    e\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"\x84\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x0f\n\x0bPROVISIONAL\x10\x01\x12\x10\n\x0cDIFFERENTIAL\
    \x10\x02\x12\r\n\tCONFIRMED\x10\x03\x12\x0b\n\x07REFUTED\x10\x04\x12\x14\
    \n\x10ENTERED_IN_ERROR\x10\x05\x12\x0b\n\x07UNKNOWN\x10\x06:=\x8a\xf9\
    \x83\xb2\x051http://hl7.org/fhir/ValueSet/condition-ver-status\xc0\x9f\
    \xe3\xb6\x05\x01\"\xac\x03\n\x1aConformanceExpectationCode\x12N\n\x05val\
    ue\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.ConformanceExpectationC\
    ode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.s\
    tu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.\
    fhir.stu3.proto.ExtensionR\textension\"\x8a\x01\n\x05Value\x12\x19\n\x15\
    INVALID_UNINITIALIZED\x10\0\x12\x16\n\x05SHALL\x10\x01\x1a\x0b\xba\x96\
    \xbb\xb2\x05\x05SHALL\x12\x18\n\x06SHOULD\x10\x02\x1a\x0c\xba\x96\xbb\
    \xb2\x05\x06SHOULD\x12\x12\n\x03MAY\x10\x03\x1a\t\xba\x96\xbb\xb2\x05\
    \x03MAY\x12\x20\n\nSHOULD_NOT\x10\x04\x1a\x10\xba\x96\xbb\xb2\x05\nSHOUL\
    D-NOT:@\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/ValueSet/conformance-exp\
    ectation\xc0\x9f\xe3\xb6\x05\x01\"\xf3\x02\n\x16ConsentDataMeaningCode\
    \x12J\n\x05value\x18\x01\x20\x01(\x0e24.google.fhir.stu3.proto.ConsentDa\
    taMeaningCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goo\
    gle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b\
    2!.google.fhir.stu3.proto.ExtensionR\textension\"]\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08INSTANCE\x10\x01\x12\x0b\n\
    \x07RELATED\x10\x02\x12\x0e\n\nDEPENDENTS\x10\x03\x12\x0e\n\nAUTHOREDBY\
    \x10\x04:=\x8a\xf9\x83\xb2\x051http://hl7.org/fhir/ValueSet/consent-data\
    -meaning\xc0\x9f\xe3\xb6\x05\x01\"\xcb\x02\n\x15ConsentExceptTypeCode\
    \x12I\n\x05value\x18\x01\x20\x01(\x0e23.google.fhir.stu3.proto.ConsentEx\
    ceptTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goog\
    le.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2\
    !.google.fhir.stu3.proto.ExtensionR\textension\"8\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04DENY\x10\x01\x12\n\n\x06PER\
    MIT\x10\x02:<\x8a\xf9\x83\xb2\x050http://hl7.org/fhir/ValueSet/consent-e\
    xcept-type\xc0\x9f\xe3\xb6\x05\x01\"\x82\x03\n\x10ConsentStateCode\x12D\
    \n\x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3.proto.ConsentStateCo\
    de.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.st\
    u3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.f\
    hir.stu3.proto.ExtensionR\textension\"y\n\x05Value\x12\x19\n\x15INVALID_\
    UNINITIALIZED\x10\0\x12\t\n\x05DRAFT\x10\x01\x12\x0c\n\x08PROPOSED\x10\
    \x02\x12\n\n\x06ACTIVE\x10\x03\x12\x0c\n\x08REJECTED\x10\x04\x12\x0c\n\
    \x08INACTIVE\x10\x05\x12\x14\n\x10ENTERED_IN_ERROR\x10\x06:<\x8a\xf9\x83\
    \xb2\x050http://hl7.org/fhir/ValueSet/consent-state-codes\xc0\x9f\xe3\
    \xb6\x05\x01\"\xbf\x03\n\x15ContactEntityTypeCode\x12I\n\x05value\x18\
    \x01\x20\x01(\x0e23.google.fhir.stu3.proto.ContactEntityTypeCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"\xac\x01\n\x05Value\x12\x19\n\x15INVALID_UN\
    INITIALIZED\x10\0\x12\x14\n\x04BILL\x10\x01\x1a\n\xba\x96\xbb\xb2\x05\
    \x04BILL\x12\x16\n\x05ADMIN\x10\x02\x1a\x0b\xba\x96\xbb\xb2\x05\x05ADMIN\
    \x12\x10\n\x02HR\x10\x03\x1a\x08\xba\x96\xbb\xb2\x05\x02HR\x12\x16\n\x05\
    PAYOR\x10\x04\x1a\x0b\xba\x96\xbb\xb2\x05\x05PAYOR\x12\x18\n\x06PATINF\
    \x10\x05\x1a\x0c\xba\x96\xbb\xb2\x05\x06PATINF\x12\x16\n\x05PRESS\x10\
    \x06\x1a\x0b\xba\x96\xbb\xb2\x05\x05PRESS:;\x8a\xf9\x83\xb2\x05/http://h\
    l7.org/fhir/ValueSet/contactentity-type\xc0\x9f\xe3\xb6\x05\x01\"\xc8\
    \x02\n\x0fContentTypeCode\x12C\n\x05value\x18\x01\x20\x01(\x0e2-.google.\
    fhir.stu3.proto.ContentTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"H\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x07\n\x03XML\
    \x10\x01\x12\x08\n\x04JSON\x10\x02\x12\x07\n\x03TTL\x10\x03\x12\x08\n\
    \x04NONE\x10\x04:5\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05)http://hl\
    7.org/fhir/ValueSet/content-type\"\x97\x04\n\x1aContractResourceStatusCo\
    de\x12N\n\x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.Contrac\
    tResourceStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\xfd\x01\n\x05\
    Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07AMENDED\x10\
    \x01\x12\x0c\n\x08APPENDED\x10\x02\x12\r\n\tCANCELLED\x10\x03\x12\x0c\n\
    \x08DISPUTED\x10\x04\x12\x14\n\x10ENTERED_IN_ERROR\x10\x05\x12\x0e\n\nEX\
    ECUTABLE\x10\x06\x12\x0c\n\x08EXECUTED\x10\x07\x12\x0e\n\nNEGOTIABLE\x10\
    \x08\x12\x0b\n\x07OFFERED\x10\t\x12\n\n\x06POLICY\x10\n\x12\x0c\n\x08REJ\
    ECTED\x10\x0b\x12\x0b\n\x07RENEWED\x10\x0c\x12\x0b\n\x07REVOKED\x10\r\
    \x12\x0c\n\x08RESOLVED\x10\x0e\x12\x0e\n\nTERMINATED\x10\x0f:8\xc0\x9f\
    \xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05,http://hl7.org/fhir/ValueSet/contra\
    ct-status\"\xe2\x02\n\x13ContributorTypeCode\x12G\n\x05value\x18\x01\x20\
    \x01(\x0e21.google.fhir.stu3.proto.ContributorTypeCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"V\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\n\n\x06AUTHOR\x10\x01\x12\n\n\x06EDITOR\x10\x02\x12\x0c\n\x08\
    REVIEWER\x10\x03\x12\x0c\n\x08ENDORSER\x10\x04:9\xc0\x9f\xe3\xb6\x05\x01\
    \x8a\xf9\x83\xb2\x05-http://hl7.org/fhir/ValueSet/contributor-type\"\xca\
    \x02\n\x13CopyNumberEventCode\x12G\n\x05value\x18\x01\x20\x01(\x0e21.goo\
    gle.fhir.stu3.proto.CopyNumberEventCode.ValueR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"=\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x07\n\x03AM\
    P\x10\x01\x12\x07\n\x03DEL\x10\x02\x12\x07\n\x03LOF\x10\x03::\x8a\xf9\
    \x83\xb2\x05.http://hl7.org/fhir/ValueSet/copy-number-event\xc0\x9f\xe3\
    \xb6\x05\x01\"\xc8\x03\n\x14DataAbsentReasonCode\x12H\n\x05value\x18\x01\
    \x20\x01(\x0e22.google.fhir.stu3.proto.DataAbsentReasonCode.ValueR\x05va\
    lue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.String\
    R\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.\
    ExtensionR\textension\"\xb7\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIA\
    LIZED\x10\0\x12\x0b\n\x07UNKNOWN\x10\x01\x12\t\n\x05ASKED\x10\x02\x12\
    \x08\n\x04TEMP\x10\x03\x12\r\n\tNOT_ASKED\x10\x04\x12\n\n\x06MASKED\x10\
    \x05\x12\x0f\n\x0bUNSUPPORTED\x10\x06\x12\n\n\x06ASTEXT\x10\x07\x12\t\n\
    \x05ERROR\x10\x08\x12\x1b\n\x0cNOT_A_NUMBER\x10\t\x1a\t\xba\x96\xbb\xb2\
    \x05\x03NaN\x12\x11\n\rNOT_PERFORMED\x10\n:;\x8a\xf9\x83\xb2\x05/http://\
    hl7.org/fhir/ValueSet/data-absent-reason\xc0\x9f\xe3\xb6\x05\x01\"\xa4\
    \x03\n\x19DataElementStringencyCode\x12M\n\x05value\x18\x01\x20\x01(\x0e\
    27.google.fhir.stu3.proto.DataElementStringencyCode.ValueR\x05value\x12.\
    \n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\x85\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x0e\n\nCOMPARABLE\x10\x01\x12\x13\n\x0fFULLY_SPECIFIED\x10\
    \x02\x12\x0e\n\nEQUIVALENT\x10\x03\x12\x0f\n\x0bCONVERTABLE\x10\x04\x12\
    \r\n\tSCALEABLE\x10\x05\x12\x0c\n\x08FLEXIBLE\x10\x06:?\xc0\x9f\xe3\xb6\
    \x05\x01\x8a\xf9\x83\xb2\x053http://hl7.org/fhir/ValueSet/dataelement-st\
    ringency\"\xa1\x03\n\x0fTriggerTypeCode\x12C\n\x05value\x18\x01\x20\x01(\
    \x0e2-.google.fhir.stu3.proto.TriggerTypeCode.ValueR\x05value\x12.\n\x02\
    id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\"\xa0\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x0f\n\x0bNAMED_EVENT\x10\x01\x12\x0c\n\x08PERIODIC\x10\x02\x12\x0e\
    \n\nDATA_ADDED\x10\x03\x12\x11\n\rDATA_MODIFIED\x10\x04\x12\x10\n\x0cDAT\
    A_REMOVED\x10\x05\x12\x11\n\rDATA_ACCESSED\x10\x06\x12\x15\n\x11DATA_ACC\
    ESS_ENDED\x10\x07:5\x8a\xf9\x83\xb2\x05)http://hl7.org/fhir/ValueSet/tri\
    gger-type\xc0\x9f\xe3\xb6\x05\x01\"\x87\x0e\n\x0cDataTypeCode\x12@\n\x05\
    value\x18\x01\x20\x01(\x0e2*.google.fhir.stu3.proto.DataTypeCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"\x8e\x0c\n\x05Value\x12\x19\n\x15INVALID_UN\
    INITIALIZED\x10\0\x12\x1a\n\x07ADDRESS\x10\x01\x1a\r\xba\x96\xbb\xb2\x05\
    \x07Address\x12\x12\n\x03AGE\x10\x02\x1a\t\xba\x96\xbb\xb2\x05\x03Age\
    \x12\x20\n\nANNOTATION\x10\x03\x1a\x10\xba\x96\xbb\xb2\x05\nAnnotation\
    \x12\x20\n\nATTACHMENT\x10\x04\x1a\x10\xba\x96\xbb\xb2\x05\nAttachment\
    \x12+\n\x10BACKBONE_ELEMENT\x10\x05\x1a\x15\xba\x96\xbb\xb2\x05\x0fBackb\
    oneElement\x12+\n\x10CODEABLE_CONCEPT\x10\x06\x1a\x15\xba\x96\xbb\xb2\
    \x05\x0fCodeableConcept\x12\x18\n\x06CODING\x10\x07\x1a\x0c\xba\x96\xbb\
    \xb2\x05\x06Coding\x12'\n\x0eCONTACT_DETAIL\x10\x08\x1a\x13\xba\x96\xbb\
    \xb2\x05\rContactDetail\x12%\n\rCONTACT_POINT\x10\t\x1a\x12\xba\x96\xbb\
    \xb2\x05\x0cContactPoint\x12\"\n\x0bCONTRIBUTOR\x10\n\x1a\x11\xba\x96\
    \xbb\xb2\x05\x0bContributor\x12\x16\n\x05COUNT\x10\x0b\x1a\x0b\xba\x96\
    \xbb\xb2\x05\x05Count\x12+\n\x10DATA_REQUIREMENT\x10\x0c\x1a\x15\xba\x96\
    \xbb\xb2\x05\x0fDataRequirement\x12\x1c\n\x08DISTANCE\x10\r\x1a\x0e\xba\
    \x96\xbb\xb2\x05\x08Distance\x12\x18\n\x06DOSAGE\x10\x0e\x1a\x0c\xba\x96\
    \xbb\xb2\x05\x06Dosage\x12\x1c\n\x08DURATION\x10\x0f\x1a\x0e\xba\x96\xbb\
    \xb2\x05\x08Duration\x12\x1a\n\x07ELEMENT\x10\x10\x1a\r\xba\x96\xbb\xb2\
    \x05\x07Element\x12/\n\x12ELEMENT_DEFINITION\x10\x11\x1a\x17\xba\x96\xbb\
    \xb2\x05\x11ElementDefinition\x12\x1e\n\tEXTENSION\x10\x12\x1a\x0f\xba\
    \x96\xbb\xb2\x05\tExtension\x12\x1f\n\nHUMAN_NAME\x10\x13\x1a\x0f\xba\
    \x96\xbb\xb2\x05\tHumanName\x12\x20\n\nIDENTIFIER\x10\x14\x1a\x10\xba\
    \x96\xbb\xb2\x05\nIdentifier\x12\x14\n\x04META\x10\x15\x1a\n\xba\x96\xbb\
    \xb2\x05\x04Meta\x12\x16\n\x05MONEY\x10\x16\x1a\x0b\xba\x96\xbb\xb2\x05\
    \x05Money\x12\x1e\n\tNARRATIVE\x10\x17\x1a\x0f\xba\x96\xbb\xb2\x05\tNarr\
    ative\x123\n\x14PARAMETER_DEFINITION\x10\x18\x1a\x19\xba\x96\xbb\xb2\x05\
    \x13ParameterDefinition\x12\x18\n\x06PERIOD\x10\x19\x1a\x0c\xba\x96\xbb\
    \xb2\x05\x06Period\x12\x1c\n\x08QUANTITY\x10\x1a\x1a\x0e\xba\x96\xbb\xb2\
    \x05\x08Quantity\x12\x16\n\x05RANGE\x10\x1b\x1a\x0b\xba\x96\xbb\xb2\x05\
    \x05Range\x12\x16\n\x05RATIO\x10\x1c\x1a\x0b\xba\x96\xbb\xb2\x05\x05Rati\
    o\x12\x1e\n\tREFERENCE\x10\x1d\x1a\x0f\xba\x96\xbb\xb2\x05\tReference\
    \x12+\n\x10RELATED_ARTIFACT\x10\x1e\x1a\x15\xba\x96\xbb\xb2\x05\x0fRelat\
    edArtifact\x12#\n\x0cSAMPLED_DATA\x10\x1f\x1a\x11\xba\x96\xbb\xb2\x05\
    \x0bSampledData\x12\x1e\n\tSIGNATURE\x10\x20\x1a\x0f\xba\x96\xbb\xb2\x05\
    \tSignature\x12)\n\x0fSIMPLE_QUANTITY\x10!\x1a\x14\xba\x96\xbb\xb2\x05\
    \x0eSimpleQuantity\x12\x18\n\x06TIMING\x10\"\x1a\x0c\xba\x96\xbb\xb2\x05\
    \x06Timing\x12/\n\x12TRIGGER_DEFINITION\x10#\x1a\x17\xba\x96\xbb\xb2\x05\
    \x11TriggerDefinition\x12%\n\rUSAGE_CONTEXT\x10$\x1a\x12\xba\x96\xbb\xb2\
    \x05\x0cUsageContext\x12%\n\rBASE64_BINARY\x10%\x1a\x12\xba\x96\xbb\xb2\
    \x05\x0cbase64Binary\x12\x0b\n\x07BOOLEAN\x10&\x12\x08\n\x04CODE\x10'\
    \x12\x08\n\x04DATE\x10(\x12\x1d\n\tDATE_TIME\x10)\x1a\x0e\xba\x96\xbb\
    \xb2\x05\x08dateTime\x12\x0b\n\x07DECIMAL\x10*\x12\x06\n\x02ID\x10+\x12\
    \x0b\n\x07INSTANT\x10,\x12\x0b\n\x07INTEGER\x10-\x12\x0c\n\x08MARKDOWN\
    \x10.\x12\x07\n\x03OID\x10/\x12#\n\x0cPOSITIVE_INT\x100\x1a\x11\xba\x96\
    \xbb\xb2\x05\x0bpositiveInt\x12\n\n\x06STRING\x101\x12\x08\n\x04TIME\x10\
    2\x12#\n\x0cUNSIGNED_INT\x103\x1a\x11\xba\x96\xbb\xb2\x05\x0bunsignedInt\
    \x12\x07\n\x03URI\x104\x12\x08\n\x04UUID\x105\x12\t\n\x05XHTML\x106:3\
    \xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05'http://hl7.org/fhir/ValueSe\
    t/data-types\"\xf13\n\x10FHIRAllTypesCode\x12D\n\x05value\x18\x01\x20\
    \x01(\x0e2..google.fhir.stu3.proto.FHIRAllTypesCode.ValueR\x05value\x12.\
    \n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\xf11\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\
    \0\x12\x1a\n\x07ADDRESS\x10\x01\x1a\r\xba\x96\xbb\xb2\x05\x07Address\x12\
    \x12\n\x03AGE\x10\x02\x1a\t\xba\x96\xbb\xb2\x05\x03Age\x12\x20\n\nANNOTA\
    TION\x10\x03\x1a\x10\xba\x96\xbb\xb2\x05\nAnnotation\x12\x20\n\nATTACHME\
    NT\x10\x04\x1a\x10\xba\x96\xbb\xb2\x05\nAttachment\x12+\n\x10BACKBONE_EL\
    EMENT\x10\x05\x1a\x15\xba\x96\xbb\xb2\x05\x0fBackboneElement\x12+\n\x10C\
    ODEABLE_CONCEPT\x10\x06\x1a\x15\xba\x96\xbb\xb2\x05\x0fCodeableConcept\
    \x12\x18\n\x06CODING\x10\x07\x1a\x0c\xba\x96\xbb\xb2\x05\x06Coding\x12'\
    \n\x0eCONTACT_DETAIL\x10\x08\x1a\x13\xba\x96\xbb\xb2\x05\rContactDetail\
    \x12%\n\rCONTACT_POINT\x10\t\x1a\x12\xba\x96\xbb\xb2\x05\x0cContactPoint\
    \x12\"\n\x0bCONTRIBUTOR\x10\n\x1a\x11\xba\x96\xbb\xb2\x05\x0bContributor\
    \x12\x16\n\x05COUNT\x10\x0b\x1a\x0b\xba\x96\xbb\xb2\x05\x05Count\x12+\n\
    \x10DATA_REQUIREMENT\x10\x0c\x1a\x15\xba\x96\xbb\xb2\x05\x0fDataRequirem\
    ent\x12\x1c\n\x08DISTANCE\x10\r\x1a\x0e\xba\x96\xbb\xb2\x05\x08Distance\
    \x12\x18\n\x06DOSAGE\x10\x0e\x1a\x0c\xba\x96\xbb\xb2\x05\x06Dosage\x12\
    \x1c\n\x08DURATION\x10\x0f\x1a\x0e\xba\x96\xbb\xb2\x05\x08Duration\x12\
    \x1a\n\x07ELEMENT\x10\x10\x1a\r\xba\x96\xbb\xb2\x05\x07Element\x12/\n\
    \x12ELEMENT_DEFINITION\x10\x11\x1a\x17\xba\x96\xbb\xb2\x05\x11ElementDef\
    inition\x12\x1e\n\tEXTENSION\x10\x12\x1a\x0f\xba\x96\xbb\xb2\x05\tExtens\
    ion\x12\x1f\n\nHUMAN_NAME\x10\x13\x1a\x0f\xba\x96\xbb\xb2\x05\tHumanName\
    \x12\x20\n\nIDENTIFIER\x10\x14\x1a\x10\xba\x96\xbb\xb2\x05\nIdentifier\
    \x12\x14\n\x04META\x10\x15\x1a\n\xba\x96\xbb\xb2\x05\x04Meta\x12\x16\n\
    \x05MONEY\x10\x16\x1a\x0b\xba\x96\xbb\xb2\x05\x05Money\x12\x1e\n\tNARRAT\
    IVE\x10\x17\x1a\x0f\xba\x96\xbb\xb2\x05\tNarrative\x123\n\x14PARAMETER_D\
    EFINITION\x10\x18\x1a\x19\xba\x96\xbb\xb2\x05\x13ParameterDefinition\x12\
    \x18\n\x06PERIOD\x10\x19\x1a\x0c\xba\x96\xbb\xb2\x05\x06Period\x12\x1c\n\
    \x08QUANTITY\x10\x1a\x1a\x0e\xba\x96\xbb\xb2\x05\x08Quantity\x12\x16\n\
    \x05RANGE\x10\x1b\x1a\x0b\xba\x96\xbb\xb2\x05\x05Range\x12\x16\n\x05RATI\
    O\x10\x1c\x1a\x0b\xba\x96\xbb\xb2\x05\x05Ratio\x12\x1e\n\tREFERENCE\x10\
    \x1d\x1a\x0f\xba\x96\xbb\xb2\x05\tReference\x12+\n\x10RELATED_ARTIFACT\
    \x10\x1e\x1a\x15\xba\x96\xbb\xb2\x05\x0fRelatedArtifact\x12#\n\x0cSAMPLE\
    D_DATA\x10\x1f\x1a\x11\xba\x96\xbb\xb2\x05\x0bSampledData\x12\x1e\n\tSIG\
    NATURE\x10\x20\x1a\x0f\xba\x96\xbb\xb2\x05\tSignature\x12)\n\x0fSIMPLE_Q\
    UANTITY\x10!\x1a\x14\xba\x96\xbb\xb2\x05\x0eSimpleQuantity\x12\x18\n\x06\
    TIMING\x10\"\x1a\x0c\xba\x96\xbb\xb2\x05\x06Timing\x12/\n\x12TRIGGER_DEF\
    INITION\x10#\x1a\x17\xba\x96\xbb\xb2\x05\x11TriggerDefinition\x12%\n\rUS\
    AGE_CONTEXT\x10$\x1a\x12\xba\x96\xbb\xb2\x05\x0cUsageContext\x12%\n\rBAS\
    E64_BINARY\x10%\x1a\x12\xba\x96\xbb\xb2\x05\x0cbase64Binary\x12\x0b\n\
    \x07BOOLEAN\x10&\x12\x08\n\x04CODE\x10'\x12\x08\n\x04DATE\x10(\x12\x1d\n\
    \tDATE_TIME\x10)\x1a\x0e\xba\x96\xbb\xb2\x05\x08dateTime\x12\x0b\n\x07DE\
    CIMAL\x10*\x12\x06\n\x02ID\x10+\x12\x0b\n\x07INSTANT\x10,\x12\x0b\n\x07I\
    NTEGER\x10-\x12\x0c\n\x08MARKDOWN\x10.\x12\x07\n\x03OID\x10/\x12#\n\x0cP\
    OSITIVE_INT\x100\x1a\x11\xba\x96\xbb\xb2\x05\x0bpositiveInt\x12\n\n\x06S\
    TRING\x101\x12\x08\n\x04TIME\x102\x12#\n\x0cUNSIGNED_INT\x103\x1a\x11\
    \xba\x96\xbb\xb2\x05\x0bunsignedInt\x12\x07\n\x03URI\x104\x12\x08\n\x04U\
    UID\x105\x12\t\n\x05XHTML\x106\x12\x1a\n\x07ACCOUNT\x107\x1a\r\xba\x96\
    \xbb\xb2\x05\x07Account\x121\n\x13ACTIVITY_DEFINITION\x108\x1a\x18\xba\
    \x96\xbb\xb2\x05\x12ActivityDefinition\x12%\n\rADVERSE_EVENT\x109\x1a\
    \x12\xba\x96\xbb\xb2\x05\x0cAdverseEvent\x121\n\x13ALLERGY_INTOLERANCE\
    \x10:\x1a\x18\xba\x96\xbb\xb2\x05\x12AllergyIntolerance\x12\"\n\x0bAPPOI\
    NTMENT\x10;\x1a\x11\xba\x96\xbb\xb2\x05\x0bAppointment\x123\n\x14APPOINT\
    MENT_RESPONSE\x10<\x1a\x19\xba\x96\xbb\xb2\x05\x13AppointmentResponse\
    \x12!\n\x0bAUDIT_EVENT\x10=\x1a\x10\xba\x96\xbb\xb2\x05\nAuditEvent\x12\
    \x16\n\x05BASIC\x10>\x1a\x0b\xba\x96\xbb\xb2\x05\x05Basic\x12\x18\n\x06B\
    INARY\x10?\x1a\x0c\xba\x96\xbb\xb2\x05\x06Binary\x12\x1d\n\tBODY_SITE\
    \x10@\x1a\x0e\xba\x96\xbb\xb2\x05\x08BodySite\x12\x18\n\x06BUNDLE\x10A\
    \x1a\x0c\xba\x96\xbb\xb2\x05\x06Bundle\x123\n\x14CAPABILITY_STATEMENT\
    \x10B\x1a\x19\xba\x96\xbb\xb2\x05\x13CapabilityStatement\x12\x1d\n\tCARE\
    _PLAN\x10C\x1a\x0e\xba\x96\xbb\xb2\x05\x08CarePlan\x12\x1d\n\tCARE_TEAM\
    \x10D\x1a\x0e\xba\x96\xbb\xb2\x05\x08CareTeam\x12!\n\x0bCHARGE_ITEM\x10E\
    \x1a\x10\xba\x96\xbb\xb2\x05\nChargeItem\x12\x16\n\x05CLAIM\x10F\x1a\x0b\
    \xba\x96\xbb\xb2\x05\x05Claim\x12'\n\x0eCLAIM_RESPONSE\x10G\x1a\x13\xba\
    \x96\xbb\xb2\x05\rClaimResponse\x121\n\x13CLINICAL_IMPRESSION\x10H\x1a\
    \x18\xba\x96\xbb\xb2\x05\x12ClinicalImpression\x12!\n\x0bCODE_SYSTEM\x10\
    I\x1a\x10\xba\x96\xbb\xb2\x05\nCodeSystem\x12&\n\rCOMMUNICATION\x10J\x1a\
    \x13\xba\x96\xbb\xb2\x05\rCommunication\x125\n\x15COMMUNICATION_REQUEST\
    \x10K\x1a\x1a\xba\x96\xbb\xb2\x05\x14CommunicationRequest\x127\n\x16COMP\
    ARTMENT_DEFINITION\x10L\x1a\x1b\xba\x96\xbb\xb2\x05\x15CompartmentDefini\
    tion\x12\"\n\x0bCOMPOSITION\x10M\x1a\x11\xba\x96\xbb\xb2\x05\x0bComposit\
    ion\x12!\n\x0bCONCEPT_MAP\x10N\x1a\x10\xba\x96\xbb\xb2\x05\nConceptMap\
    \x12\x1e\n\tCONDITION\x10O\x1a\x0f\xba\x96\xbb\xb2\x05\tCondition\x12\
    \x1a\n\x07CONSENT\x10P\x1a\r\xba\x96\xbb\xb2\x05\x07Consent\x12\x1c\n\
    \x08CONTRACT\x10Q\x1a\x0e\xba\x96\xbb\xb2\x05\x08Contract\x12\x1c\n\x08C\
    OVERAGE\x10R\x1a\x0e\xba\x96\xbb\xb2\x05\x08Coverage\x12#\n\x0cDATA_ELEM\
    ENT\x10S\x1a\x11\xba\x96\xbb\xb2\x05\x0bDataElement\x12'\n\x0eDETECTED_I\
    SSUE\x10T\x1a\x13\xba\x96\xbb\xb2\x05\rDetectedIssue\x12\x18\n\x06DEVICE\
    \x10U\x1a\x0c\xba\x96\xbb\xb2\x05\x06Device\x12+\n\x10DEVICE_COMPONENT\
    \x10V\x1a\x15\xba\x96\xbb\xb2\x05\x0fDeviceComponent\x12%\n\rDEVICE_METR\
    IC\x10W\x1a\x12\xba\x96\xbb\xb2\x05\x0cDeviceMetric\x12'\n\x0eDEVICE_REQ\
    UEST\x10X\x1a\x13\xba\x96\xbb\xb2\x05\rDeviceRequest\x122\n\x14DEVICE_US\
    E_STATEMENT\x10Y\x1a\x18\xba\x96\xbb\xb2\x05\x12DeviceUseStatement\x12-\
    \n\x11DIAGNOSTIC_REPORT\x10Z\x1a\x16\xba\x96\xbb\xb2\x05\x10DiagnosticRe\
    port\x12-\n\x11DOCUMENT_MANIFEST\x10[\x1a\x16\xba\x96\xbb\xb2\x05\x10Doc\
    umentManifest\x12/\n\x12DOCUMENT_REFERENCE\x10\\\x1a\x17\xba\x96\xbb\xb2\
    \x05\x11DocumentReference\x12)\n\x0fDOMAIN_RESOURCE\x10]\x1a\x14\xba\x96\
    \xbb\xb2\x05\x0eDomainResource\x121\n\x13ELIGIBILITY_REQUEST\x10^\x1a\
    \x18\xba\x96\xbb\xb2\x05\x12EligibilityRequest\x123\n\x14ELIGIBILITY_RES\
    PONSE\x10_\x1a\x19\xba\x96\xbb\xb2\x05\x13EligibilityResponse\x12\x1e\n\
    \tENCOUNTER\x10`\x1a\x0f\xba\x96\xbb\xb2\x05\tEncounter\x12\x1c\n\x08END\
    POINT\x10a\x1a\x0e\xba\x96\xbb\xb2\x05\x08Endpoint\x12/\n\x12ENROLLMENT_\
    REQUEST\x10b\x1a\x17\xba\x96\xbb\xb2\x05\x11EnrollmentRequest\x121\n\x13\
    ENROLLMENT_RESPONSE\x10c\x1a\x18\xba\x96\xbb\xb2\x05\x12EnrollmentRespon\
    se\x12(\n\x0fEPISODE_OF_CARE\x10d\x1a\x13\xba\x96\xbb\xb2\x05\rEpisodeOf\
    Care\x12-\n\x11EXPANSION_PROFILE\x10e\x1a\x16\xba\x96\xbb\xb2\x05\x10Exp\
    ansionProfile\x126\n\x16EXPLANATION_OF_BENEFIT\x10f\x1a\x1a\xba\x96\xbb\
    \xb2\x05\x14ExplanationOfBenefit\x124\n\x15FAMILY_MEMBER_HISTORY\x10g\
    \x1a\x19\xba\x96\xbb\xb2\x05\x13FamilyMemberHistory\x12\x14\n\x04FLAG\
    \x10h\x1a\n\xba\x96\xbb\xb2\x05\x04Flag\x12\x14\n\x04GOAL\x10i\x1a\n\xba\
    \x96\xbb\xb2\x05\x04Goal\x12+\n\x10GRAPH_DEFINITION\x10j\x1a\x15\xba\x96\
    \xbb\xb2\x05\x0fGraphDefinition\x12\x16\n\x05GROUP\x10k\x1a\x0b\xba\x96\
    \xbb\xb2\x05\x05Group\x12-\n\x11GUIDANCE_RESPONSE\x10l\x1a\x16\xba\x96\
    \xbb\xb2\x05\x10GuidanceResponse\x12/\n\x12HEALTHCARE_SERVICE\x10m\x1a\
    \x17\xba\x96\xbb\xb2\x05\x11HealthcareService\x12+\n\x10IMAGING_MANIFEST\
    \x10n\x1a\x15\xba\x96\xbb\xb2\x05\x0fImagingManifest\x12%\n\rIMAGING_STU\
    DY\x10o\x1a\x12\xba\x96\xbb\xb2\x05\x0cImagingStudy\x12$\n\x0cIMMUNIZATI\
    ON\x10p\x1a\x12\xba\x96\xbb\xb2\x05\x0cImmunization\x12A\n\x1bIMMUNIZATI\
    ON_RECOMMENDATION\x10q\x1a\x20\xba\x96\xbb\xb2\x05\x1aImmunizationRecomm\
    endation\x123\n\x14IMPLEMENTATION_GUIDE\x10r\x1a\x19\xba\x96\xbb\xb2\x05\
    \x13ImplementationGuide\x12\x1a\n\x07LIBRARY\x10s\x1a\r\xba\x96\xbb\xb2\
    \x05\x07Library\x12\x1a\n\x07LINKAGE\x10t\x1a\r\xba\x96\xbb\xb2\x05\x07L\
    inkage\x12\x14\n\x04LIST\x10u\x1a\n\xba\x96\xbb\xb2\x05\x04List\x12\x1c\
    \n\x08LOCATION\x10v\x1a\x0e\xba\x96\xbb\xb2\x05\x08Location\x12\x1a\n\
    \x07MEASURE\x10w\x1a\r\xba\x96\xbb\xb2\x05\x07Measure\x12'\n\x0eMEASURE_\
    REPORT\x10x\x1a\x13\xba\x96\xbb\xb2\x05\rMeasureReport\x12\x16\n\x05MEDI\
    A\x10y\x1a\x0b\xba\x96\xbb\xb2\x05\x05Media\x12\x20\n\nMEDICATION\x10z\
    \x1a\x10\xba\x96\xbb\xb2\x05\nMedication\x12=\n\x19MEDICATION_ADMINISTRA\
    TION\x10{\x1a\x1e\xba\x96\xbb\xb2\x05\x18MedicationAdministration\x121\n\
    \x13MEDICATION_DISPENSE\x10|\x1a\x18\xba\x96\xbb\xb2\x05\x12MedicationDi\
    spense\x12/\n\x12MEDICATION_REQUEST\x10}\x1a\x17\xba\x96\xbb\xb2\x05\x11\
    MedicationRequest\x123\n\x14MEDICATION_STATEMENT\x10~\x1a\x19\xba\x96\
    \xbb\xb2\x05\x13MedicationStatement\x12/\n\x12MESSAGE_DEFINITION\x10\x7f\
    \x1a\x17\xba\x96\xbb\xb2\x05\x11MessageDefinition\x12(\n\x0eMESSAGE_HEAD\
    ER\x10\x80\x01\x1a\x13\xba\x96\xbb\xb2\x05\rMessageHeader\x12&\n\rNAMING\
    _SYSTEM\x10\x81\x01\x1a\x12\xba\x96\xbb\xb2\x05\x0cNamingSystem\x12*\n\
    \x0fNUTRITION_ORDER\x10\x82\x01\x1a\x14\xba\x96\xbb\xb2\x05\x0eNutrition\
    Order\x12#\n\x0bOBSERVATION\x10\x83\x01\x1a\x11\xba\x96\xbb\xb2\x05\x0bO\
    bservation\x123\n\x13OPERATIONDEFINITION\x10\x84\x01\x1a\x19\xba\x96\xbb\
    \xb2\x05\x13OperationDefinition\x12.\n\x11OPERATION_OUTCOME\x10\x85\x01\
    \x1a\x16\xba\x96\xbb\xb2\x05\x10OperationOutcome\x12%\n\x0cORGANIZATION\
    \x10\x86\x01\x1a\x12\xba\x96\xbb\xb2\x05\x0cOrganization\x12!\n\nPARAMET\
    ERS\x10\x87\x01\x1a\x10\xba\x96\xbb\xb2\x05\nParameters\x12\x1b\n\x07PAT\
    IENT\x10\x88\x01\x1a\r\xba\x96\xbb\xb2\x05\x07Patient\x12(\n\x0ePAYMENT_\
    NOTICE\x10\x89\x01\x1a\x13\xba\x96\xbb\xb2\x05\rPaymentNotice\x128\n\x16\
    PAYMENT_RECONCILIATION\x10\x8a\x01\x1a\x1b\xba\x96\xbb\xb2\x05\x15Paymen\
    tReconciliation\x12\x19\n\x06PERSON\x10\x8b\x01\x1a\x0c\xba\x96\xbb\xb2\
    \x05\x06Person\x12*\n\x0fPLAN_DEFINITION\x10\x8c\x01\x1a\x14\xba\x96\xbb\
    \xb2\x05\x0ePlanDefinition\x12%\n\x0cPRACTITIONER\x10\x8d\x01\x1a\x12\
    \xba\x96\xbb\xb2\x05\x0cPractitioner\x12.\n\x11PRACTITIONER_ROLE\x10\x8e\
    \x01\x1a\x16\xba\x96\xbb\xb2\x05\x10PractitionerRole\x12\x1f\n\tPROCEDUR\
    E\x10\x8f\x01\x1a\x0f\xba\x96\xbb\xb2\x05\tProcedure\x12.\n\x11PROCEDURE\
    _REQUEST\x10\x90\x01\x1a\x16\xba\x96\xbb\xb2\x05\x10ProcedureRequest\x12\
    *\n\x0fPROCESS_REQUEST\x10\x91\x01\x1a\x14\xba\x96\xbb\xb2\x05\x0eProces\
    sRequest\x12,\n\x10PROCESS_RESPONSE\x10\x92\x01\x1a\x15\xba\x96\xbb\xb2\
    \x05\x0fProcessResponse\x12!\n\nPROVENANCE\x10\x93\x01\x1a\x10\xba\x96\
    \xbb\xb2\x05\nProvenance\x12'\n\rQUESTIONNAIRE\x10\x94\x01\x1a\x13\xba\
    \x96\xbb\xb2\x05\rQuestionnaire\x128\n\x16QUESTIONNAIRE_RESPONSE\x10\x95\
    \x01\x1a\x1b\xba\x96\xbb\xb2\x05\x15QuestionnaireResponse\x12,\n\x10REFE\
    RRAL_REQUEST\x10\x96\x01\x1a\x15\xba\x96\xbb\xb2\x05\x0fReferralRequest\
    \x12(\n\x0eRELATED_PERSON\x10\x97\x01\x1a\x13\xba\x96\xbb\xb2\x05\rRelat\
    edPerson\x12&\n\rREQUEST_GROUP\x10\x98\x01\x1a\x12\xba\x96\xbb\xb2\x05\
    \x0cRequestGroup\x12(\n\x0eRESEARCH_STUDY\x10\x99\x01\x1a\x13\xba\x96\
    \xbb\xb2\x05\rResearchStudy\x12,\n\x10RESEARCH_SUBJECT\x10\x9a\x01\x1a\
    \x15\xba\x96\xbb\xb2\x05\x0fResearchSubject\x12\x1d\n\x08RESOURCE\x10\
    \x9b\x01\x1a\x0e\xba\x96\xbb\xb2\x05\x08Resource\x12*\n\x0fRISK_ASSESSME\
    NT\x10\x9c\x01\x1a\x14\xba\x96\xbb\xb2\x05\x0eRiskAssessment\x12\x1d\n\
    \x08SCHEDULE\x10\x9d\x01\x1a\x0e\xba\x96\xbb\xb2\x05\x08Schedule\x12,\n\
    \x10SEARCH_PARAMETER\x10\x9e\x01\x1a\x15\xba\x96\xbb\xb2\x05\x0fSearchPa\
    rameter\x12\x1d\n\x08SEQUENCE\x10\x9f\x01\x1a\x0e\xba\x96\xbb\xb2\x05\
    \x08Sequence\x120\n\x12SERVICE_DEFINITION\x10\xa0\x01\x1a\x17\xba\x96\
    \xbb\xb2\x05\x11ServiceDefinition\x12\x15\n\x04SLOT\x10\xa1\x01\x1a\n\
    \xba\x96\xbb\xb2\x05\x04Slot\x12\x1d\n\x08SPECIMEN\x10\xa2\x01\x1a\x0e\
    \xba\x96\xbb\xb2\x05\x08Specimen\x124\n\x14STRUCTURE_DEFINITION\x10\xa3\
    \x01\x1a\x19\xba\x96\xbb\xb2\x05\x13StructureDefinition\x12&\n\rSTRUCTUR\
    E_MAP\x10\xa4\x01\x1a\x12\xba\x96\xbb\xb2\x05\x0cStructureMap\x12%\n\x0c\
    SUBSCRIPTION\x10\xa5\x01\x1a\x12\xba\x96\xbb\xb2\x05\x0cSubscription\x12\
    \x1f\n\tSUBSTANCE\x10\xa6\x01\x1a\x0f\xba\x96\xbb\xb2\x05\tSubstance\x12\
    *\n\x0fSUPPLY_DELIVERY\x10\xa7\x01\x1a\x14\xba\x96\xbb\xb2\x05\x0eSupply\
    Delivery\x12(\n\x0eSUPPLY_REQUEST\x10\xa8\x01\x1a\x13\xba\x96\xbb\xb2\
    \x05\rSupplyRequest\x12\x15\n\x04TASK\x10\xa9\x01\x1a\n\xba\x96\xbb\xb2\
    \x05\x04Task\x12\"\n\x0bTEST_REPORT\x10\xaa\x01\x1a\x10\xba\x96\xbb\xb2\
    \x05\nTestReport\x12\"\n\x0bTEST_SCRIPT\x10\xab\x01\x1a\x10\xba\x96\xbb\
    \xb2\x05\nTestScript\x12\x1e\n\tVALUE_SET\x10\xac\x01\x1a\x0e\xba\x96\
    \xbb\xb2\x05\x08ValueSet\x122\n\x13VISION_PRESCRIPTION\x10\xad\x01\x1a\
    \x18\xba\x96\xbb\xb2\x05\x12VisionPrescription\x12\x15\n\x04TYPE\x10\xae\
    \x01\x1a\n\xba\x96\xbb\xb2\x05\x04Type\x12\x13\n\x03ANY\x10\xaf\x01\x1a\
    \t\xba\x96\xbb\xb2\x05\x03Any:2\x8a\xf9\x83\xb2\x05&http://hl7.org/fhir/\
    ValueSet/all-types\xc0\x9f\xe3\xb6\x05\x01\"\xcf3\n\x13FHIRDefinedTypeCo\
    de\x12G\n\x05value\x18\x01\x20\x01(\x0e21.google.fhir.stu3.proto.FHIRDef\
    inedTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goog\
    le.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2\
    !.google.fhir.stu3.proto.ExtensionR\textension\"\xc51\n\x05Value\x12\x19\
    \n\x15INVALID_UNINITIALIZED\x10\0\x12\x1a\n\x07ADDRESS\x10\x01\x1a\r\xba\
    \x96\xbb\xb2\x05\x07Address\x12\x12\n\x03AGE\x10\x02\x1a\t\xba\x96\xbb\
    \xb2\x05\x03Age\x12\x20\n\nANNOTATION\x10\x03\x1a\x10\xba\x96\xbb\xb2\
    \x05\nAnnotation\x12\x20\n\nATTACHMENT\x10\x04\x1a\x10\xba\x96\xbb\xb2\
    \x05\nAttachment\x12+\n\x10BACKBONE_ELEMENT\x10\x05\x1a\x15\xba\x96\xbb\
    \xb2\x05\x0fBackboneElement\x12+\n\x10CODEABLE_CONCEPT\x10\x06\x1a\x15\
    \xba\x96\xbb\xb2\x05\x0fCodeableConcept\x12\x18\n\x06CODING\x10\x07\x1a\
    \x0c\xba\x96\xbb\xb2\x05\x06Coding\x12'\n\x0eCONTACT_DETAIL\x10\x08\x1a\
    \x13\xba\x96\xbb\xb2\x05\rContactDetail\x12%\n\rCONTACT_POINT\x10\t\x1a\
    \x12\xba\x96\xbb\xb2\x05\x0cContactPoint\x12\"\n\x0bCONTRIBUTOR\x10\n\
    \x1a\x11\xba\x96\xbb\xb2\x05\x0bContributor\x12\x16\n\x05COUNT\x10\x0b\
    \x1a\x0b\xba\x96\xbb\xb2\x05\x05Count\x12+\n\x10DATA_REQUIREMENT\x10\x0c\
    \x1a\x15\xba\x96\xbb\xb2\x05\x0fDataRequirement\x12\x1c\n\x08DISTANCE\
    \x10\r\x1a\x0e\xba\x96\xbb\xb2\x05\x08Distance\x12\x18\n\x06DOSAGE\x10\
    \x0e\x1a\x0c\xba\x96\xbb\xb2\x05\x06Dosage\x12\x1c\n\x08DURATION\x10\x0f\
    \x1a\x0e\xba\x96\xbb\xb2\x05\x08Duration\x12\x1a\n\x07ELEMENT\x10\x10\
    \x1a\r\xba\x96\xbb\xb2\x05\x07Element\x12/\n\x12ELEMENT_DEFINITION\x10\
    \x11\x1a\x17\xba\x96\xbb\xb2\x05\x11ElementDefinition\x12\x1e\n\tEXTENSI\
    ON\x10\x12\x1a\x0f\xba\x96\xbb\xb2\x05\tExtension\x12\x1f\n\nHUMAN_NAME\
    \x10\x13\x1a\x0f\xba\x96\xbb\xb2\x05\tHumanName\x12\x20\n\nIDENTIFIER\
    \x10\x14\x1a\x10\xba\x96\xbb\xb2\x05\nIdentifier\x12\x14\n\x04META\x10\
    \x15\x1a\n\xba\x96\xbb\xb2\x05\x04Meta\x12\x16\n\x05MONEY\x10\x16\x1a\
    \x0b\xba\x96\xbb\xb2\x05\x05Money\x12\x1e\n\tNARRATIVE\x10\x17\x1a\x0f\
    \xba\x96\xbb\xb2\x05\tNarrative\x123\n\x14PARAMETER_DEFINITION\x10\x18\
    \x1a\x19\xba\x96\xbb\xb2\x05\x13ParameterDefinition\x12\x18\n\x06PERIOD\
    \x10\x19\x1a\x0c\xba\x96\xbb\xb2\x05\x06Period\x12\x1c\n\x08QUANTITY\x10\
    \x1a\x1a\x0e\xba\x96\xbb\xb2\x05\x08Quantity\x12\x16\n\x05RANGE\x10\x1b\
    \x1a\x0b\xba\x96\xbb\xb2\x05\x05Range\x12\x16\n\x05RATIO\x10\x1c\x1a\x0b\
    \xba\x96\xbb\xb2\x05\x05Ratio\x12\x1e\n\tREFERENCE\x10\x1d\x1a\x0f\xba\
    \x96\xbb\xb2\x05\tReference\x12+\n\x10RELATED_ARTIFACT\x10\x1e\x1a\x15\
    \xba\x96\xbb\xb2\x05\x0fRelatedArtifact\x12#\n\x0cSAMPLED_DATA\x10\x1f\
    \x1a\x11\xba\x96\xbb\xb2\x05\x0bSampledData\x12\x1e\n\tSIGNATURE\x10\x20\
    \x1a\x0f\xba\x96\xbb\xb2\x05\tSignature\x12)\n\x0fSIMPLE_QUANTITY\x10!\
    \x1a\x14\xba\x96\xbb\xb2\x05\x0eSimpleQuantity\x12\x18\n\x06TIMING\x10\"\
    \x1a\x0c\xba\x96\xbb\xb2\x05\x06Timing\x12/\n\x12TRIGGER_DEFINITION\x10#\
    \x1a\x17\xba\x96\xbb\xb2\x05\x11TriggerDefinition\x12%\n\rUSAGE_CONTEXT\
    \x10$\x1a\x12\xba\x96\xbb\xb2\x05\x0cUsageContext\x12%\n\rBASE64_BINARY\
    \x10%\x1a\x12\xba\x96\xbb\xb2\x05\x0cbase64Binary\x12\x0b\n\x07BOOLEAN\
    \x10&\x12\x08\n\x04CODE\x10'\x12\x08\n\x04DATE\x10(\x12\x1d\n\tDATE_TIME\
    \x10)\x1a\x0e\xba\x96\xbb\xb2\x05\x08dateTime\x12\x0b\n\x07DECIMAL\x10*\
    \x12\x06\n\x02ID\x10+\x12\x0b\n\x07INSTANT\x10,\x12\x0b\n\x07INTEGER\x10\
    -\x12\x0c\n\x08MARKDOWN\x10.\x12\x07\n\x03OID\x10/\x12#\n\x0cPOSITIVE_IN\
    T\x100\x1a\x11\xba\x96\xbb\xb2\x05\x0bpositiveInt\x12\n\n\x06STRING\x101\
    \x12\x08\n\x04TIME\x102\x12#\n\x0cUNSIGNED_INT\x103\x1a\x11\xba\x96\xbb\
    \xb2\x05\x0bunsignedInt\x12\x07\n\x03URI\x104\x12\x08\n\x04UUID\x105\x12\
    \t\n\x05XHTML\x106\x12\x1a\n\x07ACCOUNT\x107\x1a\r\xba\x96\xbb\xb2\x05\
    \x07Account\x121\n\x13ACTIVITY_DEFINITION\x108\x1a\x18\xba\x96\xbb\xb2\
    \x05\x12ActivityDefinition\x12%\n\rADVERSE_EVENT\x109\x1a\x12\xba\x96\
    \xbb\xb2\x05\x0cAdverseEvent\x121\n\x13ALLERGY_INTOLERANCE\x10:\x1a\x18\
    \xba\x96\xbb\xb2\x05\x12AllergyIntolerance\x12\"\n\x0bAPPOINTMENT\x10;\
    \x1a\x11\xba\x96\xbb\xb2\x05\x0bAppointment\x123\n\x14APPOINTMENT_RESPON\
    SE\x10<\x1a\x19\xba\x96\xbb\xb2\x05\x13AppointmentResponse\x12!\n\x0bAUD\
    IT_EVENT\x10=\x1a\x10\xba\x96\xbb\xb2\x05\nAuditEvent\x12\x16\n\x05BASIC\
    \x10>\x1a\x0b\xba\x96\xbb\xb2\x05\x05Basic\x12\x18\n\x06BINARY\x10?\x1a\
    \x0c\xba\x96\xbb\xb2\x05\x06Binary\x12\x1d\n\tBODY_SITE\x10@\x1a\x0e\xba\
    \x96\xbb\xb2\x05\x08BodySite\x12\x18\n\x06BUNDLE\x10A\x1a\x0c\xba\x96\
    \xbb\xb2\x05\x06Bundle\x123\n\x14CAPABILITY_STATEMENT\x10B\x1a\x19\xba\
    \x96\xbb\xb2\x05\x13CapabilityStatement\x12\x1d\n\tCARE_PLAN\x10C\x1a\
    \x0e\xba\x96\xbb\xb2\x05\x08CarePlan\x12\x1d\n\tCARE_TEAM\x10D\x1a\x0e\
    \xba\x96\xbb\xb2\x05\x08CareTeam\x12!\n\x0bCHARGE_ITEM\x10E\x1a\x10\xba\
    \x96\xbb\xb2\x05\nChargeItem\x12\x16\n\x05CLAIM\x10F\x1a\x0b\xba\x96\xbb\
    \xb2\x05\x05Claim\x12'\n\x0eCLAIM_RESPONSE\x10G\x1a\x13\xba\x96\xbb\xb2\
    \x05\rClaimResponse\x121\n\x13CLINICAL_IMPRESSION\x10H\x1a\x18\xba\x96\
    \xbb\xb2\x05\x12ClinicalImpression\x12!\n\x0bCODE_SYSTEM\x10I\x1a\x10\
    \xba\x96\xbb\xb2\x05\nCodeSystem\x12&\n\rCOMMUNICATION\x10J\x1a\x13\xba\
    \x96\xbb\xb2\x05\rCommunication\x125\n\x15COMMUNICATION_REQUEST\x10K\x1a\
    \x1a\xba\x96\xbb\xb2\x05\x14CommunicationRequest\x127\n\x16COMPARTMENT_D\
    EFINITION\x10L\x1a\x1b\xba\x96\xbb\xb2\x05\x15CompartmentDefinition\x12\
    \"\n\x0bCOMPOSITION\x10M\x1a\x11\xba\x96\xbb\xb2\x05\x0bComposition\x12!\
    \n\x0bCONCEPT_MAP\x10N\x1a\x10\xba\x96\xbb\xb2\x05\nConceptMap\x12\x1e\n\
    \tCONDITION\x10O\x1a\x0f\xba\x96\xbb\xb2\x05\tCondition\x12\x1a\n\x07CON\
    SENT\x10P\x1a\r\xba\x96\xbb\xb2\x05\x07Consent\x12\x1c\n\x08CONTRACT\x10\
    Q\x1a\x0e\xba\x96\xbb\xb2\x05\x08Contract\x12\x1c\n\x08COVERAGE\x10R\x1a\
    \x0e\xba\x96\xbb\xb2\x05\x08Coverage\x12#\n\x0cDATA_ELEMENT\x10S\x1a\x11\
    \xba\x96\xbb\xb2\x05\x0bDataElement\x12'\n\x0eDETECTED_ISSUE\x10T\x1a\
    \x13\xba\x96\xbb\xb2\x05\rDetectedIssue\x12\x18\n\x06DEVICE\x10U\x1a\x0c\
    \xba\x96\xbb\xb2\x05\x06Device\x12+\n\x10DEVICE_COMPONENT\x10V\x1a\x15\
    \xba\x96\xbb\xb2\x05\x0fDeviceComponent\x12%\n\rDEVICE_METRIC\x10W\x1a\
    \x12\xba\x96\xbb\xb2\x05\x0cDeviceMetric\x12'\n\x0eDEVICE_REQUEST\x10X\
    \x1a\x13\xba\x96\xbb\xb2\x05\rDeviceRequest\x122\n\x14DEVICE_USE_STATEME\
    NT\x10Y\x1a\x18\xba\x96\xbb\xb2\x05\x12DeviceUseStatement\x12-\n\x11DIAG\
    NOSTIC_REPORT\x10Z\x1a\x16\xba\x96\xbb\xb2\x05\x10DiagnosticReport\x12-\
    \n\x11DOCUMENT_MANIFEST\x10[\x1a\x16\xba\x96\xbb\xb2\x05\x10DocumentMani\
    fest\x12/\n\x12DOCUMENT_REFERENCE\x10\\\x1a\x17\xba\x96\xbb\xb2\x05\x11D\
    ocumentReference\x12)\n\x0fDOMAIN_RESOURCE\x10]\x1a\x14\xba\x96\xbb\xb2\
    \x05\x0eDomainResource\x121\n\x13ELIGIBILITY_REQUEST\x10^\x1a\x18\xba\
    \x96\xbb\xb2\x05\x12EligibilityRequest\x123\n\x14ELIGIBILITY_RESPONSE\
    \x10_\x1a\x19\xba\x96\xbb\xb2\x05\x13EligibilityResponse\x12\x1e\n\tENCO\
    UNTER\x10`\x1a\x0f\xba\x96\xbb\xb2\x05\tEncounter\x12\x1c\n\x08ENDPOINT\
    \x10a\x1a\x0e\xba\x96\xbb\xb2\x05\x08Endpoint\x12/\n\x12ENROLLMENT_REQUE\
    ST\x10b\x1a\x17\xba\x96\xbb\xb2\x05\x11EnrollmentRequest\x121\n\x13ENROL\
    LMENT_RESPONSE\x10c\x1a\x18\xba\x96\xbb\xb2\x05\x12EnrollmentResponse\
    \x12(\n\x0fEPISODE_OF_CARE\x10d\x1a\x13\xba\x96\xbb\xb2\x05\rEpisodeOfCa\
    re\x12-\n\x11EXPANSION_PROFILE\x10e\x1a\x16\xba\x96\xbb\xb2\x05\x10Expan\
    sionProfile\x126\n\x16EXPLANATION_OF_BENEFIT\x10f\x1a\x1a\xba\x96\xbb\
    \xb2\x05\x14ExplanationOfBenefit\x124\n\x15FAMILY_MEMBER_HISTORY\x10g\
    \x1a\x19\xba\x96\xbb\xb2\x05\x13FamilyMemberHistory\x12\x14\n\x04FLAG\
    \x10h\x1a\n\xba\x96\xbb\xb2\x05\x04Flag\x12\x14\n\x04GOAL\x10i\x1a\n\xba\
    \x96\xbb\xb2\x05\x04Goal\x12+\n\x10GRAPH_DEFINITION\x10j\x1a\x15\xba\x96\
    \xbb\xb2\x05\x0fGraphDefinition\x12\x16\n\x05GROUP\x10k\x1a\x0b\xba\x96\
    \xbb\xb2\x05\x05Group\x12-\n\x11GUIDANCE_RESPONSE\x10l\x1a\x16\xba\x96\
    \xbb\xb2\x05\x10GuidanceResponse\x12/\n\x12HEALTHCARE_SERVICE\x10m\x1a\
    \x17\xba\x96\xbb\xb2\x05\x11HealthcareService\x12+\n\x10IMAGING_MANIFEST\
    \x10n\x1a\x15\xba\x96\xbb\xb2\x05\x0fImagingManifest\x12%\n\rIMAGING_STU\
    DY\x10o\x1a\x12\xba\x96\xbb\xb2\x05\x0cImagingStudy\x12$\n\x0cIMMUNIZATI\
    ON\x10p\x1a\x12\xba\x96\xbb\xb2\x05\x0cImmunization\x12A\n\x1bIMMUNIZATI\
    ON_RECOMMENDATION\x10q\x1a\x20\xba\x96\xbb\xb2\x05\x1aImmunizationRecomm\
    endation\x123\n\x14IMPLEMENTATION_GUIDE\x10r\x1a\x19\xba\x96\xbb\xb2\x05\
    \x13ImplementationGuide\x12\x1a\n\x07LIBRARY\x10s\x1a\r\xba\x96\xbb\xb2\
    \x05\x07Library\x12\x1a\n\x07LINKAGE\x10t\x1a\r\xba\x96\xbb\xb2\x05\x07L\
    inkage\x12\x14\n\x04LIST\x10u\x1a\n\xba\x96\xbb\xb2\x05\x04List\x12\x1c\
    \n\x08LOCATION\x10v\x1a\x0e\xba\x96\xbb\xb2\x05\x08Location\x12\x1a\n\
    \x07MEASURE\x10w\x1a\r\xba\x96\xbb\xb2\x05\x07Measure\x12'\n\x0eMEASURE_\
    REPORT\x10x\x1a\x13\xba\x96\xbb\xb2\x05\rMeasureReport\x12\x16\n\x05MEDI\
    A\x10y\x1a\x0b\xba\x96\xbb\xb2\x05\x05Media\x12\x20\n\nMEDICATION\x10z\
    \x1a\x10\xba\x96\xbb\xb2\x05\nMedication\x12=\n\x19MEDICATION_ADMINISTRA\
    TION\x10{\x1a\x1e\xba\x96\xbb\xb2\x05\x18MedicationAdministration\x121\n\
    \x13MEDICATION_DISPENSE\x10|\x1a\x18\xba\x96\xbb\xb2\x05\x12MedicationDi\
    spense\x12/\n\x12MEDICATION_REQUEST\x10}\x1a\x17\xba\x96\xbb\xb2\x05\x11\
    MedicationRequest\x123\n\x14MEDICATION_STATEMENT\x10~\x1a\x19\xba\x96\
    \xbb\xb2\x05\x13MedicationStatement\x12/\n\x12MESSAGE_DEFINITION\x10\x7f\
    \x1a\x17\xba\x96\xbb\xb2\x05\x11MessageDefinition\x12(\n\x0eMESSAGE_HEAD\
    ER\x10\x80\x01\x1a\x13\xba\x96\xbb\xb2\x05\rMessageHeader\x12&\n\rNAMING\
    _SYSTEM\x10\x81\x01\x1a\x12\xba\x96\xbb\xb2\x05\x0cNamingSystem\x12*\n\
    \x0fNUTRITION_ORDER\x10\x82\x01\x1a\x14\xba\x96\xbb\xb2\x05\x0eNutrition\
    Order\x12#\n\x0bOBSERVATION\x10\x83\x01\x1a\x11\xba\x96\xbb\xb2\x05\x0bO\
    bservation\x123\n\x13OPERATIONDEFINITION\x10\x84\x01\x1a\x19\xba\x96\xbb\
    \xb2\x05\x13OperationDefinition\x12.\n\x11OPERATION_OUTCOME\x10\x85\x01\
    \x1a\x16\xba\x96\xbb\xb2\x05\x10OperationOutcome\x12%\n\x0cORGANIZATION\
    \x10\x86\x01\x1a\x12\xba\x96\xbb\xb2\x05\x0cOrganization\x12!\n\nPARAMET\
    ERS\x10\x87\x01\x1a\x10\xba\x96\xbb\xb2\x05\nParameters\x12\x1b\n\x07PAT\
    IENT\x10\x88\x01\x1a\r\xba\x96\xbb\xb2\x05\x07Patient\x12(\n\x0ePAYMENT_\
    NOTICE\x10\x89\x01\x1a\x13\xba\x96\xbb\xb2\x05\rPaymentNotice\x128\n\x16\
    PAYMENT_RECONCILIATION\x10\x8a\x01\x1a\x1b\xba\x96\xbb\xb2\x05\x15Paymen\
    tReconciliation\x12\x19\n\x06PERSON\x10\x8b\x01\x1a\x0c\xba\x96\xbb\xb2\
    \x05\x06Person\x12*\n\x0fPLAN_DEFINITION\x10\x8c\x01\x1a\x14\xba\x96\xbb\
    \xb2\x05\x0ePlanDefinition\x12%\n\x0cPRACTITIONER\x10\x8d\x01\x1a\x12\
    \xba\x96\xbb\xb2\x05\x0cPractitioner\x12.\n\x11PRACTITIONER_ROLE\x10\x8e\
    \x01\x1a\x16\xba\x96\xbb\xb2\x05\x10PractitionerRole\x12\x1f\n\tPROCEDUR\
    E\x10\x8f\x01\x1a\x0f\xba\x96\xbb\xb2\x05\tProcedure\x12.\n\x11PROCEDURE\
    _REQUEST\x10\x90\x01\x1a\x16\xba\x96\xbb\xb2\x05\x10ProcedureRequest\x12\
    *\n\x0fPROCESS_REQUEST\x10\x91\x01\x1a\x14\xba\x96\xbb\xb2\x05\x0eProces\
    sRequest\x12,\n\x10PROCESS_RESPONSE\x10\x92\x01\x1a\x15\xba\x96\xbb\xb2\
    \x05\x0fProcessResponse\x12!\n\nPROVENANCE\x10\x93\x01\x1a\x10\xba\x96\
    \xbb\xb2\x05\nProvenance\x12'\n\rQUESTIONNAIRE\x10\x94\x01\x1a\x13\xba\
    \x96\xbb\xb2\x05\rQuestionnaire\x128\n\x16QUESTIONNAIRE_RESPONSE\x10\x95\
    \x01\x1a\x1b\xba\x96\xbb\xb2\x05\x15QuestionnaireResponse\x12,\n\x10REFE\
    RRAL_REQUEST\x10\x96\x01\x1a\x15\xba\x96\xbb\xb2\x05\x0fReferralRequest\
    \x12(\n\x0eRELATED_PERSON\x10\x97\x01\x1a\x13\xba\x96\xbb\xb2\x05\rRelat\
    edPerson\x12&\n\rREQUEST_GROUP\x10\x98\x01\x1a\x12\xba\x96\xbb\xb2\x05\
    \x0cRequestGroup\x12(\n\x0eRESEARCH_STUDY\x10\x99\x01\x1a\x13\xba\x96\
    \xbb\xb2\x05\rResearchStudy\x12,\n\x10RESEARCH_SUBJECT\x10\x9a\x01\x1a\
    \x15\xba\x96\xbb\xb2\x05\x0fResearchSubject\x12\x1d\n\x08RESOURCE\x10\
    \x9b\x01\x1a\x0e\xba\x96\xbb\xb2\x05\x08Resource\x12*\n\x0fRISK_ASSESSME\
    NT\x10\x9c\x01\x1a\x14\xba\x96\xbb\xb2\x05\x0eRiskAssessment\x12\x1d\n\
    \x08SCHEDULE\x10\x9d\x01\x1a\x0e\xba\x96\xbb\xb2\x05\x08Schedule\x12,\n\
    \x10SEARCH_PARAMETER\x10\x9e\x01\x1a\x15\xba\x96\xbb\xb2\x05\x0fSearchPa\
    rameter\x12\x1d\n\x08SEQUENCE\x10\x9f\x01\x1a\x0e\xba\x96\xbb\xb2\x05\
    \x08Sequence\x120\n\x12SERVICE_DEFINITION\x10\xa0\x01\x1a\x17\xba\x96\
    \xbb\xb2\x05\x11ServiceDefinition\x12\x15\n\x04SLOT\x10\xa1\x01\x1a\n\
    \xba\x96\xbb\xb2\x05\x04Slot\x12\x1d\n\x08SPECIMEN\x10\xa2\x01\x1a\x0e\
    \xba\x96\xbb\xb2\x05\x08Specimen\x124\n\x14STRUCTURE_DEFINITION\x10\xa3\
    \x01\x1a\x19\xba\x96\xbb\xb2\x05\x13StructureDefinition\x12&\n\rSTRUCTUR\
    E_MAP\x10\xa4\x01\x1a\x12\xba\x96\xbb\xb2\x05\x0cStructureMap\x12%\n\x0c\
    SUBSCRIPTION\x10\xa5\x01\x1a\x12\xba\x96\xbb\xb2\x05\x0cSubscription\x12\
    \x1f\n\tSUBSTANCE\x10\xa6\x01\x1a\x0f\xba\x96\xbb\xb2\x05\tSubstance\x12\
    *\n\x0fSUPPLY_DELIVERY\x10\xa7\x01\x1a\x14\xba\x96\xbb\xb2\x05\x0eSupply\
    Delivery\x12(\n\x0eSUPPLY_REQUEST\x10\xa8\x01\x1a\x13\xba\x96\xbb\xb2\
    \x05\rSupplyRequest\x12\x15\n\x04TASK\x10\xa9\x01\x1a\n\xba\x96\xbb\xb2\
    \x05\x04Task\x12\"\n\x0bTEST_REPORT\x10\xaa\x01\x1a\x10\xba\x96\xbb\xb2\
    \x05\nTestReport\x12\"\n\x0bTEST_SCRIPT\x10\xab\x01\x1a\x10\xba\x96\xbb\
    \xb2\x05\nTestScript\x12\x1e\n\tVALUE_SET\x10\xac\x01\x1a\x0e\xba\x96\
    \xbb\xb2\x05\x08ValueSet\x122\n\x13VISION_PRESCRIPTION\x10\xad\x01\x1a\
    \x18\xba\x96\xbb\xb2\x05\x12VisionPrescription:6\xc0\x9f\xe3\xb6\x05\x01\
    \x8a\xf9\x83\xb2\x05*http://hl7.org/fhir/ValueSet/defined-types\"\xdb\
    \x01\n\x16FHIRDefinedTypeExtCode\x12\x14\n\x05value\x18\x01\x20\x01(\tR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension::\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\
    \x05.http://hl7.org/fhir/ValueSet/defined-types#ext\"\xe4\x02\n\x14Defin\
    itionStatusCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.google.fhir.stu3.\
    proto.DefinitionStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"U\n\x05Val\
    ue\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05DRAFT\x10\x01\x12\
    \n\n\x06ACTIVE\x10\x02\x12\r\n\tWITHDRAWN\x10\x03\x12\x0b\n\x07UNKNOWN\
    \x10\x04::\x8a\xf9\x83\xb2\x05.http://hl7.org/fhir/ValueSet/definition-s\
    tatus\xc0\x9f\xe3\xb6\x05\x01\"\xdc\x02\n\x13DefinitionTopicCode\x12G\n\
    \x05value\x18\x01\x20\x01(\x0e21.google.fhir.stu3.proto.DefinitionTopicC\
    ode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.s\
    tu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.\
    fhir.stu3.proto.ExtensionR\textension\"P\n\x05Value\x12\x19\n\x15INVALID\
    _UNINITIALIZED\x10\0\x12\r\n\tTREATMENT\x10\x01\x12\r\n\tEDUCATION\x10\
    \x02\x12\x0e\n\nASSESSMENT\x10\x03:9\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\
    \xb2\x05-http://hl7.org/fhir/ValueSet/definition-topic\"\xe1\x02\n\x19De\
    tectedIssueSeverityCode\x12M\n\x05value\x18\x01\x20\x01(\x0e27.google.fh\
    ir.stu3.proto.DetectedIssueSeverityCode.ValueR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"C\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04HI\
    GH\x10\x01\x12\x0c\n\x08MODERATE\x10\x02\x12\x07\n\x03LOW\x10\x03:?\xc0\
    \x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x053http://hl7.org/fhir/ValueSet/de\
    tectedissue-severity\"\xa0\x03\n\x1cDeviceUseStatementStatusCode\x12P\n\
    \x05value\x18\x01\x20\x01(\x0e2:.google.fhir.stu3.proto.DeviceUseStateme\
    ntStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goog\
    le.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2\
    !.google.fhir.stu3.proto.ExtensionR\textension\"{\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\r\n\tCOMPL\
    ETED\x10\x02\x12\x14\n\x10ENTERED_IN_ERROR\x10\x03\x12\x0c\n\x08INTENDED\
    \x10\x04\x12\x0b\n\x07STOPPED\x10\x05\x12\x0b\n\x07ON_HOLD\x10\x06:@\xc0\
    \x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/ValueSet/de\
    vice-statement-status\"\xea\x02\n\x14FHIRDeviceStatusCode\x12H\n\x05valu\
    e\x18\x01\x20\x01(\x0e22.google.fhir.stu3.proto.FHIRDeviceStatusCode.Val\
    ueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.pro\
    to.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.st\
    u3.proto.ExtensionR\textension\"_\n\x05Value\x12\x19\n\x15INVALID_UNINIT\
    IALIZED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\x0c\n\x08INACTIVE\x10\x02\
    \x12\x14\n\x10ENTERED_IN_ERROR\x10\x03\x12\x0b\n\x07UNKNOWN\x10\x04:6\
    \x8a\xf9\x83\xb2\x05*http://hl7.org/fhir/ValueSet/device-status\xc0\x9f\
    \xe3\xb6\x05\x01\"\x97\x03\n\x11DiagnosisRoleCode\x12E\n\x05value\x18\
    \x01\x20\x01(\x0e2/.google.fhir.stu3.proto.DiagnosisRoleCode.ValueR\x05v\
    alue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Strin\
    gR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto\
    .ExtensionR\textension\"\x90\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITI\
    ALIZED\x10\0\x12\x10\n\x02AD\x10\x01\x1a\x08\xba\x96\xbb\xb2\x05\x02AD\
    \x12\x10\n\x02DD\x10\x02\x1a\x08\xba\x96\xbb\xb2\x05\x02DD\x12\x10\n\x02\
    CC\x10\x03\x1a\x08\xba\x96\xbb\xb2\x05\x02CC\x12\x10\n\x02CM\x10\x04\x1a\
    \x08\xba\x96\xbb\xb2\x05\x02CM\x12\n\n\x06PRE_OP\x10\x05\x12\x0b\n\x07PO\
    ST_OP\x10\x06\x12\x0b\n\x07BILLING\x10\x07:7\x8a\xf9\x83\xb2\x05+http://\
    hl7.org/fhir/ValueSet/diagnosis-role\xc0\x9f\xe3\xb6\x05\x01\"\xda\x03\n\
    \x1aDiagnosticReportStatusCode\x12N\n\x05value\x18\x01\x20\x01(\x0e28.go\
    ogle.fhir.stu3.proto.DiagnosticReportStatusCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\xb7\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x0e\n\nREGISTERED\x10\x01\x12\x0b\n\x07PARTIAL\x10\x02\x12\
    \x0f\n\x0bPRELIMINARY\x10\x03\x12\t\n\x05FINAL\x10\x04\x12\x0b\n\x07AMEN\
    DED\x10\x05\x12\r\n\tCORRECTED\x10\x06\x12\x0c\n\x08APPENDED\x10\x07\x12\
    \r\n\tCANCELLED\x10\x08\x12\x14\n\x10ENTERED_IN_ERROR\x10\t\x12\x0b\n\
    \x07UNKNOWN\x10\n:A\x8a\xf9\x83\xb2\x055http://hl7.org/fhir/ValueSet/dia\
    gnostic-report-status\xc0\x9f\xe3\xb6\x05\x01\"\xd3\x02\n\x14DigitalMedi\
    aTypeCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.google.fhir.stu3.proto.\
    DigitalMediaTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"C\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05PHOTO\x10\x01\x12\t\
    \n\x05VIDEO\x10\x02\x12\t\n\x05AUDIO\x10\x03:;\x8a\xf9\x83\xb2\x05/http:\
    //hl7.org/fhir/ValueSet/digital-media-type\xc0\x9f\xe3\xb6\x05\x01\"\xc1\
    \x02\n\x10DocumentModeCode\x12D\n\x05value\x18\x01\x20\x01(\x0e2..google\
    .fhir.stu3.proto.DocumentModeCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\">\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08PRODUC\
    ER\x10\x01\x12\x0c\n\x08CONSUMER\x10\x02:6\x8a\xf9\x83\xb2\x05*http://hl\
    7.org/fhir/ValueSet/document-mode\xc0\x9f\xe3\xb6\x05\x01\"\xfa\x02\n\
    \x1bDocumentReferenceStatusCode\x12O\n\x05value\x18\x01\x20\x01(\x0e29.g\
    oogle.fhir.stu3.proto.DocumentReferenceStatusCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"U\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x0b\n\x07CURRENT\x10\x01\x12\x0e\n\nSUPERSEDED\x10\x02\x12\x14\n\
    \x10ENTERED_IN_ERROR\x10\x03:B\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\
    \x056http://hl7.org/fhir/ValueSet/document-reference-status\"\x80\x03\n\
    \x1cDocumentRelationshipTypeCode\x12P\n\x05value\x18\x01\x20\x01(\x0e2:.\
    google.fhir.stu3.proto.DocumentRelationshipTypeCode.ValueR\x05value\x12.\
    \n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"X\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x0c\n\x08REPLACES\x10\x01\x12\x0e\n\nTRANSFORMS\x10\x02\x12\t\n\x05\
    SIGNS\x10\x03\x12\x0b\n\x07APPENDS\x10\x04:C\xc0\x9f\xe3\xb6\x05\x01\x8a\
    \xf9\x83\xb2\x057http://hl7.org/fhir/ValueSet/document-relationship-type\
    \"\x98\x03\n\x0fAdmitSourceCode\x12C\n\x05value\x18\x01\x20\x01(\x0e2-.g\
    oogle.fhir.stu3.proto.AdmitSourceCode.ValueR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"\x8d\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0e\
    \n\nHOSP_TRANS\x10\x01\x12\x07\n\x03EMD\x10\x02\x12\x08\n\x04OUTP\x10\
    \x03\x12\x08\n\x04BORN\x10\x04\x12\x06\n\x02GP\x10\x05\x12\x06\n\x02MP\
    \x10\x06\x12\x0b\n\x07NURSING\x10\x07\x12\t\n\x05PSYCH\x10\x08\x12\t\n\
    \x05REHAB\x10\t\x12\t\n\x05OTHER\x10\n:?\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\
    \x83\xb2\x053http://hl7.org/fhir/ValueSet/encounter-admit-source\"\xf8\
    \x02\n\x08DietCode\x12<\n\x05value\x18\x01\x20\x01(\x0e2&.google.fhir.st\
    u3.proto.DietCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e\
    .google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\x83\x01\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0e\n\nVEGETARIAN\x10\x01\
    \x12\x0e\n\nDAIRY_FREE\x10\x02\x12\x0c\n\x08NUT_FREE\x10\x03\x12\x0f\n\
    \x0bGLUTEN_FREE\x10\x04\x12\t\n\x05VEGAN\x10\x05\x12\t\n\x05HALAL\x10\
    \x06\x12\n\n\x06KOSHER\x10\x07:7\x8a\xf9\x83\xb2\x05+http://hl7.org/fhir\
    /ValueSet/encounter-diet\xc0\x9f\xe3\xb6\x05\x01\"\xb1\x03\n\x18Discharg\
    eDispositionCode\x12L\n\x05value\x18\x01\x20\x01(\x0e26.google.fhir.stu3\
    .proto.DischargeDispositionCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\
    \x8b\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\
    \x04HOME\x10\x01\x12\r\n\tOTHER_HCF\x10\x02\x12\x08\n\x04HOSP\x10\x03\
    \x12\x08\n\x04LONG\x10\x04\x12\x0b\n\x07AADVICE\x10\x05\x12\x07\n\x03EXP\
    \x10\x06\x12\x07\n\x03PSY\x10\x07\x12\t\n\x05REHAB\x10\x08\x12\x07\n\x03\
    SNF\x10\t\x12\x07\n\x03OTH\x10\n:H\x8a\xf9\x83\xb2\x05<http://hl7.org/fh\
    ir/ValueSet/encounter-discharge-disposition\xc0\x9f\xe3\xb6\x05\x01\"\
    \xfd\x02\n\x1bEncounterLocationStatusCode\x12O\n\x05value\x18\x01\x20\
    \x01(\x0e29.google.fhir.stu3.proto.EncounterLocationStatusCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"X\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x0b\n\x07PLANNED\x10\x01\x12\n\n\x06ACTIVE\x10\x02\x12\
    \x0c\n\x08RESERVED\x10\x03\x12\r\n\tCOMPLETED\x10\x04:B\x8a\xf9\x83\xb2\
    \x056http://hl7.org/fhir/ValueSet/encounter-location-status\xc0\x9f\xe3\
    \xb6\x05\x01\"\xf7\x02\n\x17SpecialArrangementsCode\x12K\n\x05value\x18\
    \x01\x20\x01(\x0e25.google.fhir.stu3.proto.SpecialArrangementsCode.Value\
    R\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto\
    .StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3\
    .proto.ExtensionR\textension\"U\n\x05Value\x12\x19\n\x15INVALID_UNINITIA\
    LIZED\x10\0\x12\t\n\x05WHEEL\x10\x01\x12\x0b\n\x07ADD_BED\x10\x02\x12\
    \x07\n\x03INT\x10\x03\x12\x07\n\x03ATT\x10\x04\x12\x07\n\x03DOG\x10\x05:\
    G\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05;http://hl7.org/fhir/ValueS\
    et/encounter-special-arrangements\"\xb4\x03\n\x13EncounterStatusCode\x12\
    G\n\x05value\x18\x01\x20\x01(\x0e21.google.fhir.stu3.proto.EncounterStat\
    usCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhi\
    r.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goog\
    le.fhir.stu3.proto.ExtensionR\textension\"\xa7\x01\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07PLANNED\x10\x01\x12\x0b\n\
    \x07ARRIVED\x10\x02\x12\x0b\n\x07TRIAGED\x10\x03\x12\x0f\n\x0bIN_PROGRES\
    S\x10\x04\x12\x0b\n\x07ONLEAVE\x10\x05\x12\x0c\n\x08FINISHED\x10\x06\x12\
    \r\n\tCANCELLED\x10\x07\x12\x14\n\x10ENTERED_IN_ERROR\x10\x08\x12\x0b\n\
    \x07UNKNOWN\x10\t:9\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05-http://h\
    l7.org/fhir/ValueSet/encounter-status\"\x8d\x03\n\x11EncounterTypeCode\
    \x12E\n\x05value\x18\x01\x20\x01(\x0e2/.google.fhir.stu3.proto.Encounter\
    TypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.f\
    hir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.go\
    ogle.fhir.stu3.proto.ExtensionR\textension\"\x86\x01\n\x05Value\x12\x19\
    \n\x15INVALID_UNINITIALIZED\x10\0\x12\x14\n\x04ADMS\x10\x01\x1a\n\xba\
    \x96\xbb\xb2\x05\x04ADMS\x12\x20\n\nBD_BM_CLIN\x10\x02\x1a\x10\xba\x96\
    \xbb\xb2\x05\nBD/BM-clin\x12\x16\n\x05CCS60\x10\x03\x1a\x0b\xba\x96\xbb\
    \xb2\x05\x05CCS60\x12\x12\n\x03OKI\x10\x04\x1a\t\xba\x96\xbb\xb2\x05\x03\
    OKI:7\x8a\xf9\x83\xb2\x05+http://hl7.org/fhir/ValueSet/encounter-type\
    \xc0\x9f\xe3\xb6\x05\x01\"\xfa\x02\n\x12EndpointStatusCode\x12F\n\x05val\
    ue\x18\x01\x20\x01(\x0e20.google.fhir.stu3.proto.EndpointStatusCode.Valu\
    eR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.prot\
    o.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu\
    3.proto.ExtensionR\textension\"q\n\x05Value\x12\x19\n\x15INVALID_UNINITI\
    ALIZED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\r\n\tSUSPENDED\x10\x02\x12\t\
    \n\x05ERROR\x10\x03\x12\x07\n\x03OFF\x10\x04\x12\x14\n\x10ENTERED_IN_ERR\
    OR\x10\x05\x12\x08\n\x04TEST\x10\x06:8\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\
    \x83\xb2\x05,http://hl7.org/fhir/ValueSet/endpoint-status\"\x8c\x04\n\
    \x1bEntityNamePartQualifierCode\x12O\n\x05value\x18\x01\x20\x01(\x0e29.g\
    oogle.fhir.stu3.proto.EntityNamePartQualifierCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\xec\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x10\n\x02LS\x10\x01\x1a\x08\xba\x96\xbb\xb2\x05\x02LS\x12\x10\
    \n\x02AC\x10\x02\x1a\x08\xba\x96\xbb\xb2\x05\x02AC\x12\x10\n\x02NB\x10\
    \x03\x1a\x08\xba\x96\xbb\xb2\x05\x02NB\x12\x10\n\x02PR\x10\x04\x1a\x08\
    \xba\x96\xbb\xb2\x05\x02PR\x12\x12\n\x03HON\x10\x05\x1a\t\xba\x96\xbb\
    \xb2\x05\x03HON\x12\x10\n\x02BR\x10\x06\x1a\x08\xba\x96\xbb\xb2\x05\x02B\
    R\x12\x10\n\x02AD\x10\x07\x1a\x08\xba\x96\xbb\xb2\x05\x02AD\x12\x10\n\
    \x02SP\x10\x08\x1a\x08\xba\x96\xbb\xb2\x05\x02SP\x12\x12\n\x03MID\x10\t\
    \x1a\t\xba\x96\xbb\xb2\x05\x03MID\x12\x10\n\x02CL\x10\n\x1a\x08\xba\x96\
    \xbb\xb2\x05\x02CL\x12\x10\n\x02IN\x10\x0b\x1a\x08\xba\x96\xbb\xb2\x05\
    \x02IN:<\x8a\xf9\x83\xb2\x050http://hl7.org/fhir/ValueSet/name-part-qual\
    ifier\xc0\x9f\xe3\xb6\x05\x01\"\x8f\x03\n\"EnteralFormulaAdditiveTypeCod\
    eCode\x12V\n\x05value\x18\x01\x20\x01(\x0e2@.google.fhir.stu3.proto.Ente\
    ralFormulaAdditiveTypeCodeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"b\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05LIPID\
    \x10\x01\x12\x0b\n\x07PROTEIN\x10\x02\x12\x10\n\x0cCARBOHYDRATE\x10\x03\
    \x12\t\n\x05FIBER\x10\x04\x12\t\n\x05WATER\x10\x05:<\x8a\xf9\x83\xb2\x05\
    0http://hl7.org/fhir/ValueSet/entformula-additive\xc0\x9f\xe3\xb6\x05\
    \x01\"\xa3\x03\n\x17EpisodeOfCareStatusCode\x12K\n\x05value\x18\x01\x20\
    \x01(\x0e25.google.fhir.stu3.proto.EpisodeOfCareStatusCode.ValueR\x05val\
    ue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"\x88\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x0b\n\x07PLANNED\x10\x01\x12\x0c\n\x08WAITLIST\x10\x02\
    \x12\n\n\x06ACTIVE\x10\x03\x12\n\n\x06ONHOLD\x10\x04\x12\x0c\n\x08FINISH\
    ED\x10\x05\x12\r\n\tCANCELLED\x10\x06\x12\x14\n\x10ENTERED_IN_ERROR\x10\
    \x07:?\x8a\xf9\x83\xb2\x053http://hl7.org/fhir/ValueSet/episode-of-care-\
    status\xc0\x9f\xe3\xb6\x05\x01\"\xe3\x02\n\x15EpisodeOfCareTypeCode\x12I\
    \n\x05value\x18\x01\x20\x01(\x0e23.google.fhir.stu3.proto.EpisodeOfCareT\
    ypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fh\
    ir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goo\
    gle.fhir.stu3.proto.ExtensionR\textension\"Q\n\x05Value\x12\x19\n\x15INV\
    ALID_UNINITIALIZED\x10\0\x12\x08\n\x04HACC\x10\x01\x12\x07\n\x03PAC\x10\
    \x02\x12\x08\n\x04DIAB\x10\x03\x12\x06\n\x02DA\x10\x04\x12\x08\n\x04CACP\
    \x10\x05:;\x8a\xf9\x83\xb2\x05/http://hl7.org/fhir/ValueSet/episodeofcar\
    e-type\xc0\x9f\xe3\xb6\x05\x01\"\xd5\x02\n\x17EventCapabilityModeCode\
    \x12K\n\x05value\x18\x01\x20\x01(\x0e25.google.fhir.stu3.proto.EventCapa\
    bilityModeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.go\
    ogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"<\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06SENDER\x10\x01\x12\x0c\
    \n\x08RECEIVER\x10\x02:>\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x052htt\
    p://hl7.org/fhir/ValueSet/event-capability-mode\"\x93\x03\n\x0fEventStat\
    usCode\x12C\n\x05value\x18\x01\x20\x01(\x0e2-.google.fhir.stu3.proto.Eve\
    ntStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goog\
    le.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2\
    !.google.fhir.stu3.proto.ExtensionR\textension\"\x92\x01\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0f\n\x0bPREPARATION\x10\x01\
    \x12\x0f\n\x0bIN_PROGRESS\x10\x02\x12\r\n\tSUSPENDED\x10\x03\x12\x0b\n\
    \x07ABORTED\x10\x04\x12\r\n\tCOMPLETED\x10\x05\x12\x14\n\x10ENTERED_IN_E\
    RROR\x10\x06\x12\x0b\n\x07UNKNOWN\x10\x07:5\x8a\xf9\x83\xb2\x05)http://h\
    l7.org/fhir/ValueSet/event-status\xc0\x9f\xe3\xb6\x05\x01\"\x86\x03\n\
    \x1aClaimPayeeResourceTypeCode\x12N\n\x05value\x18\x01\x20\x01(\x0e28.go\
    ogle.fhir.stu3.proto.ClaimPayeeResourceTypeCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"f\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x10\n\x0cORGANIZATION\x10\x01\x12\x0b\n\x07PATIENT\x10\x02\x12\x10\
    \n\x0cPRACTITIONER\x10\x03\x12\x11\n\rRELATEDPERSON\x10\x04:?\xc0\x9f\
    \xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x053http://hl7.org/fhir/ValueSet/ex-pay\
    ee-resource-type\"\x8b\x03\n\x1eExplanationOfBenefitStatusCode\x12R\n\
    \x05value\x18\x01\x20\x01(\x0e2<.google.fhir.stu3.proto.ExplanationOfBen\
    efitStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.go\
    ogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"^\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\r\n\
    \tCANCELLED\x10\x02\x12\t\n\x05DRAFT\x10\x03\x12\x14\n\x10ENTERED_IN_ERR\
    OR\x10\x04:D\x8a\xf9\x83\xb2\x058http://hl7.org/fhir/ValueSet/explanatio\
    nofbenefit-status\xc0\x9f\xe3\xb6\x05\x01\"\xdc\x02\n\x14ExtensionContex\
    tCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.google.fhir.stu3.proto.Exte\
    nsionContextCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.\
    google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"M\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08RESOURCE\x10\x01\x12\
    \x0c\n\x08DATATYPE\x10\x02\x12\r\n\tEXTENSION\x10\x03::\x8a\xf9\x83\xb2\
    \x05.http://hl7.org/fhir/ValueSet/extension-context\xc0\x9f\xe3\xb6\x05\
    \x01\"\xa8\x03\n\x12FilterOperatorCode\x12F\n\x05value\x18\x01\x20\x01(\
    \x0e20.google.fhir.stu3.proto.FilterOperatorCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\x9e\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x13\n\x06EQUALS\x10\x01\x1a\x07\xba\x96\xbb\xb2\x05\x01=\x12\
    \x08\n\x04IS_A\x10\x02\x12\x11\n\rDESCENDENT_OF\x10\x03\x12\x0c\n\x08IS_\
    NOT_A\x10\x04\x12\t\n\x05REGEX\x10\x05\x12\x06\n\x02IN\x10\x06\x12\n\n\
    \x06NOT_IN\x10\x07\x12\x0f\n\x0bGENERALIZES\x10\x08\x12\n\n\x06EXISTS\
    \x10\t:8\x8a\xf9\x83\xb2\x05,http://hl7.org/fhir/ValueSet/filter-operato\
    r\xc0\x9f\xe3\xb6\x05\x01\"\xda\x02\n\x10FlagCategoryCode\x12D\n\x05valu\
    e\x18\x01\x20\x01(\x0e2..google.fhir.stu3.proto.FlagCategoryCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"W\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x08\n\x04DIET\x10\x01\x12\x08\n\x04DRUG\x10\x02\x12\x07\n\
    \x03LAB\x10\x03\x12\t\n\x05ADMIN\x10\x04\x12\x0b\n\x07CONTACT\x10\x05:6\
    \x8a\xf9\x83\xb2\x05*http://hl7.org/fhir/ValueSet/flag-category\xc0\x9f\
    \xe3\xb6\x05\x01\"\xf7\x02\n\x15FlagPriorityCodesCode\x12I\n\x05value\
    \x18\x01\x20\x01(\x0e23.google.fhir.stu3.proto.FlagPriorityCodesCode.Val\
    ueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.pro\
    to.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.st\
    u3.proto.ExtensionR\textension\"j\n\x05Value\x12\x19\n\x15INVALID_UNINIT\
    IALIZED\x10\0\x12\x10\n\x02PN\x10\x01\x1a\x08\xba\x96\xbb\xb2\x05\x02PN\
    \x12\x10\n\x02PL\x10\x02\x1a\x08\xba\x96\xbb\xb2\x05\x02PL\x12\x10\n\x02\
    PM\x10\x03\x1a\x08\xba\x96\xbb\xb2\x05\x02PM\x12\x10\n\x02PH\x10\x04\x1a\
    \x08\xba\x96\xbb\xb2\x05\x02PH:6\x8a\xf9\x83\xb2\x05*http://hl7.org/fhir\
    /ValueSet/flag-priority\xc0\x9f\xe3\xb6\x05\x01\"\xcf\x02\n\x0eFlagStatu\
    sCode\x12B\n\x05value\x18\x01\x20\x01(\x0e2,.google.fhir.stu3.proto.Flag\
    StatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google\
    .fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.\
    google.fhir.stu3.proto.ExtensionR\textension\"R\n\x05Value\x12\x19\n\x15\
    INVALID_UNINITIALIZED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\x0c\n\x08INACT\
    IVE\x10\x02\x12\x14\n\x10ENTERED_IN_ERROR\x10\x03:4\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x05(http://hl7.org/fhir/ValueSet/flag-status\"\xf3\
    \x02\n\x1bFinancialResourceStatusCode\x12O\n\x05value\x18\x01\x20\x01(\
    \x0e29.google.fhir.stu3.proto.FinancialResourceStatusCode.ValueR\x05valu\
    e\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"^\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\r\n\tCANCELLED\x10\x02\x12\t\n\x05D\
    RAFT\x10\x03\x12\x14\n\x10ENTERED_IN_ERROR\x10\x04:2\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x05&http://hl7.org/fhir/ValueSet/fm-status\"\xe4\
    \x02\n\x18GoalAcceptanceStatusCode\x12L\n\x05value\x18\x01\x20\x01(\x0e2\
    6.google.fhir.stu3.proto.GoalAcceptanceStatusCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"H\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\t\n\x05AGREE\x10\x01\x12\x0c\n\x08DISAGREE\x10\x02\x12\x0b\n\x07PEN\
    DING\x10\x03:?\x8a\xf9\x83\xb2\x053http://hl7.org/fhir/ValueSet/goal-acc\
    eptance-status\xc0\x9f\xe3\xb6\x05\x01\"\xee\x02\n\x10GoalCategoryCode\
    \x12D\n\x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3.proto.GoalCateg\
    oryCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fh\
    ir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goo\
    gle.fhir.stu3.proto.ExtensionR\textension\"k\n\x05Value\x12\x19\n\x15INV\
    ALID_UNINITIALIZED\x10\0\x12\x0b\n\x07DIETARY\x10\x01\x12\n\n\x06SAFETY\
    \x10\x02\x12\x0e\n\nBEHAVIORAL\x10\x03\x12\x0b\n\x07NURSING\x10\x04\x12\
    \x11\n\rPHYSIOTHERAPY\x10\x05:6\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\
    \x05*http://hl7.org/fhir/ValueSet/goal-category\"\xdf\x02\n\x10GoalPrior\
    ityCode\x12D\n\x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3.proto.Go\
    alPriorityCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.go\
    ogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\\\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x11\n\rHIGH_PRIORITY\x10\x01\
    \x12\x13\n\x0fMEDIUM_PRIORITY\x10\x02\x12\x10\n\x0cLOW_PRIORITY\x10\x03:\
    6\x8a\xf9\x83\xb2\x05*http://hl7.org/fhir/ValueSet/goal-priority\xc0\x9f\
    \xe3\xb6\x05\x01\"\x89\x03\n\x18GoalRelationshipTypeCode\x12L\n\x05value\
    \x18\x01\x20\x01(\x0e26.google.fhir.stu3.proto.GoalRelationshipTypeCode.\
    ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.\
    proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir\
    .stu3.proto.ExtensionR\textension\"m\n\x05Value\x12\x19\n\x15INVALID_UNI\
    NITIALIZED\x10\0\x12\x0f\n\x0bPREDECESSOR\x10\x01\x12\r\n\tSUCCESSOR\x10\
    \x02\x12\x0f\n\x0bREPLACEMENT\x10\x03\x12\r\n\tMILESTONE\x10\x04\x12\t\n\
    \x05OTHER\x10\x05:?\x8a\xf9\x83\xb2\x053http://hl7.org/fhir/ValueSet/goa\
    l-relationship-type\xc0\x9f\xe3\xb6\x05\x01\"\xef\x03\n\x0eGoalStatusCod\
    e\x12B\n\x05value\x18\x01\x20\x01(\x0e2,.google.fhir.stu3.proto.GoalStat\
    usCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhi\
    r.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goog\
    le.fhir.stu3.proto.ExtensionR\textension\"\xf1\x01\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08PROPOSED\x10\x01\x12\x0c\n\
    \x08ACCEPTED\x10\x02\x12\x0b\n\x07PLANNED\x10\x03\x12\x0f\n\x0bIN_PROGRE\
    SS\x10\x04\x12\r\n\tON_TARGET\x10\x05\x12\x13\n\x0fAHEAD_OF_TARGET\x10\
    \x06\x12\x11\n\rBEHIND_TARGET\x10\x07\x12\x0e\n\nSUSTAINING\x10\x08\x12\
    \x0c\n\x08ACHIEVED\x10\t\x12\x0b\n\x07ON_HOLD\x10\n\x12\r\n\tCANCELLED\
    \x10\x0b\x12\x14\n\x10ENTERED_IN_ERROR\x10\x0c\x12\x0c\n\x08REJECTED\x10\
    \r:4\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05(http://hl7.org/fhir/Val\
    ueSet/goal-status\"\xf9\x03\n\x14GoalStatusReasonCode\x12H\n\x05value\
    \x18\x01\x20\x01(\x0e22.google.fhir.stu3.proto.GoalStatusReasonCode.Valu\
    eR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.prot\
    o.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu\
    3.proto.ExtensionR\textension\"\xe8\x01\n\x05Value\x12\x19\n\x15INVALID_\
    UNINITIALIZED\x10\0\x12\x0b\n\x07SURGERY\x10\x01\x12\x0e\n\nLIFE_EVENT\
    \x10\x02\x12\x0c\n\x08REPLACED\x10\x03\x12\x13\n\x0fPATIENT_REQUEST\x10\
    \x04\x12\x17\n\x13TEMP_NOT_ATTAINABLE\x10\x05\x12\x1c\n\x18PERMANENT_NOT\
    _ATTAINABLE\x10\x06\x12\x15\n\x11FINANCIAL_BARRIER\x10\x07\x12\x1a\n\x16\
    LACK_OF_TRANSPORTATION\x10\x08\x12\x1a\n\x16LACK_OF_SOCIAL_SUPPORT\x10\t\
    :;\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05/http://hl7.org/fhir/Value\
    Set/goal-status-reason\"\xf6\x02\n\x18GraphCompartmentRuleCode\x12L\n\
    \x05value\x18\x01\x20\x01(\x0e26.google.fhir.stu3.proto.GraphCompartment\
    RuleCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.f\
    hir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.go\
    ogle.fhir.stu3.proto.ExtensionR\textension\"Z\n\x05Value\x12\x19\n\x15IN\
    VALID_UNINITIALIZED\x10\0\x12\r\n\tIDENTICAL\x10\x01\x12\x0c\n\x08MATCHI\
    NG\x10\x02\x12\r\n\tDIFFERENT\x10\x03\x12\n\n\x06CUSTOM\x10\x04:?\x8a\
    \xf9\x83\xb2\x053http://hl7.org/fhir/ValueSet/graph-compartment-rule\xc0\
    \x9f\xe3\xb6\x05\x01\"\xf1\x02\n\rGroupTypeCode\x12A\n\x05value\x18\x01\
    \x20\x01(\x0e2+.google.fhir.stu3.proto.GroupTypeCode.ValueR\x05value\x12\
    .\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"w\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\n\n\x06PERSON\x10\x01\x12\n\n\x06ANIMAL\x10\x02\x12\x10\n\x0cPRACTI\
    TIONER\x10\x03\x12\n\n\x06DEVICE\x10\x04\x12\x0e\n\nMEDICATION\x10\x05\
    \x12\r\n\tSUBSTANCE\x10\x06:3\x8a\xf9\x83\xb2\x05'http://hl7.org/fhir/Va\
    lueSet/group-type\xc0\x9f\xe3\xb6\x05\x01\"\xad\x03\n\x1aGuidanceRespons\
    eStatusCode\x12N\n\x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.prot\
    o.GuidanceResponseStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\
    \x8a\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\
    \x07SUCCESS\x10\x01\x12\x12\n\x0eDATA_REQUESTED\x10\x02\x12\x11\n\rDATA_\
    REQUIRED\x10\x03\x12\x0f\n\x0bIN_PROGRESS\x10\x04\x12\x0b\n\x07FAILURE\
    \x10\x05\x12\x14\n\x10ENTERED_IN_ERROR\x10\x06:A\x8a\xf9\x83\xb2\x055htt\
    p://hl7.org/fhir/ValueSet/guidance-response-status\xc0\x9f\xe3\xb6\x05\
    \x01\"\xd9\x02\n\x17GuideDependencyTypeCode\x12K\n\x05value\x18\x01\x20\
    \x01(\x0e25.google.fhir.stu3.proto.GuideDependencyTypeCode.ValueR\x05val\
    ue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"@\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\r\n\tREFERENCE\x10\x01\x12\r\n\tINCLUSION\x10\x02:>\x8a\xf9\
    \x83\xb2\x052http://hl7.org/fhir/ValueSet/guide-dependency-type\xc0\x9f\
    \xe3\xb6\x05\x01\"\x8e\x03\n\x11GuidePageKindCode\x12E\n\x05value\x18\
    \x01\x20\x01(\x0e2/.google.fhir.stu3.proto.GuidePageKindCode.ValueR\x05v\
    alue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Strin\
    gR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto\
    .ExtensionR\textension\"\x86\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITI\
    ALIZED\x10\0\x12\x08\n\x04PAGE\x10\x01\x12\x0b\n\x07EXAMPLE\x10\x02\x12\
    \x08\n\x04LIST\x10\x03\x12\x0b\n\x07INCLUDE\x10\x04\x12\r\n\tDIRECTORY\
    \x10\x05\x12\x0e\n\nDICTIONARY\x10\x06\x12\x07\n\x03TOC\x10\x07\x12\x0c\
    \n\x08RESOURCE\x10\x08:8\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05,htt\
    p://hl7.org/fhir/ValueSet/guide-page-kind\"\x92\x03\n\x1eFamilyHistoryNo\
    tDoneReasonCode\x12R\n\x05value\x18\x01\x20\x01(\x0e2<.google.fhir.stu3.\
    proto.FamilyHistoryNotDoneReasonCode.ValueR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"i\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x13\n\x0fSU\
    BJECT_UNKNOWN\x10\x01\x12\x0c\n\x08WITHHELD\x10\x02\x12\x14\n\x10UNABLE_\
    TO_OBTAIN\x10\x03\x12\x0c\n\x08DEFERRED\x10\x04:@\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/ValueSet/history-not-done-r\
    eason\"\xfa\x02\n\x17FamilyHistoryStatusCode\x12K\n\x05value\x18\x01\x20\
    \x01(\x0e25.google.fhir.stu3.proto.FamilyHistoryStatusCode.ValueR\x05val\
    ue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"h\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x0b\n\x07PARTIAL\x10\x01\x12\r\n\tCOMPLETED\x10\x02\x12\x14\n\
    \x10ENTERED_IN_ERROR\x10\x03\x12\x12\n\x0eHEALTH_UNKNOWN\x10\x04:7\xc0\
    \x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05+http://hl7.org/fhir/ValueSet/hi\
    story-status\"\xf5\x03\n\x10HL7WorkgroupCode\x12D\n\x05value\x18\x01\x20\
    \x01(\x0e2..google.fhir.stu3.proto.HL7WorkgroupCode.ValueR\x05value\x12.\
    \n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\xf0\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x08\n\x04CBCC\x10\x01\x12\x07\n\x03CDS\x10\x02\x12\x07\n\x03C\
    QI\x10\x03\x12\x06\n\x02CG\x10\x04\x12\x07\n\x03DEV\x10\x05\x12\x07\n\
    \x03EHR\x10\x06\x12\x08\n\x04FHIR\x10\x07\x12\x06\n\x02FM\x10\x08\x12\
    \x07\n\x03HSI\x10\t\x12\x06\n\x02II\x10\n\x12\x07\n\x03INM\x10\x0b\x12\
    \x07\n\x03ITS\x10\x0c\x12\x06\n\x02OO\x10\r\x12\x06\n\x02PA\x10\x0e\x12\
    \x06\n\x02PC\x10\x0f\x12\x08\n\x04PHER\x10\x10\x12\x07\n\x03PHX\x10\x11\
    \x12\t\n\x05RCRIM\x10\x12\x12\x06\n\x02SD\x10\x13\x12\x07\n\x03SEC\x10\
    \x14\x12\x06\n\x02US\x10\x15\x12\t\n\x05VOCAB\x10\x16\x12\x07\n\x03AID\
    \x10\x17:7\x8a\xf9\x83\xb2\x05+http://hl7.org/fhir/ValueSet/hl7-work-gro\
    up\xc0\x9f\xe3\xb6\x05\x01\"\x85\x03\n\x1fTestScriptRequestMethodCodeCod\
    e\x12S\n\x05value\x18\x01\x20\x01(\x0e2=.google.fhir.stu3.proto.TestScri\
    ptRequestMethodCodeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"b\n\x05Val\
    ue\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06DELETE\x10\x01\
    \x12\x07\n\x03GET\x10\x02\x12\x0b\n\x07OPTIONS\x10\x03\x12\t\n\x05PATCH\
    \x10\x04\x12\x08\n\x04POST\x10\x05\x12\x07\n\x03PUT\x10\x06:8\x8a\xf9\
    \x83\xb2\x05,http://hl7.org/fhir/ValueSet/http-operations\xc0\x9f\xe3\
    \xb6\x05\x01\"\xf1\x02\n\x0cHTTPVerbCode\x12@\n\x05value\x18\x01\x20\x01\
    (\x0e2*.google.fhir.stu3.proto.HTTPVerbCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"z\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x12\n\
    \x03GET\x10\x01\x1a\t\xba\x96\xbb\xb2\x05\x03GET\x12\x14\n\x04POST\x10\
    \x02\x1a\n\xba\x96\xbb\xb2\x05\x04POST\x12\x12\n\x03PUT\x10\x03\x1a\t\
    \xba\x96\xbb\xb2\x05\x03PUT\x12\x18\n\x06DELETE\x10\x04\x1a\x0c\xba\x96\
    \xbb\xb2\x05\x06DELETE:2\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05&htt\
    p://hl7.org/fhir/ValueSet/http-verb\"\xf3\x02\n\x1aIdentityAssuranceLeve\
    lCode\x12N\n\x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.Iden\
    tityAssuranceLevelCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b\
    2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"R\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06LEVEL1\x10\x01\x12\
    \n\n\x06LEVEL2\x10\x02\x12\n\n\x06LEVEL3\x10\x03\x12\n\n\x06LEVEL4\x10\
    \x04:@\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/ValueSet/identity-assuran\
    ceLevel\xc0\x9f\xe3\xb6\x05\x01\"\xf3\x02\n\x1bImmunizationOriginCodesCo\
    de\x12O\n\x05value\x18\x01\x20\x01(\x0e29.google.fhir.stu3.proto.Immuniz\
    ationOriginCodesCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"T\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08PROVIDER\x10\x01\
    \x12\n\n\x06RECORD\x10\x02\x12\n\n\x06RECALL\x10\x03\x12\n\n\x06SCHOOL\
    \x10\x04:<\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x050http://hl7.org/fh\
    ir/ValueSet/immunization-origin\"\xc3\x03\n0ImmunizationRecommendationDa\
    teCriterionCodesCode\x12d\n\x05value\x18\x01\x20\x01(\x0e2N.google.fhir.\
    stu3.proto.ImmunizationRecommendationDateCriterionCodesCode.ValueR\x05va\
    lue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.String\
    R\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.\
    ExtensionR\textension\"c\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x07\n\x03DUE\x10\x01\x12\x0f\n\x0bRECOMMENDED\x10\x02\x12\x0c\
    \n\x08EARLIEST\x10\x03\x12\x0b\n\x07OVERDUE\x10\x04\x12\n\n\x06LATEST\
    \x10\x05:S\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05Ghttp://hl7.org/fh\
    ir/ValueSet/immunization-recommendation-date-criterion\"\x82\x03\n)Immun\
    izationRecommendationStatusCodesCode\x12]\n\x05value\x18\x01\x20\x01(\
    \x0e2G.google.fhir.stu3.proto.ImmunizationRecommendationStatusCodesCode.\
    ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.\
    proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir\
    .stu3.proto.ExtensionR\textension\"8\n\x05Value\x12\x19\n\x15INVALID_UNI\
    NITIALIZED\x10\0\x12\x07\n\x03DUE\x10\x01\x12\x0b\n\x07OVERDUE\x10\x02:K\
    \x8a\xf9\x83\xb2\x05?http://hl7.org/fhir/ValueSet/immunization-recommend\
    ation-status\xc0\x9f\xe3\xb6\x05\x01\"\xe6\x02\n\x1bImmunizationStatusCo\
    desCode\x12O\n\x05value\x18\x01\x20\x01(\x0e29.google.fhir.stu3.proto.Im\
    munizationStatusCodesCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"G\n\x05Val\
    ue\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\r\n\tCOMPLETED\x10\x01\
    \x12\x14\n\x10ENTERED_IN_ERROR\x10\x02:<\x8a\xf9\x83\xb2\x050http://hl7.\
    org/fhir/ValueSet/immunization-status\xc0\x9f\xe3\xb6\x05\x01\"\xe7\x02\
    \n\x11ImplantStatusCode\x12E\n\x05value\x18\x01\x20\x01(\x0e2/.google.fh\
    ir.stu3.proto.ImplantStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"a\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0e\n\nFUNCTION\
    AL\x10\x01\x12\x12\n\x0eNON_FUNCTIONAL\x10\x02\x12\x0c\n\x08DISABLED\x10\
    \x03\x12\x0b\n\x07UNKNOWN\x10\x04:7\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\
    \xb2\x05+http://hl7.org/fhir/ValueSet/implant-status\"\xb6\x03\n\x18Inst\
    anceAvailabilityCode\x12L\n\x05value\x18\x01\x20\x01(\x0e26.google.fhir.\
    stu3.proto.InstanceAvailabilityCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\
    \x9a\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x18\n\
    \x06ONLINE\x10\x01\x1a\x0c\xba\x96\xbb\xb2\x05\x06ONLINE\x12\x1a\n\x07OF\
    FLINE\x10\x02\x1a\r\xba\x96\xbb\xb2\x05\x07OFFLINE\x12\x1c\n\x08NEARLINE\
    \x10\x03\x1a\x0e\xba\x96\xbb\xb2\x05\x08NEARLINE\x12\"\n\x0bUNAVAILABLE\
    \x10\x04\x1a\x11\xba\x96\xbb\xb2\x05\x0bUNAVAILABLE:>\x8a\xf9\x83\xb2\
    \x052http://hl7.org/fhir/ValueSet/instance-availability\xc0\x9f\xe3\xb6\
    \x05\x01\"\xdc\x02\n\x11IssueSeverityCode\x12E\n\x05value\x18\x01\x20\
    \x01(\x0e2/.google.fhir.stu3.proto.IssueSeverityCode.ValueR\x05value\x12\
    .\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"V\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\t\n\x05FATAL\x10\x01\x12\t\n\x05ERROR\x10\x02\x12\x0b\n\x07WARNING\
    \x10\x03\x12\x0f\n\x0bINFORMATION\x10\x04:7\x8a\xf9\x83\xb2\x05+http://h\
    l7.org/fhir/ValueSet/issue-severity\xc0\x9f\xe3\xb6\x05\x01\"\xcf\x05\n\
    \rIssueTypeCode\x12A\n\x05value\x18\x01\x20\x01(\x0e2+.google.fhir.stu3.\
    proto.IssueTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\xd4\x03\n\x05\
    Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07INVALID\x10\
    \x01\x12\r\n\tSTRUCTURE\x10\x02\x12\x0c\n\x08REQUIRED\x10\x03\x12\t\n\
    \x05VALUE\x10\x04\x12\r\n\tINVARIANT\x10\x05\x12\x0c\n\x08SECURITY\x10\
    \x06\x12\t\n\x05LOGIN\x10\x07\x12\x0b\n\x07UNKNOWN\x10\x08\x12\x0b\n\x07\
    EXPIRED\x10\t\x12\r\n\tFORBIDDEN\x10\n\x12\x0e\n\nSUPPRESSED\x10\x0b\x12\
    \x0e\n\nPROCESSING\x10\x0c\x12\x11\n\rNOT_SUPPORTED\x10\r\x12\r\n\tDUPLI\
    CATE\x10\x0e\x12\r\n\tNOT_FOUND\x10\x0f\x12\x0c\n\x08TOO_LONG\x10\x10\
    \x12\x10\n\x0cCODE_INVALID\x10\x11\x12\r\n\tEXTENSION\x10\x12\x12\x0e\n\
    \nTOO_COSTLY\x10\x13\x12\x11\n\rBUSINESS_RULE\x10\x14\x12\x0c\n\x08CONFL\
    ICT\x10\x15\x12\x0e\n\nINCOMPLETE\x10\x16\x12\r\n\tTRANSIENT\x10\x17\x12\
    \x0e\n\nLOCK_ERROR\x10\x18\x12\x0c\n\x08NO_STORE\x10\x19\x12\r\n\tEXCEPT\
    ION\x10\x1a\x12\x0b\n\x07TIMEOUT\x10\x1b\x12\r\n\tTHROTTLED\x10\x1c\x12\
    \x11\n\rINFORMATIONAL\x10\x1d:3\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\
    \x05'http://hl7.org/fhir/ValueSet/issue-type\"\x9d\x04\n\x19Questionnair\
    eItemTypeCode\x12M\n\x05value\x18\x01\x20\x01(\x0e27.google.fhir.stu3.pr\
    oto.QuestionnaireItemTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\
    \x8b\x02\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05\
    GROUP\x10\x01\x12\x0b\n\x07DISPLAY\x10\x02\x12\x0c\n\x08QUESTION\x10\x03\
    \x12\x0b\n\x07BOOLEAN\x10\x04\x12\x0b\n\x07DECIMAL\x10\x05\x12\x0b\n\x07\
    INTEGER\x10\x06\x12\x08\n\x04DATE\x10\x07\x12\x1d\n\tDATE_TIME\x10\x08\
    \x1a\x0e\xba\x96\xbb\xb2\x05\x08dateTime\x12\x08\n\x04TIME\x10\t\x12\n\n\
    \x06STRING\x10\n\x12\x08\n\x04TEXT\x10\x0b\x12\x07\n\x03URL\x10\x0c\x12\
    \n\n\x06CHOICE\x10\r\x12\x0f\n\x0bOPEN_CHOICE\x10\x0e\x12\x0e\n\nATTACHM\
    ENT\x10\x0f\x12\r\n\tREFERENCE\x10\x10\x12\x0c\n\x08QUANTITY\x10\x11:2\
    \xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05&http://hl7.org/fhir/ValueSe\
    t/item-type\"\xf8\x02\n\x0fLibraryTypeCode\x12C\n\x05value\x18\x01\x20\
    \x01(\x0e2-.google.fhir.stu3.proto.LibraryTypeCode.ValueR\x05value\x12.\
    \n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"x\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x11\n\rLOGIC_LIBRARY\x10\x01\x12\x14\n\x10MODEL_DEFINITION\x10\x02\
    \x12\x14\n\x10ASSET_COLLECTION\x10\x03\x12\x15\n\x11MODULE_DEFINITION\
    \x10\x04:5\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05)http://hl7.org/fh\
    ir/ValueSet/library-type\"\xcd\x02\n\x0fLinkageTypeCode\x12C\n\x05value\
    \x18\x01\x20\x01(\x0e2-.google.fhir.stu3.proto.LinkageTypeCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"M\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\n\n\x06SOURCE\x10\x01\x12\r\n\tALTERNATE\x10\x02\x12\x0e\
    \n\nHISTORICAL\x10\x03:5\x8a\xf9\x83\xb2\x05)http://hl7.org/fhir/ValueSe\
    t/linkage-type\xc0\x9f\xe3\xb6\x05\x01\"\xd0\x02\n\x0cLinkTypeCode\x12@\
    \n\x05value\x18\x01\x20\x01(\x0e2*.google.fhir.stu3.proto.LinkTypeCode.V\
    alueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.p\
    roto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.\
    stu3.proto.ExtensionR\textension\"Y\n\x05Value\x12\x19\n\x15INVALID_UNIN\
    ITIALIZED\x10\0\x12\x0f\n\x0bREPLACED_BY\x10\x01\x12\x0c\n\x08REPLACES\
    \x10\x02\x12\t\n\x05REFER\x10\x03\x12\x0b\n\x07SEEALSO\x10\x04:2\x8a\xf9\
    \x83\xb2\x05&http://hl7.org/fhir/ValueSet/link-type\xc0\x9f\xe3\xb6\x05\
    \x01\"\x88\x03\n\x14ListEmptyReasonsCode\x12H\n\x05value\x18\x01\x20\x01\
    (\x0e22.google.fhir.stu3.proto.ListEmptyReasonsCode.ValueR\x05value\x12.\
    \n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"y\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x0c\n\x08NILKNOWN\x10\x01\x12\x0c\n\x08NOTASKED\x10\x02\x12\x0c\n\
    \x08WITHHELD\x10\x03\x12\x0f\n\x0bUNAVAILABLE\x10\x04\x12\x0e\n\nNOTSTAR\
    TED\x10\x05\x12\n\n\x06CLOSED\x10\x06::\x8a\xf9\x83\xb2\x05.http://hl7.o\
    rg/fhir/ValueSet/list-empty-reason\xc0\x9f\xe3\xb6\x05\x01\"\xbf\x03\n\
    \x1aExampleUseCodesforListCode\x12N\n\x05value\x18\x01\x20\x01(\x0e28.go\
    ogle.fhir.stu3.proto.ExampleUseCodesforListCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\xa2\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\n\n\x06ALERTS\x10\x01\x12\x0f\n\x0bADVERSERXNS\x10\x02\x12\r\
    \n\tALLERGIES\x10\x03\x12\x0f\n\x0bMEDICATIONS\x10\x04\x12\x0c\n\x08PROB\
    LEMS\x10\x05\x12\x0c\n\x08WORKLIST\x10\x06\x12\x0b\n\x07WAITING\x10\x07\
    \x12\r\n\tPROTOCOLS\x10\x08\x12\t\n\x05PLANS\x10\t:;\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x05/http://hl7.org/fhir/ValueSet/list-example-codes\
    \"\xc1\x02\n\x0cListModeCode\x12@\n\x05value\x18\x01\x20\x01(\x0e2*.goog\
    le.fhir.stu3.proto.ListModeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"J\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07WORKIN\
    G\x10\x01\x12\x0c\n\x08SNAPSHOT\x10\x02\x12\x0b\n\x07CHANGES\x10\x03:2\
    \xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05&http://hl7.org/fhir/ValueSe\
    t/list-mode\"\x96\x03\n\x12ListOrderCodesCode\x12F\n\x05value\x18\x01\
    \x20\x01(\x0e20.google.fhir.stu3.proto.ListOrderCodesCode.ValueR\x05valu\
    e\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"\x91\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x08\n\x04USER\x10\x01\x12\n\n\x06SYSTEM\x10\x02\x12\x0e\n\
    \nEVENT_DATE\x10\x03\x12\x0e\n\nENTRY_DATE\x10\x04\x12\x0c\n\x08PRIORITY\
    \x10\x05\x12\x0e\n\nALPHABETIC\x10\x06\x12\x0c\n\x08CATEGORY\x10\x07\x12\
    \x0b\n\x07PATIENT\x10\x08:3\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05'\
    http://hl7.org/fhir/ValueSet/list-order\"\xcf\x02\n\x0eListStatusCode\
    \x12B\n\x05value\x18\x01\x20\x01(\x0e2,.google.fhir.stu3.proto.ListStatu\
    sCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir\
    .stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.googl\
    e.fhir.stu3.proto.ExtensionR\textension\"R\n\x05Value\x12\x19\n\x15INVAL\
    ID_UNINITIALIZED\x10\0\x12\x0b\n\x07CURRENT\x10\x01\x12\x0b\n\x07RETIRED\
    \x10\x02\x12\x14\n\x10ENTERED_IN_ERROR\x10\x03:4\x8a\xf9\x83\xb2\x05(htt\
    p://hl7.org/fhir/ValueSet/list-status\xc0\x9f\xe3\xb6\x05\x01\"\xbd\x02\
    \n\x10LocationModeCode\x12D\n\x05value\x18\x01\x20\x01(\x0e2..google.fhi\
    r.stu3.proto.LocationModeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\":\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08INSTAN\
    CE\x10\x01\x12\x08\n\x04KIND\x10\x02:6\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\
    \x83\xb2\x05*http://hl7.org/fhir/ValueSet/location-mode\"\xa3\x03\n\x10L\
    ocationTypeCode\x12D\n\x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3.\
    proto.LocationTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b\
    2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\x96\x01\n\x05\
    Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x06\n\x02SI\x10\x01\
    \x12\x06\n\x02BU\x10\x02\x12\x06\n\x02WI\x10\x03\x12\x06\n\x02WA\x10\x04\
    \x12\x07\n\x03LVL\x10\x05\x12\x06\n\x02CO\x10\x06\x12\x06\n\x02RO\x10\
    \x07\x12\x06\n\x02BD\x10\x08\x12\x06\n\x02VE\x10\t\x12\x06\n\x02HO\x10\n\
    \x12\x06\n\x02CA\x10\x0b\x12\x06\n\x02RD\x10\x0c\x12\x08\n\x04AREA\x10\r\
    \x12\x07\n\x03JDN\x10\x0e:?\x8a\xf9\x83\xb2\x053http://hl7.org/fhir/Valu\
    eSet/location-physical-type\xc0\x9f\xe3\xb6\x05\x01\"\xd4\x02\n\x12Locat\
    ionStatusCode\x12F\n\x05value\x18\x01\x20\x01(\x0e20.google.fhir.stu3.pr\
    oto.LocationStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b\
    2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"K\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\
    \r\n\tSUSPENDED\x10\x02\x12\x0c\n\x08INACTIVE\x10\x03:8\x8a\xf9\x83\xb2\
    \x05,http://hl7.org/fhir/ValueSet/location-status\xc0\x9f\xe3\xb6\x05\
    \x01\"\xe8\x03\n\x1fProbabilityDistributionTypeCode\x12S\n\x05value\x18\
    \x01\x20\x01(\x0e2=.google.fhir.stu3.proto.ProbabilityDistributionTypeCo\
    de.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.st\
    u3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.f\
    hir.stu3.proto.ExtensionR\textension\"\xb6\x01\n\x05Value\x12\x19\n\x15I\
    NVALID_UNINITIALIZED\x10\0\x12\x0e\n\x01B\x10\x01\x1a\x07\xba\x96\xbb\
    \xb2\x05\x01B\x12\x0e\n\x01E\x10\x02\x1a\x07\xba\x96\xbb\xb2\x05\x01E\
    \x12\x0e\n\x01F\x10\x03\x1a\x07\xba\x96\xbb\xb2\x05\x01F\x12\x0e\n\x01G\
    \x10\x04\x1a\x07\xba\x96\xbb\xb2\x05\x01G\x12\x10\n\x02LN\x10\x05\x1a\
    \x08\xba\x96\xbb\xb2\x05\x02LN\x12\x0e\n\x01N\x10\x06\x1a\x07\xba\x96\
    \xbb\xb2\x05\x01N\x12\x0e\n\x01T\x10\x07\x1a\x07\xba\x96\xbb\xb2\x05\x01\
    T\x12\x0e\n\x01U\x10\x08\x1a\x07\xba\x96\xbb\xb2\x05\x01U\x12\x10\n\x02X\
    2\x10\t\x1a\x08\xba\x96\xbb\xb2\x05\x02X2:F\xc0\x9f\xe3\xb6\x05\x01\x8a\
    \xf9\x83\xb2\x05:http://hl7.org/fhir/ValueSet/probability-distribution-t\
    ype\"\xd6\x02\n\x1bStructureMapContextTypeCode\x12O\n\x05value\x18\x01\
    \x20\x01(\x0e29.google.fhir.stu3.proto.StructureMapContextTypeCode.Value\
    R\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto\
    .StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3\
    .proto.ExtensionR\textension\":\n\x05Value\x12\x19\n\x15INVALID_UNINITIA\
    LIZED\x10\0\x12\x08\n\x04TYPE\x10\x01\x12\x0c\n\x08VARIABLE\x10\x02:9\
    \x8a\xf9\x83\xb2\x05-http://hl7.org/fhir/ValueSet/map-context-type\xc0\
    \x9f\xe3\xb6\x05\x01\"\xee\x02\n\x1dStructureMapGroupTypeModeCode\x12Q\n\
    \x05value\x18\x01\x20\x01(\x0e2;.google.fhir.stu3.proto.StructureMapGrou\
    pTypeModeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goo\
    gle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b\
    2!.google.fhir.stu3.proto.ExtensionR\textension\"K\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04NONE\x10\x01\x12\t\n\x05TYP\
    ES\x10\x02\x12\x12\n\x0eTYPE_AND_TYPES\x10\x03:<\x8a\xf9\x83\xb2\x050htt\
    p://hl7.org/fhir/ValueSet/map-group-type-mode\xc0\x9f\xe3\xb6\x05\x01\"\
    \xd0\x02\n\x19StructureMapInputModeCode\x12M\n\x05value\x18\x01\x20\x01(\
    \x0e27.google.fhir.stu3.proto.StructureMapInputModeCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\":\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\n\n\x06SOURCE\x10\x01\x12\n\n\x06TARGET\x10\x02:7\xc0\x9f\xe3\
    \xb6\x05\x01\x8a\xf9\x83\xb2\x05+http://hl7.org/fhir/ValueSet/map-input-\
    mode\"\xeb\x02\n\x19StructureMapModelModeCode\x12M\n\x05value\x18\x01\
    \x20\x01(\x0e27.google.fhir.stu3.proto.StructureMapModelModeCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"U\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\n\n\x06SOURCE\x10\x01\x12\x0b\n\x07QUERIED\x10\x02\x12\n\
    \n\x06TARGET\x10\x03\x12\x0c\n\x08PRODUCED\x10\x04:7\x8a\xf9\x83\xb2\x05\
    +http://hl7.org/fhir/ValueSet/map-model-mode\xc0\x9f\xe3\xb6\x05\x01\"\
    \xba\x03\n\x1eStructureMapSourceListModeCode\x12R\n\x05value\x18\x01\x20\
    \x01(\x0e2<.google.fhir.stu3.proto.StructureMapSourceListModeCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"\x93\x01\n\x05Value\x12\x19\n\x15INVALID_UN\
    INITIALIZED\x10\0\x12\t\n\x05FIRST\x10\x01\x12\x1e\n\tNOT_FIRST\x10\x02\
    \x1a\x0f\xba\x96\xbb\xb2\x05\tnot_first\x12\x08\n\x04LAST\x10\x03\x12\
    \x1c\n\x08NOT_LAST\x10\x04\x1a\x0e\xba\x96\xbb\xb2\x05\x08not_last\x12\
    \x1c\n\x08ONLY_ONE\x10\x05\x1a\x0e\xba\x96\xbb\xb2\x05\x08only_one:=\xc0\
    \x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x051http://hl7.org/fhir/ValueSet/ma\
    p-source-list-mode\"\xf5\x02\n\x1eStructureMapTargetListModeCode\x12R\n\
    \x05value\x18\x01\x20\x01(\x0e2<.google.fhir.stu3.proto.StructureMapTarg\
    etListModeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.go\
    ogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"O\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05FIRST\x10\x01\x12\t\n\
    \x05SHARE\x10\x02\x12\x08\n\x04LAST\x10\x03\x12\x0b\n\x07COLLATE\x10\x04\
    :=\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x051http://hl7.org/fhir/Value\
    Set/map-target-list-mode\"\x84\x04\n\x19StructureMapTransformCode\x12M\n\
    \x05value\x18\x01\x20\x01(\x0e27.google.fhir.stu3.proto.StructureMapTran\
    sformCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.\
    fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.g\
    oogle.fhir.stu3.proto.ExtensionR\textension\"\xee\x01\n\x05Value\x12\x19\
    \n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06CREATE\x10\x01\x12\x08\n\
    \x04COPY\x10\x02\x12\x0c\n\x08TRUNCATE\x10\x03\x12\n\n\x06ESCAPE\x10\x04\
    \x12\x08\n\x04CAST\x10\x05\x12\n\n\x06APPEND\x10\x06\x12\r\n\tTRANSLATE\
    \x10\x07\x12\r\n\tREFERENCE\x10\x08\x12\x19\n\x07DATE_OP\x10\t\x1a\x0c\
    \xba\x96\xbb\xb2\x05\x06dateOp\x12\x08\n\x04UUID\x10\n\x12\x0b\n\x07POIN\
    TER\x10\x0b\x12\x0c\n\x08EVALUATE\x10\x0c\x12\x06\n\x02CC\x10\r\x12\x05\
    \n\x01C\x10\x0e\x12\x07\n\x03QTY\x10\x0f\x12\x06\n\x02ID\x10\x10\x12\x06\
    \n\x02CP\x10\x11:6\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05*http://hl\
    7.org/fhir/ValueSet/map-transform\"\xdb\x02\n\x0eMatchGradeCode\x12B\n\
    \x05value\x18\x01\x20\x01(\x0e2,.google.fhir.stu3.proto.MatchGradeCode.V\
    alueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.p\
    roto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.\
    stu3.proto.ExtensionR\textension\"^\n\x05Value\x12\x19\n\x15INVALID_UNIN\
    ITIALIZED\x10\0\x12\x0b\n\x07CERTAIN\x10\x01\x12\x0c\n\x08PROBABLE\x10\
    \x02\x12\x0c\n\x08POSSIBLE\x10\x03\x12\x11\n\rCERTAINLY_NOT\x10\x04:4\
    \x8a\xf9\x83\xb2\x05(http://hl7.org/fhir/ValueSet/match-grade\xc0\x9f\
    \xe3\xb6\x05\x01\"\xe5\x02\n\x14MeasureDataUsageCode\x12H\n\x05value\x18\
    \x01\x20\x01(\x0e22.google.fhir.stu3.proto.MeasureDataUsageCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"U\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x15\n\x11SUPPLEMENTAL_DATA\x10\x01\x12\x1a\n\x16RISK_ADJU\
    STMENT_FACTOR\x10\x02:;\x8a\xf9\x83\xb2\x05/http://hl7.org/fhir/ValueSet\
    /measure-data-usage\xc0\x9f\xe3\xb6\x05\x01\"\xd1\x03\n\x14MeasmntPrinci\
    pleCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.google.fhir.stu3.proto.Me\
    asmntPrincipleCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\xbd\x01\n\x05\
    Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05OTHER\x10\x01\
    \x12\x0c\n\x08CHEMICAL\x10\x02\x12\x0e\n\nELECTRICAL\x10\x03\x12\r\n\tIM\
    PEDANCE\x10\x04\x12\x0b\n\x07NUCLEAR\x10\x05\x12\x0b\n\x07OPTICAL\x10\
    \x06\x12\x0b\n\x07THERMAL\x10\x07\x12\x0e\n\nBIOLOGICAL\x10\x08\x12\x0e\
    \n\nMECHANICAL\x10\t\x12\x0e\n\nACOUSTICAL\x10\n\x12\n\n\x06MANUAL\x10\
    \x0b:>\x8a\xf9\x83\xb2\x052http://hl7.org/fhir/ValueSet/measurement-prin\
    ciple\xc0\x9f\xe3\xb6\x05\x01\"\x97\x04\n\x19MeasurePopulationTypeCode\
    \x12M\n\x05value\x18\x01\x20\x01(\x0e27.google.fhir.stu3.proto.MeasurePo\
    pulationTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.\
    google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\xfc\x01\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x16\n\x12INITIAL_POPULATIO\
    N\x10\x01\x12\r\n\tNUMERATOR\x10\x02\x12\x17\n\x13NUMERATOR_EXCLUSION\
    \x10\x03\x12\x0f\n\x0bDENOMINATOR\x10\x04\x12\x19\n\x15DENOMINATOR_EXCLU\
    SION\x10\x05\x12\x19\n\x15DENOMINATOR_EXCEPTION\x10\x06\x12\x16\n\x12MEA\
    SURE_POPULATION\x10\x07\x12\x20\n\x1cMEASURE_POPULATION_EXCLUSION\x10\
    \x08\x12\x17\n\x13MEASURE_OBSERVATION\x10\t:;\xc0\x9f\xe3\xb6\x05\x01\
    \x8a\xf9\x83\xb2\x05/http://hl7.org/fhir/ValueSet/measure-population\"\
    \xe1\x02\n\x17MeasureReportStatusCode\x12K\n\x05value\x18\x01\x20\x01(\
    \x0e25.google.fhir.stu3.proto.MeasureReportStatusCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"H\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x0c\n\x08COMPLETE\x10\x01\x12\x0b\n\x07PENDING\x10\x02\x12\t\
    \n\x05ERROR\x10\x03:>\x8a\xf9\x83\xb2\x052http://hl7.org/fhir/ValueSet/m\
    easure-report-status\xc0\x9f\xe3\xb6\x05\x01\"\xe4\x02\n\x15MeasureRepor\
    tTypeCode\x12I\n\x05value\x18\x01\x20\x01(\x0e23.google.fhir.stu3.proto.\
    MeasureReportTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"Q\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0e\n\nINDIVIDUAL\x10\x01\
    \x12\x10\n\x0cPATIENT_LIST\x10\x02\x12\x0b\n\x07SUMMARY\x10\x03:<\x8a\
    \xf9\x83\xb2\x050http://hl7.org/fhir/ValueSet/measure-report-type\xc0\
    \x9f\xe3\xb6\x05\x01\"\xeb\x02\n\x12MeasureScoringCode\x12F\n\x05value\
    \x18\x01\x20\x01(\x0e20.google.fhir.stu3.proto.MeasureScoringCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"b\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x0e\n\nPROPORTION\x10\x01\x12\t\n\x05RATIO\x10\x02\x12\
    \x17\n\x13CONTINUOUS_VARIABLE\x10\x03\x12\n\n\x06COHORT\x10\x04:8\x8a\
    \xf9\x83\xb2\x05,http://hl7.org/fhir/ValueSet/measure-scoring\xc0\x9f\
    \xe3\xb6\x05\x01\"\xf8\x02\n\x0fMeasureTypeCode\x12C\n\x05value\x18\x01\
    \x20\x01(\x0e2-.google.fhir.stu3.proto.MeasureTypeCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"x\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x0b\n\x07PROCESS\x10\x01\x12\x0b\n\x07OUTCOME\x10\x02\x12\r\n\
    \tSTRUCTURE\x10\x03\x12\x1c\n\x18PATIENT_REPORTED_OUTCOME\x10\x04\x12\r\
    \n\tCOMPOSITE\x10\x05:5\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05)http\
    ://hl7.org/fhir/ValueSet/measure-type\"\x87\x03\n$MedicationAdministrati\
    onCategoryCode\x12X\n\x05value\x18\x01\x20\x01(\x0e2B.google.fhir.stu3.p\
    roto.MedicationAdministrationCategoryCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"P\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\r\n\tIN\
    PATIENT\x10\x01\x12\x0e\n\nOUTPATIENT\x10\x02\x12\r\n\tCOMMUNITY\x10\x03\
    :B\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x056http://hl7.org/fhir/Value\
    Set/medication-admin-category\"\xb0\x03\n\"MedicationAdministrationStatu\
    sCode\x12V\n\x05value\x18\x01\x20\x01(\x0e2@.google.fhir.stu3.proto.Medi\
    cationAdministrationStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\
    \x7f\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0f\n\x0bIN\
    _PROGRESS\x10\x01\x12\x0b\n\x07ON_HOLD\x10\x02\x12\r\n\tCOMPLETED\x10\
    \x03\x12\x14\n\x10ENTERED_IN_ERROR\x10\x04\x12\x0b\n\x07STOPPED\x10\x05\
    \x12\x0b\n\x07UNKNOWN\x10\x06:@\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\
    \x054http://hl7.org/fhir/ValueSet/medication-admin-status\"\xfe\x02\n\
    \x1eMedicationDispenseCategoryCode\x12R\n\x05value\x18\x01\x20\x01(\x0e2\
    <.google.fhir.stu3.proto.MedicationDispenseCategoryCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"P\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\r\n\tINPATIENT\x10\x01\x12\x0e\n\nOUTPATIENT\x10\x02\x12\r\n\
    \tCOMMUNITY\x10\x03:E\x8a\xf9\x83\xb2\x059http://hl7.org/fhir/ValueSet/m\
    edication-dispense-category\xc0\x9f\xe3\xb6\x05\x01\"\xac\x03\n\x1cMedic\
    ationDispenseStatusCode\x12P\n\x05value\x18\x01\x20\x01(\x0e2:.google.fh\
    ir.stu3.proto.MedicationDispenseStatusCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"\x83\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\
    \x0f\n\x0bPREPARATION\x10\x01\x12\x0f\n\x0bIN_PROGRESS\x10\x02\x12\x0b\n\
    \x07ON_HOLD\x10\x03\x12\r\n\tCOMPLETED\x10\x04\x12\x14\n\x10ENTERED_IN_E\
    RROR\x10\x05\x12\x0b\n\x07STOPPED\x10\x06:C\x8a\xf9\x83\xb2\x057http://h\
    l7.org/fhir/ValueSet/medication-dispense-status\xc0\x9f\xe3\xb6\x05\x01\
    \"\xa0\x03\n\x17MedicationContainerCode\x12K\n\x05value\x18\x01\x20\x01(\
    \x0e25.google.fhir.stu3.proto.MedicationContainerCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"\x84\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x0b\n\x07AMPOULE\x10\x01\x12\n\n\x06BOTTLE\x10\x02\x12\
    \x07\n\x03BOX\x10\x03\x12\r\n\tCARTRIDGE\x10\x04\x12\r\n\tCONTAINER\x10\
    \x05\x12\x08\n\x04TUBE\x10\x06\x12\x0c\n\x08UNITDOSE\x10\x07\x12\x08\n\
    \x04VIAL\x10\x08:@\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x054http://hl\
    7.org/fhir/ValueSet/medication-package-form\"\xfb\x02\n\x1dMedicationReq\
    uestCategoryCode\x12Q\n\x05value\x18\x01\x20\x01(\x0e2;.google.fhir.stu3\
    .proto.MedicationRequestCategoryCode.ValueR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"P\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\r\n\tINPATI\
    ENT\x10\x01\x12\x0e\n\nOUTPATIENT\x10\x02\x12\r\n\tCOMMUNITY\x10\x03:D\
    \x8a\xf9\x83\xb2\x058http://hl7.org/fhir/ValueSet/medication-request-cat\
    egory\xc0\x9f\xe3\xb6\x05\x01\"\xfe\x02\n\x1bMedicationRequestIntentCode\
    \x12O\n\x05value\x18\x01\x20\x01(\x0e29.google.fhir.stu3.proto.Medicatio\
    nRequestIntentCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"Y\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08PROPOSAL\x10\x01\
    \x12\x08\n\x04PLAN\x10\x02\x12\t\n\x05ORDER\x10\x03\x12\x12\n\x0eINSTANC\
    E_ORDER\x10\x04:B\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x056http://hl7\
    .org/fhir/ValueSet/medication-request-intent\"\xfa\x02\n\x1dMedicationRe\
    questPriorityCode\x12Q\n\x05value\x18\x01\x20\x01(\x0e2;.google.fhir.stu\
    3.proto.MedicationRequestPriorityCode.ValueR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"O\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07RO\
    UTINE\x10\x01\x12\n\n\x06URGENT\x10\x02\x12\x08\n\x04STAT\x10\x03\x12\
    \x08\n\x04ASAP\x10\x04:D\x8a\xf9\x83\xb2\x058http://hl7.org/fhir/ValueSe\
    t/medication-request-priority\xc0\x9f\xe3\xb6\x05\x01\"\xba\x03\n\x1bMed\
    icationRequestStatusCode\x12O\n\x05value\x18\x01\x20\x01(\x0e29.google.f\
    hir.stu3.proto.MedicationRequestStatusCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"\x94\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\
    \n\n\x06ACTIVE\x10\x01\x12\x0b\n\x07ON_HOLD\x10\x02\x12\r\n\tCANCELLED\
    \x10\x03\x12\r\n\tCOMPLETED\x10\x04\x12\x14\n\x10ENTERED_IN_ERROR\x10\
    \x05\x12\x0b\n\x07STOPPED\x10\x06\x12\t\n\x05DRAFT\x10\x07\x12\x0b\n\x07\
    UNKNOWN\x10\x08:B\x8a\xf9\x83\xb2\x056http://hl7.org/fhir/ValueSet/medic\
    ation-request-status\xc0\x9f\xe3\xb6\x05\x01\"\x97\x03\n\x1fMedicationSt\
    atementCategoryCode\x12S\n\x05value\x18\x01\x20\x01(\x0e2=.google.fhir.s\
    tu3.proto.MedicationStatementCategoryCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"f\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\r\n\tIN\
    PATIENT\x10\x01\x12\x0e\n\nOUTPATIENT\x10\x02\x12\r\n\tCOMMUNITY\x10\x03\
    \x12\x14\n\x10PATIENTSPECIFIED\x10\x04:F\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\
    \x83\xb2\x05:http://hl7.org/fhir/ValueSet/medication-statement-category\
    \"\xa6\x03\n\x1dMedicationStatementStatusCode\x12Q\n\x05value\x18\x01\
    \x20\x01(\x0e2;.google.fhir.stu3.proto.MedicationStatementStatusCode.Val\
    ueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.pro\
    to.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.st\
    u3.proto.ExtensionR\textension\"{\n\x05Value\x12\x19\n\x15INVALID_UNINIT\
    IALIZED\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\r\n\tCOMPLETED\x10\x02\x12\
    \x14\n\x10ENTERED_IN_ERROR\x10\x03\x12\x0c\n\x08INTENDED\x10\x04\x12\x0b\
    \n\x07STOPPED\x10\x05\x12\x0b\n\x07ON_HOLD\x10\x06:D\x8a\xf9\x83\xb2\x05\
    8http://hl7.org/fhir/ValueSet/medication-statement-status\xc0\x9f\xe3\
    \xb6\x05\x01\"\xe9\x02\n\x1cMedicationStatementTakenCode\x12P\n\x05value\
    \x18\x01\x20\x01(\x0e2:.google.fhir.stu3.proto.MedicationStatementTakenC\
    ode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.s\
    tu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.\
    fhir.stu3.proto.ExtensionR\textension\"A\n\x05Value\x12\x19\n\x15INVALID\
    _UNINITIALIZED\x10\0\x12\x05\n\x01Y\x10\x01\x12\x05\n\x01N\x10\x02\x12\
    \x07\n\x03UNK\x10\x03\x12\x06\n\x02NA\x10\x04:C\xc0\x9f\xe3\xb6\x05\x01\
    \x8a\xf9\x83\xb2\x057http://hl7.org/fhir/ValueSet/medication-statement-t\
    aken\"\xe1\x02\n\x14MedicationStatusCode\x12H\n\x05value\x18\x01\x20\x01\
    (\x0e22.google.fhir.stu3.proto.MedicationStatusCode.ValueR\x05value\x12.\
    \n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"R\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\n\n\x06ACTIVE\x10\x01\x12\x0c\n\x08INACTIVE\x10\x02\x12\x14\n\x10EN\
    TERED_IN_ERROR\x10\x03::\x8a\xf9\x83\xb2\x05.http://hl7.org/fhir/ValueSe\
    t/medication-status\xc0\x9f\xe3\xb6\x05\x01\"\xc3\x06\n\x10MessageEventC\
    ode\x12D\n\x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3.proto.Messag\
    eEventCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google\
    .fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.\
    google.fhir.stu3.proto.ExtensionR\textension\"\xbe\x04\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12/\n\x12CODE_SYSTEM_EXPAND\x10\
    \x01\x1a\x17\xba\x96\xbb\xb2\x05\x11CodeSystem-expand\x12O\n\"MEDICATION\
    _ADMINISTRATION_COMPLETE\x10\x02\x1a'\xba\x96\xbb\xb2\x05!MedicationAdmi\
    nistration-Complete\x12Y\n'MEDICATION_ADMINISTRATION_NULLIFICATION\x10\
    \x03\x1a,\xba\x96\xbb\xb2\x05&MedicationAdministration-Nullification\x12\
    Q\n#MEDICATION_ADMINISTRATION_RECORDING\x10\x04\x1a(\xba\x96\xbb\xb2\x05\
    \"MedicationAdministration-Recording\x12K\n\x20MEDICATION_ADMINISTRATION\
    _UPDATE\x10\x05\x1a%\xba\x96\xbb\xb2\x05\x1fMedicationAdministration-Upd\
    ate\x12\x10\n\x0cADMIN_NOTIFY\x10\x06\x12\x19\n\x15COMMUNICATION_REQUEST\
    \x10\x07\x12\x1c\n\x18DIAGNOSTICREPORT_PROVIDE\x10\x08\x12\x17\n\x13OBSE\
    RVATION_PROVIDE\x10\t\x12\x10\n\x0cPATIENT_LINK\x10\n\x12\x12\n\x0ePATIE\
    NT_UNLINK\x10\x0b\x12\x13\n\x0fVALUESET_EXPAND\x10\x0c:7\xc0\x9f\xe3\xb6\
    \x05\x01\x8a\xf9\x83\xb2\x05+http://hl7.org/fhir/ValueSet/message-events\
    \"\xad\x03\n\x20MessageHeaderResponseRequestCode\x12T\n\x05value\x18\x01\
    \x20\x01(\x0e2>.google.fhir.stu3.proto.MessageHeaderResponseRequestCode.\
    ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.\
    proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir\
    .stu3.proto.ExtensionR\textension\"y\n\x05Value\x12\x19\n\x15INVALID_UNI\
    NITIALIZED\x10\0\x12\n\n\x06ALWAYS\x10\x01\x12\x1c\n\x08ON_ERROR\x10\x02\
    \x1a\x0e\xba\x96\xbb\xb2\x05\x08on_error\x12\t\n\x05NEVER\x10\x03\x12\
    \x20\n\nON_SUCCESS\x10\x04\x1a\x10\xba\x96\xbb\xb2\x05\non_success:G\xc0\
    \x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05;http://hl7.org/fhir/ValueSet/me\
    ssageheader-response-request\"\x91\x03\n\x1dExampleMessageReasonCodesCod\
    e\x12Q\n\x05value\x18\x01\x20\x01(\x0e2;.google.fhir.stu3.proto.ExampleM\
    essageReasonCodesCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"i\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05ADMIT\x10\x01\x12\r\
    \n\tDISCHARGE\x10\x02\x12\n\n\x06ABSENT\x10\x03\x12\n\n\x06RETURN\x10\
    \x04\x12\t\n\x05MOVED\x10\x05\x12\x08\n\x04EDIT\x10\x06:A\x8a\xf9\x83\
    \xb2\x055http://hl7.org/fhir/ValueSet/message-reason-encounter\xc0\x9f\
    \xe3\xb6\x05\x01\"\xbc\x03\n\x1fMessageSignificanceCategoryCode\x12S\n\
    \x05value\x18\x01\x20\x01(\x0e2=.google.fhir.stu3.proto.MessageSignifica\
    nceCategoryCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.g\
    oogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\x8a\x01\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\"\n\x0bCONSEQUENCE\x10\x01\
    \x1a\x11\xba\x96\xbb\xb2\x05\x0bConsequence\x12\x1c\n\x08CURRENCY\x10\
    \x02\x1a\x0e\xba\x96\xbb\xb2\x05\x08Currency\x12$\n\x0cNOTIFICATION\x10\
    \x03\x1a\x12\xba\x96\xbb\xb2\x05\x0cNotification:F\x8a\xf9\x83\xb2\x05:h\
    ttp://hl7.org/fhir/ValueSet/message-significance-category\xc0\x9f\xe3\
    \xb6\x05\x01\"\xce\x02\n\x14MessageTransportCode\x12H\n\x05value\x18\x01\
    \x20\x01(\x0e22.google.fhir.stu3.proto.MessageTransportCode.ValueR\x05va\
    lue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.String\
    R\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.\
    ExtensionR\textension\"?\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x08\n\x04HTTP\x10\x01\x12\x07\n\x03FTP\x10\x02\x12\x08\n\x04M\
    LLP\x10\x03::\x8a\xf9\x83\xb2\x05.http://hl7.org/fhir/ValueSet/message-t\
    ransport\xc0\x9f\xe3\xb6\x05\x01\"\x9f\x03\n\x20DeviceMetricCalibrationS\
    tateCode\x12T\n\x05value\x18\x01\x20\x01(\x0e2>.google.fhir.stu3.proto.D\
    eviceMetricCalibrationStateCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"q\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x12\n\x0eNOT_CA\
    LIBRATED\x10\x01\x12\x18\n\x14CALIBRATION_REQUIRED\x10\x02\x12\x0e\n\nCA\
    LIBRATED\x10\x03\x12\x0f\n\x0bUNSPECIFIED\x10\x04:A\x8a\xf9\x83\xb2\x055\
    http://hl7.org/fhir/ValueSet/metric-calibration-state\xc0\x9f\xe3\xb6\
    \x05\x01\"\x83\x03\n\x1fDeviceMetricCalibrationTypeCode\x12S\n\x05value\
    \x18\x01\x20\x01(\x0e2=.google.fhir.stu3.proto.DeviceMetricCalibrationTy\
    peCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhi\
    r.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goog\
    le.fhir.stu3.proto.ExtensionR\textension\"X\n\x05Value\x12\x19\n\x15INVA\
    LID_UNINITIALIZED\x10\0\x12\x0f\n\x0bUNSPECIFIED\x10\x01\x12\n\n\x06OFFS\
    ET\x10\x02\x12\x08\n\x04GAIN\x10\x03\x12\r\n\tTWO_POINT\x10\x04:@\x8a\
    \xf9\x83\xb2\x054http://hl7.org/fhir/ValueSet/metric-calibration-type\
    \xc0\x9f\xe3\xb6\x05\x01\"\xf7\x02\n\x18DeviceMetricCategoryCode\x12L\n\
    \x05value\x18\x01\x20\x01(\x0e26.google.fhir.stu3.proto.DeviceMetricCate\
    goryCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.f\
    hir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.go\
    ogle.fhir.stu3.proto.ExtensionR\textension\"b\n\x05Value\x12\x19\n\x15IN\
    VALID_UNINITIALIZED\x10\0\x12\x0f\n\x0bMEASUREMENT\x10\x01\x12\x0b\n\x07\
    SETTING\x10\x02\x12\x0f\n\x0bCALCULATION\x10\x03\x12\x0f\n\x0bUNSPECIFIE\
    D\x10\x04:8\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05,http://hl7.org/f\
    hir/ValueSet/metric-category\"\x85\x03\n\x15DeviceMetricColorCode\x12I\n\
    \x05value\x18\x01\x20\x01(\x0e23.google.fhir.stu3.proto.DeviceMetricColo\
    rCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir\
    .stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.googl\
    e.fhir.stu3.proto.ExtensionR\textension\"y\n\x05Value\x12\x19\n\x15INVAL\
    ID_UNINITIALIZED\x10\0\x12\t\n\x05BLACK\x10\x01\x12\x07\n\x03RED\x10\x02\
    \x12\t\n\x05GREEN\x10\x03\x12\n\n\x06YELLOW\x10\x04\x12\x08\n\x04BLUE\
    \x10\x05\x12\x0b\n\x07MAGENTA\x10\x06\x12\x08\n\x04CYAN\x10\x07\x12\t\n\
    \x05WHITE\x10\x08:5\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05)http://h\
    l7.org/fhir/ValueSet/metric-color\"\x87\x03\n!DeviceMetricOperationalSta\
    tusCode\x12U\n\x05value\x18\x01\x20\x01(\x0e2?.google.fhir.stu3.proto.De\
    viceMetricOperationalStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"V\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x06\n\x02ON\x10\
    \x01\x12\x07\n\x03OFF\x10\x02\x12\x0b\n\x07STANDBY\x10\x03\x12\x14\n\x10\
    ENTERED_IN_ERROR\x10\x04:B\x8a\xf9\x83\xb2\x056http://hl7.org/fhir/Value\
    Set/metric-operational-status\xc0\x9f\xe3\xb6\x05\x01\"\x8f\x03\n\x1aHum\
    anNameAssemblyOrderCode\x12N\n\x05value\x18\x01\x20\x01(\x0e28.google.fh\
    ir.stu3.proto.HumanNameAssemblyOrderCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"r\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x12\n\
    \x03NL1\x10\x01\x1a\t\xba\x96\xbb\xb2\x05\x03NL1\x12\x12\n\x03NL2\x10\
    \x02\x1a\t\xba\x96\xbb\xb2\x05\x03NL2\x12\x12\n\x03NL3\x10\x03\x1a\t\xba\
    \x96\xbb\xb2\x05\x03NL3\x12\x12\n\x03NL4\x10\x04\x1a\t\xba\x96\xbb\xb2\
    \x05\x03NL4:<\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x050http://hl7.org\
    /fhir/ValueSet/name-assembly-order\"\xfc\x02\n\x19NameRepresentationUseC\
    ode\x12M\n\x05value\x18\x01\x20\x01(\x0e27.google.fhir.stu3.proto.NameRe\
    presentationUseCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"^\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x12\n\x03ABC\x10\x01\x1a\t\
    \xba\x96\xbb\xb2\x05\x03ABC\x12\x12\n\x03IDE\x10\x02\x1a\t\xba\x96\xbb\
    \xb2\x05\x03IDE\x12\x12\n\x03SYL\x10\x03\x1a\t\xba\x96\xbb\xb2\x05\x03SY\
    L:?\x8a\xf9\x83\xb2\x053http://hl7.org/fhir/ValueSet/name-v3-representat\
    ion\xc0\x9f\xe3\xb6\x05\x01\"\xf7\x02\n\x1eNamingSystemIdentifierTypeCod\
    e\x12R\n\x05value\x18\x01\x20\x01(\x0e2<.google.fhir.stu3.proto.NamingSy\
    stemIdentifierTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b\
    2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"I\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x07\n\x03OID\x10\x01\x12\
    \x08\n\x04UUID\x10\x02\x12\x07\n\x03URI\x10\x03\x12\t\n\x05OTHER\x10\x04\
    :E\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x059http://hl7.org/fhir/Value\
    Set/namingsystem-identifier-type\"\xdb\x02\n\x14NamingSystemTypeCode\x12\
    H\n\x05value\x18\x01\x20\x01(\x0e22.google.fhir.stu3.proto.NamingSystemT\
    ypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fh\
    ir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goo\
    gle.fhir.stu3.proto.ExtensionR\textension\"L\n\x05Value\x12\x19\n\x15INV\
    ALID_UNINITIALIZED\x10\0\x12\x0e\n\nCODESYSTEM\x10\x01\x12\x0e\n\nIDENTI\
    FIER\x10\x02\x12\x08\n\x04ROOT\x10\x03::\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\
    \x83\xb2\x05.http://hl7.org/fhir/ValueSet/namingsystem-type\"\xc2\x03\n\
    \x1eAuditEventAgentNetworkTypeCode\x12R\n\x05value\x18\x01\x20\x01(\x0e2\
    <.google.fhir.stu3.proto.AuditEventAgentNetworkTypeCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"\xa3\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x19\n\x0cMACHINE_NAME\x10\x01\x1a\x07\xba\x96\xbb\xb2\x05\
    \x011\x12\x17\n\nIP_ADDRESS\x10\x02\x1a\x07\xba\x96\xbb\xb2\x05\x012\x12\
    \x1d\n\x10TELEPHONE_NUMBER\x10\x03\x1a\x07\xba\x96\xbb\xb2\x05\x013\x12\
    \x1a\n\rEMAIL_ADDRESS\x10\x04\x1a\x07\xba\x96\xbb\xb2\x05\x014\x12\x10\n\
    \x03URI\x10\x05\x1a\x07\xba\x96\xbb\xb2\x05\x015:5\x8a\xf9\x83\xb2\x05)h\
    ttp://hl7.org/fhir/ValueSet/network-type\xc0\x9f\xe3\xb6\x05\x01\"\xc0\
    \x02\n\x0cNoteTypeCode\x12@\n\x05value\x18\x01\x20\x01(\x0e2*.google.fhi\
    r.stu3.proto.NoteTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"I\n\x05Val\
    ue\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07DISPLAY\x10\x01\
    \x12\t\n\x05PRINT\x10\x02\x12\r\n\tPRINTOPER\x10\x03:2\x8a\xf9\x83\xb2\
    \x05&http://hl7.org/fhir/ValueSet/note-type\xc0\x9f\xe3\xb6\x05\x01\"\
    \xf8\x04\n\x0eNullFlavorCode\x12B\n\x05value\x18\x01\x20\x01(\x0e2,.goog\
    le.fhir.stu3.proto.NullFlavorCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\
    \xf8\x02\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x10\n\
    \x02NI\x10\x01\x1a\x08\xba\x96\xbb\xb2\x05\x02NI\x12\x12\n\x03INV\x10\
    \x02\x1a\t\xba\x96\xbb\xb2\x05\x03INV\x12\x12\n\x03DER\x10\x03\x1a\t\xba\
    \x96\xbb\xb2\x05\x03DER\x12\x12\n\x03OTH\x10\x04\x1a\t\xba\x96\xbb\xb2\
    \x05\x03OTH\x12\x14\n\x04NINF\x10\x05\x1a\n\xba\x96\xbb\xb2\x05\x04NINF\
    \x12\x14\n\x04PINF\x10\x06\x1a\n\xba\x96\xbb\xb2\x05\x04PINF\x12\x12\n\
    \x03UNC\x10\x07\x1a\t\xba\x96\xbb\xb2\x05\x03UNC\x12\x12\n\x03MSK\x10\
    \x08\x1a\t\xba\x96\xbb\xb2\x05\x03MSK\x12\x10\n\x02NA\x10\t\x1a\x08\xba\
    \x96\xbb\xb2\x05\x02NA\x12\x12\n\x03UNK\x10\n\x1a\t\xba\x96\xbb\xb2\x05\
    \x03UNK\x12\x14\n\x04ASKU\x10\x0b\x1a\n\xba\x96\xbb\xb2\x05\x04ASKU\x12\
    \x12\n\x03NAV\x10\x0c\x1a\t\xba\x96\xbb\xb2\x05\x03NAV\x12\x14\n\x04NASK\
    \x10\r\x1a\n\xba\x96\xbb\xb2\x05\x04NASK\x12\x14\n\x04NAVU\x10\x0e\x1a\n\
    \xba\x96\xbb\xb2\x05\x04NAVU\x12\x10\n\x02QS\x10\x0f\x1a\x08\xba\x96\xbb\
    \xb2\x05\x02QS\x12\x12\n\x03TRC\x10\x10\x1a\t\xba\x96\xbb\xb2\x05\x03TRC\
    \x12\x10\n\x02NP\x10\x11\x1a\x08\xba\x96\xbb\xb2\x05\x02NP:6\x8a\xf9\x83\
    \xb2\x05*http://hl7.org/fhir/ValueSet/v3-NullFlavor\xc0\x9f\xe3\xb6\x05\
    \x01\"\xc3\x03\n\x18NutritionOrderStatusCode\x12L\n\x05value\x18\x01\x20\
    \x01(\x0e26.google.fhir.stu3.proto.NutritionOrderStatusCode.ValueR\x05va\
    lue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.String\
    R\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.\
    ExtensionR\textension\"\xa4\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIA\
    LIZED\x10\0\x12\x0c\n\x08PROPOSED\x10\x01\x12\t\n\x05DRAFT\x10\x02\x12\
    \x0b\n\x07PLANNED\x10\x03\x12\r\n\tREQUESTED\x10\x04\x12\n\n\x06ACTIVE\
    \x10\x05\x12\x0b\n\x07ON_HOLD\x10\x06\x12\r\n\tCOMPLETED\x10\x07\x12\r\n\
    \tCANCELLED\x10\x08\x12\x14\n\x10ENTERED_IN_ERROR\x10\t:A\xc0\x9f\xe3\
    \xb6\x05\x01\x8a\xf9\x83\xb2\x055http://hl7.org/fhir/ValueSet/nutrition-\
    request-status\"\xb9\x03\n\x1cObservationCategoryCodesCode\x12P\n\x05val\
    ue\x18\x01\x20\x01(\x0e2:.google.fhir.stu3.proto.ObservationCategoryCode\
    sCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir\
    .stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.googl\
    e.fhir.stu3.proto.ExtensionR\textension\"\x96\x01\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x12\n\x0eSOCIAL_HISTORY\x10\x01\x12\
    \x0f\n\x0bVITAL_SIGNS\x10\x02\x12\x0b\n\x07IMAGING\x10\x03\x12\x0e\n\nLA\
    BORATORY\x10\x04\x12\r\n\tPROCEDURE\x10\x05\x12\n\n\x06SURVEY\x10\x06\
    \x12\x08\n\x04EXAM\x10\x07\x12\x0b\n\x07THERAPY\x10\x08:=\xc0\x9f\xe3\
    \xb6\x05\x01\x8a\xf9\x83\xb2\x051http://hl7.org/fhir/ValueSet/observatio\
    n-category\"\xb8\x03\n\x1fObservationRelationshipTypeCode\x12S\n\x05valu\
    e\x18\x01\x20\x01(\x0e2=.google.fhir.stu3.proto.ObservationRelationshipT\
    ypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fh\
    ir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goo\
    gle.fhir.stu3.proto.ExtensionR\textension\"\x86\x01\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x0e\n\nHAS_MEMBER\x10\x01\x12\x10\n\
    \x0cDERIVED_FROM\x10\x02\x12\r\n\tSEQUEL_TO\x10\x03\x12\x0c\n\x08REPLACE\
    S\x10\x04\x12\x10\n\x0cQUALIFIED_BY\x10\x05\x12\x11\n\rINTERFERED_BY\x10\
    \x06:F\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05:http://hl7.org/fhir/V\
    alueSet/observation-relationshiptypes\"\xd9\x05\n\x12StatisticsCodeCode\
    \x12F\n\x05value\x18\x01\x20\x01(\x0e20.google.fhir.stu3.proto.Statistic\
    sCodeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.\
    fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.g\
    oogle.fhir.stu3.proto.ExtensionR\textension\"\xc8\x03\n\x05Value\x12\x19\
    \n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07AVERAGE\x10\x01\x12\x0b\n\
    \x07MAXIMUM\x10\x02\x12\x0b\n\x07MINIMUM\x10\x03\x12\t\n\x05COUNT\x10\
    \x04\x12\x0e\n\nTOTALCOUNT\x10\x05\x12\n\n\x06MEDIAN\x10\x06\x12\x0b\n\
    \x07STD_DEV\x10\x07\x12\x07\n\x03SUM\x10\x08\x12\x0c\n\x08VARIANCE\x10\t\
    \x12$\n\x0eTWENTY_PERCENT\x10\n\x1a\x10\xba\x96\xbb\xb2\x05\n20-percent\
    \x12$\n\x0eEIGHTY_PERCENT\x10\x0b\x1a\x10\xba\x96\xbb\xb2\x05\n80-percen\
    t\x12\x1d\n\nFOUR_LOWER\x10\x0c\x1a\r\xba\x96\xbb\xb2\x05\x074-lower\x12\
    \x1d\n\nFOUR_UPPER\x10\r\x1a\r\xba\x96\xbb\xb2\x05\x074-upper\x12\x19\n\
    \x08FOUR_DEV\x10\x0e\x1a\x0b\xba\x96\xbb\xb2\x05\x054-dev\x12\x17\n\x08F\
    IVE_ONE\x10\x0f\x1a\t\xba\x96\xbb\xb2\x05\x035-1\x12\x17\n\x08FIVE_TWO\
    \x10\x10\x1a\t\xba\x96\xbb\xb2\x05\x035-2\x12\x19\n\nFIVE_THREE\x10\x11\
    \x1a\t\xba\x96\xbb\xb2\x05\x035-3\x12\x18\n\tFIVE_FOUR\x10\x12\x1a\t\xba\
    \x96\xbb\xb2\x05\x035-4\x12\x08\n\x04SKEW\x10\x13\x12\x0c\n\x08KURTOSIS\
    \x10\x14\x12\x0e\n\nREGRESSION\x10\x15:?\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\
    \x83\xb2\x053http://hl7.org/fhir/ValueSet/observation-statistics\"\xaf\
    \x03\n\x15ObservationStatusCode\x12I\n\x05value\x18\x01\x20\x01(\x0e23.g\
    oogle.fhir.stu3.proto.ObservationStatusCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"\x9c\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\
    \x0e\n\nREGISTERED\x10\x01\x12\x0f\n\x0bPRELIMINARY\x10\x02\x12\t\n\x05F\
    INAL\x10\x03\x12\x0b\n\x07AMENDED\x10\x04\x12\r\n\tCORRECTED\x10\x05\x12\
    \r\n\tCANCELLED\x10\x06\x12\x14\n\x10ENTERED_IN_ERROR\x10\x07\x12\x0b\n\
    \x07UNKNOWN\x10\x08:;\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05/http:/\
    /hl7.org/fhir/ValueSet/observation-status\"\xba\x03\n$DeviceComponentOpe\
    rationalStatusCode\x12X\n\x05value\x18\x01\x20\x01(\x0e2B.google.fhir.st\
    u3.proto.DeviceComponentOperationalStatusCode.ValueR\x05value\x12.\n\x02\
    id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\"\x89\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x07\n\x03OFF\x10\x01\x12\x06\n\x02ON\x10\x02\x12\r\n\tNOT_READY\x10\
    \x03\x12\x0b\n\x07STANDBY\x10\x04\x12\x13\n\x0fTRANSDUC_DISCON\x10\x05\
    \x12\r\n\tHW_DISCON\x10\x06\x12\x14\n\x10ENTERED_IN_ERROR\x10\x07:;\x8a\
    \xf9\x83\xb2\x05/http://hl7.org/fhir/ValueSet/operational-status\xc0\x9f\
    \xe3\xb6\x05\x01\"\xc2\x02\n\x11OperationKindCode\x12E\n\x05value\x18\
    \x01\x20\x01(\x0e2/.google.fhir.stu3.proto.OperationKindCode.ValueR\x05v\
    alue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Strin\
    gR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto\
    .ExtensionR\textension\"<\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\r\n\tOPERATION\x10\x01\x12\t\n\x05QUERY\x10\x02:7\x8a\xf9\x83\
    \xb2\x05+http://hl7.org/fhir/ValueSet/operation-kind\xc0\x9f\xe3\xb6\x05\
    \x01\"\xfe\x15\n\x19OperationOutcomeCodesCode\x12M\n\x05value\x18\x01\
    \x20\x01(\x0e27.google.fhir.stu3.proto.OperationOutcomeCodesCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"\xe4\x13\n\x05Value\x12\x19\n\x15INVALID_UN\
    INITIALIZED\x10\0\x12.\n\x11MSG_AUTH_REQUIRED\x10\x01\x1a\x17\xba\x96\
    \xbb\xb2\x05\x11MSG_AUTH_REQUIRED\x12(\n\x0eMSG_BAD_FORMAT\x10\x02\x1a\
    \x14\xba\x96\xbb\xb2\x05\x0eMSG_BAD_FORMAT\x12(\n\x0eMSG_BAD_SYNTAX\x10\
    \x03\x1a\x14\xba\x96\xbb\xb2\x05\x0eMSG_BAD_SYNTAX\x128\n\x16MSG_CANT_PA\
    RSE_CONTENT\x10\x04\x1a\x1c\xba\x96\xbb\xb2\x05\x16MSG_CANT_PARSE_CONTEN\
    T\x122\n\x13MSG_CANT_PARSE_ROOT\x10\x05\x1a\x19\xba\x96\xbb\xb2\x05\x13M\
    SG_CANT_PARSE_ROOT\x12\"\n\x0bMSG_CREATED\x10\x06\x1a\x11\xba\x96\xbb\
    \xb2\x05\x0bMSG_CREATED\x12*\n\x0fMSG_DATE_FORMAT\x10\x07\x1a\x15\xba\
    \x96\xbb\xb2\x05\x0fMSG_DATE_FORMAT\x12\"\n\x0bMSG_DELETED\x10\x08\x1a\
    \x11\xba\x96\xbb\xb2\x05\x0bMSG_DELETED\x12,\n\x10MSG_DELETED_DONE\x10\t\
    \x1a\x16\xba\x96\xbb\xb2\x05\x10MSG_DELETED_DONE\x12(\n\x0eMSG_DELETED_I\
    D\x10\n\x1a\x14\xba\x96\xbb\xb2\x05\x0eMSG_DELETED_ID\x12,\n\x10MSG_DUPL\
    ICATE_ID\x10\x0b\x1a\x16\xba\x96\xbb\xb2\x05\x10MSG_DUPLICATE_ID\x12.\n\
    \x11MSG_ERROR_PARSING\x10\x0c\x1a\x17\xba\x96\xbb\xb2\x05\x11MSG_ERROR_P\
    ARSING\x12(\n\x0eMSG_ID_INVALID\x10\r\x1a\x14\xba\x96\xbb\xb2\x05\x0eMSG\
    _ID_INVALID\x12*\n\x0fMSG_ID_TOO_LONG\x10\x0e\x1a\x15\xba\x96\xbb\xb2\
    \x05\x0fMSG_ID_TOO_LONG\x12(\n\x0eMSG_INVALID_ID\x10\x0f\x1a\x14\xba\x96\
    \xbb\xb2\x05\x0eMSG_INVALID_ID\x12*\n\x0fMSG_JSON_OBJECT\x10\x10\x1a\x15\
    \xba\x96\xbb\xb2\x05\x0fMSG_JSON_OBJECT\x12(\n\x0eMSG_LOCAL_FAIL\x10\x11\
    \x1a\x14\xba\x96\xbb\xb2\x05\x0eMSG_LOCAL_FAIL\x12$\n\x0cMSG_NO_MATCH\
    \x10\x12\x1a\x12\xba\x96\xbb\xb2\x05\x0cMSG_NO_MATCH\x12$\n\x0cMSG_NO_EX\
    IST\x10\x13\x1a\x12\xba\x96\xbb\xb2\x05\x0cMSG_NO_EXIST\x12&\n\rMSG_NO_M\
    ODULE\x10\x14\x1a\x13\xba\x96\xbb\xb2\x05\rMSG_NO_MODULE\x12(\n\x0eMSG_N\
    O_SUMMARY\x10\x15\x1a\x14\xba\x96\xbb\xb2\x05\x0eMSG_NO_SUMMARY\x120\n\
    \x12MSG_OP_NOT_ALLOWED\x10\x16\x1a\x18\xba\x96\xbb\xb2\x05\x12MSG_OP_NOT\
    _ALLOWED\x12.\n\x11MSG_PARAM_CHAINED\x10\x17\x1a\x17\xba\x96\xbb\xb2\x05\
    \x11MSG_PARAM_CHAINED\x122\n\x13MSG_PARAM_NO_REPEAT\x10\x18\x1a\x19\xba\
    \x96\xbb\xb2\x05\x13MSG_PARAM_NO_REPEAT\x12.\n\x11MSG_PARAM_UNKNOWN\x10\
    \x19\x1a\x17\xba\x96\xbb\xb2\x05\x11MSG_PARAM_UNKNOWN\x12.\n\x11MSG_PARA\
    M_INVALID\x10\x1a\x1a\x17\xba\x96\xbb\xb2\x05\x11MSG_PARAM_INVALID\x12@\
    \n\x1aMSG_PARAM_MODIFIER_INVALID\x10\x1b\x1a\x20\xba\x96\xbb\xb2\x05\x1a\
    MSG_PARAM_MODIFIER_INVALID\x12H\n\x1eMSG_RESOURCE_EXAMPLE_PROTECTED\x10\
    \x1c\x1a$\xba\x96\xbb\xb2\x05\x1eMSG_RESOURCE_EXAMPLE_PROTECTED\x124\n\
    \x14MSG_RESOURCE_ID_FAIL\x10\x1d\x1a\x1a\xba\x96\xbb\xb2\x05\x14MSG_RESO\
    URCE_ID_FAIL\x12<\n\x18MSG_RESOURCE_NOT_ALLOWED\x10\x1e\x1a\x1e\xba\x96\
    \xbb\xb2\x05\x18MSG_RESOURCE_NOT_ALLOWED\x126\n\x15MSG_RESOURCE_REQUIRED\
    \x10\x1f\x1a\x1b\xba\x96\xbb\xb2\x05\x15MSG_RESOURCE_REQUIRED\x12<\n\x18\
    MSG_RESOURCE_ID_MISMATCH\x10\x20\x1a\x1e\xba\x96\xbb\xb2\x05\x18MSG_RESO\
    URCE_ID_MISMATCH\x12:\n\x17MSG_RESOURCE_ID_MISSING\x10!\x1a\x1d\xba\x96\
    \xbb\xb2\x05\x17MSG_RESOURCE_ID_MISSING\x12@\n\x1aMSG_RESOURCE_TYPE_MISM\
    ATCH\x10\"\x1a\x20\xba\x96\xbb\xb2\x05\x1aMSG_RESOURCE_TYPE_MISMATCH\x12\
    ,\n\x10MSG_SORT_UNKNOWN\x10#\x1a\x16\xba\x96\xbb\xb2\x05\x10MSG_SORT_UNK\
    NOWN\x12D\n\x1cMSG_TRANSACTION_DUPLICATE_ID\x10$\x1a\"\xba\x96\xbb\xb2\
    \x05\x1cMSG_TRANSACTION_DUPLICATE_ID\x12@\n\x1aMSG_TRANSACTION_MISSING_I\
    D\x10%\x1a\x20\xba\x96\xbb\xb2\x05\x1aMSG_TRANSACTION_MISSING_ID\x12:\n\
    \x17MSG_UNHANDLED_NODE_TYPE\x10&\x1a\x1d\xba\x96\xbb\xb2\x05\x17MSG_UNHA\
    NDLED_NODE_TYPE\x122\n\x13MSG_UNKNOWN_CONTENT\x10'\x1a\x19\xba\x96\xbb\
    \xb2\x05\x13MSG_UNKNOWN_CONTENT\x126\n\x15MSG_UNKNOWN_OPERATION\x10(\x1a\
    \x1b\xba\x96\xbb\xb2\x05\x15MSG_UNKNOWN_OPERATION\x12,\n\x10MSG_UNKNOWN_\
    TYPE\x10)\x1a\x16\xba\x96\xbb\xb2\x05\x10MSG_UNKNOWN_TYPE\x12\"\n\x0bMSG\
    _UPDATED\x10*\x1a\x11\xba\x96\xbb\xb2\x05\x0bMSG_UPDATED\x12.\n\x11MSG_V\
    ERSION_AWARE\x10+\x1a\x17\xba\x96\xbb\xb2\x05\x11MSG_VERSION_AWARE\x12@\
    \n\x1aMSG_VERSION_AWARE_CONFLICT\x10,\x1a\x20\xba\x96\xbb\xb2\x05\x1aMSG\
    _VERSION_AWARE_CONFLICT\x126\n\x15MSG_VERSION_AWARE_URL\x10-\x1a\x1b\xba\
    \x96\xbb\xb2\x05\x15MSG_VERSION_AWARE_URL\x12$\n\x0cMSG_WRONG_NS\x10.\
    \x1a\x12\xba\x96\xbb\xb2\x05\x0cMSG_WRONG_NS\x12*\n\x0fSEARCH_MULTIPLE\
    \x10/\x1a\x15\xba\x96\xbb\xb2\x05\x0fSEARCH_MULTIPLE\x12:\n\x17UPDATE_MU\
    LTIPLE_MATCHES\x100\x1a\x1d\xba\x96\xbb\xb2\x05\x17UPDATE_MULTIPLE_MATCH\
    ES\x12:\n\x17DELETE_MULTIPLE_MATCHES\x101\x1a\x1d\xba\x96\xbb\xb2\x05\
    \x17DELETE_MULTIPLE_MATCHES\x12\"\n\x0bSEARCH_NONE\x102\x1a\x11\xba\x96\
    \xbb\xb2\x05\x0bSEARCH_NONE::\x8a\xf9\x83\xb2\x05.http://hl7.org/fhir/Va\
    lueSet/operation-outcome\xc0\x9f\xe3\xb6\x05\x01\"\xe8\x02\n\x13Narrativ\
    eStatusCode\x12G\n\x05value\x18\x01\x20\x01(\x0e21.google.fhir.stu3.prot\
    o.NarrativeStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\\\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\r\n\tGENERATED\x10\x01\x12\
    \x0e\n\nEXTENSIONS\x10\x02\x12\x0e\n\nADDITIONAL\x10\x03\x12\t\n\x05EMPT\
    Y\x10\x04:9\x8a\xf9\x83\xb2\x05-http://hl7.org/fhir/ValueSet/narrative-s\
    tatus\xc0\x9f\xe3\xb6\x05\x01\"\xd2\x02\n\x19OperationParameterUseCode\
    \x12M\n\x05value\x18\x01\x20\x01(\x0e27.google.fhir.stu3.proto.Operation\
    ParameterUseCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.\
    google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"3\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x06\n\x02IN\x10\x01\x12\x07\n\
    \x03OUT\x10\x02:@\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x054http://hl7\
    .org/fhir/ValueSet/operation-parameter-use\"\x9b\x03\n\x14OrganizationTy\
    peCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.google.fhir.stu3.proto.Org\
    anizationTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e\
    .google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\x8b\x01\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04PROV\x10\x01\x12\
    \x08\n\x04DEPT\x10\x02\x12\x08\n\x04TEAM\x10\x03\x12\x08\n\x04GOVT\x10\
    \x04\x12\x07\n\x03INS\x10\x05\x12\x07\n\x03EDU\x10\x06\x12\x08\n\x04RELI\
    \x10\x07\x12\x07\n\x03CRS\x10\x08\x12\x06\n\x02CG\x10\t\x12\x07\n\x03BUS\
    \x10\n\x12\t\n\x05OTHER\x10\x0b::\x8a\xf9\x83\xb2\x05.http://hl7.org/fhi\
    r/ValueSet/organization-type\xc0\x9f\xe3\xb6\x05\x01\"\xe9\x03\n!DeviceC\
    omponentParameterGroupCode\x12U\n\x05value\x18\x01\x20\x01(\x0e2?.google\
    .fhir.stu3.proto.DeviceComponentParameterGroupCode.ValueR\x05value\x12.\
    \n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\xc1\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x10\n\x0cHAEMODYNAMIC\x10\x01\x12\x07\n\x03ECG\x10\x02\x12\
    \x0f\n\x0bRESPIRATORY\x10\x03\x12\x0f\n\x0bVENTILATION\x10\x04\x12\x10\n\
    \x0cNEUROLOGICAL\x10\x05\x12\x11\n\rDRUG_DELIVERY\x10\x06\x12\x13\n\x0fF\
    LUID_CHEMISTRY\x10\x07\x12\x13\n\x0fBLOOD_CHEMISTRY\x10\x08\x12\x11\n\rM\
    ISCELLANEOUS\x10\t:8\x8a\xf9\x83\xb2\x05,http://hl7.org/fhir/ValueSet/pa\
    rameter-group\xc0\x9f\xe3\xb6\x05\x01\"\xeb\x02\n\x17ParticipantRequired\
    Code\x12K\n\x05value\x18\x01\x20\x01(\x0e25.google.fhir.stu3.proto.Parti\
    cipantRequiredCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"T\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08REQUIRED\x10\x01\
    \x12\x0c\n\x08OPTIONAL\x10\x02\x12\x14\n\x10INFORMATION_ONLY\x10\x03:<\
    \x8a\xf9\x83\xb2\x050http://hl7.org/fhir/ValueSet/participantrequired\
    \xc0\x9f\xe3\xb6\x05\x01\"\xf6\x02\n\x17ParticipationStatusCode\x12K\n\
    \x05value\x18\x01\x20\x01(\x0e25.google.fhir.stu3.proto.ParticipationSta\
    tusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fh\
    ir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goo\
    gle.fhir.stu3.proto.ExtensionR\textension\"_\n\x05Value\x12\x19\n\x15INV\
    ALID_UNINITIALIZED\x10\0\x12\x0c\n\x08ACCEPTED\x10\x01\x12\x0c\n\x08DECL\
    INED\x10\x02\x12\r\n\tTENTATIVE\x10\x03\x12\x10\n\x0cNEEDS_ACTION\x10\
    \x04:<\x8a\xf9\x83\xb2\x050http://hl7.org/fhir/ValueSet/participationsta\
    tus\xc0\x9f\xe3\xb6\x05\x01\"\xe3\x02\n\x16PlanDefinitionTypeCode\x12J\n\
    \x05value\x18\x01\x20\x01(\x0e24.google.fhir.stu3.proto.PlanDefinitionTy\
    peCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhi\
    r.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goog\
    le.fhir.stu3.proto.ExtensionR\textension\"M\n\x05Value\x12\x19\n\x15INVA\
    LID_UNINITIALIZED\x10\0\x12\r\n\tORDER_SET\x10\x01\x12\x0c\n\x08PROTOCOL\
    \x10\x02\x12\x0c\n\x08ECA_RULE\x10\x03:=\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\
    \x83\xb2\x051http://hl7.org/fhir/ValueSet/plan-definition-type\"\xab\x04\
    \n\x18PostalAddressUseTypeCode\x12L\n\x05value\x18\x01\x20\x01(\x0e26.go\
    ogle.fhir.stu3.proto.PostalAddressUseTypeCode.ValueR\x05value\x12.\n\x02\
    id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\"\x92\x02\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x1a\n\x0bBAD_ADDRESS\x10\x01\x1a\t\xba\x96\xbb\xb2\x05\x03BAD\x12$\
    \n\x14CONFIDENTIAL_ADDRESS\x10\x02\x1a\n\xba\x96\xbb\xb2\x05\x04CONF\x12\
    \x1a\n\x0cPRIMARY_HOME\x10\x03\x1a\x08\xba\x96\xbb\xb2\x05\x02HP\x12\x1b\
    \n\rVACATION_HOME\x10\x04\x1a\x08\xba\x96\xbb\xb2\x05\x02HV\x12\x15\n\
    \x06DIRECT\x10\x05\x1a\t\xba\x96\xbb\xb2\x05\x03DIR\x12\x15\n\x06PUBLIC\
    \x10\x06\x1a\t\xba\x96\xbb\xb2\x05\x03PUB\x12&\n\x16PHYSICAL_VISIT_ADDRE\
    SS\x10\x07\x1a\n\xba\x96\xbb\xb2\x05\x04PHYS\x12\x1d\n\x0ePOSTAL_ADDRESS\
    \x10\x08\x1a\t\xba\x96\xbb\xb2\x05\x03PST:;\xc0\x9f\xe3\xb6\x05\x01\x8a\
    \xf9\x83\xb2\x05/http://hl7.org/fhir/ValueSet/postal-address-use\"\xfe\
    \x02\n\x14PractitionerRoleCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.go\
    ogle.fhir.stu3.proto.PractitionerRoleCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"o\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06\
    DOCTOR\x10\x01\x12\t\n\x05NURSE\x10\x02\x12\x0e\n\nPHARMACIST\x10\x03\
    \x12\x0e\n\nRESEARCHER\x10\x04\x12\x0b\n\x07TEACHER\x10\x05\x12\x07\n\
    \x03ICT\x10\x06::\x8a\xf9\x83\xb2\x05.http://hl7.org/fhir/ValueSet/pract\
    itioner-role\xc0\x9f\xe3\xb6\x05\x01\"\xfa\x02\n\x19PractitionerSpecialt\
    yCode\x12M\n\x05value\x18\x01\x20\x01(\x0e27.google.fhir.stu3.proto.Prac\
    titionerSpecialtyCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\\\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06CARDIO\x10\x01\x12\
    \x08\n\x04DENT\x10\x02\x12\x0b\n\x07DIETARY\x10\x03\x12\x08\n\x04MIDW\
    \x10\x04\x12\x0b\n\x07SYSARCH\x10\x05:?\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\
    \x83\xb2\x053http://hl7.org/fhir/ValueSet/practitioner-specialty\"\xd3\
    \x03\n\x20ProcedureProgressStatusCodesCode\x12T\n\x05value\x18\x01\x20\
    \x01(\x0e2>.google.fhir.stu3.proto.ProcedureProgressStatusCodesCode.Valu\
    eR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.prot\
    o.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu\
    3.proto.ExtensionR\textension\"\x9d\x01\n\x05Value\x12\x19\n\x15INVALID_\
    UNINITIALIZED\x10\0\x12\x15\n\x11IN_OPERATING_ROOM\x10\x01\x12\x0c\n\x08\
    PREPARED\x10\x02\x12\x16\n\x12ANESTHESIA_INDUCED\x10\x03\x12\x11\n\rOPEN\
    _INCISION\x10\x04\x12\x13\n\x0fCLOSED_INCISION\x10\x05\x12\x14\n\x10IN_R\
    ECOVERY_ROOM\x10\x06:H\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05<http:\
    //hl7.org/fhir/ValueSet/procedure-progress-status-codes\"\x84\x03\n\x18P\
    rovenanceEntityRoleCode\x12L\n\x05value\x18\x01\x20\x01(\x0e26.google.fh\
    ir.stu3.proto.ProvenanceEntityRoleCode.ValueR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"h\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0e\n\nDERI\
    VATION\x10\x01\x12\x0c\n\x08REVISION\x10\x02\x12\r\n\tQUOTATION\x10\x03\
    \x12\n\n\x06SOURCE\x10\x04\x12\x0b\n\x07REMOVAL\x10\x05:?\x8a\xf9\x83\
    \xb2\x053http://hl7.org/fhir/ValueSet/provenance-entity-role\xc0\x9f\xe3\
    \xb6\x05\x01\"\xe5\x02\n\x15PublicationStatusCode\x12I\n\x05value\x18\
    \x01\x20\x01(\x0e23.google.fhir.stu3.proto.PublicationStatusCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"S\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\t\n\x05DRAFT\x10\x01\x12\n\n\x06ACTIVE\x10\x02\x12\x0b\n\
    \x07RETIRED\x10\x03\x12\x0b\n\x07UNKNOWN\x10\x04:;\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x05/http://hl7.org/fhir/ValueSet/publication-status\
    \"\xc3\x02\n\x0fQualityTypeCode\x12C\n\x05value\x18\x01\x20\x01(\x0e2-.g\
    oogle.fhir.stu3.proto.QualityTypeCode.ValueR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"C\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05INDE\
    L\x10\x01\x12\x07\n\x03SNP\x10\x02\x12\x0b\n\x07UNKNOWN\x10\x03:5\xc0\
    \x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05)http://hl7.org/fhir/ValueSet/qu\
    ality-type\"\xb7\x02\n\rMaxOccursCode\x12A\n\x05value\x18\x01\x20\x01(\
    \x0e2+.google.fhir.stu3.proto.MaxOccursCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"4\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x10\n\
    \x03MAX\x10\x01\x1a\x07\xba\x96\xbb\xb2\x05\x01*:<\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x050http://hl7.org/fhir/ValueSet/question-max-occur\
    s\"\xa2\x03\n\x1fQuestionnaireResponseStatusCode\x12S\n\x05value\x18\x01\
    \x20\x01(\x0e2=.google.fhir.stu3.proto.QuestionnaireResponseStatusCode.V\
    alueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.p\
    roto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.\
    stu3.proto.ExtensionR\textension\"r\n\x05Value\x12\x19\n\x15INVALID_UNIN\
    ITIALIZED\x10\0\x12\x0f\n\x0bIN_PROGRESS\x10\x01\x12\r\n\tCOMPLETED\x10\
    \x02\x12\x0b\n\x07AMENDED\x10\x03\x12\x14\n\x10ENTERED_IN_ERROR\x10\x04\
    \x12\x0b\n\x07STOPPED\x10\x05:E\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\
    \x059http://hl7.org/fhir/ValueSet/questionnaire-answers-status\"\xf4\x02\
    \n\x1fQuestionnaireTextCategoriesCode\x12S\n\x05value\x18\x01\x20\x01(\
    \x0e2=.google.fhir.stu3.proto.QuestionnaireTextCategoriesCode.ValueR\x05\
    value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Stri\
    ngR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.prot\
    o.ExtensionR\textension\"B\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x10\n\x0cINSTRUCTIONS\x10\x01\x12\x0c\n\x08SECURITY\x10\x02:G\
    \xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05;http://hl7.org/fhir/ValueSe\
    t/questionnaire-display-category\"\xca\x04\n#QuestionnaireItemUIControlC\
    odesCode\x12W\n\x05value\x18\x01\x20\x01(\x0e2A.google.fhir.stu3.proto.Q\
    uestionnaireItemUIControlCodesCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\
    \x93\x02\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\
    \x04LIST\x10\x01\x12\t\n\x05TABLE\x10\x02\x12\n\n\x06HEADER\x10\x03\x12\
    \n\n\x06FOOTER\x10\x04\x12\n\n\x06INLINE\x10\x05\x12\n\n\x06PROMPT\x10\
    \x06\x12\x08\n\x04UNIT\x10\x07\x12\t\n\x05LOWER\x10\x08\x12\t\n\x05UPPER\
    \x10\t\x12\x0b\n\x07FLYOVER\x10\n\x12\x08\n\x04HELP\x10\x0b\x12\x10\n\
    \x0cAUTOCOMPLETE\x10\x0c\x12\r\n\tDROP_DOWN\x10\r\x12\r\n\tCHECK_BOX\x10\
    \x0e\x12\n\n\x06LOOKUP\x10\x0f\x12\x10\n\x0cRADIO_BUTTON\x10\x10\x12\n\n\
    \x06SLIDER\x10\x11\x12\x0b\n\x07SPINNER\x10\x12\x12\x0c\n\x08TEXT_BOX\
    \x10\x13:C\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x057http://hl7.org/fh\
    ir/ValueSet/questionnaire-item-control\"\xb2\x03\n\x1eQuestionnaireItemU\
    sageModeCode\x12R\n\x05value\x18\x01\x20\x01(\x0e2<.google.fhir.stu3.pro\
    to.QuestionnaireItemUsageModeCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\
    \x87\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x13\n\
    \x0fCAPTURE_DISPLAY\x10\x01\x12\x0b\n\x07CAPTURE\x10\x02\x12\x0b\n\x07DI\
    SPLAY\x10\x03\x12\x15\n\x11DISPLAY_NON_EMPTY\x10\x04\x12\x1d\n\x19CAPTUR\
    E_DISPLAY_NON_EMPTY\x10\x05:A\x8a\xf9\x83\xb2\x055http://hl7.org/fhir/Va\
    lueSet/questionnaire-usage-mode\xc0\x9f\xe3\xb6\x05\x01\"\x84\x03\n\x1fA\
    llergyIntoleranceCertaintyCode\x12S\n\x05value\x18\x01\x20\x01(\x0e2=.go\
    ogle.fhir.stu3.proto.AllergyIntoleranceCertaintyCode.ValueR\x05value\x12\
    .\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"X\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x0c\n\x08UNLIKELY\x10\x01\x12\n\n\x06LIKELY\x10\x02\x12\r\n\tCONFIR\
    MED\x10\x03\x12\x0b\n\x07UNKNOWN\x10\x04:A\xc0\x9f\xe3\xb6\x05\x01\x8a\
    \xf9\x83\xb2\x055http://hl7.org/fhir/ValueSet/reaction-event-certainty\"\
    \xef\x02\n\x1eAllergyIntoleranceSeverityCode\x12R\n\x05value\x18\x01\x20\
    \x01(\x0e2<.google.fhir.stu3.proto.AllergyIntoleranceSeverityCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"F\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x08\n\x04MILD\x10\x01\x12\x0c\n\x08MODERATE\x10\x02\x12\n\
    \n\x06SEVERE\x10\x03:@\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x054http:\
    //hl7.org/fhir/ValueSet/reaction-event-severity\"\xe6\x02\n\x1eReasonMed\
    icationGivenCodesCode\x12R\n\x05value\x18\x01\x20\x01(\x0e2<.google.fhir\
    .stu3.proto.ReasonMedicationGivenCodesCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"7\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x05\n\
    \x01A\x10\x01\x12\x05\n\x01B\x10\x02\x12\x05\n\x01C\x10\x03:F\xc0\x9f\
    \xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05:http://hl7.org/fhir/ValueSet/reason\
    -medication-given-codes\"\x88\x03\n\x1bReferenceHandlingPolicyCode\x12O\
    \n\x05value\x18\x01\x20\x01(\x0e29.google.fhir.stu3.proto.ReferenceHandl\
    ingPolicyCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goo\
    gle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b\
    2!.google.fhir.stu3.proto.ExtensionR\textension\"c\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07LITERAL\x10\x01\x12\x0b\n\
    \x07LOGICAL\x10\x02\x12\x0c\n\x08RESOLVES\x10\x03\x12\x0c\n\x08ENFORCED\
    \x10\x04\x12\t\n\x05LOCAL\x10\x05:B\x8a\xf9\x83\xb2\x056http://hl7.org/f\
    hir/ValueSet/reference-handling-policy\xc0\x9f\xe3\xb6\x05\x01\"\xc3\x03\
    \n\x17RelatedArtifactTypeCode\x12K\n\x05value\x18\x01\x20\x01(\x0e25.goo\
    gle.fhir.stu3.proto.RelatedArtifactTypeCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"\xa9\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\
    \x11\n\rDOCUMENTATION\x10\x01\x12\x11\n\rJUSTIFICATION\x10\x02\x12\x0c\n\
    \x08CITATION\x10\x03\x12\x0f\n\x0bPREDECESSOR\x10\x04\x12\r\n\tSUCCESSOR\
    \x10\x05\x12\x10\n\x0cDERIVED_FROM\x10\x06\x12\x0e\n\nDEPENDS_ON\x10\x07\
    \x12\x0f\n\x0bCOMPOSED_OF\x10\x08:>\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\
    \xb2\x052http://hl7.org/fhir/ValueSet/related-artifact-type\"\xff\x03\n)\
    ObservationReferenceRangeMeaningCodesCode\x12]\n\x05value\x18\x01\x20\
    \x01(\x0e2G.google.fhir.stu3.proto.ObservationReferenceRangeMeaningCodes\
    Code.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.\
    stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google\
    .fhir.stu3.proto.ExtensionR\textension\"\xc0\x01\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06NORMAL\x10\x01\x12\x0f\n\x0bR\
    ECOMMENDED\x10\x02\x12\r\n\tTREATMENT\x10\x03\x12\x0f\n\x0bTHERAPEUTIC\
    \x10\x04\x12\x07\n\x03PRE\x10\x05\x12\x08\n\x04POST\x10\x06\x12\x0f\n\
    \x0bPRE_PUBERTY\x10\x07\x12\x0e\n\nFOLLICULAR\x10\x08\x12\x0c\n\x08MIDCY\
    CLE\x10\t\x12\n\n\x06LUTEAL\x10\n\x12\x11\n\rPOSTMEOPAUSAL\x10\x0b:?\x8a\
    \xf9\x83\xb2\x053http://hl7.org/fhir/ValueSet/referencerange-meaning\xc0\
    \x9f\xe3\xb6\x05\x01\"\xfc\x02\n\x1aTestReportActionResultCode\x12N\n\
    \x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.TestReportAction\
    ResultCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google\
    .fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.\
    google.fhir.stu3.proto.ExtensionR\textension\"X\n\x05Value\x12\x19\n\x15\
    INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04PASS\x10\x01\x12\x08\n\x04SKIP\
    \x10\x02\x12\x08\n\x04FAIL\x10\x03\x12\x0b\n\x07WARNING\x10\x04\x12\t\n\
    \x05ERROR\x10\x05:C\x8a\xf9\x83\xb2\x057http://hl7.org/fhir/ValueSet/rep\
    ort-action-result-codes\xc0\x9f\xe3\xb6\x05\x01\"\xf2\x02\n\x1dTestRepor\
    tParticipantTypeCode\x12Q\n\x05value\x18\x01\x20\x01(\x0e2;.google.fhir.\
    stu3.proto.TestReportParticipantTypeCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"K\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0f\n\
    \x0bTEST_ENGINE\x10\x01\x12\n\n\x06CLIENT\x10\x02\x12\n\n\x06SERVER\x10\
    \x03:@\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/V\
    alueSet/report-participant-type\"\xd4\x02\n\x14TestReportResultCode\x12H\
    \n\x05value\x18\x01\x20\x01(\x0e22.google.fhir.stu3.proto.TestReportResu\
    ltCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhi\
    r.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goog\
    le.fhir.stu3.proto.ExtensionR\textension\"C\n\x05Value\x12\x19\n\x15INVA\
    LID_UNINITIALIZED\x10\0\x12\x08\n\x04PASS\x10\x01\x12\x08\n\x04FAIL\x10\
    \x02\x12\x0b\n\x07PENDING\x10\x03:<\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\
    \xb2\x050http://hl7.org/fhir/ValueSet/report-result-codes\"\x83\x03\n\
    \x14TestReportStatusCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.google.f\
    hir.stu3.proto.TestReportStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"r\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\r\n\tCOMPLETED\
    \x10\x01\x12\x0f\n\x0bIN_PROGRESS\x10\x02\x12\x0b\n\x07WAITING\x10\x03\
    \x12\x0b\n\x07STOPPED\x10\x04\x12\x14\n\x10ENTERED_IN_ERROR\x10\x05:<\
    \xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x050http://hl7.org/fhir/ValueSe\
    t/report-status-codes\"\xe9\x02\n\x12RepositoryTypeCode\x12F\n\x05value\
    \x18\x01\x20\x01(\x0e20.google.fhir.stu3.proto.RepositoryTypeCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"`\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x0e\n\nDIRECTLINK\x10\x01\x12\x0b\n\x07OPENAPI\x10\x02\
    \x12\t\n\x05LOGIN\x10\x03\x12\t\n\x05OAUTH\x10\x04\x12\t\n\x05OTHER\x10\
    \x05:8\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05,http://hl7.org/fhir/V\
    alueSet/repository-type\"\xa4\x03\n\x11RequestIntentCode\x12E\n\x05value\
    \x18\x01\x20\x01(\x0e2/.google.fhir.stu3.proto.RequestIntentCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"\x9d\x01\n\x05Value\x12\x19\n\x15INVALID_UN\
    INITIALIZED\x10\0\x12\x0c\n\x08PROPOSAL\x10\x01\x12\x08\n\x04PLAN\x10\
    \x02\x12\t\n\x05ORDER\x10\x03\x12\x12\n\x0eORIGINAL_ORDER\x10\x04\x12\
    \x10\n\x0cREFLEX_ORDER\x10\x05\x12\x10\n\x0cFILLER_ORDER\x10\x06\x12\x12\
    \n\x0eINSTANCE_ORDER\x10\x07\x12\n\n\x06OPTION\x10\x08:7\x8a\xf9\x83\xb2\
    \x05+http://hl7.org/fhir/ValueSet/request-intent\xc0\x9f\xe3\xb6\x05\x01\
    \"\xdb\x02\n\x13RequestPriorityCode\x12G\n\x05value\x18\x01\x20\x01(\x0e\
    21.google.fhir.stu3.proto.RequestPriorityCode.ValueR\x05value\x12.\n\x02\
    id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\"O\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\
    \x07ROUTINE\x10\x01\x12\n\n\x06URGENT\x10\x02\x12\x08\n\x04ASAP\x10\x03\
    \x12\x08\n\x04STAT\x10\x04:9\x8a\xf9\x83\xb2\x05-http://hl7.org/fhir/Val\
    ueSet/request-priority\xc0\x9f\xe3\xb6\x05\x01\"\x90\x03\n\x11RequestSta\
    tusCode\x12E\n\x05value\x18\x01\x20\x01(\x0e2/.google.fhir.stu3.proto.Re\
    questStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.g\
    oogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\x89\x01\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05DRAFT\x10\x01\x12\n\
    \n\x06ACTIVE\x10\x02\x12\r\n\tSUSPENDED\x10\x03\x12\r\n\tCANCELLED\x10\
    \x04\x12\r\n\tCOMPLETED\x10\x05\x12\x14\n\x10ENTERED_IN_ERROR\x10\x06\
    \x12\x0b\n\x07UNKNOWN\x10\x07:7\x8a\xf9\x83\xb2\x05+http://hl7.org/fhir/\
    ValueSet/request-status\xc0\x9f\xe3\xb6\x05\x01\"\x98\x03\n\x17ResearchS\
    tudyStatusCode\x12K\n\x05value\x18\x01\x20\x01(\x0e25.google.fhir.stu3.p\
    roto.ResearchStudyStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\
    \x7f\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05DRAF\
    T\x10\x01\x12\x0f\n\x0bIN_PROGRESS\x10\x02\x12\r\n\tSUSPENDED\x10\x03\
    \x12\x0b\n\x07STOPPED\x10\x04\x12\r\n\tCOMPLETED\x10\x05\x12\x14\n\x10EN\
    TERED_IN_ERROR\x10\x06:>\x8a\xf9\x83\xb2\x052http://hl7.org/fhir/ValueSe\
    t/research-study-status\xc0\x9f\xe3\xb6\x05\x01\"\x97\x03\n\x19ResearchS\
    ubjectStatusCode\x12M\n\x05value\x18\x01\x20\x01(\x0e27.google.fhir.stu3\
    .proto.ResearchSubjectStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"x\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\r\n\tCANDIDATE\
    \x10\x01\x12\x0c\n\x08ENROLLED\x10\x02\x12\n\n\x06ACTIVE\x10\x03\x12\r\n\
    \tSUSPENDED\x10\x04\x12\r\n\tWITHDRAWN\x10\x05\x12\r\n\tCOMPLETED\x10\
    \x06:@\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/V\
    alueSet/research-subject-status\"\xf8\x02\n\x15PayeeResourceTypeCode\x12\
    I\n\x05value\x18\x01\x20\x01(\x0e23.google.fhir.stu3.proto.PayeeResource\
    TypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.f\
    hir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.go\
    ogle.fhir.stu3.proto.ExtensionR\textension\"f\n\x05Value\x12\x19\n\x15IN\
    VALID_UNINITIALIZED\x10\0\x12\x10\n\x0cORGANIZATION\x10\x01\x12\x0b\n\
    \x07PATIENT\x10\x02\x12\x10\n\x0cPRACTITIONER\x10\x03\x12\x11\n\rRELATED\
    PERSON\x10\x04:;\x8a\xf9\x83\xb2\x05/http://hl7.org/fhir/ValueSet/resour\
    ce-type-link\xc0\x9f\xe3\xb6\x05\x01\"\xb1'\n\x10ResourceTypeCode\x12D\n\
    \x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3.proto.ResourceTypeCode\
    .ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3\
    .proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhi\
    r.stu3.proto.ExtensionR\textension\"\xac%\n\x05Value\x12\x19\n\x15INVALI\
    D_UNINITIALIZED\x10\0\x12\x1a\n\x07ACCOUNT\x10\x01\x1a\r\xba\x96\xbb\xb2\
    \x05\x07Account\x121\n\x13ACTIVITY_DEFINITION\x10\x02\x1a\x18\xba\x96\
    \xbb\xb2\x05\x12ActivityDefinition\x12%\n\rADVERSE_EVENT\x10\x03\x1a\x12\
    \xba\x96\xbb\xb2\x05\x0cAdverseEvent\x121\n\x13ALLERGY_INTOLERANCE\x10\
    \x04\x1a\x18\xba\x96\xbb\xb2\x05\x12AllergyIntolerance\x12\"\n\x0bAPPOIN\
    TMENT\x10\x05\x1a\x11\xba\x96\xbb\xb2\x05\x0bAppointment\x123\n\x14APPOI\
    NTMENT_RESPONSE\x10\x06\x1a\x19\xba\x96\xbb\xb2\x05\x13AppointmentRespon\
    se\x12!\n\x0bAUDIT_EVENT\x10\x07\x1a\x10\xba\x96\xbb\xb2\x05\nAuditEvent\
    \x12\x16\n\x05BASIC\x10\x08\x1a\x0b\xba\x96\xbb\xb2\x05\x05Basic\x12\x18\
    \n\x06BINARY\x10\t\x1a\x0c\xba\x96\xbb\xb2\x05\x06Binary\x12\x1d\n\tBODY\
    _SITE\x10\n\x1a\x0e\xba\x96\xbb\xb2\x05\x08BodySite\x12\x18\n\x06BUNDLE\
    \x10\x0b\x1a\x0c\xba\x96\xbb\xb2\x05\x06Bundle\x123\n\x14CAPABILITY_STAT\
    EMENT\x10\x0c\x1a\x19\xba\x96\xbb\xb2\x05\x13CapabilityStatement\x12\x1d\
    \n\tCARE_PLAN\x10\r\x1a\x0e\xba\x96\xbb\xb2\x05\x08CarePlan\x12\x1d\n\tC\
    ARE_TEAM\x10\x0e\x1a\x0e\xba\x96\xbb\xb2\x05\x08CareTeam\x12!\n\x0bCHARG\
    E_ITEM\x10\x0f\x1a\x10\xba\x96\xbb\xb2\x05\nChargeItem\x12\x16\n\x05CLAI\
    M\x10\x10\x1a\x0b\xba\x96\xbb\xb2\x05\x05Claim\x12'\n\x0eCLAIM_RESPONSE\
    \x10\x11\x1a\x13\xba\x96\xbb\xb2\x05\rClaimResponse\x121\n\x13CLINICAL_I\
    MPRESSION\x10\x12\x1a\x18\xba\x96\xbb\xb2\x05\x12ClinicalImpression\x12!\
    \n\x0bCODE_SYSTEM\x10\x13\x1a\x10\xba\x96\xbb\xb2\x05\nCodeSystem\x12&\n\
    \rCOMMUNICATION\x10\x14\x1a\x13\xba\x96\xbb\xb2\x05\rCommunication\x125\
    \n\x15COMMUNICATION_REQUEST\x10\x15\x1a\x1a\xba\x96\xbb\xb2\x05\x14Commu\
    nicationRequest\x127\n\x16COMPARTMENT_DEFINITION\x10\x16\x1a\x1b\xba\x96\
    \xbb\xb2\x05\x15CompartmentDefinition\x12\"\n\x0bCOMPOSITION\x10\x17\x1a\
    \x11\xba\x96\xbb\xb2\x05\x0bComposition\x12!\n\x0bCONCEPT_MAP\x10\x18\
    \x1a\x10\xba\x96\xbb\xb2\x05\nConceptMap\x12\x1e\n\tCONDITION\x10\x19\
    \x1a\x0f\xba\x96\xbb\xb2\x05\tCondition\x12\x1a\n\x07CONSENT\x10\x1a\x1a\
    \r\xba\x96\xbb\xb2\x05\x07Consent\x12\x1c\n\x08CONTRACT\x10\x1b\x1a\x0e\
    \xba\x96\xbb\xb2\x05\x08Contract\x12\x1c\n\x08COVERAGE\x10\x1c\x1a\x0e\
    \xba\x96\xbb\xb2\x05\x08Coverage\x12#\n\x0cDATA_ELEMENT\x10\x1d\x1a\x11\
    \xba\x96\xbb\xb2\x05\x0bDataElement\x12'\n\x0eDETECTED_ISSUE\x10\x1e\x1a\
    \x13\xba\x96\xbb\xb2\x05\rDetectedIssue\x12\x18\n\x06DEVICE\x10\x1f\x1a\
    \x0c\xba\x96\xbb\xb2\x05\x06Device\x12+\n\x10DEVICE_COMPONENT\x10\x20\
    \x1a\x15\xba\x96\xbb\xb2\x05\x0fDeviceComponent\x12%\n\rDEVICE_METRIC\
    \x10!\x1a\x12\xba\x96\xbb\xb2\x05\x0cDeviceMetric\x12'\n\x0eDEVICE_REQUE\
    ST\x10\"\x1a\x13\xba\x96\xbb\xb2\x05\rDeviceRequest\x122\n\x14DEVICE_USE\
    _STATEMENT\x10#\x1a\x18\xba\x96\xbb\xb2\x05\x12DeviceUseStatement\x12-\n\
    \x11DIAGNOSTIC_REPORT\x10$\x1a\x16\xba\x96\xbb\xb2\x05\x10DiagnosticRepo\
    rt\x12-\n\x11DOCUMENT_MANIFEST\x10%\x1a\x16\xba\x96\xbb\xb2\x05\x10Docum\
    entManifest\x12/\n\x12DOCUMENT_REFERENCE\x10&\x1a\x17\xba\x96\xbb\xb2\
    \x05\x11DocumentReference\x12)\n\x0fDOMAIN_RESOURCE\x10'\x1a\x14\xba\x96\
    \xbb\xb2\x05\x0eDomainResource\x121\n\x13ELIGIBILITY_REQUEST\x10(\x1a\
    \x18\xba\x96\xbb\xb2\x05\x12EligibilityRequest\x123\n\x14ELIGIBILITY_RES\
    PONSE\x10)\x1a\x19\xba\x96\xbb\xb2\x05\x13EligibilityResponse\x12\x1e\n\
    \tENCOUNTER\x10*\x1a\x0f\xba\x96\xbb\xb2\x05\tEncounter\x12\x1c\n\x08END\
    POINT\x10+\x1a\x0e\xba\x96\xbb\xb2\x05\x08Endpoint\x12/\n\x12ENROLLMENT_\
    REQUEST\x10,\x1a\x17\xba\x96\xbb\xb2\x05\x11EnrollmentRequest\x121\n\x13\
    ENROLLMENT_RESPONSE\x10-\x1a\x18\xba\x96\xbb\xb2\x05\x12EnrollmentRespon\
    se\x12(\n\x0fEPISODE_OF_CARE\x10.\x1a\x13\xba\x96\xbb\xb2\x05\rEpisodeOf\
    Care\x12-\n\x11EXPANSION_PROFILE\x10/\x1a\x16\xba\x96\xbb\xb2\x05\x10Exp\
    ansionProfile\x126\n\x16EXPLANATION_OF_BENEFIT\x100\x1a\x1a\xba\x96\xbb\
    \xb2\x05\x14ExplanationOfBenefit\x124\n\x15FAMILY_MEMBER_HISTORY\x101\
    \x1a\x19\xba\x96\xbb\xb2\x05\x13FamilyMemberHistory\x12\x14\n\x04FLAG\
    \x102\x1a\n\xba\x96\xbb\xb2\x05\x04Flag\x12\x14\n\x04GOAL\x103\x1a\n\xba\
    \x96\xbb\xb2\x05\x04Goal\x12+\n\x10GRAPH_DEFINITION\x104\x1a\x15\xba\x96\
    \xbb\xb2\x05\x0fGraphDefinition\x12\x16\n\x05GROUP\x105\x1a\x0b\xba\x96\
    \xbb\xb2\x05\x05Group\x12-\n\x11GUIDANCE_RESPONSE\x106\x1a\x16\xba\x96\
    \xbb\xb2\x05\x10GuidanceResponse\x12/\n\x12HEALTHCARE_SERVICE\x107\x1a\
    \x17\xba\x96\xbb\xb2\x05\x11HealthcareService\x12+\n\x10IMAGING_MANIFEST\
    \x108\x1a\x15\xba\x96\xbb\xb2\x05\x0fImagingManifest\x12%\n\rIMAGING_STU\
    DY\x109\x1a\x12\xba\x96\xbb\xb2\x05\x0cImagingStudy\x12$\n\x0cIMMUNIZATI\
    ON\x10:\x1a\x12\xba\x96\xbb\xb2\x05\x0cImmunization\x12A\n\x1bIMMUNIZATI\
    ON_RECOMMENDATION\x10;\x1a\x20\xba\x96\xbb\xb2\x05\x1aImmunizationRecomm\
    endation\x123\n\x14IMPLEMENTATION_GUIDE\x10<\x1a\x19\xba\x96\xbb\xb2\x05\
    \x13ImplementationGuide\x12\x1a\n\x07LIBRARY\x10=\x1a\r\xba\x96\xbb\xb2\
    \x05\x07Library\x12\x1a\n\x07LINKAGE\x10>\x1a\r\xba\x96\xbb\xb2\x05\x07L\
    inkage\x12\x14\n\x04LIST\x10?\x1a\n\xba\x96\xbb\xb2\x05\x04List\x12\x1c\
    \n\x08LOCATION\x10@\x1a\x0e\xba\x96\xbb\xb2\x05\x08Location\x12\x1a\n\
    \x07MEASURE\x10A\x1a\r\xba\x96\xbb\xb2\x05\x07Measure\x12'\n\x0eMEASURE_\
    REPORT\x10B\x1a\x13\xba\x96\xbb\xb2\x05\rMeasureReport\x12\x16\n\x05MEDI\
    A\x10C\x1a\x0b\xba\x96\xbb\xb2\x05\x05Media\x12\x20\n\nMEDICATION\x10D\
    \x1a\x10\xba\x96\xbb\xb2\x05\nMedication\x12=\n\x19MEDICATION_ADMINISTRA\
    TION\x10E\x1a\x1e\xba\x96\xbb\xb2\x05\x18MedicationAdministration\x121\n\
    \x13MEDICATION_DISPENSE\x10F\x1a\x18\xba\x96\xbb\xb2\x05\x12MedicationDi\
    spense\x12/\n\x12MEDICATION_REQUEST\x10G\x1a\x17\xba\x96\xbb\xb2\x05\x11\
    MedicationRequest\x123\n\x14MEDICATION_STATEMENT\x10H\x1a\x19\xba\x96\
    \xbb\xb2\x05\x13MedicationStatement\x12/\n\x12MESSAGE_DEFINITION\x10I\
    \x1a\x17\xba\x96\xbb\xb2\x05\x11MessageDefinition\x12'\n\x0eMESSAGE_HEAD\
    ER\x10J\x1a\x13\xba\x96\xbb\xb2\x05\rMessageHeader\x12%\n\rNAMING_SYSTEM\
    \x10K\x1a\x12\xba\x96\xbb\xb2\x05\x0cNamingSystem\x12)\n\x0fNUTRITION_OR\
    DER\x10L\x1a\x14\xba\x96\xbb\xb2\x05\x0eNutritionOrder\x12\"\n\x0bOBSERV\
    ATION\x10M\x1a\x11\xba\x96\xbb\xb2\x05\x0bObservation\x123\n\x14OPERATIO\
    N_DEFINITION\x10N\x1a\x19\xba\x96\xbb\xb2\x05\x13OperationDefinition\x12\
    -\n\x11OPERATION_OUTCOME\x10O\x1a\x16\xba\x96\xbb\xb2\x05\x10OperationOu\
    tcome\x12$\n\x0cORGANIZATION\x10P\x1a\x12\xba\x96\xbb\xb2\x05\x0cOrganiz\
    ation\x12\x20\n\nPARAMETERS\x10Q\x1a\x10\xba\x96\xbb\xb2\x05\nParameters\
    \x12\x1a\n\x07PATIENT\x10R\x1a\r\xba\x96\xbb\xb2\x05\x07Patient\x12'\n\
    \x0ePAYMENT_NOTICE\x10S\x1a\x13\xba\x96\xbb\xb2\x05\rPaymentNotice\x127\
    \n\x16PAYMENT_RECONCILIATION\x10T\x1a\x1b\xba\x96\xbb\xb2\x05\x15Payment\
    Reconciliation\x12\x18\n\x06PERSON\x10U\x1a\x0c\xba\x96\xbb\xb2\x05\x06P\
    erson\x12)\n\x0fPLAN_DEFINITION\x10V\x1a\x14\xba\x96\xbb\xb2\x05\x0ePlan\
    Definition\x12$\n\x0cPRACTITIONER\x10W\x1a\x12\xba\x96\xbb\xb2\x05\x0cPr\
    actitioner\x12-\n\x11PRACTITIONER_ROLE\x10X\x1a\x16\xba\x96\xbb\xb2\x05\
    \x10PractitionerRole\x12\x1e\n\tPROCEDURE\x10Y\x1a\x0f\xba\x96\xbb\xb2\
    \x05\tProcedure\x12-\n\x11PROCEDURE_REQUEST\x10Z\x1a\x16\xba\x96\xbb\xb2\
    \x05\x10ProcedureRequest\x12)\n\x0fPROCESS_REQUEST\x10[\x1a\x14\xba\x96\
    \xbb\xb2\x05\x0eProcessRequest\x12+\n\x10PROCESS_RESPONSE\x10\\\x1a\x15\
    \xba\x96\xbb\xb2\x05\x0fProcessResponse\x12\x20\n\nPROVENANCE\x10]\x1a\
    \x10\xba\x96\xbb\xb2\x05\nProvenance\x12&\n\rQUESTIONNAIRE\x10^\x1a\x13\
    \xba\x96\xbb\xb2\x05\rQuestionnaire\x127\n\x16QUESTIONNAIRE_RESPONSE\x10\
    _\x1a\x1b\xba\x96\xbb\xb2\x05\x15QuestionnaireResponse\x12+\n\x10REFERRA\
    L_REQUEST\x10`\x1a\x15\xba\x96\xbb\xb2\x05\x0fReferralRequest\x12'\n\x0e\
    RELATED_PERSON\x10a\x1a\x13\xba\x96\xbb\xb2\x05\rRelatedPerson\x12%\n\rR\
    EQUEST_GROUP\x10b\x1a\x12\xba\x96\xbb\xb2\x05\x0cRequestGroup\x12'\n\x0e\
    RESEARCH_STUDY\x10c\x1a\x13\xba\x96\xbb\xb2\x05\rResearchStudy\x12+\n\
    \x10RESEARCH_SUBJECT\x10d\x1a\x15\xba\x96\xbb\xb2\x05\x0fResearchSubject\
    \x12\x1c\n\x08RESOURCE\x10e\x1a\x0e\xba\x96\xbb\xb2\x05\x08Resource\x12)\
    \n\x0fRISK_ASSESSMENT\x10f\x1a\x14\xba\x96\xbb\xb2\x05\x0eRiskAssessment\
    \x12\x1c\n\x08SCHEDULE\x10g\x1a\x0e\xba\x96\xbb\xb2\x05\x08Schedule\x12+\
    \n\x10SEARCH_PARAMETER\x10h\x1a\x15\xba\x96\xbb\xb2\x05\x0fSearchParamet\
    er\x12\x1c\n\x08SEQUENCE\x10i\x1a\x0e\xba\x96\xbb\xb2\x05\x08Sequence\
    \x12/\n\x12SERVICE_DEFINITION\x10j\x1a\x17\xba\x96\xbb\xb2\x05\x11Servic\
    eDefinition\x12\x14\n\x04SLOT\x10k\x1a\n\xba\x96\xbb\xb2\x05\x04Slot\x12\
    \x1c\n\x08SPECIMEN\x10l\x1a\x0e\xba\x96\xbb\xb2\x05\x08Specimen\x123\n\
    \x14STRUCTURE_DEFINITION\x10m\x1a\x19\xba\x96\xbb\xb2\x05\x13StructureDe\
    finition\x12%\n\rSTRUCTURE_MAP\x10n\x1a\x12\xba\x96\xbb\xb2\x05\x0cStruc\
    tureMap\x12$\n\x0cSUBSCRIPTION\x10o\x1a\x12\xba\x96\xbb\xb2\x05\x0cSubsc\
    ription\x12\x1e\n\tSUBSTANCE\x10p\x1a\x0f\xba\x96\xbb\xb2\x05\tSubstance\
    \x12)\n\x0fSUPPLY_DELIVERY\x10q\x1a\x14\xba\x96\xbb\xb2\x05\x0eSupplyDel\
    ivery\x12'\n\x0eSUPPLY_REQUEST\x10r\x1a\x13\xba\x96\xbb\xb2\x05\rSupplyR\
    equest\x12\x14\n\x04TASK\x10s\x1a\n\xba\x96\xbb\xb2\x05\x04Task\x12!\n\
    \x0bTEST_REPORT\x10t\x1a\x10\xba\x96\xbb\xb2\x05\nTestReport\x12!\n\x0bT\
    EST_SCRIPT\x10u\x1a\x10\xba\x96\xbb\xb2\x05\nTestScript\x12\x1d\n\tVALUE\
    _SET\x10v\x1a\x0e\xba\x96\xbb\xb2\x05\x08ValueSet\x121\n\x13VISION_PRESC\
    RIPTION\x10w\x1a\x18\xba\x96\xbb\xb2\x05\x12VisionPrescription:7\x8a\xf9\
    \x83\xb2\x05+http://hl7.org/fhir/ValueSet/resource-types\xc0\x9f\xe3\xb6\
    \x05\x01\"\xe8\x02\n\x1aResourceValidationModeCode\x12N\n\x05value\x18\
    \x01\x20\x01(\x0e28.google.fhir.stu3.proto.ResourceValidationModeCode.Va\
    lueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.pr\
    oto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.s\
    tu3.proto.ExtensionR\textension\"F\n\x05Value\x12\x19\n\x15INVALID_UNINI\
    TIALIZED\x10\0\x12\n\n\x06CREATE\x10\x01\x12\n\n\x06UPDATE\x10\x02\x12\n\
    \n\x06DELETE\x10\x03:A\x8a\xf9\x83\xb2\x055http://hl7.org/fhir/ValueSet/\
    resource-validation-mode\xc0\x9f\xe3\xb6\x05\x01\"\xd3\x02\n\x10Response\
    TypeCode\x12D\n\x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3.proto.R\
    esponseTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.g\
    oogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"P\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x06\n\x02OK\x10\x01\x12\x13\n\
    \x0fTRANSIENT_ERROR\x10\x02\x12\x0f\n\x0bFATAL_ERROR\x10\x03:6\x8a\xf9\
    \x83\xb2\x05*http://hl7.org/fhir/ValueSet/response-code\xc0\x9f\xe3\xb6\
    \x05\x01\"\xd9\x02\n\x19RestfulCapabilityModeCode\x12M\n\x05value\x18\
    \x01\x20\x01(\x0e27.google.fhir.stu3.proto.RestfulCapabilityModeCode.Val\
    ueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.pro\
    to.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.st\
    u3.proto.ExtensionR\textension\":\n\x05Value\x12\x19\n\x15INVALID_UNINIT\
    IALIZED\x10\0\x12\n\n\x06CLIENT\x10\x01\x12\n\n\x06SERVER\x10\x02:@\xc0\
    \x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x054http://hl7.org/fhir/ValueSet/re\
    stful-capability-mode\"\xf7\x03\n\x1aRestfulSecurityServiceCode\x12N\n\
    \x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.RestfulSecurityS\
    erviceCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google\
    .fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.\
    google.fhir.stu3.proto.ExtensionR\textension\"\xd4\x01\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x16\n\x05OAUTH\x10\x01\x1a\x0b\
    \xba\x96\xbb\xb2\x05\x05OAuth\x12&\n\rSMART_ON_FHIR\x10\x02\x1a\x13\xba\
    \x96\xbb\xb2\x05\rSMART-on-FHIR\x12\x14\n\x04NTLM\x10\x03\x1a\n\xba\x96\
    \xbb\xb2\x05\x04NTLM\x12\x16\n\x05BASIC\x10\x04\x1a\x0b\xba\x96\xbb\xb2\
    \x05\x05Basic\x12\x1c\n\x08KERBEROS\x10\x05\x1a\x0e\xba\x96\xbb\xb2\x05\
    \x08Kerberos\x12$\n\x0cCERTIFICATES\x10\x06\x1a\x12\xba\x96\xbb\xb2\x05\
    \x0cCertificates:A\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x055http://hl\
    7.org/fhir/ValueSet/restful-security-service\"\xec\x02\n\x13RiskProbabil\
    ityCode\x12G\n\x05value\x18\x01\x20\x01(\x0e21.google.fhir.stu3.proto.Ri\
    skProbabilityCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e\
    .google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"`\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0e\n\nNEGLIGIBLE\x10\x01\x12\
    \x07\n\x03LOW\x10\x02\x12\x0c\n\x08MODERATE\x10\x03\x12\x08\n\x04HIGH\
    \x10\x04\x12\x0b\n\x07CERTAIN\x10\x05:9\x8a\xf9\x83\xb2\x05-http://hl7.o\
    rg/fhir/ValueSet/risk-probability\xc0\x9f\xe3\xb6\x05\x01\"\xf9\x02\n\
    \x14SearchComparatorCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.google.f\
    hir.stu3.proto.SearchComparatorCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"j\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x06\n\x02EQ\x10\
    \x01\x12\x06\n\x02NE\x10\x02\x12\x06\n\x02GT\x10\x03\x12\x06\n\x02LT\x10\
    \x04\x12\x06\n\x02GE\x10\x05\x12\x06\n\x02LE\x10\x06\x12\x06\n\x02SA\x10\
    \x07\x12\x06\n\x02EB\x10\x08\x12\x06\n\x02AP\x10\t::\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x05.http://hl7.org/fhir/ValueSet/search-comparator\
    \"\xd4\x02\n\x13SearchEntryModeCode\x12G\n\x05value\x18\x01\x20\x01(\x0e\
    21.google.fhir.stu3.proto.SearchEntryModeCode.ValueR\x05value\x12.\n\x02\
    id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\"G\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\
    \x05MATCH\x10\x01\x12\x0b\n\x07INCLUDE\x10\x02\x12\x0b\n\x07OUTCOME\x10\
    \x03::\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05.http://hl7.org/fhir/V\
    alueSet/search-entry-mode\"\xa6\x03\n\x16SearchModifierCodeCode\x12J\n\
    \x05value\x18\x01\x20\x01(\x0e24.google.fhir.stu3.proto.SearchModifierCo\
    deCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhi\
    r.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.goog\
    le.fhir.stu3.proto.ExtensionR\textension\"\x8f\x01\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07MISSING\x10\x01\x12\t\n\x05\
    EXACT\x10\x02\x12\x0c\n\x08CONTAINS\x10\x03\x12\x07\n\x03NOT\x10\x04\x12\
    \x08\n\x04TEXT\x10\x05\x12\x06\n\x02IN\x10\x06\x12\n\n\x06NOT_IN\x10\x07\
    \x12\t\n\x05BELOW\x10\x08\x12\t\n\x05ABOVE\x10\t\x12\x08\n\x04TYPE\x10\n\
    :=\x8a\xf9\x83\xb2\x051http://hl7.org/fhir/ValueSet/search-modifier-code\
    \xc0\x9f\xe3\xb6\x05\x01\"\x92\x03\n\x13SearchParamTypeCode\x12G\n\x05va\
    lue\x18\x01\x20\x01(\x0e21.google.fhir.stu3.proto.SearchParamTypeCode.Va\
    lueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.pr\
    oto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.s\
    tu3.proto.ExtensionR\textension\"\x84\x01\n\x05Value\x12\x19\n\x15INVALI\
    D_UNINITIALIZED\x10\0\x12\n\n\x06NUMBER\x10\x01\x12\x08\n\x04DATE\x10\
    \x02\x12\n\n\x06STRING\x10\x03\x12\t\n\x05TOKEN\x10\x04\x12\r\n\tREFEREN\
    CE\x10\x05\x12\r\n\tCOMPOSITE\x10\x06\x12\x0c\n\x08QUANTITY\x10\x07\x12\
    \x07\n\x03URI\x10\x08::\x8a\xf9\x83\xb2\x05.http://hl7.org/fhir/ValueSet\
    /search-param-type\xc0\x9f\xe3\xb6\x05\x01\"\xed\x02\n\x12XPathUsageType\
    Code\x12F\n\x05value\x18\x01\x20\x01(\x0e20.google.fhir.stu3.proto.XPath\
    UsageTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.goo\
    gle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b\
    2!.google.fhir.stu3.proto.ExtensionR\textension\"a\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06NORMAL\x10\x01\x12\x0c\n\x08P\
    HONETIC\x10\x02\x12\n\n\x06NEARBY\x10\x03\x12\x0c\n\x08DISTANCE\x10\x04\
    \x12\t\n\x05OTHER\x10\x05:;\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05/\
    http://hl7.org/fhir/ValueSet/search-xpath-usage\"\xbf\x02\n\x10SequenceT\
    ypeCode\x12D\n\x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3.proto.Se\
    quenceTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.go\
    ogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"<\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x06\n\x02AA\x10\x01\x12\x07\n\
    \x03DNA\x10\x02\x12\x07\n\x03RNA\x10\x03:6\x8a\xf9\x83\xb2\x05*http://hl\
    7.org/fhir/ValueSet/sequence-type\xc0\x9f\xe3\xb6\x05\x01\"\xee\x02\n\
    \x1eServiceProvisionConditionsCode\x12R\n\x05value\x18\x01\x20\x01(\x0e2\
    <.google.fhir.stu3.proto.ServiceProvisionConditionsCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"@\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x08\n\x04FREE\x10\x01\x12\x08\n\x04DISC\x10\x02\x12\x08\n\x04\
    COST\x10\x03:E\x8a\xf9\x83\xb2\x059http://hl7.org/fhir/ValueSet/service-\
    provision-conditions\xc0\x9f\xe3\xb6\x05\x01\"\xe7\x02\n\x12ReferralMeth\
    odCode\x12F\n\x05value\x18\x01\x20\x01(\x0e20.google.fhir.stu3.proto.Ref\
    erralMethodCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.g\
    oogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"V\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x07\n\x03FAX\x10\x01\x12\t\n\
    \x05PHONE\x10\x02\x12\x08\n\x04ELEC\x10\x03\x12\n\n\x06SEMAIL\x10\x04\
    \x12\x08\n\x04MAIL\x10\x05:@\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05\
    4http://hl7.org/fhir/ValueSet/service-referral-method\"\xf2\x02\n\x0eSlo\
    tStatusCode\x12B\n\x05value\x18\x01\x20\x01(\x0e2,.google.fhir.stu3.prot\
    o.SlotStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.\
    google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"v\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04BUSY\x10\x01\x12\x08\
    \n\x04FREE\x10\x02\x12\x14\n\x10BUSY_UNAVAILABLE\x10\x03\x12\x12\n\x0eBU\
    SY_TENTATIVE\x10\x04\x12\x14\n\x10ENTERED_IN_ERROR\x10\x05:3\x8a\xf9\x83\
    \xb2\x05'http://hl7.org/fhir/ValueSet/slotstatus\xc0\x9f\xe3\xb6\x05\x01\
    \"\xf6\x02\n\x11SpecialValuesCode\x12E\n\x05value\x18\x01\x20\x01(\x0e2/\
    .google.fhir.stu3.proto.SpecialValuesCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"p\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\
    \x04TRUE\x10\x01\x12\t\n\x05FALSE\x10\x02\x12\t\n\x05TRACE\x10\x03\x12\
    \x0e\n\nSUFFICIENT\x10\x04\x12\r\n\tWITHDRAWN\x10\x05\x12\r\n\tNIL_KNOWN\
    \x10\x06:7\x8a\xf9\x83\xb2\x05+http://hl7.org/fhir/ValueSet/special-valu\
    es\xc0\x9f\xe3\xb6\x05\x01\"\xe4\x03\n\x1fDeviceSpecificationSpecTypeCod\
    e\x12S\n\x05value\x18\x01\x20\x01(\x0e2=.google.fhir.stu3.proto.DeviceSp\
    ecificationSpecTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\xbd\x01\n\
    \x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0f\n\x0bUNSPECIF\
    IED\x10\x01\x12\x11\n\rSERIAL_NUMBER\x10\x02\x12\x0f\n\x0bPART_NUMBER\
    \x10\x03\x12\x15\n\x11HARDWARE_REVISION\x10\x04\x12\x15\n\x11SOFTWARE_RE\
    VISION\x10\x05\x12\x15\n\x11FIRMWARE_REVISION\x10\x06\x12\x15\n\x11PROTO\
    COL_REVISION\x10\x07\x12\x08\n\x04GMDN\x10\x08:;\x8a\xf9\x83\xb2\x05/htt\
    p://hl7.org/fhir/ValueSet/specification-type\xc0\x9f\xe3\xb6\x05\x01\"\
    \xf5\x02\n\x12SpecimenStatusCode\x12F\n\x05value\x18\x01\x20\x01(\x0e20.\
    google.fhir.stu3.proto.SpecimenStatusCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"l\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\r\n\tAV\
    AILABLE\x10\x01\x12\x0f\n\x0bUNAVAILABLE\x10\x02\x12\x12\n\x0eUNSATISFAC\
    TORY\x10\x03\x12\x14\n\x10ENTERED_IN_ERROR\x10\x04:8\xc0\x9f\xe3\xb6\x05\
    \x01\x8a\xf9\x83\xb2\x05,http://hl7.org/fhir/ValueSet/specimen-status\"\
    \x88\x03\n\x1bStructureDefinitionKindCode\x12O\n\x05value\x18\x01\x20\
    \x01(\x0e29.google.fhir.stu3.proto.StructureDefinitionKindCode.ValueR\
    \x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.\
    StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.\
    proto.ExtensionR\textension\"c\n\x05Value\x12\x19\n\x15INVALID_UNINITIAL\
    IZED\x10\0\x12\x12\n\x0ePRIMITIVE_TYPE\x10\x01\x12\x10\n\x0cCOMPLEX_TYPE\
    \x10\x02\x12\x0c\n\x08RESOURCE\x10\x03\x12\x0b\n\x07LOGICAL\x10\x04:B\
    \x8a\xf9\x83\xb2\x056http://hl7.org/fhir/ValueSet/structure-definition-k\
    ind\xc0\x9f\xe3\xb6\x05\x01\"\x86\x03\n\x1bSubscriptionChannelTypeCode\
    \x12O\n\x05value\x18\x01\x20\x01(\x0e29.google.fhir.stu3.proto.Subscript\
    ionChannelTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"a\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\r\n\tREST_HOOK\x10\x01\x12\
    \r\n\tWEBSOCKET\x10\x02\x12\t\n\x05EMAIL\x10\x03\x12\x07\n\x03SMS\x10\
    \x04\x12\x0b\n\x07MESSAGE\x10\x05:B\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\
    \xb2\x056http://hl7.org/fhir/ValueSet/subscription-channel-type\"\xe6\
    \x02\n\x16SubscriptionStatusCode\x12J\n\x05value\x18\x01\x20\x01(\x0e24.\
    google.fhir.stu3.proto.SubscriptionStatusCode.ValueR\x05value\x12.\n\x02\
    id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\"Q\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\r\n\t\
    REQUESTED\x10\x01\x12\n\n\x06ACTIVE\x10\x02\x12\t\n\x05ERROR\x10\x03\x12\
    \x07\n\x03OFF\x10\x04:<\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x050http\
    ://hl7.org/fhir/ValueSet/subscription-status\"\xc9\x02\n\x13Subscription\
    TagCode\x12G\n\x05value\x18\x01\x20\x01(\x0e21.google.fhir.stu3.proto.Su\
    bscriptionTagCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e\
    .google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"=\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06QUEUED\x10\x01\x12\r\n\
    \tDELIVERED\x10\x02:9\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05-http:/\
    /hl7.org/fhir/ValueSet/subscription-tag\"\x96\x03\n\x1aSubstanceCategory\
    CodesCode\x12N\n\x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.\
    SubstanceCategoryCodesCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"z\n\x05Val\
    ue\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08ALLERGEN\x10\
    \x01\x12\x0e\n\nBIOLOGICAL\x10\x02\x12\x08\n\x04BODY\x10\x03\x12\x0c\n\
    \x08CHEMICAL\x10\x04\x12\x08\n\x04FOOD\x10\x05\x12\x08\n\x04DRUG\x10\x06\
    \x12\x0c\n\x08MATERIAL\x10\x07:;\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\
    \x05/http://hl7.org/fhir/ValueSet/substance-category\"\xe6\x02\n\x17FHIR\
    SubstanceStatusCode\x12K\n\x05value\x18\x01\x20\x01(\x0e25.google.fhir.s\
    tu3.proto.FHIRSubstanceStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\
    \x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textensio\
    n\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"R\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06ACTIVE\
    \x10\x01\x12\x0c\n\x08INACTIVE\x10\x02\x12\x14\n\x10ENTERED_IN_ERROR\x10\
    \x03:9\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05-http://hl7.org/fhir/V\
    alueSet/substance-status\"\x82\x03\n\x18SupplyDeliveryStatusCode\x12L\n\
    \x05value\x18\x01\x20\x01(\x0e26.google.fhir.stu3.proto.SupplyDeliverySt\
    atusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.f\
    hir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.go\
    ogle.fhir.stu3.proto.ExtensionR\textension\"g\n\x05Value\x12\x19\n\x15IN\
    VALID_UNINITIALIZED\x10\0\x12\x0f\n\x0bIN_PROGRESS\x10\x01\x12\r\n\tCOMP\
    LETED\x10\x02\x12\r\n\tABANDONED\x10\x03\x12\x14\n\x10ENTERED_IN_ERROR\
    \x10\x04:>\x8a\xf9\x83\xb2\x052http://hl7.org/fhir/ValueSet/supplydelive\
    ry-status\xc0\x9f\xe3\xb6\x05\x01\"\xcb\x02\n\x12SupplyItemTypeCode\x12F\
    \n\x05value\x18\x01\x20\x01(\x0e20.google.fhir.stu3.proto.SupplyItemType\
    Code.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.\
    stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google\
    .fhir.stu3.proto.ExtensionR\textension\">\n\x05Value\x12\x19\n\x15INVALI\
    D_UNINITIALIZED\x10\0\x12\x0e\n\nMEDICATION\x10\x01\x12\n\n\x06DEVICE\
    \x10\x02:<\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x050http://hl7.org/fh\
    ir/ValueSet/supplydelivery-type\"\xc1\x02\n\x0eSupplyTypeCode\x12B\n\x05\
    value\x18\x01\x20\x01(\x0e2,.google.fhir.stu3.proto.SupplyTypeCode.Value\
    R\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto\
    .StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3\
    .proto.ExtensionR\textension\"=\n\x05Value\x12\x19\n\x15INVALID_UNINITIA\
    LIZED\x10\0\x12\x0b\n\x07CENTRAL\x10\x01\x12\x0c\n\x08NONSTOCK\x10\x02:;\
    \x8a\xf9\x83\xb2\x05/http://hl7.org/fhir/ValueSet/supplyrequest-kind\xc0\
    \x9f\xe3\xb6\x05\x01\"\xdc\x02\n\x17SupplyRequestReasonCode\x12K\n\x05va\
    lue\x18\x01\x20\x01(\x0e25.google.fhir.stu3.proto.SupplyRequestReasonCod\
    e.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu\
    3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fh\
    ir.stu3.proto.ExtensionR\textension\"D\n\x05Value\x12\x19\n\x15INVALID_U\
    NINITIALIZED\x10\0\x12\x10\n\x0cPATIENT_CARE\x10\x01\x12\x0e\n\nWARD_STO\
    CK\x10\x02:=\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x051http://hl7.org/\
    fhir/ValueSet/supplyrequest-reason\"\xa2\x03\n\x17SupplyRequestStatusCod\
    e\x12K\n\x05value\x18\x01\x20\x01(\x0e25.google.fhir.stu3.proto.SupplyRe\
    questStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.g\
    oogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\x89\x01\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05DRAFT\x10\x01\x12\n\
    \n\x06ACTIVE\x10\x02\x12\r\n\tSUSPENDED\x10\x03\x12\r\n\tCANCELLED\x10\
    \x04\x12\r\n\tCOMPLETED\x10\x05\x12\x14\n\x10ENTERED_IN_ERROR\x10\x06\
    \x12\x0b\n\x07UNKNOWN\x10\x07:=\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\
    \x051http://hl7.org/fhir/ValueSet/supplyrequest-status\"\x8d\x03\n\x1cSy\
    stemRestfulInteractionCode\x12P\n\x05value\x18\x01\x20\x01(\x0e2:.google\
    .fhir.stu3.proto.SystemRestfulInteractionCode.ValueR\x05value\x12.\n\x02\
    id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\
    \textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\tex\
    tension\"e\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0f\n\
    \x0bTRANSACTION\x10\x01\x12\t\n\x05BATCH\x10\x02\x12\x11\n\rSEARCH_SYSTE\
    M\x10\x03\x12\x12\n\x0eHISTORY_SYSTEM\x10\x04:C\xc0\x9f\xe3\xb6\x05\x01\
    \x8a\xf9\x83\xb2\x057http://hl7.org/fhir/ValueSet/system-restful-interac\
    tion\"\xfa\x02\n\x1fSystemVersionProcessingModeCode\x12S\n\x05value\x18\
    \x01\x20\x01(\x0e2=.google.fhir.stu3.proto.SystemVersionProcessingModeCo\
    de.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.st\
    u3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.f\
    hir.stu3.proto.ExtensionR\textension\"H\n\x05Value\x12\x19\n\x15INVALID_\
    UNINITIALIZED\x10\0\x12\x0b\n\x07DEFAULT\x10\x01\x12\t\n\x05CHECK\x10\
    \x02\x12\x0c\n\x08OVERRIDE\x10\x03:G\x8a\xf9\x83\xb2\x05;http://hl7.org/\
    fhir/ValueSet/system-version-processing-mode\xc0\x9f\xe3\xb6\x05\x01\"\
    \xa9\x03\n\x15TaskPerformerTypeCode\x12I\n\x05value\x18\x01\x20\x01(\x0e\
    23.google.fhir.stu3.proto.TaskPerformerTypeCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\x95\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\r\n\tREQUESTER\x10\x01\x12\x0e\n\nDISPATCHER\x10\x02\x12\r\n\
    \tSCHEDULER\x10\x03\x12\r\n\tPERFORMER\x10\x04\x12\x0b\n\x07MONITOR\x10\
    \x05\x12\x0b\n\x07MANAGER\x10\x06\x12\x0c\n\x08ACQUIRER\x10\x07\x12\x0c\
    \n\x08REVIEWER\x10\x08:<\x8a\xf9\x83\xb2\x050http://hl7.org/fhir/ValueSe\
    t/task-performer-type\xc0\x9f\xe3\xb6\x05\x01\"\xa3\x03\n\x16TemplateSta\
    tusCodeCode\x12J\n\x05value\x18\x01\x20\x01(\x0e24.google.fhir.stu3.prot\
    o.TemplateStatusCodeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\
    \x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\
    \x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\x8c\x01\n\
    \x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\t\n\x05DRAFT\x10\
    \x01\x12\x0b\n\x07PENDING\x10\x02\x12\n\n\x06ACTIVE\x10\x03\x12\n\n\x06R\
    EVIEW\x10\x04\x12\r\n\tCANCELLED\x10\x05\x12\x0c\n\x08REJECTED\x10\x06\
    \x12\x0b\n\x07RETIRED\x10\x07\x12\x0e\n\nTERMINATED\x10\x08:=\xc0\x9f\
    \xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x051http://hl7.org/fhir/ValueSet/templa\
    te-status-code\"\xcd\x03\n\x0eTaskStatusCode\x12B\n\x05value\x18\x01\x20\
    \x01(\x0e2,.google.fhir.stu3.proto.TaskStatusCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"\xcf\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\t\n\x05DRAFT\x10\x01\x12\r\n\tREQUESTED\x10\x02\x12\x0c\n\x08\
    RECEIVED\x10\x03\x12\x0c\n\x08ACCEPTED\x10\x04\x12\x0c\n\x08REJECTED\x10\
    \x05\x12\t\n\x05READY\x10\x06\x12\r\n\tCANCELLED\x10\x07\x12\x0f\n\x0bIN\
    _PROGRESS\x10\x08\x12\x0b\n\x07ON_HOLD\x10\t\x12\n\n\x06FAILED\x10\n\x12\
    \r\n\tCOMPLETED\x10\x0b\x12\x14\n\x10ENTERED_IN_ERROR\x10\x0c:4\x8a\xf9\
    \x83\xb2\x05(http://hl7.org/fhir/ValueSet/task-status\xc0\x9f\xe3\xb6\
    \x05\x01\"\x8d\t\n\x1bTestScriptOperationCodeCode\x12O\n\x05value\x18\
    \x01\x20\x01(\x0e29.google.fhir.stu3.proto.TestScriptOperationCodeCode.V\
    alueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.p\
    roto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.\
    stu3.proto.ExtensionR\textension\"\xe6\x06\n\x05Value\x12\x19\n\x15INVAL\
    ID_UNINITIALIZED\x10\0\x12\x08\n\x04READ\x10\x01\x12\t\n\x05VREAD\x10\
    \x02\x12\n\n\x06UPDATE\x10\x03\x12%\n\rUPDATE_CREATE\x10\x04\x1a\x12\xba\
    \x96\xbb\xb2\x05\x0cupdateCreate\x12\n\n\x06DELETE\x10\x05\x12.\n\x12DEL\
    ETE_COND_SINGLE\x10\x06\x1a\x16\xba\x96\xbb\xb2\x05\x10deleteCondSingle\
    \x122\n\x14DELETE_COND_MULTIPLE\x10\x07\x1a\x18\xba\x96\xbb\xb2\x05\x12d\
    eleteCondMultiple\x12\x0b\n\x07HISTORY\x10\x08\x12\n\n\x06CREATE\x10\t\
    \x12\n\n\x06SEARCH\x10\n\x12\t\n\x05BATCH\x10\x0b\x12\x0f\n\x0bTRANSACTI\
    ON\x10\x0c\x12\x10\n\x0cCAPABILITIES\x10\r\x12\t\n\x05APPLY\x10\x0e\x12\
    \n\n\x06CANCEL\x10\x0f\x12\x0b\n\x07CLOSURE\x10\x10\x12\x0b\n\x07COMPOSE\
    \x10\x11\x12\x0c\n\x08CONFORMS\x10\x12\x12\x15\n\x11DATA_REQUIREMENTS\
    \x10\x13\x12\x0c\n\x08DOCUMENT\x10\x14\x12\x0c\n\x08EVALUATE\x10\x15\x12\
    \x14\n\x10EVALUATE_MEASURE\x10\x16\x12\x0e\n\nEVERYTHING\x10\x17\x12\n\n\
    \x06EXPAND\x10\x18\x12\x08\n\x04FAIL\x10\x19\x12\x08\n\x04FIND\x10\x1a\
    \x12\n\n\x06FINISH\x10\x1b\x12\x0e\n\nIMPLEMENTS\x10\x1c\x12\n\n\x06LOOK\
    UP\x10\x1d\x12\t\n\x05MATCH\x10\x1e\x12\x08\n\x04META\x10\x1f\x12\x0c\n\
    \x08META_ADD\x10\x20\x12\x0f\n\x0bMETA_DELETE\x10!\x12\x0c\n\x08POPULATE\
    \x10\"\x12\x10\n\x0cPOPULATEHTML\x10#\x12\x10\n\x0cPOPULATELINK\x10$\x12\
    \x13\n\x0fPROCESS_MESSAGE\x10%\x12\x11\n\rQUESTIONNAIRE\x10&\x12\x0b\n\
    \x07RELEASE\x10'\x12\x0b\n\x07RESERVE\x10(\x12\n\n\x06RESUME\x10)\x12\r\
    \n\tSET_INPUT\x10*\x12\x0e\n\nSET_OUTPUT\x10+\x12\t\n\x05START\x10,\x12\
    \t\n\x05STATS\x10-\x12\x08\n\x04STOP\x10.\x12\n\n\x06SUBSET\x10/\x12\x0c\
    \n\x08SUBSUMES\x100\x12\x0b\n\x07SUSPEND\x101\x12\r\n\tTRANSFORM\x102\
    \x12\r\n\tTRANSLATE\x103\x12\x0c\n\x08VALIDATE\x104\x12\x11\n\rVALIDATE_\
    CODE\x105:C\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x057http://hl7.org/f\
    hir/ValueSet/testscript-operation-codes\"\xb1\x04\n$TestScriptProfileDes\
    tinationTypeCode\x12X\n\x05value\x18\x01\x20\x01(\x0e2B.google.fhir.stu3\
    .proto.TestScriptProfileDestinationTypeCode.ValueR\x05value\x12.\n\x02id\
    \x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\t\
    extension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\texte\
    nsion\"\xee\x01\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\
    \"\n\x0bFHIR_SERVER\x10\x01\x1a\x11\xba\x96\xbb\xb2\x05\x0bFHIR-Server\
    \x124\n\x14FHIR_SDC_FORMMANAGER\x10\x02\x1a\x1a\xba\x96\xbb\xb2\x05\x14F\
    HIR-SDC-FormManager\x128\n\x16FHIR_SDC_FORMPROCESSOR\x10\x03\x1a\x1c\xba\
    \x96\xbb\xb2\x05\x16FHIR-SDC-FormProcessor\x126\n\x15FHIR_SDC_FORMRECEIV\
    ER\x10\x04\x1a\x1b\xba\x96\xbb\xb2\x05\x15FHIR-SDC-FormReceiver:M\x8a\
    \xf9\x83\xb2\x05Ahttp://hl7.org/fhir/ValueSet/testscript-profile-destina\
    tion-types\xc0\x9f\xe3\xb6\x05\x01\"\xad\x03\n\x1fTestScriptProfileOrigi\
    nTypeCode\x12S\n\x05value\x18\x01\x20\x01(\x0e2=.google.fhir.stu3.proto.\
    TestScriptProfileOriginTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\
    \x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\
    \x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"z\
    \n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\"\n\x0bFHIR_CLI\
    ENT\x10\x01\x1a\x11\xba\x96\xbb\xb2\x05\x0bFHIR-Client\x122\n\x13FHIR_SD\
    C_FORMFILLER\x10\x02\x1a\x19\xba\x96\xbb\xb2\x05\x13FHIR-SDC-FormFiller:\
    H\x8a\xf9\x83\xb2\x05<http://hl7.org/fhir/ValueSet/testscript-profile-or\
    igin-types\xc0\x9f\xe3\xb6\x05\x01\"\xe7\x02\n\x13TransactionModeCode\
    \x12G\n\x05value\x18\x01\x20\x01(\x0e21.google.fhir.stu3.proto.Transacti\
    onModeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google\
    .fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.\
    google.fhir.stu3.proto.ExtensionR\textension\"[\n\x05Value\x12\x19\n\x15\
    INVALID_UNINITIALIZED\x10\0\x12\x11\n\rNOT_SUPPORTED\x10\x01\x12\t\n\x05\
    BATCH\x10\x02\x12\x0f\n\x0bTRANSACTION\x10\x03\x12\x08\n\x04BOTH\x10\x04\
    :9\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05-http://hl7.org/fhir/Value\
    Set/transaction-mode\"\xdc\x02\n\x16TypeDerivationRuleCode\x12J\n\x05val\
    ue\x18\x01\x20\x01(\x0e24.google.fhir.stu3.proto.TypeDerivationRuleCode.\
    ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.\
    proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir\
    .stu3.proto.ExtensionR\textension\"F\n\x05Value\x12\x19\n\x15INVALID_UNI\
    NITIALIZED\x10\0\x12\x12\n\x0eSPECIALIZATION\x10\x01\x12\x0e\n\nCONSTRAI\
    NT\x10\x02:=\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x051http://hl7.org/\
    fhir/ValueSet/type-derivation-rule\"\xc2\x03\n\x1aTypeRestfulInteraction\
    Code\x12N\n\x05value\x18\x01\x20\x01(\x0e28.google.fhir.stu3.proto.TypeR\
    estfulInteractionCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"\x9f\x01\n\x05\
    Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x08\n\x04READ\x10\x01\
    \x12\t\n\x05VREAD\x10\x02\x12\n\n\x06UPDATE\x10\x03\x12\t\n\x05PATCH\x10\
    \x04\x12\n\n\x06DELETE\x10\x05\x12\x14\n\x10HISTORY_INSTANCE\x10\x06\x12\
    \x10\n\x0cHISTORY_TYPE\x10\x07\x12\n\n\x06CREATE\x10\x08\x12\x0f\n\x0bSE\
    ARCH_TYPE\x10\t:A\x8a\xf9\x83\xb2\x055http://hl7.org/fhir/ValueSet/type-\
    restful-interaction\xc0\x9f\xe3\xb6\x05\x01\"\xf3\x02\n\x10UDIEntryTypeC\
    ode\x12D\n\x05value\x18\x01\x20\x01(\x0e2..google.fhir.stu3.proto.UDIEnt\
    ryTypeCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google\
    .fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.\
    google.fhir.stu3.proto.ExtensionR\textension\"o\n\x05Value\x12\x19\n\x15\
    INVALID_UNINITIALIZED\x10\0\x12\x0b\n\x07BARCODE\x10\x01\x12\x08\n\x04RF\
    ID\x10\x02\x12\n\n\x06MANUAL\x10\x03\x12\x08\n\x04CARD\x10\x04\x12\x11\n\
    \rSELF_REPORTED\x10\x05\x12\x0b\n\x07UNKNOWN\x10\x06:7\xc0\x9f\xe3\xb6\
    \x05\x01\x8a\xf9\x83\xb2\x05+http://hl7.org/fhir/ValueSet/udi-entry-type\
    \"\xe8\x02\n\x16UnknownContentCodeCode\x12J\n\x05value\x18\x01\x20\x01(\
    \x0e24.google.fhir.stu3.proto.UnknownContentCodeCode.ValueR\x05value\x12\
    .\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"R\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x06\n\x02NO\x10\x01\x12\x0e\n\nEXTENSIONS\x10\x02\x12\x0c\n\x08ELEM\
    ENTS\x10\x03\x12\x08\n\x04BOTH\x10\x04:=\x8a\xf9\x83\xb2\x051http://hl7.\
    org/fhir/ValueSet/unknown-content-code\xc0\x9f\xe3\xb6\x05\x01\"\x8c\x03\
    \n\x14UsageContextTypeCode\x12H\n\x05value\x18\x01\x20\x01(\x0e22.google\
    .fhir.stu3.proto.UsageContextTypeCode.ValueR\x05value\x12.\n\x02id\x18\
    \x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\texte\
    nsion\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textensio\
    n\"|\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\n\n\x06GEND\
    ER\x10\x01\x12\x07\n\x03AGE\x10\x02\x12\t\n\x05FOCUS\x10\x03\x12\x08\n\
    \x04USER\x10\x04\x12\x0c\n\x08WORKFLOW\x10\x05\x12\x08\n\x04TASK\x10\x06\
    \x12\t\n\x05VENUE\x10\x07\x12\x0b\n\x07SPECIES\x10\x08:;\x8a\xf9\x83\xb2\
    \x05/http://hl7.org/fhir/ValueSet/usage-context-type\xc0\x9f\xe3\xb6\x05\
    \x01\"\xbb\x03\n!ConfidentialityClassificationCode\x12U\n\x05value\x18\
    \x01\x20\x01(\x0e2?.google.fhir.stu3.proto.ConfidentialityClassification\
    Code.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.\
    stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google\
    .fhir.stu3.proto.ExtensionR\textension\"\x82\x01\n\x05Value\x12\x19\n\
    \x15INVALID_UNINITIALIZED\x10\0\x12\x0e\n\x01U\x10\x01\x1a\x07\xba\x96\
    \xbb\xb2\x05\x01U\x12\x0e\n\x01L\x10\x02\x1a\x07\xba\x96\xbb\xb2\x05\x01\
    L\x12\x0e\n\x01M\x10\x03\x1a\x07\xba\x96\xbb\xb2\x05\x01M\x12\x0e\n\x01N\
    \x10\x04\x1a\x07\xba\x96\xbb\xb2\x05\x01N\x12\x0e\n\x01R\x10\x05\x1a\x07\
    \xba\x96\xbb\xb2\x05\x01R\x12\x0e\n\x01V\x10\x06\x1a\x07\xba\x96\xbb\xb2\
    \x05\x01V:I\xc0\x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05=http://hl7.org/f\
    hir/ValueSet/v3-ConfidentialityClassification\"\xfc\x02\n&VaccinationPro\
    tocolDoseStatuscodesCode\x12Z\n\x05value\x18\x01\x20\x01(\x0e2D.google.f\
    hir.stu3.proto.VaccinationProtocolDoseStatuscodesCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\":\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\t\n\x05COUNT\x10\x01\x12\x0b\n\x07NOCOUNT\x10\x02:I\xc0\x9f\
    \xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05=http://hl7.org/fhir/ValueSet/vaccin\
    ation-protocol-dose-status\"\xc4\x03\n,VaccinationProtocolDoseStatusReas\
    oncodesCode\x12`\n\x05value\x18\x01\x20\x01(\x0e2J.google.fhir.stu3.prot\
    o.VaccinationProtocolDoseStatusReasoncodesCode.ValueR\x05value\x12.\n\
    \x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\x02id\
    \x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.Extensi\
    onR\textension\"o\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\
    \x12\x0e\n\nADVSTORAGE\x10\x01\x12\r\n\tCOLDCHBRK\x10\x02\x12\n\n\x06EXP\
    LOT\x10\x03\x12\x10\n\x0cOUTSIDESCHED\x10\x04\x12\x0e\n\nPRODRECALL\x10\
    \x05:P\x8a\xf9\x83\xb2\x05Dhttp://hl7.org/fhir/ValueSet/vaccination-prot\
    ocol-dose-status-reason\xc0\x9f\xe3\xb6\x05\x01\"\xd1\x02\n\x12sequenceS\
    tatusCode\x12F\n\x05value\x18\x01\x20\x01(\x0e20.google.fhir.stu3.proto.\
    sequenceStatusCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\
    \x1e.google.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\
    \x03(\x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"J\n\x05Value\
    \x12\x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x0c\n\x08POSITIVE\x10\x01\
    \x12\x0c\n\x08NEGATIVE\x10\x02\x12\n\n\x06ABSENT\x10\x03:6\xc0\x9f\xe3\
    \xb6\x05\x01\x8a\xf9\x83\xb2\x05*http://hl7.org/fhir/ValueSet/variant-st\
    ate\"\xf0\x02\n\x19ResourceVersionPolicyCode\x12M\n\x05value\x18\x01\x20\
    \x01(\x0e27.google.fhir.stu3.proto.ResourceVersionPolicyCode.ValueR\x05v\
    alue\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.Strin\
    gR\x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto\
    .ExtensionR\textension\"W\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\x0e\n\nNO_VERSION\x10\x01\x12\r\n\tVERSIONED\x10\x02\x12\x14\
    \n\x10VERSIONED_UPDATE\x10\x03::\x8a\xf9\x83\xb2\x05.http://hl7.org/fhir\
    /ValueSet/versioning-policy\xc0\x9f\xe3\xb6\x05\x01\"\xc8\x02\n\x0eVisio\
    nBaseCode\x12B\n\x05value\x18\x01\x20\x01(\x0e2,.google.fhir.stu3.proto.\
    VisionBaseCode.ValueR\x05value\x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.go\
    ogle.fhir.stu3.proto.StringR\x02id\x12?\n\textension\x18\x03\x20\x03(\
    \x0b2!.google.fhir.stu3.proto.ExtensionR\textension\"E\n\x05Value\x12\
    \x19\n\x15INVALID_UNINITIALIZED\x10\0\x12\x06\n\x02UP\x10\x01\x12\x08\n\
    \x04DOWN\x10\x02\x12\x06\n\x02IN\x10\x03\x12\x07\n\x03OUT\x10\x04::\xc0\
    \x9f\xe3\xb6\x05\x01\x8a\xf9\x83\xb2\x05.http://hl7.org/fhir/ValueSet/vi\
    sion-base-codes\"\xb9\x02\n\x0eVisionEyesCode\x12B\n\x05value\x18\x01\
    \x20\x01(\x0e2,.google.fhir.stu3.proto.VisionEyesCode.ValueR\x05value\
    \x12.\n\x02id\x18\x02\x20\x01(\x0b2\x1e.google.fhir.stu3.proto.StringR\
    \x02id\x12?\n\textension\x18\x03\x20\x03(\x0b2!.google.fhir.stu3.proto.E\
    xtensionR\textension\"7\n\x05Value\x12\x19\n\x15INVALID_UNINITIALIZED\
    \x10\0\x12\t\n\x05RIGHT\x10\x01\x12\x08\n\x04LEFT\x10\x02:9\xc0\x9f\xe3\
    \xb6\x05\x01\x8a\xf9\x83\xb2\x05-http://hl7.org/fhir/ValueSet/vision-eye\
    -codesB\x1e\n\x1acom.google.fhir.stu3.protoP\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
